## API Report File for "@gooddata/sdk-backend-spi"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { DateAttributeGranularity } from '@gooddata/sdk-model';
import { DimensionGenerator } from '@gooddata/sdk-model';
import { IAttributeElements } from '@gooddata/sdk-model';
import { IAttributeFilter } from '@gooddata/sdk-model';
import { IAttributeOrMeasure } from '@gooddata/sdk-model';
import { IBucket } from '@gooddata/sdk-model';
import { IColorPalette } from '@gooddata/sdk-model';
import { Identifier } from '@gooddata/sdk-model';
import { IDimension } from '@gooddata/sdk-model';
import { IExecutionDefinition } from '@gooddata/sdk-model';
import { IFilter } from '@gooddata/sdk-model';
import { IInsight } from '@gooddata/sdk-model';
import { IInsightDefinition } from '@gooddata/sdk-model';
import { INullableFilter } from '@gooddata/sdk-model';
import { ISortItem } from '@gooddata/sdk-model';
import { IVisualizationClass } from '@gooddata/sdk-model';
import { ObjectType } from '@gooddata/sdk-model';
import { ObjRef } from '@gooddata/sdk-model';
import { ObjRefInScope } from '@gooddata/sdk-model';
import { SortDirection } from '@gooddata/sdk-model';
import { VisualizationProperties } from '@gooddata/sdk-model';

// @alpha
export type AbsoluteFormType = "absoluteForm";

// @alpha
export type AbsolutePresetType = "absolutePreset";

// @alpha
export type AbsoluteType = "absolute";

// @alpha
export type AllTimeType = "allTime";

// @public
export abstract class AnalyticalBackendError extends Error {
    protected constructor(message: string, abeType: string, cause?: Error | undefined);
    // (undocumented)
    readonly abeType: string;
    // (undocumented)
    readonly cause?: Error | undefined;
}

// @public
export const AnalyticalBackendErrorTypes: {
    NO_DATA: string;
    DATA_TOO_LARGE: string;
    PROTECTED_DATA: string;
    UNEXPECTED_HTTP: string;
    UNEXPECTED: string;
    NOT_SUPPORTED: string;
    NOT_IMPLEMENTED: string;
    NOT_AUTHENTICATED: string;
};

// @public
export type AnalyticalBackendFactory = (config?: IAnalyticalBackendConfig, implConfig?: any) => IAnalyticalBackend;

// @public
export function attributeDescriptorLocalId(descriptor: IAttributeDescriptor): string;

// @public
export function attributeDescriptorName(descriptor: IAttributeDescriptor): string;

// @public
export type AuthenticationFlow = {
    loginUrl: string;
    returnRedirectParam: string;
};

// @public
export type CatalogItem = ICatalogAttribute | ICatalogMeasure | ICatalogFact | ICatalogDateDataset;

// @public
export const catalogItemMetadataObject: (catalogItem: CatalogItem) => MetadataObject;

// @public
export type CatalogItemType = "attribute" | "measure" | "fact" | "dateDataset";

// @alpha
export type DashboardDateFilterConfigMode = "readonly" | "hidden" | "active";

// @alpha
export function dashboardFilterReferenceObjRef(ref: IDashboardFilterReference): ObjRef;

// @public
export type DataColumnType = "ATTRIBUTE" | "FACT" | "DATE";

// @public
export type DatasetLoadStatus = "RUNNING" | "OK" | "ERROR" | "CANCELLED" | "ERROR_METADATA" | "REFRESHING";

// @public
export class DataTooLargeError extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @public
export type DataValue = null | string | number;

// @alpha
export type DateFilterGranularity = "GDC.time.date" | "GDC.time.week_us" | "GDC.time.month" | "GDC.time.quarter" | "GDC.time.year";

// @alpha
export type DateFilterType = RelativeType | AbsoluteType;

// @alpha
export type DateString = string;

// @alpha
export type DrillDefinition = InsightDrillDefinition | KpiDrillDefinition;

// @alpha
export type DrillOrigin = IDrillFromMeasure;

// @alpha
export type DrillOriginType = "drillFromMeasure";

// @alpha
export type DrillTransition = "pop-up" | "in-place" | "new-window";

// @alpha
export type DrillType = "drillToInsight" | "drillToDashboard" | "drillToLegacyDashboard" | "drillToCustomUrl" | "drillToAttributeUrl";

// @public
export type ErrorConverter = (e: Error) => AnalyticalBackendError;

// @alpha
export type FilterContextItem = IDashboardAttributeFilter | IDashboardDateFilter;

// @alpha (undocumented)
export class FluidLayoutBuilder<TContent, TLayout extends IFluidLayout<TContent>, TRow extends IFluidLayoutRow<TContent>, TColumn extends IFluidLayoutColumn<TContent>, TRowFacade extends IFluidLayoutRowFacade<TContent, TRow>, TRowsFacade extends IFluidLayoutRowsFacade<TContent, TRow, TRowFacade>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>, TColumnsFacade extends IFluidLayoutColumnsFacade<TContent, TColumn, TColumnFacade>, TLayoutFacade extends IFluidLayoutFacade<TContent, TLayout>, TColumnBuilder extends IFluidLayoutColumnBuilder<TContent, TColumn, TColumnFacade>, TRowBuilder extends IFluidLayoutRowBuilder<TContent, TRow, TColumn, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder>> implements IFluidLayoutBuilder<TContent, TLayout, TRow, TColumn, TRowFacade, TRowsFacade, TColumnFacade, TColumnsFacade, TLayoutFacade, TColumnBuilder, TRowBuilder> {
    protected constructor(layoutFacade: TLayoutFacade, layoutFacadeConstructor: (layout: TLayout) => TLayoutFacade, getRowBuilder: (rowIndex: number) => TRowBuilder);
    // (undocumented)
    addRow(create?: FluidLayoutRowModifications<TContent, TColumn, TRow, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder, TRowBuilder>, index?: number): this;
    // (undocumented)
    build(): TLayout;
    // (undocumented)
    facade(): TLayoutFacade;
    static for<TContent>(layout: IFluidLayout<TContent>): IFluidLayoutBuilderImpl<TContent>;
    static forNewLayout<TContent>(): IFluidLayoutBuilderImpl<TContent>;
    // (undocumented)
    protected getRowBuilder: (rowIndex: number) => TRowBuilder;
    // (undocumented)
    protected layoutFacade: TLayoutFacade;
    // (undocumented)
    protected layoutFacadeConstructor: (layout: TLayout) => TLayoutFacade;
    // (undocumented)
    modify(modifications: FluidLayoutModifications<TContent, TLayout, TRow, TColumn, TRowFacade, TRowsFacade, TColumnFacade, TColumnsFacade, TLayoutFacade, TColumnBuilder, TRowBuilder, this>): this;
    // (undocumented)
    modifyRow(index: number, modify: FluidLayoutRowModifications<TContent, TColumn, TRow, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder, TRowBuilder>): this;
    // (undocumented)
    modifyRows(modify: FluidLayoutRowModifications<TContent, TColumn, TRow, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder, TRowBuilder>, selector?: FluidLayoutRowsSelector<TContent, TRow, TRowFacade, TRowsFacade>): this;
    // (undocumented)
    moveRow(fromIndex: number, toIndex: number): this;
    // (undocumented)
    removeEmptyRows(): this;
    // (undocumented)
    removeRow(index: number): this;
    // (undocumented)
    removeRows(selector?: FluidLayoutRowsSelector<TContent, TRow, TRowFacade, TRowsFacade>): this;
    // (undocumented)
    setLayout: (valueOrUpdateCallback: ValueOrUpdateCallback<TLayout>) => this;
    // (undocumented)
    size(valueOrUpdateCallback: ValueOrUpdateCallback<IFluidLayoutSize | undefined>): this;
}

// @alpha (undocumented)
export class FluidLayoutColumnBuilder<TContent, TColumn extends IFluidLayoutColumn<TContent>, TRow extends IFluidLayoutRow<TContent>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>> implements IFluidLayoutColumnBuilder<TContent, TColumn, TColumnFacade> {
    protected constructor(setRow: (valueOrUpdateCallback: ValueOrUpdateCallback<TRow>) => void, getColumnFacade: () => TColumnFacade, columnIndex: number);
    // (undocumented)
    build(): TColumn;
    // (undocumented)
    protected columnIndex: number;
    // (undocumented)
    content(valueOrUpdateCallback: ValueOrUpdateCallback<TContent | undefined>): this;
    // (undocumented)
    facade(): TColumnFacade;
    static for<TContent>(rowBuilder: IFluidLayoutRowBuilderImpl<TContent>, columnIndex: number): IFluidLayoutColumnBuilderImpl<TContent>;
    // (undocumented)
    protected getColumnFacade: () => TColumnFacade;
    // (undocumented)
    modify(modifications: FluidLayoutColumnModifications<TContent, TColumn, TColumnFacade, this>): this;
    // (undocumented)
    setColumn: (valueOrUpdateCallback: ValueOrUpdateCallback<TColumn>) => this;
    // (undocumented)
    protected setRow: (valueOrUpdateCallback: ValueOrUpdateCallback<TRow>) => void;
    // (undocumented)
    size(valueOrUpdateCallback: ValueOrUpdateCallback<IFluidLayoutSizeByScreen>): this;
}

// @alpha (undocumented)
export class FluidLayoutColumnFacade<TContent, TColumn extends IFluidLayoutColumn<TContent>, TRow extends IFluidLayoutRow<TContent>, TRowFacade extends IFluidLayoutRowFacade<TContent, TRow>> implements IFluidLayoutColumnFacade<TContent, TColumn> {
    protected constructor(rowFacade: TRowFacade, column: TColumn, columnIndex: number);
    // (undocumented)
    protected readonly column: TColumn;
    // (undocumented)
    protected readonly columnIndex: number;
    // (undocumented)
    content(): TContent | undefined;
    // (undocumented)
    contentEquals(content: TContent | undefined): boolean;
    // (undocumented)
    contentIs(content: TContent): boolean;
    // (undocumented)
    static for<TContent>(rowFacade: IFluidLayoutRowFacadeImpl<TContent>, column: IFluidLayoutColumn<TContent>, index: number): IFluidLayoutColumnFacadeImpl<TContent>;
    // (undocumented)
    hasContent(): boolean;
    // (undocumented)
    hasSizeForScreen(screen: ResponsiveScreenType): boolean;
    // (undocumented)
    index(): number;
    // (undocumented)
    indexIs(index: number): boolean;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    isFirstInRow(): boolean;
    // (undocumented)
    isLastInRow(): boolean;
    // (undocumented)
    raw(): TColumn;
    // (undocumented)
    row(): IFluidLayoutRowFacadeImpl<TContent>;
    // (undocumented)
    protected readonly rowFacade: TRowFacade;
    // (undocumented)
    size(): IFluidLayoutSizeByScreen;
    // (undocumented)
    sizeForScreen(screen: ResponsiveScreenType): IFluidLayoutSize | undefined;
    // (undocumented)
    test(pred: (column: this) => boolean): boolean;
    // (undocumented)
    testRaw(pred: (column: TColumn) => boolean): boolean;
}

// @alpha
export type FluidLayoutColumnModifications<TContent, TColumn extends IFluidLayoutColumn<TContent>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>, TColumnBuilder extends IFluidLayoutColumnBuilder<TContent, TColumn, TColumnFacade>> = (columnBuilder: TColumnBuilder, columnFacade: TColumnFacade) => TColumnBuilder;

// @alpha (undocumented)
export class FluidLayoutColumnsFacade<TContent, TColumn extends IFluidLayoutColumn<TContent>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>> implements IFluidLayoutColumnsFacade<TContent, TColumn, TColumnFacade> {
    protected constructor(columnFacades: TColumnFacade[]);
    // (undocumented)
    all(): TColumnFacade[];
    // (undocumented)
    column(columnIndex: number): TColumnFacade | undefined;
    // (undocumented)
    protected readonly columnFacades: TColumnFacade[];
    // (undocumented)
    count(): number;
    // (undocumented)
    every(pred: (row: TColumnFacade) => boolean): boolean;
    // (undocumented)
    filter(pred: (row: TColumnFacade) => boolean): TColumnFacade[];
    // (undocumented)
    find(pred: (row: TColumnFacade) => boolean): TColumnFacade | undefined;
    // (undocumented)
    flatMap<TReturn>(callback: (column: TColumnFacade) => TReturn[]): TReturn[];
    // (undocumented)
    static for<TContent>(rowFacade: IFluidLayoutRowFacadeImpl<TContent>, columns: IFluidLayoutColumn<TContent>[]): IFluidLayoutColumnsFacadeImpl<TContent>;
    // (undocumented)
    map<TReturn>(callback: (column: TColumnFacade) => TReturn): TReturn[];
    // (undocumented)
    raw(): TColumn[];
    // (undocumented)
    reduce<TReturn>(callback: (acc: TReturn, row: TColumnFacade) => TReturn, initialValue: TReturn): TReturn;
    // (undocumented)
    some(pred: (row: TColumnFacade) => boolean): boolean;
}

// @alpha
export type FluidLayoutColumnsSelector<TContent, TColumn extends IFluidLayoutColumn<TContent>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>, TColumnsFacade extends IFluidLayoutColumnsFacade<TContent, TColumn, TColumnFacade>> = (columnsFacade: TColumnsFacade) => TColumnFacade[] | TColumnFacade | undefined;

// @alpha (undocumented)
export class FluidLayoutFacade<TContent, TLayout extends IFluidLayout<TContent>> implements IFluidLayoutFacade<TContent, TLayout> {
    protected constructor(layout: TLayout);
    static for<TContent>(layout: IFluidLayout<TContent>): IFluidLayoutFacadeImpl<TContent>;
    // (undocumented)
    protected layout: TLayout;
    // (undocumented)
    raw(): TLayout;
    // (undocumented)
    rows(): IFluidLayoutRowsFacadeImpl<TContent>;
    // (undocumented)
    size(): IFluidLayoutSize | undefined;
}

// @alpha
export type FluidLayoutModifications<TContent, TLayout extends IFluidLayout<TContent>, TRow extends IFluidLayoutRow<TContent>, TColumn extends IFluidLayoutColumn<TContent>, TRowFacade extends IFluidLayoutRowFacade<TContent, TRow>, TRowsFacade extends IFluidLayoutRowsFacade<TContent, TRow, TRowFacade>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>, TColumnsFacade extends IFluidLayoutColumnsFacade<TContent, TColumn, TColumnFacade>, TLayoutFacade extends IFluidLayoutFacade<TContent, TLayout>, TColumnBuilder extends IFluidLayoutColumnBuilder<TContent, TColumn, TColumnFacade>, TRowBuilder extends IFluidLayoutRowBuilder<TContent, TRow, TColumn, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder>, TLayoutBuilder extends IFluidLayoutBuilder<TContent, TLayout, TRow, TColumn, TRowFacade, TRowsFacade, TColumnFacade, TColumnsFacade, TLayoutFacade, TColumnBuilder, TRowBuilder>> = (layoutBuilder: TLayoutBuilder, layoutFacade: TLayoutFacade) => TLayoutBuilder;

// @alpha (undocumented)
export class FluidLayoutRowBuilder<TContent, TRow extends IFluidLayoutRow<TContent>, TColumn extends IFluidLayoutColumn<TContent>, TLayout extends IFluidLayout<TContent>, TRowFacade extends IFluidLayoutRowFacade<TContent, TRow>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>, TColumnsFacade extends IFluidLayoutColumnsFacade<TContent, TColumn, TColumnFacade>, TColumnBuilder extends IFluidLayoutColumnBuilder<TContent, TColumn, TColumnFacade>> implements IFluidLayoutRowBuilder<TContent, TRow, TColumn, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder> {
    protected constructor(rowIndex: number, setLayout: (valueOrUpdateCallback: ValueOrUpdateCallback<TLayout>) => void, getRowFacade: () => TRowFacade, getColumnsFacade: () => TColumnsFacade, getColumnBuilder: (columnIndex: number) => TColumnBuilder);
    // (undocumented)
    addColumn(xlSize: IFluidLayoutSize, create?: (builder: TColumnBuilder) => TColumnBuilder, index?: number): this;
    // (undocumented)
    build(): TRow;
    // (undocumented)
    facade(): TRowFacade;
    static for<TContent>(layoutBuilder: IFluidLayoutBuilderImpl<TContent>, rowIndex: number): IFluidLayoutRowBuilderImpl<TContent>;
    // (undocumented)
    protected getColumnBuilder: (columnIndex: number) => TColumnBuilder;
    // (undocumented)
    protected getColumnsFacade: () => TColumnsFacade;
    // (undocumented)
    protected getRowFacade: () => TRowFacade;
    // (undocumented)
    header(valueOrUpdateCallback: ValueOrUpdateCallback<IFluidLayoutSectionHeader | undefined>): this;
    // (undocumented)
    modify(modifications: FluidLayoutRowModifications<TContent, TColumn, TRow, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder, this>): this;
    // (undocumented)
    modifyColumn(index: number, modify: FluidLayoutColumnModifications<TContent, TColumn, TColumnFacade, TColumnBuilder>): this;
    // (undocumented)
    modifyColumns(modify: FluidLayoutColumnModifications<TContent, TColumn, TColumnFacade, TColumnBuilder>, selector?: FluidLayoutColumnsSelector<TContent, TColumn, TColumnFacade, TColumnsFacade>): this;
    // (undocumented)
    moveColumn(fromIndex: number, toIndex: number): this;
    // (undocumented)
    removeColumn(index: number): this;
    // (undocumented)
    removeColumns(selector?: FluidLayoutColumnsSelector<TContent, TColumn, TColumnFacade, TColumnsFacade>): this;
    // (undocumented)
    removeEmptyColumns: () => this;
    // (undocumented)
    protected rowIndex: number;
    // (undocumented)
    protected setLayout: (valueOrUpdateCallback: ValueOrUpdateCallback<TLayout>) => void;
    // (undocumented)
    setRow: (valueOrUpdateCallback: ValueOrUpdateCallback<TRow>) => this;
}

// @alpha (undocumented)
export class FluidLayoutRowFacade<TContent, TRow extends IFluidLayoutRow<TContent>, TLayout extends IFluidLayout<TContent>, TLayoutFacade extends IFluidLayoutFacade<TContent, TLayout>> implements IFluidLayoutRowFacade<TContent, TRow> {
    protected constructor(layoutFacade: TLayoutFacade, row: TRow, rowIndex: number);
    // (undocumented)
    columns(): IFluidLayoutColumnsFacadeImpl<TContent>;
    // (undocumented)
    description(): string | undefined;
    // (undocumented)
    descriptionEquals(description: string): boolean;
    // (undocumented)
    static for<TContent>(layoutFacade: IFluidLayoutFacadeImpl<TContent>, row: IFluidLayoutRow<TContent>, index: number): IFluidLayoutRowFacadeImpl<TContent>;
    // (undocumented)
    hasDescription(): boolean;
    // (undocumented)
    hasHeader(): boolean;
    // (undocumented)
    hasTitle(): boolean;
    // (undocumented)
    header(): IFluidLayoutSectionHeader | undefined;
    // (undocumented)
    headerEquals(header: IFluidLayoutSectionHeader): boolean;
    // (undocumented)
    index(): number;
    // (undocumented)
    indexIs(index: number): boolean;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    isFirst(): boolean;
    // (undocumented)
    isLast(): boolean;
    // (undocumented)
    layout(): IFluidLayoutFacadeImpl<TContent>;
    // (undocumented)
    protected readonly layoutFacade: TLayoutFacade;
    // (undocumented)
    raw(): TRow;
    // (undocumented)
    protected readonly row: TRow;
    // (undocumented)
    protected readonly rowIndex: number;
    // (undocumented)
    test(pred: (row: this) => boolean): boolean;
    // (undocumented)
    testRaw(pred: (row: TRow) => boolean): boolean;
    // (undocumented)
    title(): string | undefined;
    // (undocumented)
    titleEquals(title: string): boolean;
}

// @alpha
export type FluidLayoutRowModifications<TContent, TColumn extends IFluidLayoutColumn<TContent>, TRow extends IFluidLayoutRow<TContent>, TRowFacade extends IFluidLayoutRowFacade<TContent, TRow>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>, TColumnsFacade extends IFluidLayoutColumnsFacade<TContent, TColumn, TColumnFacade>, TColumnBuilder extends IFluidLayoutColumnBuilder<TContent, TColumn, TColumnFacade>, TRowBuilder extends IFluidLayoutRowBuilder<TContent, TRow, TColumn, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder>> = (rowBuilder: TRowBuilder, rowFacade: TRowFacade) => TRowBuilder;

// @alpha (undocumented)
export class FluidLayoutRowsFacade<TContent, TRow extends IFluidLayoutRow<TContent>, TRowFacade extends IFluidLayoutRowFacade<TContent, TRow>, TLayout extends IFluidLayout<TContent>, TLayoutFacade extends IFluidLayoutFacade<TContent, TLayout>> implements IFluidLayoutRowsFacade<TContent, TRow, TRowFacade> {
    protected constructor(layoutFacade: TLayoutFacade, rowFacades: TRowFacade[]);
    // (undocumented)
    all(): TRowFacade[];
    // (undocumented)
    count(): number;
    // (undocumented)
    every(pred: (row: TRowFacade) => boolean): boolean;
    // (undocumented)
    filter(pred: (row: TRowFacade) => boolean): TRowFacade[];
    // (undocumented)
    find(pred: (row: TRowFacade) => boolean): TRowFacade | undefined;
    // (undocumented)
    flatMap<TReturn>(callback: (row: TRowFacade) => TReturn[]): TReturn[];
    // (undocumented)
    static for<TContent>(layoutFacade: IFluidLayoutFacadeImpl<TContent>, rows: IFluidLayoutRow<TContent>[]): IFluidLayoutRowsFacadeImpl<TContent>;
    // (undocumented)
    protected readonly layoutFacade: TLayoutFacade;
    // (undocumented)
    map<TReturn>(callback: (row: TRowFacade) => TReturn): TReturn[];
    // (undocumented)
    raw(): TRow[];
    // (undocumented)
    reduce<TReturn>(callback: (acc: TReturn, row: TRowFacade) => TReturn, initialValue: TReturn): TReturn;
    // (undocumented)
    row(rowIndex: number): TRowFacade | undefined;
    // (undocumented)
    protected readonly rowFacades: TRowFacade[];
    // (undocumented)
    some(pred: (row: TRowFacade) => boolean): boolean;
}

// @alpha
export type FluidLayoutRowsSelector<TContent, TRow extends IFluidLayoutRow<TContent>, TRowFacade extends IFluidLayoutRowFacade<TContent, TRow>, TRowsFacade extends IFluidLayoutRowsFacade<TContent, TRow, TRowFacade>> = (rowsFacade: TRowsFacade) => TRowFacade[] | TRowFacade | undefined;

// @public
export type GroupableCatalogItem = ICatalogAttribute | ICatalogMeasure | ICatalogFact;

// @alpha
export interface IAbsoluteDateFilterForm extends IDateFilterOption {
    type: AbsoluteFormType;
}

// @alpha
export interface IAbsoluteDateFilterPreset extends IDateFilterOption {
    from: DateString;
    to: DateString;
    type: AbsolutePresetType;
}

// @alpha
export interface IAllTimeDateFilterOption extends IDateFilterOption {
    type: AllTimeType;
}

// @public
export interface IAnalyticalBackend {
    authenticate(force?: boolean): Promise<IAuthenticatedPrincipal>;
    readonly capabilities: IBackendCapabilities;
    readonly config: IAnalyticalBackendConfig;
    currentUser(): IUserService;
    deauthenticate(): Promise<void>;
    isAuthenticated(): Promise<IAuthenticatedPrincipal | null>;
    onHostname(hostname: string): IAnalyticalBackend;
    withAuthentication(provider: IAuthenticationProvider): IAnalyticalBackend;
    withTelemetry(componentName: string, props: object): IAnalyticalBackend;
    workspace(id: string): IAnalyticalWorkspace;
    workspaces(): IWorkspacesQueryFactory;
}

// @public
export interface IAnalyticalBackendConfig {
    readonly hostname?: string;
}

// @public
export interface IAnalyticalWorkspace {
    attributes(): IWorkspaceAttributesService;
    catalog(): IWorkspaceCatalogFactory;
    dashboards(): IWorkspaceDashboardsService;
    datasets(): IWorkspaceDatasetsService;
    dateFilterConfigs(): IDateFilterConfigsQuery;
    execution(): IExecutionFactory;
    facts(): IWorkspaceFactsService;
    getDescriptor(): Promise<IWorkspaceDescriptor>;
    insights(): IWorkspaceInsightsService;
    measures(): IWorkspaceMeasuresService;
    permissions(): IWorkspacePermissionsService;
    settings(): IWorkspaceSettingsService;
    styling(): IWorkspaceStylingService;
    users(): IWorkspaceUsersQuery;
    // (undocumented)
    readonly workspace: string;
}

// @public
export interface IAttributeDescriptor {
    // (undocumented)
    attributeHeader: {
        uri: string;
        identifier: string;
        localIdentifier: string;
        ref: ObjRef;
        name: string;
        totalItems?: ITotalDescriptor[];
        type?: string;
        formOf: {
            ref: ObjRef;
            uri: string;
            identifier: string;
            name: string;
        };
    };
}

// @public
export interface IAttributeDisplayFormMetadataObject extends IMetadataObject {
    attribute: ObjRef;
    displayFormType?: string;
    isDefault?: boolean;
    // (undocumented)
    type: "displayForm";
}

// @public
export interface IAttributeElement {
    readonly title: string;
    readonly uri: string;
}

// @public
export interface IAttributeElementExpressionToken {
    deleted?: boolean;
    type: "attributeElement";
    value: string | undefined;
}

// @public
export interface IAttributeMetadataObject extends IMetadataObject {
    displayForms: IAttributeDisplayFormMetadataObject[];
    drillDownStep?: ObjRef;
    // (undocumented)
    type: "attribute";
}

// @public
export interface IAuthenticatedPrincipal {
    userId: string;
    userMeta?: any;
}

// @public
export interface IAuthenticationContext {
    backend: IAnalyticalBackend;
    client: any;
}

// @public
export interface IAuthenticationProvider {
    authenticate(context: IAuthenticationContext): Promise<IAuthenticatedPrincipal>;
    deauthenticate(context: IAuthenticationContext): Promise<void>;
    getCurrentPrincipal(context: IAuthenticationContext): Promise<IAuthenticatedPrincipal | null>;
    initializeClient?(client: any): void;
    onNotAuthenticated?: NotAuthenticatedHandler;
}

// @public
export interface IBackendCapabilities {
    [key: string]: undefined | boolean | number | string;
    canCalculateTotals?: boolean;
    canExecuteByReference?: boolean;
    canExportCsv?: boolean;
    canExportXlsx?: boolean;
    canSortData?: boolean;
    canTransformExistingResult?: boolean;
    maxDimensions?: number;
    supportsCsvUploader?: boolean;
    supportsElementsQueryParentFiltering?: boolean;
    supportsElementUris?: boolean;
    supportsObjectUris?: boolean;
    supportsRankingFilter?: boolean;
}

// @public
export interface ICatalogAttribute extends IGroupableCatalogItemBase {
    attribute: IAttributeMetadataObject;
    defaultDisplayForm: IAttributeDisplayFormMetadataObject;
    displayForms: IAttributeDisplayFormMetadataObject[];
    geoPinDisplayForms: IAttributeDisplayFormMetadataObject[];
    type: "attribute";
}

// @public
export interface ICatalogDateAttribute {
    attribute: IAttributeMetadataObject;
    defaultDisplayForm: IAttributeDisplayFormMetadataObject;
    granularity: DateAttributeGranularity;
}

// @public
export interface ICatalogDateDataset extends ICatalogItemBase {
    dataSet: IDataSetMetadataObject;
    dateAttributes: ICatalogDateAttribute[];
    relevance: number;
    type: "dateDataset";
}

// @public
export interface ICatalogFact extends IGroupableCatalogItemBase {
    fact: IFactMetadataObject;
    type: "fact";
}

// @public
export interface ICatalogGroup {
    tag: ObjRef;
    title: string;
}

// @public
export interface ICatalogItemBase {
    // (undocumented)
    type: CatalogItemType;
}

// @public
export interface ICatalogMeasure extends IGroupableCatalogItemBase {
    measure: IMeasureMetadataObject;
    type: "measure";
}

// @alpha
export interface IDashboard extends IDashboardBase, IDashboardObjectIdentity {
    readonly created: string;
    readonly dateFilterConfig?: IDashboardDateFilterConfig;
    readonly filterContext?: IFilterContext | ITempFilterContext;
    readonly layout?: IDashboardLayout;
    readonly updated: string;
}

// @alpha
export interface IDashboardAttachment {
    dashboard: ObjRef;
    filterContext?: ObjRef;
    format: "pdf";
}

// @alpha
export interface IDashboardAttributeFilter {
    // (undocumented)
    attributeFilter: {
        displayForm: ObjRef;
        negativeSelection: boolean;
        attributeElements: IAttributeElements;
        localIdentifier?: string;
        filterElementsBy?: IDashboardAttributeFilterParent[];
    };
}

// @alpha
export interface IDashboardAttributeFilterParent {
    filterLocalIdentifier: string;
    over: {
        attributes: ObjRef[];
    };
}

// @alpha
export interface IDashboardAttributeFilterReference {
    displayForm: ObjRef;
    type: "attributeFilterReference";
}

// @alpha
export interface IDashboardBase {
    readonly description: string;
    readonly isLocked?: boolean;
    readonly tags?: string[];
    readonly title: string;
}

// @alpha
export interface IDashboardDateFilter {
    // (undocumented)
    dateFilter: {
        type: DateFilterType;
        granularity: DateFilterGranularity;
        from?: DateString | number;
        to?: DateString | number;
        dataSet?: ObjRef;
        attribute?: ObjRef;
    };
}

// @alpha
export interface IDashboardDateFilterAddedPresets {
    absolutePresets?: IAbsoluteDateFilterPreset[];
    relativePresets?: IRelativeDateFilterPreset[];
}

// @alpha
export interface IDashboardDateFilterConfig {
    addPresets?: IDashboardDateFilterAddedPresets;
    filterName: string;
    hideGranularities?: DateFilterGranularity[];
    hideOptions?: Identifier[];
    mode: DashboardDateFilterConfigMode;
}

// @alpha
export interface IDashboardDateFilterReference {
    dataSet: ObjRef;
    type: "dateFilterReference";
}

// @alpha
export interface IDashboardDefinition extends IDashboardBase, Partial<IDashboardObjectIdentity> {
    readonly dateFilterConfig?: IDashboardDateFilterConfig;
    readonly filterContext?: IFilterContext | IFilterContextDefinition;
    readonly layout?: IDashboardLayout;
}

// @alpha
export type IDashboardFilterReference = IDashboardDateFilterReference | IDashboardAttributeFilterReference;

// @alpha
export type IDashboardLayout = IFluidLayout<IDashboardLayoutContent>;

// @alpha
export type IDashboardLayoutColumn = IFluidLayoutColumn<IDashboardLayoutContent>;

// @alpha
export type IDashboardLayoutContent = IWidget | IWidgetDefinition | IDashboardLayout;

// @alpha
export type IDashboardLayoutRow = IFluidLayoutRow<IDashboardLayoutContent>;

// @alpha
export interface IDashboardObjectIdentity {
    readonly identifier: string;
    readonly ref: ObjRef;
    readonly uri: string;
}

// @alpha
export interface IDashboardReferences {
    // (undocumented)
    insights: IInsight[];
}

// @alpha
export interface IDashboardWithReferences {
    // (undocumented)
    dashboard: IDashboard;
    // (undocumented)
    references: IDashboardReferences;
}

// @public
export interface IDataColumn {
    // (undocumented)
    column: {
        name: string;
        type: DataColumnType;
        skip?: boolean;
        format?: string;
    };
}

// @public
export interface IDataHeader {
    // (undocumented)
    columns: IDataColumn[];
    // (undocumented)
    headerRowIndex?: number;
}

// @public
export interface IDataset {
    // (undocumented)
    dataset: {
        name: string;
        dataHeader: IDataHeader;
        datasetId: string;
        loadedRowCount: number;
        datasetLoadStatus: DatasetLoadStatus;
        firstSuccessfulUpdate?: IDatasetLoadInfo;
        lastSuccessfulUpdate?: IDatasetLoadInfo;
        lastUpdate?: IDatasetLoadInfo;
    };
}

// @public
export interface IDatasetLoadInfo {
    // (undocumented)
    created: string;
    // (undocumented)
    owner: IDatasetUser;
    // (undocumented)
    status: DatasetLoadStatus;
}

// @public
export interface IDataSetMetadataObject extends IMetadataObject {
    // (undocumented)
    type: "dataSet";
}

// @public
export interface IDatasetUser {
    // (undocumented)
    fullName: string;
    // (undocumented)
    login: string;
}

// @public
export interface IDataView {
    readonly count: number[];
    readonly data: DataValue[][] | DataValue[];
    readonly definition: IExecutionDefinition;
    equals(other: IDataView): boolean;
    fingerprint(): string;
    readonly headerItems: IResultHeader[][][];
    readonly offset: number[];
    readonly result: IExecutionResult;
    readonly totalCount: number[];
    readonly totals?: DataValue[][][];
    readonly warnings?: IResultWarning[];
}

// @alpha
export interface IDateFilterConfig {
    absoluteForm?: IAbsoluteDateFilterForm;
    absolutePresets?: IAbsoluteDateFilterPreset[];
    allTime?: IAllTimeDateFilterOption;
    ref: ObjRef;
    relativeForm?: IRelativeDateFilterForm;
    relativePresets?: IRelativeDateFilterPreset[];
    selectedOption: Identifier;
}

// @alpha
export interface IDateFilterConfigsQuery {
    query(): Promise<IDateFilterConfigsQueryResult>;
    withLimit(limit: number): IDateFilterConfigsQuery;
    withOffset(offset: number): IDateFilterConfigsQuery;
}

// @public
export type IDateFilterConfigsQueryResult = IPagedResource<IDateFilterConfig>;

// @alpha
export interface IDateFilterOption {
    localIdentifier: Identifier;
    name?: string;
    type: OptionType;
    visible: boolean;
}

// @public
export interface IDimensionDescriptor {
    // (undocumented)
    headers: IDimensionItemDescriptor[];
}

// @public
export type IDimensionItemDescriptor = IMeasureGroupDescriptor | IAttributeDescriptor;

// @alpha
export interface IDrill {
    origin: DrillOrigin;
    transition: DrillTransition;
    type: DrillType;
}

// @alpha
export interface IDrillFromMeasure extends IDrillOrigin {
    measure: ObjRefInScope;
    type: "drillFromMeasure";
}

// @alpha
export interface IDrillOrigin {
    type: DrillOriginType;
}

// @alpha
export type IDrillTarget = ObjRef | IDrillToCustomUrlTarget | IDrillToAttributeUrlTarget;

// @alpha
export interface IDrillToAttributeUrl extends IDrill {
    target: IDrillToAttributeUrlTarget;
    transition: "new-window";
    type: "drillToAttributeUrl";
}

// @alpha
export interface IDrillToAttributeUrlTarget {
    displayForm: ObjRef;
    hyperlinkDisplayForm: ObjRef;
}

// @alpha
export interface IDrillToCustomUrl extends IDrill {
    target: IDrillToCustomUrlTarget;
    transition: "new-window";
    type: "drillToCustomUrl";
}

// @alpha
export interface IDrillToCustomUrlTarget {
    url: string;
}

// @alpha
export interface IDrillToDashboard extends IDrill {
    target?: ObjRef;
    transition: "in-place";
    type: "drillToDashboard";
}

// @alpha
export interface IDrillToInsight extends IDrill {
    target: ObjRef;
    transition: "pop-up";
    type: "drillToInsight";
}

// @alpha
export interface IDrillToLegacyDashboard extends IDrill {
    tab: string;
    target: ObjRef;
    transition: "in-place";
    type: "drillToLegacyDashboard";
}

// @public
export interface IElementsQuery {
    query(): Promise<IElementsQueryResult>;
    withAttributeFilters(filters: IElementsQueryAttributeFilter[]): IElementsQuery;
    withLimit(limit: number): IElementsQuery;
    withOffset(offset: number): IElementsQuery;
    withOptions(options: IElementsQueryOptions): IElementsQuery;
}

// @public
export interface IElementsQueryAttributeFilter {
    // (undocumented)
    attributeFilter: IAttributeFilter;
    // (undocumented)
    overAttribute: ObjRef;
}

// @public
export interface IElementsQueryFactory {
    forDisplayForm(ref: ObjRef): IElementsQuery;
}

// @public
export interface IElementsQueryOptions {
    complement?: boolean;
    filter?: string;
    includeTotalCountWithoutFilters?: boolean;
    order?: SortDirection;
    prompt?: string;
    restrictiveDefinition?: string;
    restrictiveDefinitionContent?: object;
    uris?: string[];
}

// @public
export type IElementsQueryResult = IPagedResource<IAttributeElement>;

// @public
export interface IExecutionFactory {
    forBuckets(buckets: IBucket[], filters?: INullableFilter[]): IPreparedExecution;
    forDefinition(def: IExecutionDefinition): IPreparedExecution;
    forInsight(insightDefinition: IInsightDefinition, filters?: INullableFilter[]): IPreparedExecution;
    forInsightByRef(insight: IInsight, filters?: INullableFilter[]): IPreparedExecution;
    forItems(items: IAttributeOrMeasure[], filters?: INullableFilter[]): IPreparedExecution;
}

// @public
export interface IExecutionResult {
    readonly definition: IExecutionDefinition;
    readonly dimensions: IDimensionDescriptor[];
    equals(other: IExecutionResult): boolean;
    export(options: IExportConfig): Promise<IExportResult>;
    fingerprint(): string;
    readAll(): Promise<IDataView>;
    readWindow(offset: number[], size: number[]): Promise<IDataView>;
    transform(): IPreparedExecution;
}

// @public
export interface IExportConfig {
    format?: "xlsx" | "csv" | "raw";
    mergeHeaders?: boolean;
    showFilters?: boolean;
    title?: string;
}

// @public
export interface IExportResult {
    // (undocumented)
    uri: string;
}

// @public
export interface IFactMetadataObject extends IMetadataObject {
    // (undocumented)
    type: "fact";
}

// @alpha
export interface IFilterContext extends IFilterContextBase, IDashboardObjectIdentity {
}

// @alpha
export interface IFilterContextBase {
    readonly description: string;
    readonly filters: FilterContextItem[];
    readonly title: string;
}

// @alpha
export interface IFilterContextDefinition extends IFilterContextBase, Partial<IDashboardObjectIdentity> {
}

// @alpha
export interface IFluidLayout<TContent> {
    rows: IFluidLayoutRow<TContent>[];
    size?: IFluidLayoutSize;
    type: "fluidLayout";
}

// @alpha
export interface IFluidLayoutBuilder<TContent, TLayout extends IFluidLayout<TContent>, TRow extends IFluidLayoutRow<TContent>, TColumn extends IFluidLayoutColumn<TContent>, TRowFacade extends IFluidLayoutRowFacade<TContent, TRow>, TRowsFacade extends IFluidLayoutRowsFacade<TContent, TRow, TRowFacade>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>, TColumnsFacade extends IFluidLayoutColumnsFacade<TContent, TColumn, TColumnFacade>, TLayoutFacade extends IFluidLayoutFacade<TContent, TLayout>, TColumnBuilder extends IFluidLayoutColumnBuilder<TContent, TColumn, TColumnFacade>, TRowBuilder extends IFluidLayoutRowBuilder<TContent, TRow, TColumn, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder>> {
    addRow(create?: (builder: TRowBuilder) => TRowBuilder, index?: number): this;
    build(): TLayout;
    facade(): TLayoutFacade;
    modify(modifications: FluidLayoutModifications<TContent, TLayout, TRow, TColumn, TRowFacade, TRowsFacade, TColumnFacade, TColumnsFacade, TLayoutFacade, TColumnBuilder, TRowBuilder, this>): this;
    modifyRow(index: number, modify: FluidLayoutRowModifications<TContent, TColumn, TRow, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder, TRowBuilder>): this;
    modifyRows(modify: FluidLayoutRowModifications<TContent, TColumn, TRow, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder, TRowBuilder>, selector?: FluidLayoutRowsSelector<TContent, TRow, TRowFacade, TRowsFacade>): this;
    moveRow(fromIndex: number, toIndex: number): this;
    removeEmptyRows(): this;
    removeRow(index: number): this;
    removeRows(selector?: FluidLayoutRowsSelector<TContent, TRow, TRowFacade, TRowsFacade>): this;
    setLayout(valueOrUpdateCallback: ValueOrUpdateCallback<TLayout>): this;
    size(valueOrUpdateCallback: ValueOrUpdateCallback<IFluidLayoutSize | undefined>): this;
}

// @alpha (undocumented)
export type IFluidLayoutBuilderImpl<TContent> = IFluidLayoutBuilder<TContent, IFluidLayout<TContent>, IFluidLayoutRow<TContent>, IFluidLayoutColumn<TContent>, IFluidLayoutRowFacadeImpl<TContent>, IFluidLayoutRowsFacadeImpl<TContent>, IFluidLayoutColumnFacadeImpl<TContent>, IFluidLayoutColumnsFacadeImpl<TContent>, IFluidLayoutFacadeImpl<TContent>, IFluidLayoutColumnBuilderImpl<TContent>, IFluidLayoutRowBuilderImpl<TContent>>;

// @alpha
export interface IFluidLayoutColumn<TContent> {
    content?: TContent;
    size: IFluidLayoutSizeByScreen;
}

// @alpha
export interface IFluidLayoutColumnBuilder<TContent, TColumn extends IFluidLayoutColumn<TContent>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>> {
    build(): TColumn;
    content(valueOrTransform: ValueOrUpdateCallback<TContent | undefined>): this;
    facade(): TColumnFacade;
    modify(modifications: FluidLayoutColumnModifications<TContent, TColumn, TColumnFacade, this>): this;
    setColumn(valueOrUpdateCallback: ValueOrUpdateCallback<TColumn>): this;
    size(valueOrTransform: ValueOrUpdateCallback<IFluidLayoutSizeByScreen>): this;
}

// @alpha (undocumented)
export type IFluidLayoutColumnBuilderImpl<TContent> = IFluidLayoutColumnBuilder<TContent, IFluidLayoutColumn<TContent>, IFluidLayoutColumnFacadeImpl<TContent>>;

// @alpha (undocumented)
export interface IFluidLayoutColumnFacade<TContent, TColumn extends IFluidLayoutColumn<TContent>> {
    // (undocumented)
    content(): TContent | undefined;
    // (undocumented)
    contentEquals(content: TContent): boolean;
    // (undocumented)
    contentIs(content: TContent): boolean;
    // (undocumented)
    hasContent(): boolean;
    // (undocumented)
    hasSizeForScreen(screen: ResponsiveScreenType): boolean;
    // (undocumented)
    index(): number;
    // (undocumented)
    indexIs(index: number): boolean;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    isFirstInRow(): boolean;
    // (undocumented)
    isLastInRow(): boolean;
    // (undocumented)
    raw(): TColumn;
    // (undocumented)
    row(): IFluidLayoutRowFacade<TContent, IFluidLayoutRow<TContent>>;
    // (undocumented)
    size(): IFluidLayoutSizeByScreen;
    // (undocumented)
    sizeForScreen(screen: ResponsiveScreenType): IFluidLayoutSize | undefined;
    // (undocumented)
    test(pred: (column: this) => boolean): boolean;
    // (undocumented)
    testRaw(pred: (column: TColumn) => boolean): boolean;
}

// @alpha (undocumented)
export type IFluidLayoutColumnFacadeImpl<TContent> = IFluidLayoutColumnFacade<TContent, IFluidLayoutColumn<TContent>>;

// @alpha (undocumented)
export interface IFluidLayoutColumnsFacade<TContent, TColumn extends IFluidLayoutColumn<TContent>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>> {
    // (undocumented)
    all(): TColumnFacade[];
    // (undocumented)
    column(columnIndex: number): TColumnFacade | undefined;
    // (undocumented)
    count(): number;
    // (undocumented)
    every(pred: (column: TColumnFacade) => boolean): boolean;
    // (undocumented)
    filter(pred: (row: TColumnFacade) => boolean): TColumnFacade[];
    // (undocumented)
    find(pred: (column: TColumnFacade) => boolean): TColumnFacade | undefined;
    // (undocumented)
    flatMap<TReturn>(callback: (row: TColumnFacade) => TReturn[]): TReturn[];
    // (undocumented)
    map<TReturn>(callback: (column: TColumnFacade) => TReturn): TReturn[];
    // (undocumented)
    raw(): TColumn[];
    // (undocumented)
    reduce<TReturn>(callback: (acc: TReturn, column: TColumnFacade) => TReturn, initialValue: TReturn): TReturn;
    // (undocumented)
    some(pred: (column: TColumnFacade) => boolean): boolean;
}

// @alpha (undocumented)
export type IFluidLayoutColumnsFacadeImpl<TContent> = IFluidLayoutColumnsFacade<TContent, IFluidLayoutColumn<TContent>, IFluidLayoutColumnFacadeImpl<TContent>>;

// @alpha (undocumented)
export interface IFluidLayoutFacade<TContent, TLayout extends IFluidLayout<TContent>> {
    // (undocumented)
    raw(): TLayout;
    // (undocumented)
    rows(): IFluidLayoutRowsFacade<TContent, IFluidLayoutRow<TContent>, IFluidLayoutRowFacade<TContent, IFluidLayoutRow<TContent>>>;
    // (undocumented)
    size(): IFluidLayoutSize | undefined;
}

// @alpha (undocumented)
export type IFluidLayoutFacadeImpl<TContent> = IFluidLayoutFacade<TContent, IFluidLayout<TContent>>;

// @alpha
export interface IFluidLayoutRow<TContent> {
    columns: IFluidLayoutColumn<TContent>[];
    header?: IFluidLayoutSectionHeader;
}

// @alpha
export interface IFluidLayoutRowBuilder<TContent, TRow extends IFluidLayoutRow<TContent>, TColumn extends IFluidLayoutColumn<TContent>, TRowFacade extends IFluidLayoutRowFacade<TContent, TRow>, TColumnFacade extends IFluidLayoutColumnFacade<TContent, TColumn>, TColumnsFacade extends IFluidLayoutColumnsFacade<TContent, TColumn, TColumnFacade>, TColumnBuilder extends IFluidLayoutColumnBuilder<TContent, TColumn, TColumnFacade>> {
    addColumn(xlSize: IFluidLayoutSize, create?: (builder: TColumnBuilder) => TColumnBuilder, index?: number): this;
    build(): TRow;
    facade(): TRowFacade;
    header(valueOrTransform: ValueOrUpdateCallback<IFluidLayoutSectionHeader | undefined>): this;
    modify(modifications: FluidLayoutRowModifications<TContent, TColumn, TRow, TRowFacade, TColumnFacade, TColumnsFacade, TColumnBuilder, this>): this;
    modifyColumn(index: number, modify: FluidLayoutColumnModifications<TContent, TColumn, TColumnFacade, TColumnBuilder>): this;
    modifyColumns(modify: FluidLayoutColumnModifications<TContent, TColumn, TColumnFacade, TColumnBuilder>, selector?: FluidLayoutColumnsSelector<TContent, TColumn, TColumnFacade, TColumnsFacade>): this;
    moveColumn(fromIndex: number, toIndex: number): this;
    removeColumn(index: number): this;
    removeColumns(selector?: FluidLayoutColumnsSelector<TContent, TColumn, TColumnFacade, TColumnsFacade>): this;
    removeEmptyColumns(): this;
    setRow(valueOrUpdateCallback: ValueOrUpdateCallback<TRow>): this;
}

// @alpha (undocumented)
export type IFluidLayoutRowBuilderImpl<TContent> = IFluidLayoutRowBuilder<TContent, IFluidLayoutRow<TContent>, IFluidLayoutColumn<TContent>, IFluidLayoutRowFacadeImpl<TContent>, IFluidLayoutColumnFacadeImpl<TContent>, IFluidLayoutColumnsFacadeImpl<TContent>, IFluidLayoutColumnBuilderImpl<TContent>>;

// @alpha (undocumented)
export interface IFluidLayoutRowFacade<TContent, TRow extends IFluidLayoutRow<TContent>> {
    // (undocumented)
    columns(): IFluidLayoutColumnsFacade<TContent, IFluidLayoutColumn<TContent>, IFluidLayoutColumnFacade<TContent, IFluidLayoutColumn<TContent>>>;
    // (undocumented)
    description(): string | undefined;
    // (undocumented)
    descriptionEquals(title: string): boolean;
    // (undocumented)
    hasDescription(): boolean;
    // (undocumented)
    hasHeader(): boolean;
    // (undocumented)
    hasTitle(): boolean;
    // (undocumented)
    header(): IFluidLayoutSectionHeader | undefined;
    // (undocumented)
    headerEquals(header: IFluidLayoutSectionHeader): boolean;
    // (undocumented)
    index(): number;
    // (undocumented)
    indexIs(index: number): boolean;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    isFirst(): boolean;
    // (undocumented)
    isLast(): boolean;
    // (undocumented)
    layout(): IFluidLayoutFacade<TContent, IFluidLayout<TContent>>;
    // (undocumented)
    raw(): TRow;
    // (undocumented)
    test(pred: (column: this) => boolean): boolean;
    // (undocumented)
    testRaw(pred: (column: TRow) => boolean): boolean;
    // (undocumented)
    title(): string | undefined;
    // (undocumented)
    titleEquals(title: string): boolean;
}

// @alpha (undocumented)
export type IFluidLayoutRowFacadeImpl<TContent> = IFluidLayoutRowFacade<TContent, IFluidLayoutRow<TContent>>;

// @alpha (undocumented)
export interface IFluidLayoutRowsFacade<TContent, TRow extends IFluidLayoutRow<TContent>, TRowFacade extends IFluidLayoutRowFacade<TContent, TRow>> {
    // (undocumented)
    all(): TRowFacade[];
    // (undocumented)
    count(): number;
    // (undocumented)
    every(pred: (row: TRowFacade) => boolean): boolean;
    // (undocumented)
    filter(pred: (row: TRowFacade) => boolean): TRowFacade[];
    // (undocumented)
    find(pred: (row: TRowFacade) => boolean): TRowFacade | undefined;
    // (undocumented)
    flatMap<TReturn>(callback: (row: TRowFacade) => TReturn[]): TReturn[];
    // (undocumented)
    map<TReturn>(callback: (row: TRowFacade) => TReturn): TReturn[];
    // (undocumented)
    raw(): TRow[];
    // (undocumented)
    reduce<TReturn>(callback: (acc: TReturn, row: TRowFacade) => TReturn, initialValue: TReturn): TReturn;
    // (undocumented)
    row(rowIndex: number): TRowFacade | undefined;
    // (undocumented)
    some(pred: (row: TRowFacade) => boolean): boolean;
}

// @alpha (undocumented)
export type IFluidLayoutRowsFacadeImpl<TContent> = IFluidLayoutRowsFacade<TContent, IFluidLayoutRow<TContent>, IFluidLayoutRowFacadeImpl<TContent>>;

// @alpha
export interface IFluidLayoutSectionHeader {
    description?: string;
    title?: string;
}

// @alpha
export interface IFluidLayoutSize {
    heightAsRatio?: number;
    widthAsGridColumnsCount: number;
}

// @alpha
export interface IFluidLayoutSizeByScreen {
    lg?: IFluidLayoutSize;
    md?: IFluidLayoutSize;
    sm?: IFluidLayoutSize;
    xl: IFluidLayoutSize;
    xs?: IFluidLayoutSize;
}

// @public
export interface IGetVisualizationClassesOptions {
    includeDeprecated?: boolean;
}

// @public
export interface IGroupableCatalogItemBase extends ICatalogItemBase {
    groups: ObjRef[];
}

// @public
export interface IInsightReferences {
    catalogItems?: CatalogItem[];
    dataSetMeta?: IMetadataObject[];
}

// @public
export interface IInsightReferencing {
    analyticalDashboards?: IMetadataObject[];
}

// @public
export interface IInsightsQueryOptions {
    author?: string;
    limit?: number;
    offset?: number;
    orderBy?: InsightOrdering;
    title?: string;
}

// @public
export type IInsightsQueryResult = IPagedResource<IInsight>;

// @alpha (undocumented)
export interface IInsightWidget extends IInsightWidgetBase, IDashboardObjectIdentity {
}

// @alpha (undocumented)
export interface IInsightWidgetBase extends IWidgetBase {
    readonly insight: ObjRef;
    readonly properties?: VisualizationProperties;
    // (undocumented)
    readonly type: "insight";
}

// @alpha (undocumented)
export interface IInsightWidgetDefinition extends IInsightWidgetBase, Partial<IDashboardObjectIdentity> {
}

// @alpha (undocumented)
export interface IKpiWidget extends IKpiWidgetBase, IDashboardObjectIdentity {
}

// @alpha (undocumented)
export interface IKpiWidgetBase extends IWidgetBase {
    readonly kpi: ILegacyKpi;
    // (undocumented)
    readonly type: "kpi";
}

// @alpha (undocumented)
export interface IKpiWidgetDefinition extends IKpiWidgetBase, Partial<IDashboardObjectIdentity> {
}

// @alpha
export type ILegacyKpi = ILegacyKpiWithComparison | ILegacyKpiWithoutComparison;

// @alpha
export interface ILegacyKpiBase {
    // (undocumented)
    comparisonDirection?: ILegacyKpiComparisonDirection;
    // (undocumented)
    comparisonType: ILegacyKpiComparisonTypeComparison;
    // (undocumented)
    metric: ObjRef;
}

// @alpha
export type ILegacyKpiComparisonDirection = "growIsGood" | "growIsBad";

// @alpha
export type ILegacyKpiComparisonTypeComparison = "previousPeriod" | "lastYear" | "none";

// @alpha (undocumented)
export type ILegacyKpiWithComparison = ILegacyKpiWithPreviousPeriodComparison | ILegacyKpiWithPopComparison;

// @alpha
export interface ILegacyKpiWithoutComparison extends ILegacyKpiBase {
    // (undocumented)
    comparisonType: "none";
}

// @alpha
export interface ILegacyKpiWithPopComparison extends ILegacyKpiBase {
    // (undocumented)
    comparisonDirection: ILegacyKpiComparisonDirection;
    // (undocumented)
    comparisonType: "lastYear";
}

// @alpha
export interface ILegacyKpiWithPreviousPeriodComparison extends ILegacyKpiBase {
    // (undocumented)
    comparisonDirection: ILegacyKpiComparisonDirection;
    // (undocumented)
    comparisonType: "previousPeriod";
}

// @alpha
export interface IListedDashboard {
    readonly created: string;
    readonly description: string;
    readonly identifier: string;
    readonly ref: ObjRef;
    readonly title: string;
    readonly updated: string;
    readonly uri: string;
}

// @public
export interface IMeasureDescriptor {
    // (undocumented)
    measureHeaderItem: {
        localIdentifier: string;
        name: string;
        format: string;
        uri?: string;
        identifier?: string;
        ref?: ObjRef;
    };
}

// @public
export type IMeasureExpressionToken = IObjectExpressionToken | IAttributeElementExpressionToken | ITextExpressionToken;

// @public
export interface IMeasureGroupDescriptor {
    // (undocumented)
    measureGroupHeader: {
        items: IMeasureDescriptor[];
        totalItems?: ITotalDescriptor[];
    };
}

// @public
export interface IMeasureMetadataObject extends IMetadataObject {
    expression: string;
    format: string;
    // (undocumented)
    type: "measure";
}

// @public (undocumented)
export interface IMetadataObject {
    deprecated: boolean;
    description: string;
    id: string;
    production: boolean;
    ref: ObjRef;
    title: string;
    type: ObjectType;
    unlisted: boolean;
    uri: string;
}

// @alpha
export type InsightDrillDefinition = IDrillToInsight | IDrillToDashboard | IDrillToCustomUrl | IDrillToAttributeUrl;

// @public
export type InsightOrdering = "id" | "title" | "updated";

// @public (undocumented)
export type InsightReferenceTypes = Exclude<ObjectType, "insight" | "tag">;

// @public
export interface IObjectExpressionToken {
    ref: ObjRef;
    type: ObjectType;
    value: string;
}

// @public
export interface IPagedResource<TItem> {
    // (undocumented)
    readonly items: TItem[];
    // (undocumented)
    readonly limit: number;
    next(): Promise<IPagedResource<TItem>>;
    // (undocumented)
    readonly offset: number;
    // (undocumented)
    readonly totalCount: number;
}

// @public
export interface IPreparedExecution {
    readonly definition: IExecutionDefinition;
    equals(other: IPreparedExecution): boolean;
    execute(): Promise<IExecutionResult>;
    fingerprint(): string;
    withDateFormat(dateFormat: string): IPreparedExecution;
    withDimensions(...dim: Array<IDimension | DimensionGenerator>): IPreparedExecution;
    withSorting(...items: ISortItem[]): IPreparedExecution;
}

// @alpha
export interface IRelativeDateFilterForm extends IDateFilterOption {
    availableGranularities: DateFilterGranularity[];
    type: RelativeFormType;
}

// @alpha
export interface IRelativeDateFilterPreset extends IDateFilterOption {
    from: RelativeGranularityOffset;
    granularity: DateFilterGranularity;
    to: RelativeGranularityOffset;
    type: RelativePresetType;
}

// @alpha
export interface IRelativeDateFilterPresetOfGranularity<Key extends DateFilterGranularity> extends IRelativeDateFilterPreset {
    granularity: Key;
}

// @public
export interface IResultAttributeHeader {
    // (undocumented)
    attributeHeaderItem: {
        name: string;
        uri: string;
    };
}

// @public
export type IResultHeader = IResultAttributeHeader | IResultMeasureHeader | IResultTotalHeader;

// @public
export interface IResultMeasureHeader {
    // (undocumented)
    measureHeaderItem: {
        name: string;
        order: number;
    };
}

// @public
export interface IResultTotalHeader {
    // (undocumented)
    totalHeaderItem: {
        name: string;
        type: string;
    };
}

// @public
export interface IResultWarning {
    message: string;
    parameters?: (ObjRef | string)[];
    warningCode: string;
}

// @alpha
export const isAbsoluteDateFilterForm: (obj: unknown) => obj is IAbsoluteDateFilterForm;

// @alpha
export const isAbsoluteDateFilterPreset: (obj: unknown) => obj is IAbsoluteDateFilterPreset;

// @alpha
export const isAllTimeDateFilterOption: (obj: unknown) => obj is IAllTimeDateFilterOption;

// @public
export function isAnalyticalBackendError(obj: unknown): obj is AnalyticalBackendError;

// @public
export function isAttributeDescriptor(obj: unknown): obj is IAttributeDescriptor;

// @public
export function isAttributeDisplayFormMetadataObject(obj: unknown): obj is IAttributeDisplayFormMetadataObject;

// @public
export function isAttributeMetadataObject(obj: unknown): obj is IAttributeMetadataObject;

// @public
export function isCatalogAttribute(obj: unknown): obj is ICatalogAttribute;

// @public
export function isCatalogDateDataset(obj: unknown): obj is ICatalogDateDataset;

// @public
export function isCatalogFact(obj: unknown): obj is ICatalogFact;

// @public
export function isCatalogMeasure(obj: unknown): obj is ICatalogMeasure;

// @alpha
export interface IScheduledMail extends IScheduledMailBase, IDashboardObjectIdentity {
}

// @alpha
export interface IScheduledMailBase {
    attachments: ScheduledMailAttachment[];
    bcc?: string[];
    body: string;
    description: string;
    lastSuccessful?: string;
    subject: string;
    title: string;
    to: string[];
    unlisted: boolean;
    unsubscribed?: string[];
    when: {
        startDate: string;
        endDate?: string;
        recurrence: string;
        timeZone: string;
    };
}

// @alpha
export interface IScheduledMailDefinition extends IScheduledMailBase, Partial<IDashboardObjectIdentity> {
}

// @alpha
export function isDashboardAttributeFilter(obj: unknown): obj is IDashboardAttributeFilter;

// @alpha
export function isDashboardAttributeFilterReference(obj: unknown): obj is IDashboardAttributeFilterReference;

// @alpha
export function isDashboardDateFilter(obj: unknown): obj is IDashboardDateFilter;

// @alpha
export function isDashboardDateFilterReference(obj: unknown): obj is IDashboardDateFilterReference;

// @alpha
export const isDashboardLayoutContent: (obj: unknown) => obj is IDashboardLayoutContent;

// @public
export function isDataSetMetadataObject(obj: unknown): obj is IDataSetMetadataObject;

// @public
export function isDataTooLargeError(obj: unknown): obj is DataTooLargeError;

// @alpha
export const isDateFilterGranularity: (obj: unknown) => obj is DateFilterGranularity;

// @alpha
export function isDrillToAttributeUrl(obj: unknown): obj is IDrillToAttributeUrl;

// @alpha
export function isDrillToCustomUrl(obj: unknown): obj is IDrillToCustomUrl;

// @alpha
export function isDrillToDashboard(obj: unknown): obj is IDrillToDashboard;

// @alpha
export function isDrillToInsight(obj: unknown): obj is IDrillToInsight;

// @alpha
export function isDrillToLegacyDashboard(obj: unknown): obj is IDrillToLegacyDashboard;

// @public
export interface ISeparators {
    decimal: string;
    thousand: string;
}

// @public
export interface ISettings {
    // (undocumented)
    [key: string]: number | boolean | string | object | undefined;
    ADMeasureValueFilterNullAsZeroOption?: string;
    areSectionHeadersEnabled?: boolean;
    disableKpiDashboardHeadlineUnderline?: boolean;
    enableAxisNameConfiguration?: boolean;
    enableBulletChart?: boolean;
    enableCustomColorPicker?: boolean;
    enableHidingOfDataPoints?: boolean;
    enableKDZooming?: boolean;
    enableKPIDashboardSchedule?: boolean;
    enableKPIDashboardScheduleRecipients?: boolean;
    enableMultipleDates?: boolean;
    enablePushpinGeoChart?: boolean;
    enableTableColumnsAutoResizing?: boolean;
    enableTableColumnsGrowToFit?: boolean;
    enableTableColumnsManualResizing?: boolean;
    enableWeekFilters?: boolean;
    responsiveUiDateFormat?: string;
}

// @public
export function isFactMetadataObject(obj: unknown): obj is IFactMetadataObject;

// @alpha
export function isFilterContext(obj: unknown): obj is IFilterContext;

// @alpha
export function isFilterContextDefinition(obj: unknown): obj is IFilterContextDefinition;

// @alpha
export function isFluidLayout<TContent>(obj: unknown): obj is IFluidLayout<TContent>;

// @alpha
export function isFluidLayoutColumn<TContent>(obj: unknown): obj is IFluidLayoutColumn<TContent>;

// @alpha
export const isFluidLayoutEmpty: (layout: IFluidLayout<any>) => boolean;

// @alpha
export function isFluidLayoutRow<TContent>(obj: unknown): obj is IFluidLayoutRow<TContent>;

// @alpha
export function isInsightWidget(obj: unknown): obj is IInsightWidget;

// @alpha
export function isInsightWidgetDefinition(obj: unknown): obj is IInsightWidgetDefinition;

// @alpha
export function isKpiWidget(obj: unknown): obj is IKpiWidget;

// @alpha
export function isKpiWidgetDefinition(obj: unknown): obj is IKpiWidgetDefinition;

// @alpha
export function isLegacyKpiWithComparison(obj: unknown): obj is ILegacyKpiWithComparison;

// @alpha
export function isLegacyKpiWithoutComparison(obj: unknown): obj is ILegacyKpiWithoutComparison;

// @public
export function isMeasureDescriptor(obj: unknown): obj is IMeasureDescriptor;

// @public
export function isMeasureGroupDescriptor(obj: unknown): obj is IMeasureGroupDescriptor;

// @public
export function isMeasureMetadataObject(obj: unknown): obj is IMeasureMetadataObject;

// @public (undocumented)
export function isMetadataObject(obj: unknown): obj is IMetadataObject;

// @public
export function isNoDataError(obj: unknown): obj is NoDataError;

// @public
export function isNotAuthenticated(obj: unknown): obj is NotAuthenticated;

// @public
export function isNotImplemented(obj: unknown): obj is NotImplemented;

// @public
export function isNotSupported(obj: unknown): obj is NotSupported;

// @public
export function isProtectedDataError(obj: unknown): obj is ProtectedDataError;

// @alpha
export const isRelativeDateFilterForm: (obj: unknown) => obj is IRelativeDateFilterForm;

// @alpha
export const isRelativeDateFilterPreset: (obj: unknown) => obj is IRelativeDateFilterPreset;

// @public
export function isResultAttributeHeader(obj: unknown): obj is IResultAttributeHeader;

// @public
export function isResultMeasureHeader(obj: unknown): obj is IResultMeasureHeader;

// @public
export function isResultTotalHeader(obj: unknown): obj is IResultTotalHeader;

// @alpha
export function isTempFilterContext(obj: unknown): obj is ITempFilterContext;

// @public
export function isTotalDescriptor(obj: unknown): obj is ITotalDescriptor;

// @public
export function isUnexpectedError(obj: unknown): obj is UnexpectedError;

// @public
export function isUnexpectedResponseError(obj: unknown): obj is UnexpectedResponseError;

// @public
export function isVariableMetadataObject(obj: unknown): obj is IVariableMetadataObject;

// @alpha
export function isWidget(obj: unknown): obj is IWidget;

// @alpha
export function isWidgetAlert(obj: unknown): obj is IWidgetAlert;

// @alpha
export function isWidgetAlertDefinition(obj: unknown): obj is IWidgetAlertDefinition;

// @alpha
export function isWidgetDefinition(obj: unknown): obj is IWidgetDefinition;

// @alpha
export interface ITempFilterContext {
    readonly created: string;
    readonly filters: FilterContextItem[];
    readonly ref: ObjRef;
    readonly uri: string;
}

// @public
export interface ITextExpressionToken {
    type: "text";
    value: string;
}

// @beta
export interface ITheme {
    analyticalDesigner?: {
        title?: {
            color?: ThemeColor;
        };
    };
    button?: {
        borderRadius?: string;
        dropShadow?: boolean;
        textCapitalization?: boolean;
    };
    chart?: IThemeChart;
    dashboards?: {
        title?: {
            color?: ThemeColor;
            backgroundColor?: ThemeColor;
            borderColor?: ThemeColor;
        };
        section?: {
            title?: {
                color?: ThemeColor;
                lineColor?: ThemeColor;
            };
            description?: {
                color?: ThemeColor;
            };
        };
        filterBar?: {
            backgroundColor?: ThemeColor;
            borderColor?: ThemeColor;
            filterButton?: {
                backgroundColor?: ThemeColor;
            };
        };
        content?: {
            backgroundColor?: ThemeColor;
            widget?: {
                title?: IThemeWidgetTitle;
                backgroundColor?: ThemeColor;
                borderColor?: ThemeColor;
                borderWidth?: string;
                borderRadius?: string;
                dropShadow?: boolean;
            };
            kpiWidget?: {
                title?: IThemeWidgetTitle;
                backgroundColor?: ThemeColor;
                borderColor?: ThemeColor;
                borderWidth?: string;
                borderRadius?: string;
                dropShadow?: boolean;
                kpi?: IThemeKpi;
            };
        };
        navigation?: {
            backgroundColor?: ThemeColor;
            borderColor?: ThemeColor;
            title?: {
                color?: ThemeColor;
            };
            item?: {
                color?: ThemeColor;
                hoverColor?: ThemeColor;
                selectedColor?: ThemeColor;
                selectedBackgroundColor?: ThemeColor;
            };
        };
        editPanel?: {
            backgroundColor?: ThemeColor;
        };
    };
    kpi?: IThemeKpi;
    modal?: {
        title?: {
            color?: ThemeColor;
            lineColor?: ThemeColor;
        };
        outsideBackgroundColor?: ThemeColor;
        dropShadow?: boolean;
        borderWidth?: string;
        borderColor?: ThemeColor;
        borderRadius?: string;
    };
    palette?: IThemePalette;
    tooltip?: {
        backgroundColor?: ThemeColor;
        color?: ThemeColor;
    };
    typography?: IThemeTypography;
}

// @internal
export interface IThemeChart {
    backgroundColor?: IThemeColorFamily;
    textColor?: IThemeColorFamily;
}

// @beta
export interface IThemeColorFamily {
    base: ThemeColor;
    contrast?: ThemeColor;
    dark?: ThemeColor;
    light?: ThemeColor;
}

// @beta
export interface IThemeKpi {
    primaryMeasureColor?: ThemeColor;
    secondaryInfoColor?: ThemeColor;
    value?: {
        textAlign?: string;
        positiveColor?: ThemeColor;
        negativeColor?: ThemeColor;
    };
}

// @beta
export interface IThemePalette {
    error?: IThemeColorFamily;
    info?: IThemeColorFamily;
    primary?: IThemeColorFamily;
    success?: IThemeColorFamily;
    warning?: IThemeColorFamily;
}

// @beta
export interface IThemeTypography {
    font?: ThemeFontUri;
    fontBold?: ThemeFontUri;
}

// @beta
export interface IThemeWidgetTitle {
    color?: ThemeColor;
    textAlign?: string;
}

// @public
export interface ITotalDescriptor {
    // (undocumented)
    totalHeaderItem: {
        name: string;
    };
}

// @alpha
export interface IUser {
    email?: string;
    firstName?: string;
    lastName?: string;
    login: string;
    ref: ObjRef;
}

// @public
export interface IUserService {
    getUser(): Promise<IUser>;
    settings(): IUserSettingsService;
}

// @public
export interface IUserSettings extends ISettings {
    locale: string;
    separators: ISeparators;
    userId: string;
}

// @public
export interface IUserSettingsService {
    getSettings(): Promise<IUserSettings>;
}

// @public
export interface IUserWorkspaceSettings extends IUserSettings, IWorkspaceSettings {
}

// @public
export interface IVariableMetadataObject extends IMetadataObject {
    // (undocumented)
    type: "variable";
}

// @alpha (undocumented)
export type IWidget = IKpiWidget | IInsightWidget;

// @alpha
export interface IWidgetAlert extends IWidgetAlertBase, IDashboardObjectIdentity {
    readonly filterContext?: IFilterContext;
}

// @alpha
export interface IWidgetAlertBase {
    readonly dashboard: ObjRef;
    readonly description: string;
    readonly isTriggered: boolean;
    readonly threshold: number;
    readonly title: string;
    readonly whenTriggered: "underThreshold" | "aboveThreshold";
    readonly widget: ObjRef;
}

// @alpha
export interface IWidgetAlertCount {
    readonly alertCount: number;
    readonly ref: ObjRef;
}

// @alpha
export interface IWidgetAlertDefinition extends IWidgetAlertBase, Partial<IDashboardObjectIdentity> {
    readonly filterContext?: IFilterContext | IFilterContextDefinition;
}

// @alpha
export interface IWidgetBase {
    readonly dateDataSet?: ObjRef;
    readonly description: string;
    readonly drills: DrillDefinition[];
    readonly ignoreDashboardFilters: IDashboardFilterReference[];
    readonly title: string;
    readonly type: WidgetType;
}

// @alpha
export type IWidgetDefinition = IKpiWidgetDefinition | IInsightWidgetDefinition;

// @alpha
export interface IWidgetReferences {
    catalogItems?: CatalogItem[];
}

// @alpha
export interface IWidgetWithLayoutPath {
    // (undocumented)
    path: LayoutPath;
    // (undocumented)
    widget: IWidget | IWidgetDefinition;
}

// @public
export interface IWorkspaceAttributesService {
    elements(): IElementsQueryFactory;
    getAttribute(ref: ObjRef): Promise<IAttributeMetadataObject>;
    getAttributeDisplayForm(ref: ObjRef): Promise<IAttributeDisplayFormMetadataObject>;
    getAttributeDisplayForms(refs: ObjRef[]): Promise<IAttributeDisplayFormMetadataObject[]>;
    getAttributes(refs: ObjRef[]): Promise<IAttributeMetadataObject[]>;
    getCommonAttributes(attributeRefs: ObjRef[]): Promise<ObjRef[]>;
    getCommonAttributesBatch(attributesRefsBatch: ObjRef[][]): Promise<ObjRef[][]>;
}

// @public
export interface IWorkspaceCatalog extends IWorkspaceCatalogMethods {
    availableItems(): IWorkspaceCatalogAvailableItemsFactory;
}

// @public
export interface IWorkspaceCatalogAvailableItemsFactory extends IWorkspaceCatalogFactoryMethods<IWorkspaceCatalogAvailableItemsFactory, IWorkspaceCatalogWithAvailableItemsFactoryOptions> {
    forInsight(insight: IInsightDefinition): IWorkspaceCatalogAvailableItemsFactory;
    forItems(items: IAttributeOrMeasure[]): IWorkspaceCatalogAvailableItemsFactory;
    load(): Promise<IWorkspaceCatalogWithAvailableItems>;
}

// @public
export interface IWorkspaceCatalogFactory extends IWorkspaceCatalogFactoryMethods<IWorkspaceCatalogFactory, IWorkspaceCatalogFactoryOptions> {
    load(): Promise<IWorkspaceCatalog>;
    readonly options: IWorkspaceCatalogFactoryOptions;
    readonly workspace: string;
}

// @public
export interface IWorkspaceCatalogFactoryMethods<TFactory, TOptions> {
    excludeTags(tags: ObjRef[]): TFactory;
    forDataset(dataset: ObjRef): TFactory;
    forTypes(types: CatalogItemType[]): TFactory;
    includeTags(tags: ObjRef[]): TFactory;
    withOptions(options: Partial<TOptions>): TFactory;
}

// @public
export interface IWorkspaceCatalogFactoryOptions {
    dataset?: ObjRef;
    excludeTags: ObjRef[];
    includeTags: ObjRef[];
    production?: boolean;
    types: CatalogItemType[];
}

// @public
export interface IWorkspaceCatalogMethods {
    allItems(): CatalogItem[];
    attributes(): ICatalogAttribute[];
    dateDatasets(): ICatalogDateDataset[];
    facts(): ICatalogFact[];
    groups(): ICatalogGroup[];
    measures(): ICatalogMeasure[];
}

// @public
export interface IWorkspaceCatalogWithAvailableItems extends IWorkspaceCatalogMethods {
    allAvailableItems(): CatalogItem[];
    availableAttributes(): ICatalogAttribute[];
    availableDateDatasets(): ICatalogDateDataset[];
    availableFacts(): ICatalogFact[];
    availableMeasures(): ICatalogMeasure[];
}

// @public
export interface IWorkspaceCatalogWithAvailableItemsFactoryOptions extends IWorkspaceCatalogFactoryOptions {
    insight?: IInsightDefinition;
    items?: IAttributeOrMeasure[];
}

// @alpha
export interface IWorkspaceDashboardsService {
    createDashboard(dashboard: IDashboardDefinition): Promise<IDashboard>;
    createScheduledMail(scheduledMail: IScheduledMailDefinition, exportFilterContext?: IFilterContextDefinition): Promise<IScheduledMail>;
    createWidgetAlert(alert: IWidgetAlertDefinition): Promise<IWidgetAlert>;
    deleteDashboard(ref: ObjRef): Promise<void>;
    deleteWidgetAlert(ref: ObjRef): Promise<void>;
    deleteWidgetAlerts(refs: ObjRef[]): Promise<void>;
    exportDashboardToPdf(ref: ObjRef, filters?: FilterContextItem[]): Promise<string>;
    getAllWidgetAlertsForCurrentUser(): Promise<IWidgetAlert[]>;
    getDashboard(ref: ObjRef, filterContextRef?: ObjRef): Promise<IDashboard>;
    getDashboards(): Promise<IListedDashboard[]>;
    getDashboardWidgetAlertsForCurrentUser(ref: ObjRef): Promise<IWidgetAlert[]>;
    getDashboardWithReferences(ref: ObjRef, filterContextRef?: ObjRef): Promise<IDashboardWithReferences>;
    getResolvedFiltersForWidget(widget: IWidget, filters: IFilter[]): Promise<IFilter[]>;
    getScheduledMailsCountForDashboard(ref: ObjRef): Promise<number>;
    getWidgetAlertsCountForWidgets(refs: ObjRef[]): Promise<IWidgetAlertCount[]>;
    getWidgetReferencedObjects(widget: IWidget, types?: SupportedWidgetReferenceTypes[]): Promise<IWidgetReferences>;
    updateDashboard(dashboard: IDashboard, updatedDashboard: IDashboardDefinition): Promise<IDashboard>;
    updateWidgetAlert(alert: IWidgetAlert | IWidgetAlertDefinition): Promise<IWidgetAlert>;
    // (undocumented)
    readonly workspace: string;
}

// @public
export interface IWorkspaceDatasetsService {
    getAllDatasetsMeta(): Promise<IMetadataObject[]>;
    getDatasets(): Promise<IDataset[]>;
}

// @public
export interface IWorkspaceDescriptor {
    // (undocumented)
    description: string;
    // (undocumented)
    id: string;
    // (undocumented)
    isDemo?: boolean;
    // (undocumented)
    title: string;
}

// @public
export interface IWorkspaceFactsService {
    getFactDatasetMeta(ref: ObjRef): Promise<IMetadataObject>;
}

// @public
export interface IWorkspaceInsightsService {
    createInsight(insight: IInsightDefinition): Promise<IInsight>;
    deleteInsight(ref: ObjRef): Promise<void>;
    getInsight(ref: ObjRef): Promise<IInsight>;
    getInsightReferencedObjects(insight: IInsight, types?: SupportedInsightReferenceTypes[]): Promise<IInsightReferences>;
    getInsightReferencingObjects(ref: ObjRef): Promise<IInsightReferencing>;
    getInsights(options?: IInsightsQueryOptions): Promise<IInsightsQueryResult>;
    getInsightWithAddedFilters<T extends IInsightDefinition>(insight: T, filters: IFilter[]): Promise<T>;
    getVisualizationClass(ref: ObjRef): Promise<IVisualizationClass>;
    getVisualizationClasses(options?: IGetVisualizationClassesOptions): Promise<IVisualizationClass[]>;
    updateInsight(insight: IInsight): Promise<IInsight>;
}

// @public
export interface IWorkspaceMeasuresService {
    getMeasureExpressionTokens(ref: ObjRef): Promise<IMeasureExpressionToken[]>;
}

// @public
export type IWorkspacePermissions = {
    [permission in WorkspacePermission]: boolean;
};

// @public
export interface IWorkspacePermissionsService {
    getPermissionsForCurrentUser(): Promise<IWorkspacePermissions>;
}

// @public
export interface IWorkspaceSettings extends ISettings {
    workspace: string;
}

// @public
export interface IWorkspaceSettingsService {
    getSettings(): Promise<IWorkspaceSettings>;
    getSettingsForCurrentUser(): Promise<IUserWorkspaceSettings>;
}

// @public
export interface IWorkspacesQuery {
    query(): Promise<IWorkspacesQueryResult>;
    withLimit(limit: number): IWorkspacesQuery;
    withOffset(offset: number): IWorkspacesQuery;
    withSearch(search: string): IWorkspacesQuery;
}

// @public
export interface IWorkspacesQueryFactory {
    forCurrentUser(): IWorkspacesQuery;
    forUser(userId: string): IWorkspacesQuery;
}

// @public
export interface IWorkspacesQueryResult extends IPagedResource<IAnalyticalWorkspace> {
    // (undocumented)
    search: string | undefined;
}

// @public
export interface IWorkspaceStylingService {
    getColorPalette(): Promise<IColorPalette>;
    getTheme(): Promise<ITheme>;
}

// @public
export interface IWorkspaceUser {
    email: string;
    firstName?: string;
    lastName?: string;
    login: string;
    ref: ObjRef;
    uri: string;
}

// @public
export interface IWorkspaceUsersQuery {
    queryAll(): Promise<IWorkspaceUser[]>;
    withOptions(options: IWorkspaceUsersQueryOptions): IWorkspaceUsersQuery;
}

// @public
export interface IWorkspaceUsersQueryOptions {
    search?: string;
}

// @alpha
export type KpiDrillDefinition = IDrillToLegacyDashboard;

// @alpha
export type LayoutPath = Array<string | number>;

// @alpha (undocumented)
export function layoutWidgets(layout: IDashboardLayout): Array<IWidgetDefinition | IWidget>;

// @alpha
export function layoutWidgetsWithPaths(layout: IDashboardLayout): IWidgetWithLayoutPath[];

// @public
export type MetadataObject = IAttributeMetadataObject | IAttributeDisplayFormMetadataObject | IFactMetadataObject | IMeasureMetadataObject | IDataSetMetadataObject | IVariableMetadataObject;

// @public
export const metadataObjectId: (metadataObject: MetadataObject) => string;

// @public
export class NoDataError extends AnalyticalBackendError {
    constructor(message: string, dataView?: IDataView, cause?: Error);
    readonly dataView?: IDataView;
}

// @public
export class NotAuthenticated extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
    // (undocumented)
    authenticationFlow?: AuthenticationFlow;
}

// @public (undocumented)
export type NotAuthenticatedHandler = (context: IAuthenticationContext, error: NotAuthenticated) => void;

// @public
export class NotImplemented extends AnalyticalBackendError {
    constructor(message: string);
}

// @public
export class NotSupported extends AnalyticalBackendError {
    constructor(message: string);
}

// @alpha
export type OptionType = AllTimeType | AbsoluteFormType | RelativeFormType | AbsolutePresetType | RelativePresetType;

// @public
export function prepareExecution(backend: IAnalyticalBackend, definition: IExecutionDefinition): IPreparedExecution;

// @public
export class ProtectedDataError extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @alpha
export type RelativeFormType = "relativeForm";

// @alpha
export type RelativeGranularityOffset = number;

// @alpha
export type RelativePresetType = "relativePreset";

// @alpha
export type RelativeType = "relative";

// @alpha
export const resolveValueOrUpdateCallback: <TValue>(valueOrUpdateCallback: ValueOrUpdateCallback<TValue>, valueToUpdate: TValue) => TValue;

// @alpha
export type ResponsiveScreenType = "xl" | "lg" | "md" | "sm" | "xs";

// @public
export function resultHeaderName(header: IResultHeader): string;

// @alpha
export type ScheduledMailAttachment = IDashboardAttachment;

// @public
export type SupportedInsightReferenceTypes = Exclude<InsightReferenceTypes, "displayForm" | "variable">;

// @alpha
export type SupportedWidgetReferenceTypes = Exclude<ObjectType, "fact" | "attribute" | "displayForm" | "dataSet" | "tag" | "insight" | "variable">;

// @beta
export type ThemeColor = string;

// @beta
export type ThemeFontUri = string;

// @public
export class UnexpectedError extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @public
export class UnexpectedResponseError extends AnalyticalBackendError {
    constructor(message: string, httpStatus: number, responseBody: unknown, cause?: Error);
    // (undocumented)
    readonly httpStatus: number;
    // (undocumented)
    readonly responseBody: unknown;
}

// @alpha
export type ValueOrUpdateCallback<TValue> = TValue | ((value: TValue) => TValue);

// @alpha
export function walkLayout(layout: IDashboardLayout, { rowCallback, columnCallback, widgetCallback, }: {
    rowCallback?: (row: IDashboardLayoutRow, rowPath: LayoutPath) => void;
    columnCallback?: (column: IDashboardLayoutColumn, columnPath: LayoutPath) => void;
    widgetCallback?: (widget: IWidget | IWidgetDefinition, widgetPath: LayoutPath) => void;
}, path?: LayoutPath): void;

// @alpha
export function widgetId(widget: IWidget): string;

// @alpha
export type WidgetType = "kpi" | "insight";

// @alpha
export function widgetType(widget: IWidget): WidgetType;

// @alpha
export function widgetUri(widget: IWidget): string;

// @public
export type WorkspacePermission = "canInitData" | "canUploadNonProductionCSV" | "canExecuteRaw" | "canExportReport" | "canAccessWorkbench" | "canCreateReport" | "canCreateVisualization" | "canCreateAnalyticalDashboard" | "canManageMetric" | "canManageReport" | "canManageAnalyticalDashboard" | "canManageProject" | "canCreateScheduledMail" | "canListUsersInProject" | "canManageDomain" | "canInviteUserToProject" | "canRefreshData";


// (No @packageDocumentation comment for this package)

```
