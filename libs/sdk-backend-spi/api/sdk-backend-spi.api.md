## API Report File for "@gooddata/sdk-backend-spi"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttributeOrMeasure } from '@gooddata/sdk-model';
import { CatalogItem } from '@gooddata/sdk-model';
import { CatalogItemType } from '@gooddata/sdk-model';
import { DimensionGenerator } from '@gooddata/sdk-model';
import { IAttribute } from '@gooddata/sdk-model';
import { IAttributeDisplayFormMetadataObject } from '@gooddata/sdk-model';
import { IAttributeElement } from '@gooddata/sdk-model';
import { IBucket } from '@gooddata/sdk-model';
import { ICatalogAttribute } from '@gooddata/sdk-model';
import { ICatalogDateDataset } from '@gooddata/sdk-model';
import { ICatalogFact } from '@gooddata/sdk-model';
import { ICatalogGroup } from '@gooddata/sdk-model';
import { ICatalogMeasure } from '@gooddata/sdk-model';
import { IColorPalette } from '@gooddata/sdk-model';
import { IDataset } from '@gooddata/sdk-model';
import { IDimension } from '@gooddata/sdk-model';
import { IExecutionDefinition } from '@gooddata/sdk-model';
import { IFilter } from '@gooddata/sdk-model';
import { IInsight } from '@gooddata/sdk-model';
import { IInsightDefinition } from '@gooddata/sdk-model';
import { IMeasure } from '@gooddata/sdk-model';
import { IMeasureExpressionToken } from '@gooddata/sdk-model';
import { IMetadataObject } from '@gooddata/sdk-model';
import { IVisualizationClass } from '@gooddata/sdk-model';
import { IWorkspace } from '@gooddata/sdk-model';
import { IWorkspacePermissions } from '@gooddata/sdk-model';
import { ObjRef } from '@gooddata/sdk-model';
import { SortDirection } from '@gooddata/sdk-model';
import { SortItem } from '@gooddata/sdk-model';
import { WorkspacePermission } from '@gooddata/sdk-model';

// @public
export abstract class AbstractExecutionFactory implements IExecutionFactory {
    constructor(workspace: string);
    // (undocumented)
    forBuckets(buckets: IBucket[], filters?: IFilter[]): IPreparedExecution;
    // (undocumented)
    abstract forDefinition(def: IExecutionDefinition): IPreparedExecution;
    // (undocumented)
    forInsight(insight: IInsight, filters?: IFilter[]): IPreparedExecution;
    // (undocumented)
    abstract forInsightByRef(uri: string, filters?: IFilter[]): Promise<IPreparedExecution>;
    // (undocumented)
    forItems(items: AttributeOrMeasure[], filters?: IFilter[]): IPreparedExecution;
    }

// @public
export type AnalyticalBackendConfig = {
    readonly hostname?: string;
};

// @public
export abstract class AnalyticalBackendError extends Error {
    protected constructor(message: string, abeType: string, cause?: Error | undefined);
    // (undocumented)
    readonly abeType: string;
    // (undocumented)
    readonly cause?: Error | undefined;
}

// @public
export const AnalyticalBackendErrorTypes: {
    NO_DATA: string;
    DATA_TOO_LARGE: string;
    PROTECTED_DATA: string;
    UNEXPECTED_HTTP: string;
    UNEXPECTED: string;
    NOT_SUPPORTED: string;
    NOT_IMPLEMENTED: string;
    NOT_AUTHENTICATED: string;
};

// @public
export type AnalyticalBackendFactory<TClient, TUser> = (config?: AnalyticalBackendConfig, implConfig?: any) => IAnalyticalBackend<TClient, TUser>;

// @public
export function attributeDescriptorLocalId(descriptor: IAttributeDescriptor): string;

// @public
export function attributeDescriptorName(descriptor: IAttributeDescriptor): string;

// @public
export type AuthenticatedAsyncCall<TClient, TUser, TReturn> = (sdk: TClient, context: IAuthenticatedAsyncCallContext<TUser>) => Promise<TReturn>;

// @public
export type AuthenticatedCallGuard<TClient, TUser> = <TReturn>(call: AuthenticatedAsyncCall<TClient, TUser, TReturn>, errorConverter?: ErrorConverter) => Promise<TReturn>;

// @public
export type AuthenticatedPrincipal<TUser = any> = {
    userId: string;
    userMeta?: TUser;
};

// @public
export type AuthenticationContext<TClient> = {
    client: TClient;
};

// Warning: (ae-internal-missing-underscore) The name "AuthProviderCallGuard" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class AuthProviderCallGuard<TClient, TUser> implements IAuthProviderCallGuard<TClient, TUser> {
    constructor(realProvider: IAuthenticationProvider<TClient, TUser>);
    // (undocumented)
    authenticate: (context: AuthenticationContext<TClient>) => Promise<AuthenticatedPrincipal<TUser>>;
    // (undocumented)
    deauthenticate(context: AuthenticationContext<TClient>): Promise<void>;
    // (undocumented)
    getCurrentPrincipal(context: AuthenticationContext<TClient>): Promise<AuthenticatedPrincipal<TUser> | undefined>;
    // (undocumented)
    reset: () => void;
}

// @public
export type BackendCapabilities = {
    supportsObjectUris?: boolean;
    canCalculateTotals?: boolean;
    canSortData?: boolean;
    supportsElementUris?: boolean;
    maxDimensions?: number;
    canExportCsv?: boolean;
    canExportXlsx?: boolean;
    canTransformExistingResult?: boolean;
    canExecuteByReference?: boolean;
    [key: string]: undefined | boolean | number | string;
};

// @public
export class DataTooLargeError extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @public
export type DataValue = null | string | number;

// @alpha
export class DataViewFacade {
    constructor(dataView: IDataView);
    // (undocumented)
    allHeaders(): IResultHeader[][][];
    // (undocumented)
    attributeHeaders(): IResultAttributeHeader[][][];
    // (undocumented)
    attributes(): IAttribute[];
    bucket(localId: string): IBucket | undefined;
    // (undocumented)
    bucketCount(): number;
    bucketMeasures(localId: string): IMeasure[];
    // (undocumented)
    buckets(): IBucket[];
    // (undocumented)
    data(): DataValue[][] | DataValue[];
    // (undocumented)
    dataAt(index: number): DataValue | DataValue[];
    // (undocumented)
    readonly dataView: IDataView;
    // (undocumented)
    readonly definition: IExecutionDefinition;
    // (undocumented)
    dimensionItemDescriptors(dimIdx: number): IDimensionItemDescriptor[];
    // (undocumented)
    dimensions(): IDimensionDescriptor[];
    // (undocumented)
    fingerprint(): () => string;
    // (undocumented)
    firstDimSize(): number;
    // (undocumented)
    hasAttributes(): boolean;
    hasBuckets(): boolean;
    hasTotals(): boolean;
    isBucketEmpty(localId: string): boolean;
    isDerivedMeasure(measureDescriptor: IMeasureDescriptor): boolean;
    masterMeasureForDerived(localId: string): IMeasure | undefined;
    measure(localId: string): IMeasure | undefined;
    measureDescriptor(localId: string): IMeasureDescriptor | undefined;
    measureDescriptors(): IMeasureDescriptor[];
    // (undocumented)
    measureGroupDescriptor(): IMeasureGroupDescriptor | undefined;
    measureIndex(localId: string): number;
    // (undocumented)
    measures(): IMeasure[];
    // (undocumented)
    result(): IExecutionResult;
    singleDimData(): DataValue[];
    // (undocumented)
    totals(): DataValue[][][] | undefined;
    twoDimData(): DataValue[][];
}

// @public
export type ErrorConverter = (e: any) => AnalyticalBackendError;

// @public
export interface IAnalyticalBackend<TClient = any, TUser = any> {
    authenticate(force?: boolean): Promise<AuthenticatedPrincipal<TUser>>;
    readonly capabilities: BackendCapabilities;
    readonly config: AnalyticalBackendConfig;
    currentUser(): IUserService;
    deauthenticate(): Promise<void>;
    isAuthenticated(): Promise<AuthenticatedPrincipal<TUser> | null>;
    onHostname(hostname: string): IAnalyticalBackend<TClient, TUser>;
    withAuthentication(provider: IAuthenticationProvider<TClient, TUser>): IAnalyticalBackend<TClient, TUser>;
    withTelemetry(componentName: string, props: object): IAnalyticalBackend<TClient, TUser>;
    workspace(id: string): IAnalyticalWorkspace;
    workspaces(): IWorkspaceQueryFactory;
}

// @public
export interface IAnalyticalWorkspace {
    catalog(): IWorkspaceCatalogFactory;
    dataSets(): IWorkspaceDatasetsService;
    elements(): IElementQueryFactory;
    execution(): IExecutionFactory;
    insights(): IWorkspaceInsights;
    metadata(): IWorkspaceMetadata;
    permissions(): IWorkspacePermissionsFactory;
    settings(): IWorkspaceSettingsService;
    styling(): IWorkspaceStylingService;
    // (undocumented)
    readonly workspace: string;
}

// @public
export interface IAttributeDescriptor {
    // (undocumented)
    attributeHeader: {
        uri: string;
        identifier: string;
        localIdentifier: string;
        name: string;
        totalItems?: ITotalDescriptor[];
        formOf: {
            uri: string;
            identifier: string;
            name: string;
        };
    };
}

// @public
export interface IAuthenticatedAsyncCallContext<TUser> {
    // (undocumented)
    principal: AuthenticatedPrincipal<TUser>;
}

// @public
export interface IAuthenticationProvider<TClient = any, TUser = any> {
    authenticate(context: AuthenticationContext<TClient>): Promise<AuthenticatedPrincipal<TUser>>;
    deauthenticate(context: AuthenticationContext<TClient>): Promise<void>;
    getCurrentPrincipal(context: AuthenticationContext<TClient>): Promise<AuthenticatedPrincipal<TUser> | undefined>;
}

// Warning: (ae-internal-missing-underscore) The name "IAuthProviderCallGuard" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface IAuthProviderCallGuard<TClient, TUser> extends IAuthenticationProvider<TClient, TUser> {
    reset(): void;
}

// @public
export interface IDataView {
    readonly count: number[];
    readonly data: DataValue[][] | DataValue[];
    readonly definition: IExecutionDefinition;
    equals(other: IDataView): boolean;
    fingerprint(): string;
    readonly headerItems: IResultHeader[][][];
    readonly offset: number[];
    readonly result: IExecutionResult;
    readonly totalCount: number[];
    readonly totals?: DataValue[][][];
}

// @public
export interface IDimensionDescriptor {
    // (undocumented)
    headers: IDimensionItemDescriptor[];
}

// @public
export type IDimensionItemDescriptor = IMeasureGroupDescriptor | IAttributeDescriptor;

// @public
export interface IElementQuery {
    query(): Promise<IElementQueryResult>;
    withLimit(limit: number): IElementQuery;
    withOffset(offset: number): IElementQuery;
    // @alpha
    withOptions(options: IElementQueryOptions): IElementQuery;
}

// @public
export interface IElementQueryFactory {
    forDisplayForm(ref: ObjRef): IElementQuery;
}

// @alpha (undocumented)
export interface IElementQueryOptions {
    // (undocumented)
    complement?: boolean;
    // (undocumented)
    filter?: string;
    // (undocumented)
    includeTotalCountWithoutFilters?: boolean;
    // (undocumented)
    order?: SortDirection;
    // (undocumented)
    prompt?: string;
    // (undocumented)
    restrictiveDefinition?: string;
    // (undocumented)
    restrictiveDefinitionContent?: object;
    // (undocumented)
    uris?: string[];
}

// @public
export interface IElementQueryResult extends IPagedResource<IAttributeElement> {
}

// @public
export interface IExecutionFactory {
    forBuckets(buckets: IBucket[], filters?: IFilter[]): IPreparedExecution;
    forDefinition(def: IExecutionDefinition): IPreparedExecution;
    forInsight(insight: IInsight, filters?: IFilter[]): IPreparedExecution;
    forInsightByRef(uri: string, filters?: IFilter[]): Promise<IPreparedExecution>;
    forItems(items: AttributeOrMeasure[], filters?: IFilter[]): IPreparedExecution;
}

// @public
export interface IExecutionResult {
    readonly definition: IExecutionDefinition;
    readonly dimensions: IDimensionDescriptor[];
    equals(other: IExecutionResult): boolean;
    export(options: IExportConfig): Promise<IExportResult>;
    fingerprint(): string;
    readAll(): Promise<IDataView>;
    readWindow(offset: number[], size: number[]): Promise<IDataView>;
    transform(): IPreparedExecution;
}

// @public
export interface IExportConfig {
    format?: "xlsx" | "csv" | "raw";
    mergeHeaders?: boolean;
    showFilters?: boolean;
    title?: string;
}

// @public
export interface IExportResult {
    // (undocumented)
    uri: string;
}

// @public
export interface IInsightQueryOptions {
    author?: string;
    limit?: number;
    offset?: number;
    orderBy?: InsightOrdering;
    title?: string;
}

// @public
export interface IInsightQueryResult extends IPagedResource<IInsight> {
}

// @public
export interface IMeasureDescriptor {
    // (undocumented)
    measureHeaderItem: {
        uri?: string;
        identifier?: string;
        localIdentifier: string;
        name: string;
        format: string;
    };
}

// @public
export interface IMeasureGroupDescriptor {
    // (undocumented)
    measureGroupHeader: {
        items: IMeasureDescriptor[];
        totalItems?: ITotalDescriptor[];
    };
}

// @public
export type InsightOrdering = "id" | "title" | "updated";

// @public
export interface IPagedResource<TItem> {
    // (undocumented)
    readonly items: TItem[];
    // (undocumented)
    readonly limit: number;
    // (undocumented)
    next(): Promise<IPagedResource<TItem>>;
    // (undocumented)
    readonly offset: number;
    // (undocumented)
    readonly totalCount: number;
}

// @public
export interface IPreparedExecution {
    readonly definition: IExecutionDefinition;
    equals(other: IPreparedExecution): boolean;
    execute(): Promise<IExecutionResult>;
    fingerprint(): string;
    withDimensions(...dim: Array<IDimension | DimensionGenerator>): IPreparedExecution;
    withSorting(...items: SortItem[]): IPreparedExecution;
}

// @public
export interface IResultAttributeHeader {
    // (undocumented)
    attributeHeaderItem: {
        uri: string;
        name: string;
    };
}

// @public
export type IResultHeader = IResultAttributeHeader | IResultMeasureHeader | IResultTotalHeader;

// @public
export interface IResultMeasureHeader {
    // (undocumented)
    measureHeaderItem: {
        name: string;
        order: number;
    };
}

// @public
export interface IResultTotalHeader {
    // (undocumented)
    totalHeaderItem: {
        name: string;
        type: string;
    };
}

// @public
export function isAnalyticalBackendError(obj: any): obj is AnalyticalBackendError;

// @public
export function isAttributeDescriptor(obj: any): obj is IAttributeDescriptor;

// @public
export function isDataTooLargeError(obj: any): obj is DataTooLargeError;

// @public
export interface ISettings {
    // (undocumented)
    [key: string]: number | boolean | string;
}

// @public
export function isMeasureDescriptor(obj: any): obj is IMeasureDescriptor;

// @public
export function isMeasureGroupDescriptor(obj: any): obj is IMeasureGroupDescriptor;

// @public
export function isNoDataError(obj: any): obj is NoDataError;

// @public
export function isNotAuthenticated(obj: any): obj is NotAuthenticated;

// @public
export function isNotImplemented(obj: any): obj is NotImplemented;

// @public
export function isNotSupported(obj: any): obj is NotSupported;

// @public
export function isProtectedDataError(obj: any): obj is ProtectedDataError;

// @public
export function isResultAttributeHeader(obj: any): obj is IResultAttributeHeader;

// @public
export function isResultMeasureHeader(obj: any): obj is IResultMeasureHeader;

// @public
export function isResultTotalHeader(obj: any): obj is IResultTotalHeader;

// @public
export function isTotalDescriptor(obj: any): obj is ITotalDescriptor;

// @public
export function isUnexpectedError(obj: any): obj is UnexpectedError;

// @public
export function isUnexpectedResponseError(obj: any): obj is UnexpectedResponseError;

// @public
export interface ITotalDescriptor {
    // (undocumented)
    totalHeaderItem: {
        name: string;
    };
}

// @public
export interface IUserService {
    settings(): IUserSettingsService;
}

// @public
export interface IUserSettings extends ISettings {
    userId: string;
}

// @public
export interface IUserSettingsService {
    query(): Promise<IUserSettings>;
}

// @public
export interface IWorkspaceCatalog extends IWorkspaceCatalogMethods {
    // (undocumented)
    availableItems(): IWorkspaceCatalogAvailableItemsFactory;
}

// @public
export interface IWorkspaceCatalogAvailableItemsFactory extends IWorkspaceCatalogFactoryMethods<IWorkspaceCatalogAvailableItemsFactory, IWorkspaceCatalogWithAvailableItemsFactoryOptions> {
    // (undocumented)
    forInsight(insight: IInsightDefinition): IWorkspaceCatalogAvailableItemsFactory;
    // (undocumented)
    forItems(items: AttributeOrMeasure[]): IWorkspaceCatalogAvailableItemsFactory;
    // (undocumented)
    load(): Promise<IWorkspaceCatalogWithAvailableItems>;
}

// @public
export interface IWorkspaceCatalogFactory extends IWorkspaceCatalogFactoryMethods<IWorkspaceCatalogFactory, IWorkspaceCatalogFactoryOptions> {
    // (undocumented)
    load(): Promise<IWorkspaceCatalog>;
}

// @public
export interface IWorkspaceCatalogFactoryMethods<T, TOptions> {
    // (undocumented)
    excludeTags(tags: ObjRef[]): T;
    // (undocumented)
    forDataset(dataset: ObjRef): T;
    // (undocumented)
    forTypes(types: CatalogItemType[]): T;
    // (undocumented)
    includeTags(tags: ObjRef[]): T;
    // (undocumented)
    withOptions(options: TOptions): T;
}

// @public
export interface IWorkspaceCatalogFactoryOptions {
    // (undocumented)
    dataset?: ObjRef;
    // (undocumented)
    excludeTags: ObjRef[];
    // (undocumented)
    includeTags: ObjRef[];
    // (undocumented)
    production: boolean;
    // (undocumented)
    types: CatalogItemType[];
}

// @public
export interface IWorkspaceCatalogMethods {
    // (undocumented)
    getAttributes(): ICatalogAttribute[];
    // (undocumented)
    getDateDatasets(): ICatalogDateDataset[];
    // (undocumented)
    getFacts(): ICatalogFact[];
    // (undocumented)
    getGroups(): ICatalogGroup[];
    // (undocumented)
    getItems(): CatalogItem[];
    // (undocumented)
    getMeasures(): ICatalogMeasure[];
}

// @public
export interface IWorkspaceCatalogWithAvailableItems extends IWorkspaceCatalogMethods {
    // (undocumented)
    getAvailableAttributes(): ICatalogAttribute[];
    // (undocumented)
    getAvailableDateDatasets(): ICatalogDateDataset[];
    // (undocumented)
    getAvailableFacts(): ICatalogFact[];
    // (undocumented)
    getAvailableItems(): CatalogItem[];
    // (undocumented)
    getAvailableMeasures(): ICatalogMeasure[];
}

// @public
export interface IWorkspaceCatalogWithAvailableItemsFactoryOptions extends IWorkspaceCatalogFactoryOptions {
    // (undocumented)
    insight?: IInsightDefinition;
    // (undocumented)
    items?: AttributeOrMeasure[];
}

// @public
export interface IWorkspaceDatasetsService {
    // (undocumented)
    getDatasets(): Promise<IDataset[]>;
}

// @public
export interface IWorkspaceInsights {
    // (undocumented)
    createInsight(insight: IInsightDefinition): Promise<IInsight>;
    // (undocumented)
    deleteInsight(ref: ObjRef): Promise<void>;
    // (undocumented)
    getInsight(ref: ObjRef): Promise<IInsight>;
    getInsights(options?: IInsightQueryOptions): Promise<IInsightQueryResult>;
    // (undocumented)
    getVisualizationClass(ref: ObjRef): Promise<IVisualizationClass>;
    // (undocumented)
    getVisualizationClasses(): Promise<IVisualizationClass[]>;
    // (undocumented)
    updateInsight(insight: IInsight): Promise<IInsight>;
}

// @public
export interface IWorkspaceMetadata {
    getAttributeDisplayForm(ref: ObjRef): Promise<IAttributeDisplayFormMetadataObject>;
    getFactDatasetMeta(ref: ObjRef): Promise<IMetadataObject>;
    getMeasureExpressionTokens(ref: ObjRef): Promise<IMeasureExpressionToken[]>;
}

// @public (undocumented)
export interface IWorkspacePermissionsFactory {
    // (undocumented)
    forCurrentUser(): Promise<IWorkspaceUserPermissions>;
}

// @public
export interface IWorkspaceQuery {
    query(): Promise<IWorkspaceQueryResult>;
    withLimit(limit: number): IWorkspaceQuery;
    withOffset(offset: number): IWorkspaceQuery;
    withSearch(search: string): IWorkspaceQuery;
}

// @public
export interface IWorkspaceQueryFactory {
    forCurrentUser(): IWorkspaceQuery;
    forUser(userId: string): IWorkspaceQuery;
}

// @public
export interface IWorkspaceQueryResult extends IPagedResource<IWorkspace> {
    // (undocumented)
    search: string | undefined;
}

// @public
export interface IWorkspaceSettings extends ISettings {
    workspace: string;
}

// @public
export interface IWorkspaceSettingsService {
    query(): Promise<IWorkspaceSettings>;
}

// @public
export interface IWorkspaceStylingService {
    colorPalette(): Promise<IColorPalette>;
}

// @public (undocumented)
export interface IWorkspaceUserPermissions {
    allPermissions(): IWorkspacePermissions;
    hasPermission(permission: WorkspacePermission): boolean;
}

// @public
export class NoDataError extends AnalyticalBackendError {
    constructor(message: string, dataView?: IDataView, cause?: Error);
    readonly dataView?: IDataView;
}

// Warning: (ae-internal-missing-underscore) The name "NoopAuthProvider" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export class NoopAuthProvider<TClient, TUser> implements IAuthProviderCallGuard<TClient, TUser> {
    // (undocumented)
    authenticate(_context: AuthenticationContext<TClient>): Promise<AuthenticatedPrincipal<TUser>>;
    // (undocumented)
    deauthenticate(_context: AuthenticationContext<TClient>): Promise<void>;
    // (undocumented)
    getCurrentPrincipal(_context: AuthenticationContext<TClient>): Promise<AuthenticatedPrincipal<TUser> | undefined>;
    // (undocumented)
    reset(): void;
}

// @public
export class NotAuthenticated extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @public
export class NotImplemented extends AnalyticalBackendError {
    constructor(message: string);
}

// @public
export class NotSupported extends AnalyticalBackendError {
    constructor(message: string);
}

// @public
export function prepareExecution<TClient, TUser>(backend: IAnalyticalBackend<TClient, TUser>, definition: IExecutionDefinition): IPreparedExecution;

// @public
export class ProtectedDataError extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @public
export function resultHeaderName(header: IResultHeader): string;

// @public
export enum SettingCatalog {
    disableKpiDashboardHeadlineUnderline = "disableKpiDashboardHeadlineUnderline",
    enableAxisNameConfiguration = "enableAxisNameConfiguration"
}

// @public
export class UnexpectedError extends AnalyticalBackendError {
    constructor(message: string, cause?: Error);
}

// @public
export class UnexpectedResponseError extends AnalyticalBackendError {
    constructor(message: string, httpStatus: number, responseBody: any, cause?: Error);
    // (undocumented)
    readonly httpStatus: number;
    // (undocumented)
    readonly responseBody: number;
}


// (No @packageDocumentation comment for this package)

```
