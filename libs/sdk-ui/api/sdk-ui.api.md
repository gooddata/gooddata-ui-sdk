## API Report File for "@gooddata/sdk-ui"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AuthenticationFlow } from '@gooddata/sdk-backend-spi';
import { ComponentType } from 'react';
import { DataValue } from '@gooddata/sdk-backend-spi';
import { DependencyList } from 'react';
import { IAnalyticalBackend } from '@gooddata/sdk-backend-spi';
import { IAttribute } from '@gooddata/sdk-model';
import { IAttributeDescriptor } from '@gooddata/sdk-backend-spi';
import { IBucket } from '@gooddata/sdk-model';
import { IColor } from '@gooddata/sdk-model';
import { IColorPalette } from '@gooddata/sdk-model';
import { IDataView } from '@gooddata/sdk-backend-spi';
import { IDimension } from '@gooddata/sdk-model';
import { IDimensionDescriptor } from '@gooddata/sdk-backend-spi';
import { IDimensionItemDescriptor } from '@gooddata/sdk-backend-spi';
import { IExecutionDefinition } from '@gooddata/sdk-model';
import { IExecutionResult } from '@gooddata/sdk-backend-spi';
import { IExportConfig } from '@gooddata/sdk-backend-spi';
import { IExportResult } from '@gooddata/sdk-backend-spi';
import { IInsightDefinition } from '@gooddata/sdk-model';
import { IMeasure } from '@gooddata/sdk-model';
import { IMeasureDefinitionType } from '@gooddata/sdk-model';
import { IMeasureDescriptor } from '@gooddata/sdk-backend-spi';
import { IMeasureGroupDescriptor } from '@gooddata/sdk-backend-spi';
import { IntlShape } from 'react-intl';
import { INullableFilter } from '@gooddata/sdk-model';
import { IPagedResource } from '@gooddata/sdk-backend-spi';
import { IPreparedExecution } from '@gooddata/sdk-backend-spi';
import { IResultAttributeHeader } from '@gooddata/sdk-backend-spi';
import { IResultHeader } from '@gooddata/sdk-backend-spi';
import { IResultMeasureHeader } from '@gooddata/sdk-backend-spi';
import { IResultTotalHeader } from '@gooddata/sdk-backend-spi';
import { IResultWarning } from '@gooddata/sdk-backend-spi';
import { ISeparators } from '@gooddata/sdk-backend-spi';
import { ISeparators as ISeparators_2 } from '@gooddata/numberjs';
import { ISortItem } from '@gooddata/sdk-model';
import { ITotal } from '@gooddata/sdk-model';
import { ITotalDescriptor } from '@gooddata/sdk-backend-spi';
import { ObjRef } from '@gooddata/sdk-model';
import { default as React_2 } from 'react';
import { ValueOrUpdateCallback } from '@gooddata/sdk-backend-base';
import { WrappedComponentProps } from 'react-intl';

// @public
export type AnyArrayOf<T> = T[] | ArrayOf<T>;

// @public
export type AnyMeasure = IMeasure | MeasureOf<IMeasureDefinitionType>;

// @public
export type AnyPlaceholder<T = any> = IPlaceholder<T> | IComposedPlaceholder<T, any, any>;

// @public
export type AnyPlaceholderOf<T> = AnyPlaceholder<T> | PlaceholderOf<T>;

// @internal
export class ArithmeticMeasureTitleFactory {
    constructor(locale: ILocale);
    getTitle(arithmeticMeasureProps: IArithmeticMeasureTitleProps, measureTitleProps: IMeasureTitleProps[]): string | null;
    }

// @public
export type ArrayOf<T> = T extends any ? T[] : never;

// @public
export function attributeItemNameMatch(name: string): IHeaderPredicate;

// @public
export const BackendProvider: React_2.FC<IBackendProviderProps>;

// @public
export class BadRequestSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal
export const BucketNames: {
    MEASURES: string;
    SECONDARY_MEASURES: string;
    TERTIARY_MEASURES: string;
    ATTRIBUTE: string;
    ATTRIBUTES: string;
    VIEW: string;
    STACK: string;
    TREND: string;
    SEGMENT: string;
    COLUMNS: string;
    LOCATION: string;
    SIZE: string;
    COLOR: string;
    TOOLTIP_TEXT: string;
};

// @internal (undocumented)
export class CancelError extends Error {
    constructor(reason?: string | undefined);
    getReason(): string | undefined;
    // (undocumented)
    reason?: string | undefined;
}

// @public
export class CancelledSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public @deprecated
export class CatalogHelper {
    constructor(catalog: ICatalog);
    // (undocumented)
    attribute(attributeName: string): string;
    // (undocumented)
    attributeDisplayForm(attributeName: string, displayFormName?: string): string;
    // (undocumented)
    attributeDisplayFormTags(attributeName: string, displayFormName?: string): string;
    // (undocumented)
    attributes: {
        [key: string]: IAttrItem;
    };
    // (undocumented)
    attributeTags(attributeName: string): string;
    // (undocumented)
    dateDataSet(dataSetName: string): string;
    // (undocumented)
    dateDataSetAttribute(dataSetName: string, attrName: string): string;
    // (undocumented)
    dateDataSetAttributeTags(dataSetName: string, attrName: string): string;
    // (undocumented)
    dateDataSetDisplayForm(dataSetName: string, attributeName: string, displayFormName?: string): string;
    // (undocumented)
    dateDataSetDisplayFormTags(dataSetName: string, attributeName: string, displayFormName?: string): string;
    // (undocumented)
    dateDataSets: {
        [key: string]: IDataSet;
    };
    // (undocumented)
    dateDataSetTags(dataSetName: string): string;
    // (undocumented)
    measure(name: string): string;
    // (undocumented)
    measures: {
        [key: string]: IIdentifierWithTags;
    };
    // (undocumented)
    measureTags(name: string): string;
    // (undocumented)
    visualization(name: string): string;
    // (undocumented)
    visualizations: {
        [key: string]: IIdentifierWithTags;
    };
    // (undocumented)
    visualizationTags(name: string): string;
}

// @public (undocumented)
export type ChartElementType = "slice" | "bar" | "point" | "label" | "cell" | "target" | "primary" | "comparative";

// @public (undocumented)
export type ChartType = "bar" | "column" | "pie" | "line" | "area" | "donut" | "scatter" | "bubble" | "heatmap" | "geo" | "pushpin" | "combo" | "combo2" | "histogram" | "bullet" | "treemap" | "waterfall" | "funnel" | "pareto" | "alluvial";

// @public
export function composedFromIdentifier(identifier: string): IHeaderPredicate;

// @public
export function composedFromUri(uri: string): IHeaderPredicate;

// @public
export type ComposedPlaceholderResolutionContext<T> = T extends IComposedPlaceholder<any, any, infer TContext> ? TContext : any;

// @internal (undocumented)
export function convertDrillableItemsToPredicates(drillableItems: Array<IDrillableItem | IHeaderPredicate>): IHeaderPredicate[];

// @public
export function convertError(error: unknown): GoodDataSdkError;

// @internal
export function createExportErrorFunction(error: GoodDataSdkError): IExportFunction;

// @internal
export function createExportFunction(result: IExecutionResult, exportTitle?: string): IExportFunction;

// @internal (undocumented)
export function createIntlMock(customMessages?: {}, locale?: string): IntlShape;

// @public
export function createNumberJsFormatter(separators?: ISeparators_2): ValueFormatter;

// @public (undocumented)
export type DataAccessConfig = {
    valueFormatter: ValueFormatter;
    headerTranslator?: HeaderTranslator;
};

// @public
export type DataPoint = {
    readonly rawValue: DataValue;
    formattedValue(): null | string;
    readonly coordinates: DataPointCoordinates;
    readonly seriesDesc: DataSeriesDescriptor;
    readonly sliceDesc?: DataSliceDescriptor;
    readonly total?: boolean;
};

// @public (undocumented)
export type DataPointCoordinates = number[];

// @public
export type DataSeriesDescriptor = DataSeriesHeaders & DataSeriesDescriptorMethods & {
    readonly id: DataSeriesId;
    readonly measureDescriptor: IMeasureDescriptor;
    readonly measureDefinition: IMeasure;
    readonly attributeDescriptors?: IAttributeDescriptor[];
    readonly attributeDefinitions?: IAttribute[];
};

// @public (undocumented)
export type DataSeriesDescriptorMethods = {
    measureTitle(): string;
    measureFormat(): string;
    scopeTitles(): string[];
};

// @public (undocumented)
export type DataSeriesHeaders = {
    readonly measureHeader: IResultMeasureHeader;
    readonly attributeHeaders?: IResultAttributeHeader[];
};

// @public (undocumented)
export type DataSeriesId = string;

// @public
export type DataSliceDescriptor = DataSliceHeaders & DataSliceDescriptorMethods & {
    readonly id: DataSliceId;
    readonly descriptors: IAttributeDescriptor[];
    readonly definitions: IAttribute[];
};

// @public (undocumented)
export type DataSliceDescriptorMethods = {
    readonly sliceTitles: () => string[];
};

// @public
export type DataSliceHeaders = {
    readonly headers: Array<IResultAttributeHeader | IResultTotalHeader>;
    readonly isTotal?: boolean;
};

// @public (undocumented)
export type DataSliceId = string;

// @public
export class DataTooLargeToComputeSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class DataTooLargeToDisplaySdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class DataViewFacade {
    protected constructor(dataView: IDataView);
    // (undocumented)
    data(config?: DataAccessConfig): IDataAccessMethods;
    // (undocumented)
    readonly dataView: IDataView;
    // @internal (undocumented)
    def(): IExecutionDefinitionMethods;
    // (undocumented)
    readonly definition: IExecutionDefinition;
    // (undocumented)
    fingerprint(): string;
    // (undocumented)
    static for(dataView: IDataView): DataViewFacade;
    // @internal (undocumented)
    meta(): IResultMetaMethods;
    // @internal (undocumented)
    rawData(): IResultDataMethods;
    // (undocumented)
    result(): IExecutionResult;
    // (undocumented)
    warnings(): IResultWarning[];
}

// @public (undocumented)
export type DataViewWindow = {
    offset: number[];
    size: number[];
};

// @public (undocumented)
export const DefaultColorPalette: IColorPalette;

// @public
export const DefaultDataAccessConfig: DataAccessConfig;

// @public
export function defaultErrorHandler(error: unknown): void;

// @public (undocumented)
export const DefaultLocale: ILocale;

// @internal
export class DerivedMeasureTitleSuffixFactory {
    constructor(locale: ILocale);
    getSuffix(overTimeComparisonType: OverTimeComparisonType): string;
    }

// @public (undocumented)
export type DrillEventIntersectionElementHeader = IAttributeDescriptor | IMeasureDescriptor | ITotalDescriptor | IDrillIntersectionAttributeItem;

// @public
export const ErrorCodes: {
    BAD_REQUEST: string;
    UNAUTHORIZED: string;
    GEO_LOCATION_MISSING: string;
    GEO_MAPBOX_TOKEN_MISSING: string;
    DATA_TOO_LARGE_TO_DISPLAY: string;
    DATA_TOO_LARGE_TO_COMPUTE: string;
    NEGATIVE_VALUES: string;
    NO_DATA: string;
    NOT_FOUND: string;
    PROTECTED_REPORT: string;
    UNKNOWN_ERROR: string;
    CANCELLED: string;
};

// @public
export class ErrorComponent extends React_2.Component<IErrorProps> {
    // (undocumented)
    static defaultProps: Partial<IErrorProps>;
    // (undocumented)
    render(): React_2.ReactNode;
}

// @public
export const Execute: (props: IExecuteProps) => JSX.Element;

// @beta
export const ExecuteInsight: React_2.ComponentType<IExecuteInsightProps>;

// @internal
export function fillMissingTitles<T extends IInsightDefinition>(insight: T, locale: ILocale, maxArithmeticMeasureTitleLength?: number): T;

// @internal
export function fireDrillEvent(drillEventFunction: IDrillEventCallback, drillEventData: IDrillEvent, target: EventTarget): void;

// @public
export type Flatten<T> = T extends Array<infer A> ? A : T;

// @public
export class GeoLocationMissingSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class GeoTokenMissingSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal (undocumented)
export function getDrillIntersection(drillItems: IMappingHeader[]): IDrillEventIntersectionElement[];

// @internal (undocumented)
export function getIntersectionPartAfter(intersection: IDrillEventIntersectionElement[], localIdentifier: string): IDrillEventIntersectionElement[];

// @internal
export function getIntl(locale?: ILocale): IntlShape;

// @internal (undocumented)
export function getMappingHeaderIdentifier(header: IMappingHeader): string | undefined;

// @internal (undocumented)
export function getMappingHeaderLocalIdentifier(header: IMappingHeader): string;

// @internal (undocumented)
export function getMappingHeaderName(header: IMappingHeader): string | undefined;

// @internal (undocumented)
export function getMappingHeaderUri(header: IMappingHeader): string | undefined;

// @internal
export function getTranslation(translationId: string, locale: ILocale, values?: {}): string;

// @internal (undocumented)
export function getVisualizationType(type: ChartType): ChartType;

// @public
export abstract class GoodDataSdkError extends Error {
    protected constructor(seType: SdkErrorType, message?: string, cause?: any);
    // (undocumented)
    readonly cause?: any;
    getCause(): any | undefined;
    getErrorCode(): string;
    getMessage(): string;
    // (undocumented)
    readonly seType: SdkErrorType;
}

// @internal (undocumented)
export function hasMappingHeaderLocalIdentifier(header: IMappingHeader): boolean;

// @public (undocumented)
export const HeaderPredicates: {
    attributeItemNameMatch: typeof attributeItemNameMatch;
    composedFromIdentifier: typeof composedFromIdentifier;
    composedFromUri: typeof composedFromUri;
    identifierMatch: typeof identifierMatch;
    localIdentifierMatch: typeof localIdentifierMatch;
    uriMatch: typeof uriMatch;
};

// @public (undocumented)
export type HeaderTranslator = (value: string) => string;

// @public (undocumented)
export type HeadlineElementType = "primaryValue" | "secondaryValue";

// @public (undocumented)
export type HeadlineType = "headline";

// @internal
export interface IArithmeticMeasureTitleProps {
    // (undocumented)
    masterMeasureLocalIdentifiers: string[];
    // (undocumented)
    operator: string;
}

// @public @deprecated (undocumented)
export interface IAttrItem {
    // (undocumented)
    defaultDisplayForm: IIdentifierWithTags;
    // (undocumented)
    displayForms: IDisplayForms;
    // (undocumented)
    identifier: string;
    // (undocumented)
    tags: string;
}

// @public @deprecated (undocumented)
export interface IAttrs {
    // (undocumented)
    [key: string]: IAttrItem;
}

// @internal (undocumented)
export interface IAvailableDrillTargetAttribute {
    // (undocumented)
    attribute: IAttributeDescriptor;
}

// @internal (undocumented)
export interface IAvailableDrillTargetMeasure {
    // (undocumented)
    attributes: IAttributeDescriptor[];
    // (undocumented)
    measure: IMeasureDescriptor;
}

// @internal (undocumented)
export interface IAvailableDrillTargets {
    // (undocumented)
    attributes?: IAvailableDrillTargetAttribute[];
    // (undocumented)
    measures?: IAvailableDrillTargetMeasure[];
}

// @public (undocumented)
export interface IBackendProviderProps {
    backend: IAnalyticalBackend;
}

// @internal (undocumented)
export interface ICancelablePromise<T> {
    // (undocumented)
    cancel: (reason?: string) => void;
    // (undocumented)
    getHasCanceled: () => boolean;
    // (undocumented)
    getHasFulfilled: () => boolean;
    // (undocumented)
    promise: Promise<T>;
}

// @public @deprecated (undocumented)
export interface ICatalog {
    // (undocumented)
    attributes: IAttrs;
    // (undocumented)
    dateDataSets: {
        [key: string]: IDataSet;
    };
    // (undocumented)
    measures?: {
        [key: string]: IIdentifierWithTags;
    };
    // (undocumented)
    visualizations: {
        [key: string]: IIdentifierWithTags;
    };
}

// @internal (undocumented)
export interface IColorAssignment {
    // (undocumented)
    color: IColor;
    // (undocumented)
    headerItem: IMappingHeader;
}

// @internal (undocumented)
export interface IColorsData {
    // (undocumented)
    colorAssignments: IColorAssignment[];
    // (undocumented)
    colorPalette: IColorPalette;
}

// @public
export interface IComposedPlaceholder<TReturn, TValue extends any[], TContext> {
    // (undocumented)
    computeValue: (values: PlaceholdersResolvedValues<TValue>, resolutionContext: TContext) => TReturn;
    // (undocumented)
    placeholders: TValue;
    // (undocumented)
    type: "IComposedPlaceholder";
    // (undocumented)
    use: IUseComposedPlaceholderHook<IComposedPlaceholder<TReturn, TValue, TContext>>;
}

// @public
export interface IDataAccessMethods {
    // (undocumented)
    series(): IDataSeriesCollection;
    // (undocumented)
    slices(): IDataSliceCollection;
}

// @public
export interface IDataSeries extends DataSeriesDescriptorMethods, Iterable<DataPoint> {
    // (undocumented)
    dataPoints(): DataPoint[];
    readonly descriptor: DataSeriesDescriptor;
    readonly id: DataSeriesId;
    // (undocumented)
    rawData(): DataValue[];
}

// @public
export interface IDataSeriesCollection extends Iterable<IDataSeries> {
    allForMeasure(localIdOrMeasure: string | IMeasure): Iterable<IDataSeries>;
    readonly count: number;
    firstForMeasure(localIdOrMeasure: string | IMeasure): IDataSeries;
    readonly fromMeasures: IMeasureDescriptor[];
    readonly fromMeasuresDef: IMeasure[];
    readonly scopingAttributes?: IAttributeDescriptor[];
    readonly scopingAttributesDef?: IAttribute[];
    toArray(): IDataSeries[];
}

// @public @deprecated (undocumented)
export interface IDataSet {
    // (undocumented)
    attributes: IAttrs;
    // (undocumented)
    identifier: string;
    // (undocumented)
    tags: string;
}

// @public
export interface IDataSlice extends DataSliceDescriptorMethods, Iterable<DataPoint> {
    // (undocumented)
    dataPoints(): DataPoint[];
    readonly descriptor: DataSliceDescriptor;
    readonly id: DataSliceId;
    // (undocumented)
    rawData(): DataValue[];
}

// @public
export interface IDataSliceCollection extends Iterable<IDataSlice> {
    readonly count: number;
    readonly descriptors: Array<IAttributeDescriptor | ITotal>;
    toArray(): IDataSlice[];
}

// @public
export interface IDataVisualizationProps extends IVisualizationProps, IVisualizationCallbacks {
    execution: IPreparedExecution;
}

// @public
export function identifierMatch(identifier: string): IHeaderPredicate;

// @public @deprecated (undocumented)
export interface IDisplayForms {
    // (undocumented)
    [key: string]: IIdentifierWithTags;
}

// @public (undocumented)
export type IDrillableItem = IDrillableItemUri | IDrillableItemIdentifier | (IDrillableItemUri & IDrillableItemIdentifier);

// @public (undocumented)
export interface IDrillableItemIdentifier {
    // (undocumented)
    identifier: string;
}

// @public (undocumented)
export interface IDrillableItemUri {
    // (undocumented)
    uri: string;
}

// @public (undocumented)
export interface IDrillConfig {
    // (undocumented)
    dataView: IDataView;
    // (undocumented)
    onDrill: OnFiredDrillEvent;
}

// @public (undocumented)
export interface IDrillEvent {
    // (undocumented)
    dataView: IDataView;
    // (undocumented)
    drillContext: IDrillEventContext;
}

// @public (undocumented)
export type IDrillEventCallback = (event: IDrillEvent) => void | boolean;

// @public
export interface IDrillEventContext {
    // (undocumented)
    columnIndex?: number;
    // (undocumented)
    element: VisElementType;
    // (undocumented)
    intersection?: IDrillEventIntersectionElement[];
    // (undocumented)
    points?: IDrillPoint[];
    // (undocumented)
    row?: any[];
    // (undocumented)
    rowIndex?: number;
    // (undocumented)
    type: VisType;
    // (undocumented)
    value?: string;
    // (undocumented)
    x?: number;
    // (undocumented)
    y?: number;
    // (undocumented)
    z?: number;
}

// @public
export interface IDrillEventContextGroup {
    // (undocumented)
    element: ChartElementType;
    // (undocumented)
    points: IDrillPoint[];
    // (undocumented)
    type: ChartType;
}

// @public
export interface IDrillEventContextHeadline {
    // (undocumented)
    element: HeadlineElementType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    type: HeadlineType;
    // (undocumented)
    value: string;
}

// @public
export interface IDrillEventContextPoint {
    // (undocumented)
    element: ChartElementType;
    // (undocumented)
    elementChartType?: ChartType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    type: ChartType;
    // (undocumented)
    value?: string;
    // (undocumented)
    x?: number;
    // (undocumented)
    y?: number;
    // (undocumented)
    z?: number;
}

// @public
export interface IDrillEventContextTable {
    // (undocumented)
    columnIndex: number;
    // (undocumented)
    element: TableElementType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    row: any[];
    // (undocumented)
    rowIndex: number;
    // (undocumented)
    type: TableType;
}

// @public
export interface IDrillEventContextXirr {
    // (undocumented)
    element: HeadlineElementType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    type: XirrType;
    // (undocumented)
    value: string;
}

// @public (undocumented)
export interface IDrillEventIntersectionElement {
    // (undocumented)
    header: DrillEventIntersectionElementHeader;
}

// @public (undocumented)
export interface IDrillIntersectionAttributeItem extends IAttributeDescriptor, IResultAttributeHeader {
}

// @public
export interface IDrillPoint {
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    type?: ChartType;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public
export interface IErrorDescriptors {
    // (undocumented)
    [key: string]: {
        icon?: string;
        message: string;
        description: string;
    };
}

// @public (undocumented)
export interface IErrorProps {
    // (undocumented)
    className?: string;
    clientHeight?: any;
    // (undocumented)
    code?: string;
    // (undocumented)
    description?: string;
    height?: any;
    // (undocumented)
    icon?: string;
    // (undocumented)
    message: string;
    // (undocumented)
    style?: object;
    // (undocumented)
    width?: any;
}

// @public
export type IExecuteErrorComponent = ComponentType<IExecuteErrorComponentProps>;

// @public
export interface IExecuteErrorComponentProps {
    error: GoodDataSdkError;
}

// @beta (undocumented)
export interface IExecuteInsightProps extends IWithLoadingEvents<IExecuteInsightProps> {
    backend?: IAnalyticalBackend;
    children: (executionResult: WithLoadingResult) => React_2.ReactElement | null;
    componentName?: string;
    dateFormat?: string | ((def: IExecutionDefinition, props: IExecuteInsightProps) => string);
    dimensions?: IDimension[] | ((def: IExecutionDefinition, props: IExecuteInsightProps) => IDimension[]);
    ErrorComponent?: IExecuteErrorComponent;
    exportTitle?: string;
    filters?: INullableFilter[];
    insight: ObjRef;
    LoadingComponent?: IExecuteLoadingComponent;
    loadOnMount?: boolean;
    sorts?: ISortItem[] | ((def: IExecutionDefinition, props: IExecuteInsightProps) => ISortItem[]);
    window?: DataViewWindow;
    workspace?: string;
}

// @public
export type IExecuteLoadingComponent = ComponentType;

// @public (undocumented)
export interface IExecuteProps extends IWithLoadingEvents<IExecuteProps> {
    backend?: IAnalyticalBackend;
    children: (executionResult: WithLoadingResult) => React_2.ReactElement | null;
    componentName?: string;
    ErrorComponent?: IExecuteErrorComponent;
    exportTitle?: string;
    filters?: ValuesOrPlaceholders<INullableFilter>;
    LoadingComponent?: IExecuteLoadingComponent;
    loadOnMount?: boolean;
    placeholdersResolutionContext?: any;
    seriesBy: ValuesOrPlaceholders<IAttribute | AnyMeasure>;
    slicesBy?: ValuesOrPlaceholders<IAttribute>;
    sortBy?: ValuesOrPlaceholders<ISortItem>;
    totals?: ValuesOrPlaceholders<ITotal>;
    window?: DataViewWindow;
    workspace?: string;
}

// @beta (undocumented)
export interface IExecutionConfiguration {
    componentName?: string;
    filters?: ValuesOrPlaceholders<INullableFilter>;
    placeholdersResolutionContext?: any;
    seriesBy: ValuesOrPlaceholders<IAttribute | AnyMeasure>;
    slicesBy?: ValuesOrPlaceholders<IAttribute>;
    sortBy?: ValuesOrPlaceholders<ISortItem>;
    totals?: ValuesOrPlaceholders<ITotal>;
}

// @alpha
export interface IExecutionDefinitionMethods {
    // (undocumented)
    attributes(): IAttribute[];
    bucket(localId: string): IBucket | undefined;
    // (undocumented)
    bucketCount(): number;
    bucketMeasures(localId: string): IMeasure[];
    // (undocumented)
    buckets(): IBucket[];
    // (undocumented)
    hasAttributes(): boolean;
    hasBuckets(): boolean;
    isBucketEmpty(localId: string): boolean;
    masterMeasureForDerived(localId: string): IMeasure | undefined;
    measure(localId: string): IMeasure | undefined;
    measureIndex(localId: string): number;
    // (undocumented)
    measures(): IMeasure[];
}

// @public (undocumented)
export type IExportFunction = (exportConfig: IExtendedExportConfig) => Promise<IExportResult>;

// @public (undocumented)
export interface IExtendedExportConfig extends IExportConfig {
    // (undocumented)
    includeFilterContext?: boolean;
}

// @internal
export function ignoreTitlesForSimpleMeasures<T extends IInsightDefinition>(insight: T): T;

// @public (undocumented)
export type IHeaderPredicate = (header: IMappingHeader, context: IHeaderPredicateContext) => boolean;

// @public (undocumented)
export interface IHeaderPredicateContext {
    // (undocumented)
    dv: DataViewFacade;
}

// @public (undocumented)
export interface IHighchartsCategoriesTree {
    // (undocumented)
    tick: IHighchartsParentTick;
}

// @public (undocumented)
export interface IHighchartsParentTick {
    // (undocumented)
    label: any;
    // (undocumented)
    leaves: number;
    // (undocumented)
    startAt: number;
}

// @public @deprecated (undocumented)
export interface IIdentifierWithTags {
    // (undocumented)
    identifier: string;
    // (undocumented)
    tags: string;
}

// @internal (undocumented)
export interface IIntlWrapperProps {
    // (undocumented)
    locale: string;
}

// @public (undocumented)
export interface IKpiProps extends IWithLoadingEvents<IRawExecuteProps> {
    backend?: IAnalyticalBackend;
    ErrorComponent?: React_2.ComponentType<IErrorProps>;
    filters?: INullableFilter[];
    LoadingComponent?: React_2.ComponentType<ILoadingProps>;
    locale?: string;
    measure: IMeasure;
    separators?: ISeparators_2;
    workspace?: string;
}

// @internal
export interface ILoadingInjectedProps {
    dataView?: IDataView;
    error?: string;
    // (undocumented)
    intl: IntlShape;
    isLoading: boolean;
    onDataTooLarge(): void;
    onExportReady(exportFunction: IExportFunction): void;
    onNegativeValues(): void;
}

// @public (undocumented)
export interface ILoadingProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    color?: string;
    // (undocumented)
    height?: any;
    // (undocumented)
    imageHeight?: any;
    // (undocumented)
    imageWidth?: any;
    // (undocumented)
    inline?: boolean;
    // (undocumented)
    speed?: number;
    // (undocumented)
    width?: any;
}

// @public (undocumented)
export interface ILoadingState {
    // (undocumented)
    isLoading: boolean;
}

// @public (undocumented)
export type ILocale = "en-US" | "de-DE" | "es-ES" | "fr-FR" | "ja-JP" | "nl-NL" | "pt-BR" | "pt-PT" | "zh-Hans";

// @public
export type IMappingHeader = IAttributeDescriptor | IResultAttributeHeader | IMeasureDescriptor | ITotalDescriptor;

// @internal
export interface IMeasureTitleProps {
    // (undocumented)
    alias?: string;
    // (undocumented)
    localIdentifier: string;
    // (undocumented)
    title?: string;
}

// @internal (undocumented)
export const IntlTranslationsProvider: React_2.FC<import("react-intl").WithIntlProps<ITranslationsProviderProps>> & {
    WrappedComponent: React_2.ComponentType<ITranslationsProviderProps>;
};

// @internal (undocumented)
export class IntlWrapper extends React_2.PureComponent<IIntlWrapperProps> {
    // (undocumented)
    static defaultProps: IIntlWrapperProps;
    // (undocumented)
    render(): React_2.ReactNode;
}

// @public
export type IPlaceholder<T> = {
    type: "IPlaceholder";
    id: string;
    defaultValue?: T;
    value?: T;
    validate?: (value: T) => void;
    use: IUsePlaceholderHook<IPlaceholder<T>>;
};

// @public
export interface IPlaceholderOptions<T> {
    id?: string;
    validate?: (value?: T) => void;
}

// @public (undocumented)
export interface IPlaceholdersProviderProps {
    // (undocumented)
    children: React_2.ReactNode;
    // (undocumented)
    initialValues?: [IPlaceholder<any>, any][];
}

// @internal
export interface IPushData {
    // (undocumented)
    availableDrillTargets?: IAvailableDrillTargets;
    // (undocumented)
    colors?: IColorsData;
    // (undocumented)
    dataView?: IDataView;
    // (undocumented)
    initialProperties?: any;
    // (undocumented)
    properties?: {
        sortItems?: ISortItem[];
        totals?: ITotal[];
        controls?: object;
    };
    // (undocumented)
    propertiesMeta?: any;
}

// @public (undocumented)
export interface IRawExecuteProps extends IWithLoadingEvents<IRawExecuteProps> {
    children: (executionResult: WithLoadingResult) => React_2.ReactElement | null;
    ErrorComponent?: IExecuteErrorComponent;
    execution: IPreparedExecution;
    exportTitle?: string;
    LoadingComponent?: IExecuteLoadingComponent;
    loadOnMount?: boolean;
    window?: DataViewWindow;
}

// @alpha
export interface IResultDataMethods {
    // (undocumented)
    data(): DataValue[][] | DataValue[];
    // (undocumented)
    dataAt(index: number): DataValue | DataValue[];
    // (undocumented)
    firstDimSize(): number;
    hasTotals(): boolean;
    // (undocumented)
    isEmpty(): boolean;
    singleDimData(): DataValue[];
    // (undocumented)
    totals(): DataValue[][][] | undefined;
    twoDimData(): DataValue[][];
}

// @alpha
export interface IResultMetaMethods {
    // (undocumented)
    allHeaders(): IResultHeader[][][];
    // (undocumented)
    attributeDescriptors(): IAttributeDescriptor[];
    attributeDescriptorsForDim(dim: number): IAttributeDescriptor[];
    // (undocumented)
    attributeHeaders(): IResultAttributeHeader[][][];
    // (undocumented)
    attributeHeadersForDim(idx: number): IResultAttributeHeader[][];
    // (undocumented)
    dimensionItemDescriptors(dimIdx: number): IDimensionItemDescriptor[];
    // (undocumented)
    dimensions(): IDimensionDescriptor[];
    effectiveSortItems(): ISortItem[];
    hasNoHeadersInDim(dim: number): boolean;
    isDerivedMeasure(measureDescriptor: IMeasureDescriptor): boolean;
    measureDescriptor(localId: string): IMeasureDescriptor | undefined;
    measureDescriptors(): IMeasureDescriptor[];
    // (undocumented)
    measureGroupDescriptor(): IMeasureGroupDescriptor | undefined;
}

// @public
export function isAnyPlaceholder<T>(obj: unknown): obj is AnyPlaceholder<T>;

// @public
export function isBadRequest(obj: unknown): obj is BadRequestSdkError;

// @internal (undocumented)
export const isCancelError: (obj: unknown) => obj is CancelError;

// @public
export function isCancelledSdkError(obj: unknown): obj is CancelledSdkError;

// @public
export function isComposedPlaceholder<TReturn, TValue extends any[], TContext>(obj: unknown): obj is IComposedPlaceholder<TReturn, TValue, TContext>;

// @public
export function isDataTooLargeToCompute(obj: unknown): obj is DataTooLargeToComputeSdkError;

// @public
export function isDataTooLargeToDisplay(obj: unknown): obj is DataTooLargeToDisplaySdkError;

// @public (undocumented)
export function isDrillableItemIdentifier(item: unknown): item is IDrillableItemIdentifier;

// @public (undocumented)
export function isDrillableItemUri(item: unknown): item is IDrillableItemUri;

// @public (undocumented)
export function isDrillIntersectionAttributeItem(header: DrillEventIntersectionElementHeader): header is IDrillIntersectionAttributeItem;

export { ISeparators }

// @public
export function isGeoLocationMissing(obj: unknown): obj is GeoLocationMissingSdkError;

// @public
export function isGeoTokenMissing(obj: unknown): obj is GeoTokenMissingSdkError;

// @public
export function isGoodDataSdkError(obj: unknown): obj is GoodDataSdkError;

// @public (undocumented)
export function isHeaderPredicate(obj: unknown): obj is IHeaderPredicate;

// @public
export function isNegativeValues(obj: unknown): obj is NegativeValuesSdkError;

// @public
export function isNoDataSdkError(obj: unknown): obj is NoDataSdkError;

// @public
export function isNotFound(obj: unknown): obj is NotFoundSdkError;

// @public
export function isPlaceholder<T>(obj: unknown): obj is IPlaceholder<T>;

// @public
export function isProtectedReport(obj: unknown): obj is ProtectedReportSdkError;

// @internal (undocumented)
export function isSomeHeaderPredicateMatched(drillablePredicates: IHeaderPredicate[], header: IMappingHeader, dv: DataViewFacade): boolean;

// @public
export function isUnauthorized(obj: unknown): obj is UnauthorizedSdkError;

// @public
export function isUnknownSdkError(obj: unknown): obj is UnexpectedSdkError;

// @internal (undocumented)
export interface ITranslations {
    // (undocumented)
    [key: string]: string;
}

// @internal (undocumented)
export interface ITranslationsComponentProps {
    // (undocumented)
    emptyHeaderString: string;
    // (undocumented)
    intl: IntlShape;
    // (undocumented)
    numericSymbols: string[];
}

// @internal (undocumented)
export interface ITranslationsProviderOwnProps {
    // (undocumented)
    children: any;
}

// @internal (undocumented)
export type ITranslationsProviderProps = ITranslationsProviderOwnProps & WrappedComponentProps;

// @public
export type IUseComposedPlaceholderHook<T extends IComposedPlaceholder<any, any, any>> = (resolutionContext: ComposedPlaceholderResolutionContext<T>) => PlaceholderResolvedValue<T>;

// @beta (undocumented)
export interface IUseExecutionConfig {
    backend?: IAnalyticalBackend;
    componentName?: string;
    filters?: ValuesOrPlaceholders<INullableFilter>;
    placeholdersResolutionContext?: any;
    seriesBy: ValuesOrPlaceholders<IAttribute | AnyMeasure>;
    slicesBy?: ValuesOrPlaceholders<IAttribute>;
    sortBy?: ValuesOrPlaceholders<ISortItem>;
    totals?: ValuesOrPlaceholders<ITotal>;
    workspace?: string;
}

// @beta (undocumented)
export interface IUseExecutionDataViewConfig {
    backend?: IAnalyticalBackend;
    execution?: IPreparedExecution | IExecutionConfiguration;
    window?: DataViewWindow;
    workspace?: string;
}

// @beta (undocumented)
export interface IUseInsightDataViewConfig {
    backend?: IAnalyticalBackend;
    dateFormat?: string | ((def: IExecutionDefinition) => string);
    dimensions?: IDimension[] | ((def: IExecutionDefinition) => IDimension[]);
    filters?: INullableFilter[];
    insight?: ObjRef;
    sorts?: ISortItem[] | ((def: IExecutionDefinition) => ISortItem[]);
    window?: DataViewWindow;
    workspace?: string;
}

// @public (undocumented)
export interface IUsePagedResourceResult<TItem> extends IUsePagedResourceState<TItem> {
    // (undocumented)
    isLoading: boolean;
}

// @public (undocumented)
export interface IUsePagedResourceState<TItem> {
    // (undocumented)
    items: Array<TItem | undefined>;
    // (undocumented)
    totalItemsCount: number | undefined;
}

// @public
export type IUsePlaceholderHook<T extends IPlaceholder<any>> = () => [
    PlaceholderValue<T> | undefined,
    (valueOrUpdateCallback: ValueOrUpdateCallback<PlaceholderValue<T> | undefined>) => void
];

// @public
export interface IVisualizationCallbacks {
    // @internal (undocumented)
    afterRender?: () => void;
    onDrill?: OnFiredDrillEvent;
    onError?: OnError;
    onExportReady?: OnExportReady;
    onLoadingChanged?: OnLoadingChanged;
    // @internal (undocumented)
    pushData?: (data: IPushData) => void;
}

// @public
export interface IVisualizationProps {
    drillableItems?: Array<IDrillableItem | IHeaderPredicate>;
    ErrorComponent?: React_2.ComponentType<IErrorProps>;
    exportTitle?: string;
    LoadingComponent?: React_2.ComponentType<ILoadingProps>;
    locale?: string;
}

// @internal
export interface IWithExecution<T> {
    events?: IWithLoadingEvents<T> | ((props: T) => IWithLoadingEvents<T>);
    execution: IPreparedExecution | ((props: T) => IPreparedExecution) | ((props: T) => Promise<IPreparedExecution>);
    exportTitle: string | ((props: T) => string);
    loadOnMount?: boolean | ((props: T) => boolean);
    shouldRefetch?: (prevProps: T, nextProps: T) => boolean;
    window?: DataViewWindow | ((props: T) => DataViewWindow | undefined);
}

// @internal
export interface IWithExecutionLoading<TProps> {
    events?: IWithLoadingEvents<TProps> | ((props: TProps) => IWithLoadingEvents<TProps>);
    exportTitle: string | ((props: TProps) => string);
    loadOnMount?: boolean | ((props: TProps) => boolean);
    promiseFactory: (props: TProps, window?: DataViewWindow) => Promise<DataViewFacade>;
    shouldRefetch?: (prevProps: TProps, nextProps: TProps) => boolean;
    window?: DataViewWindow | ((props: TProps) => DataViewWindow | undefined);
}

// @public (undocumented)
export interface IWithLoadingEvents<TProps> {
    onError?: (error: GoodDataSdkError, props: TProps) => void;
    onExportReady?: (exportFunction: IExportFunction, props: TProps) => void;
    onLoadingChanged?: (isLoading: boolean, props: TProps) => void;
    onLoadingFinish?: (result: DataViewFacade, props: TProps) => void;
    onLoadingStart?: (props: TProps) => void;
}

// @public (undocumented)
export interface IWorkspaceProviderProps {
    workspace: string;
}

// @public
export const Kpi: React_2.ComponentType<IKpiProps>;

// @public
export class LoadingComponent extends React_2.Component<ILoadingProps> {
    // (undocumented)
    static defaultProps: Partial<ILoadingProps>;
    // (undocumented)
    render(): React_2.ReactNode;
}

// @public
export function localIdentifierMatch(localIdOrMeasure: string | IMeasure): IHeaderPredicate;

// @internal
export function makeCancelable<T>(promise: Promise<T>): ICancelablePromise<T>;

// @public
export type MeasureOf<T extends IMeasureDefinitionType> = T extends any ? IMeasure<T> : never;

// @internal (undocumented)
export const messagesMap: {
    [locale: string]: ITranslations;
};

// @public
export class NegativeValuesSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export function newComposedPlaceholder<TValue extends any[], TReturn = PlaceholdersResolvedValues<TValue>, TContext = UnionToIntersection<ComposedPlaceholderResolutionContext<Flatten<TValue>>>>(placeholders: [...TValue], computeValue?: (values: PlaceholdersResolvedValues<TValue>, resolutionContext: TContext) => TReturn): IComposedPlaceholder<TReturn, TValue, TContext>;

// @public
export function newErrorMapping(intl: IntlShape): IErrorDescriptors;

// @public
export function newPlaceholder<T>(defaultValue?: T, options?: IPlaceholderOptions<T>): IPlaceholder<T>;

// @public
export class NoDataSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class NotFoundSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public (undocumented)
export type OnError = (error: GoodDataSdkError) => void;

// @public (undocumented)
export type OnExportReady = (exportFunction: IExportFunction) => void;

// @public (undocumented)
export type OnFiredDrillEvent = IDrillEventCallback;

// @public (undocumented)
export type OnLoadingChanged = (loadingState: ILoadingState) => void;

// @internal (undocumented)
export type OverTimeComparisonType = "same_period_previous_year" | "previous_period" | "nothing";

// @internal (undocumented)
export const OverTimeComparisonTypes: {
    SAME_PERIOD_PREVIOUS_YEAR: "same_period_previous_year";
    PREVIOUS_PERIOD: "previous_period";
    NOTHING: "nothing";
};

// @public
export type PlaceholderOf<T> = T extends any ? AnyPlaceholder<T> : never;

// @public
export type PlaceholderResolvedValue<T> = T extends Array<infer A> ? Flatten<PlaceholderResolvedValue<A>>[] : T extends IPlaceholder<infer B> ? B : T extends IComposedPlaceholder<infer C, any, any> ? C : T;

// @public (undocumented)
export function PlaceholdersProvider(props: IPlaceholdersProviderProps): JSX.Element;

// @public
export type PlaceholdersResolvedValues<Tuple extends any[]> = {
    [Index in keyof Tuple]: PlaceholderResolvedValue<Tuple[Index]>;
};

// @public
export type PlaceholdersValues<Tuple extends [...any[]]> = {
    [Index in keyof Tuple]: PlaceholderValue<Tuple[Index]>;
};

// @public
export type PlaceholderValue<T> = T extends IPlaceholder<infer A> ? A : T extends IComposedPlaceholder<infer B, any, any> ? B : T;

// @public
export class ProtectedReportSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export const RawExecute: React_2.ComponentClass<IRawExecuteProps, any>;

// @beta
export function resolveUseCancelablePromisesError<TError>(states: UseCancelablePromiseState<unknown, TError>[]): TError | undefined;

// @beta
export function resolveUseCancelablePromisesStatus(cancelablePromisesStates: UseCancelablePromiseState<unknown, unknown>[], options?: {
    strategy?: "serial" | "parallel";
}): UseCancelablePromiseStatus;

// @public (undocumented)
export type SdkErrorType = keyof typeof ErrorCodes;

// @internal (undocumented)
export type Subtract<T, K> = Pick<T, Exclude<keyof T, keyof K>>;

// @public (undocumented)
export type TableElementType = "cell";

// @public (undocumented)
export type TableType = "table";

// @internal (undocumented)
export class TranslationsProvider extends React_2.PureComponent<ITranslationsProviderProps> {
    // (undocumented)
    render(): React_2.ReactNode;
}

// @public
export class UnauthorizedSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
    // (undocumented)
    authenticationFlow?: AuthenticationFlow;
}

// @public
export class UnexpectedSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;

// @public
export function uriMatch(uri: string): IHeaderPredicate;

// @public
export const useBackend: (backend?: IAnalyticalBackend | undefined) => IAnalyticalBackend | undefined;

// @public
export const useBackendStrict: (backend?: IAnalyticalBackend | undefined, context?: string) => IAnalyticalBackend;

// @beta
export function useCancelablePromise<TResult, TError = any>({ promise, onLoading, onPending, onCancel, onSuccess, onError, }: {
    promise: (() => Promise<TResult>) | undefined | null;
} & UseCancelablePromiseCallbacks<TResult, TError>, deps?: DependencyList): UseCancelablePromiseState<TResult, TError>;

// @beta
export type UseCancelablePromiseCallbacks<TResult, TError> = {
    onLoading?: () => void;
    onPending?: () => void;
    onCancel?: () => void;
    onSuccess?: (result: TResult) => void;
    onError?: (err: TError) => void;
};

// @beta
export type UseCancelablePromiseErrorState<TError> = {
    result: undefined;
    error: TError;
    status: "error";
};

// @beta
export type UseCancelablePromiseLoadingState = {
    result: undefined;
    error: undefined;
    status: "loading";
};

// @beta
export type UseCancelablePromisePendingState = {
    result: undefined;
    error: undefined;
    status: "pending";
};

// @beta
export type UseCancelablePromiseState<TResult, TError> = UseCancelablePromisePendingState | UseCancelablePromiseLoadingState | UseCancelablePromiseErrorState<TError> | UseCancelablePromiseSuccessState<TResult>;

// @beta
export type UseCancelablePromiseStatus = "success" | "error" | "loading" | "pending";

// @beta
export type UseCancelablePromiseSuccessState<TResult> = {
    result: TResult;
    error: undefined;
    status: "success";
};

// @public
export function useComposedPlaceholder<TContext, TPlaceholder extends IComposedPlaceholder<any, any, TContext>>(placeholder: TPlaceholder, resolutionContext?: TContext): PlaceholderResolvedValue<TPlaceholder>;

// @beta
export function useDataExport({ execution, exportConfig, onCancel, onError, onLoading, onPending, onSuccess, }: {
    execution: IPreparedExecution | undefined | null;
    exportConfig?: IExportConfig;
} & UseDataExportCallbacks, deps?: DependencyList): UseDataExportState;

// @beta
export type UseDataExportCallbacks = UseCancelablePromiseCallbacks<string, GoodDataSdkError>;

// @beta
export type UseDataExportState = UseCancelablePromiseState<string, GoodDataSdkError>;

// @beta
export function useDataView({ execution, window, onCancel, onError, onLoading, onPending, onSuccess, }: {
    execution: IPreparedExecution | undefined | null;
    window?: DataViewWindow;
} & UseDataViewCallbacks, deps?: DependencyList): UseDataViewState;

// @beta
export type UseDataViewCallbacks = UseCancelablePromiseCallbacks<DataViewFacade, GoodDataSdkError>;

// @beta
export type UseDataViewState = UseCancelablePromiseState<DataViewFacade, GoodDataSdkError>;

// @beta
export function useExecution(config: IUseExecutionConfig): IPreparedExecution;

// @beta
export function useExecutionDataView(config: IUseExecutionDataViewConfig, deps?: React.DependencyList): UseCancelablePromiseState<DataViewFacade, GoodDataSdkError>;

// @beta
export function useInsightDataView(config: IUseInsightDataViewConfig, deps?: React.DependencyList): UseCancelablePromiseState<DataViewFacade, GoodDataSdkError>;

// @public
export function usePagedResource<TParams, TItem>(resourceFactory: (params: TParams) => Promise<IPagedResource<TItem>>, fetchParams: TParams[], fetchDeps: React.DependencyList, resetDeps: React.DependencyList, getCacheKey?: (params: TParams) => string, initialState?: IUsePagedResourceState<TItem>): IUsePagedResourceResult<TItem>;

// @public
export function usePlaceholder<T extends IPlaceholder<any>>(placeholder?: T): [
    PlaceholderValue<T> | undefined,
    (valueOrUpdateCallback: ValueOrUpdateCallback<PlaceholderValue<T> | undefined>) => void
];

// @public
export function usePlaceholders<T extends IPlaceholder<any>[]>(placeholders: [...T]): [PlaceholdersValues<T>, (valueOrUpdateCallback: ValueOrUpdateCallback<PlaceholdersValues<T>>) => void];

// @public
export function useResolveValuesWithPlaceholders<T extends any[], C>(values: [...T], resolutionContext?: C): PlaceholdersResolvedValues<T>;

// @public
export function useResolveValueWithPlaceholders<T, C>(value: T, resolutionContext?: C): PlaceholderResolvedValue<T>;

// @public
export const useWorkspace: (workspace?: string | undefined) => string | undefined;

// @public
export const useWorkspaceStrict: (workspace?: string | undefined, context?: string) => string;

// @public (undocumented)
export type ValueFormatter = (value: DataValue, format: string) => string;

// @public
export type ValueOrPlaceholder<T> = T | AnyPlaceholderOf<T>;

// @public
export type ValuesOrPlaceholders<T> = AnyArrayOf<ValueOrPlaceholder<T> | AnyPlaceholderOf<AnyArrayOf<T>>>;

// @public (undocumented)
export type VisElementType = ChartElementType | HeadlineElementType | TableElementType | "pushpin";

// @public (undocumented)
export type VisType = ChartType | HeadlineType | TableType | XirrType;

// @internal (undocumented)
export type VisualizationEnvironment = "none" | "dashboards";

// @internal (undocumented)
export function visualizationIsBetaWarning(): void;

// @internal (undocumented)
export const VisualizationTypes: {
    BAR: "bar";
    COLUMN: "column";
    LINE: "line";
    PIE: "pie";
    DONUT: "donut";
    TABLE: "table";
    HEADLINE: "headline";
    AREA: "area";
    SCATTER: "scatter";
    BUBBLE: "bubble";
    HEATMAP: "heatmap";
    GEO: "geo";
    PUSHPIN: "pushpin";
    COMBO: "combo";
    COMBO2: "combo2";
    HISTOGRAM: "histogram";
    BULLET: "bullet";
    TREEMAP: "treemap";
    WATERFALL: "waterfall";
    FUNNEL: "funnel";
    PARETO: "pareto";
    ALLUVIAL: "alluvial";
    XIRR: "xirr";
};

// @internal
export function withBackend<T extends {
    backend?: IAnalyticalBackend;
}>(Component: React_2.ComponentType<T>): React_2.ComponentType<T>;

// @internal
export function withContexts<T extends {
    backend?: IAnalyticalBackend;
    workspace?: string;
}>(Chart: React.ComponentType<T>): React.ComponentType<T>;

// @internal
export function withEntireDataView<T extends IDataVisualizationProps>(InnerComponent: React_2.ComponentClass<T & ILoadingInjectedProps>): React_2.ComponentClass<T>;

// @internal
export function withExecution<T>(params: IWithExecution<T>): (WrappedComponent: React.ComponentType<T & WithLoadingResult>) => React.ComponentClass<T, any>;

// @internal
export function withExecutionLoading<TProps>(params: IWithExecutionLoading<TProps>): (WrappedComponent: React_2.ComponentType<TProps & WithLoadingResult>) => React_2.ComponentClass<TProps>;

// @internal (undocumented)
export function withIntl<P>(WrappedComponent: React_2.FC<P> | React_2.ComponentClass<P>, customLocale?: ILocale, customMessages?: ITranslations): React_2.ComponentType<P>;

// @public (undocumented)
export type WithLoadingResult = {
    result: DataViewFacade | undefined;
    error: GoodDataSdkError | undefined;
    isLoading: boolean;
    reload: () => void;
};

// @internal
export function withWorkspace<T extends {
    workspace?: string;
}>(Component: React_2.ComponentType<T>): React_2.ComponentType<T>;

// @public
export const WorkspaceProvider: React_2.FC<IWorkspaceProviderProps>;

// @internal
export const wrapDisplayName: (hocName: string, BaseComponent?: import("react").ComponentClass<any, any> | import("react").FunctionComponent<any> | undefined) => <T>(Component: import("react").ComponentType<T>) => import("react").ComponentType<T>;

// @public (undocumented)
export type XirrType = "xirr";


```
