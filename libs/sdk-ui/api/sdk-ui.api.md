## API Report File for "@gooddata/sdk-ui"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="react" />

import { AuthenticationFlow } from '@gooddata/sdk-backend-spi';
import { ComponentType } from 'react';
import { DataValue } from '@gooddata/sdk-model';
import { DependencyList } from 'react';
import { IAbsoluteDateFilter } from '@gooddata/sdk-model';
import { IAnalyticalBackend } from '@gooddata/sdk-backend-spi';
import { IAttribute } from '@gooddata/sdk-model';
import { IAttributeDescriptor } from '@gooddata/sdk-model';
import { IAttributeFilter } from '@gooddata/sdk-model';
import { IAttributeOrMeasure } from '@gooddata/sdk-model';
import { IBucket } from '@gooddata/sdk-model';
import { IColor } from '@gooddata/sdk-model';
import { IColorDescriptor } from '@gooddata/sdk-model';
import { IColorPalette } from '@gooddata/sdk-model';
import { IDataView } from '@gooddata/sdk-backend-spi';
import { IDateFilter } from '@gooddata/sdk-model';
import { IDimension } from '@gooddata/sdk-model';
import { IDimensionDescriptor } from '@gooddata/sdk-model';
import { IDimensionItemDescriptor } from '@gooddata/sdk-model';
import { IExecutionDefinition } from '@gooddata/sdk-model';
import { IExecutionResult } from '@gooddata/sdk-backend-spi';
import { IExportConfig } from '@gooddata/sdk-backend-spi';
import { IExportResult } from '@gooddata/sdk-backend-spi';
import { IFilter } from '@gooddata/sdk-model';
import { IInsightDefinition } from '@gooddata/sdk-model';
import { IMeasure } from '@gooddata/sdk-model';
import { IMeasureDefinitionType } from '@gooddata/sdk-model';
import { IMeasureDescriptor } from '@gooddata/sdk-model';
import { IMeasureFilter } from '@gooddata/sdk-model';
import { IMeasureGroupDescriptor } from '@gooddata/sdk-model';
import { IMeasureValueFilter } from '@gooddata/sdk-model';
import { INegativeAttributeFilter } from '@gooddata/sdk-model';
import { IntlShape } from 'react-intl';
import { INullableFilter } from '@gooddata/sdk-model';
import { IPagedResource } from '@gooddata/sdk-backend-spi';
import { IPositiveAttributeFilter } from '@gooddata/sdk-model';
import { IPreparedExecution } from '@gooddata/sdk-backend-spi';
import { IRankingFilter } from '@gooddata/sdk-model';
import { IRelativeDateFilter } from '@gooddata/sdk-model';
import { IResultAttributeHeader } from '@gooddata/sdk-model';
import { IResultAttributeHeaderItem } from '@gooddata/sdk-model';
import { IResultHeader } from '@gooddata/sdk-model';
import { IResultMeasureHeader } from '@gooddata/sdk-model';
import { IResultTotalHeader } from '@gooddata/sdk-model';
import { IResultWarning } from '@gooddata/sdk-model';
import { ISeparators } from '@gooddata/sdk-model';
import { ISortItem } from '@gooddata/sdk-model';
import { ITotal } from '@gooddata/sdk-model';
import { ITotalDescriptor } from '@gooddata/sdk-model';
import { IWorkspaceSettings } from '@gooddata/sdk-backend-spi';
import { MessageDescriptor } from 'react-intl';
import { ObjRef } from '@gooddata/sdk-model';
import { default as React_2 } from 'react';
import { ValueOrUpdateCallback } from '@gooddata/sdk-backend-base';
import { WithIntlProps } from 'react-intl';
import { WrappedComponentProps } from 'react-intl';

// @public
export type AnyArrayOf<T> = T[] | ArrayOf<T>;

// @public
export type AnyMeasure = IMeasure | MeasureOf<IMeasureDefinitionType>;

// @public
export type AnyPlaceholder<T = any> = IPlaceholder<T> | IComposedPlaceholder<T, any, any>;

// @public
export type AnyPlaceholderOf<T> = AnyPlaceholder<T> | PlaceholderOf<T>;

// @internal
export class ArithmeticMeasureTitleFactory {
    constructor(locale: ILocale);
    getTitle(arithmeticMeasureProps: IArithmeticMeasureTitleProps, measureTitleProps: IMeasureTitleProps[]): string | null;
}

// @public
export type ArrayOf<T> = T extends any ? T[] : never;

// @public
export type AttributeFilterOrPlaceholder = ValueOrPlaceholder<IAttributeFilter> | ValueOrPlaceholder<IPositiveAttributeFilter> | ValueOrPlaceholder<INegativeAttributeFilter>;

// @public
export type AttributeFiltersOrPlaceholders = Array<ValueOrMultiValuePlaceholder<IAttributeFilter> | ValueOrMultiValuePlaceholder<IPositiveAttributeFilter> | ValueOrMultiValuePlaceholder<INegativeAttributeFilter>>;

// @public
export function attributeItemNameMatch(name: string): IHeaderPredicate;

// @public
export type AttributeMeasureOrPlaceholder = ValueOrPlaceholder<IAttribute | AnyMeasure> | ValueOrPlaceholder<IAttribute> | ValueOrPlaceholder<AnyMeasure>;

// @public
export type AttributeOrPlaceholder = ValueOrPlaceholder<IAttribute>;

// @public
export type AttributesMeasuresOrPlaceholders = Array<ValueOrMultiValuePlaceholder<IAttribute | AnyMeasure> | ValueOrMultiValuePlaceholder<IAttribute> | ValueOrMultiValuePlaceholder<AnyMeasure>>;

// @public
export type AttributesOrPlaceholders = ValuesOrPlaceholders<IAttribute>;

// @public
export const BackendProvider: React_2.FC<IBackendProviderProps>;

// @public
export class BadRequestSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal (undocumented)
export type BucketNameKeys = keyof typeof BucketNames;

// @internal
export const BucketNames: {
    readonly MEASURES: "measures";
    readonly SECONDARY_MEASURES: "secondary_measures";
    readonly TERTIARY_MEASURES: "tertiary_measures";
    readonly ATTRIBUTE: "attribute";
    readonly ATTRIBUTES: "attributes";
    readonly ATTRIBUTE_FROM: "attribute_from";
    readonly ATTRIBUTE_TO: "attribute_to";
    readonly VIEW: "view";
    readonly STACK: "stack";
    readonly TREND: "trend";
    readonly SEGMENT: "segment";
    readonly COLUMNS: "columns";
    readonly LOCATION: "location";
    readonly LONGITUDE: "longitude";
    readonly LATITUDE: "latitude";
    readonly SIZE: "size";
    readonly COLOR: "color";
    readonly TOOLTIP_TEXT: "tooltipText";
};

// @internal (undocumented)
export type BucketNameValues = typeof BucketNames[BucketNameKeys];

// @internal (undocumented)
export class CancelError extends Error {
    constructor(reason?: string | undefined);
    getReason(): string | undefined;
    // (undocumented)
    reason?: string | undefined;
}

// @public
export class CancelledSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public (undocumented)
export type ChartElementType = "slice" | "bar" | "point" | "label" | "cell" | "target" | "primary" | "comparative";

// @public (undocumented)
export type ChartType = "bar" | "column" | "pie" | "line" | "area" | "donut" | "scatter" | "bubble" | "heatmap" | "geo" | "pushpin" | "combo" | "combo2" | "histogram" | "bullet" | "treemap" | "waterfall" | "funnel" | "pyramid" | "pareto" | "alluvial" | "sankey" | "dependencywheel" | "repeater";

// @alpha
export const ClientWorkspaceProvider: React_2.FC<IClientWorkspaceProviderProps>;

// @public
export function composedFromIdentifier(identifier: string): IHeaderPredicate;

// @public
export function composedFromUri(uri: string): IHeaderPredicate;

// @public
export type ComposedPlaceholderResolutionContext<T> = T extends IComposedPlaceholder<any, any, infer TContext> ? TContext : any;

// @public (undocumented)
export function convertDrillableItemsToPredicates(drillableItems: ExplicitDrill[]): IHeaderPredicate[];

// @public
export function convertError(error: unknown): GoodDataSdkError;

// @internal
export function createExportErrorFunction(error: GoodDataSdkError): IExportFunction;

// @internal
export function createExportFunction(result: IExecutionResult, exportTitle?: string): IExportFunction;

// @internal (undocumented)
export function createIntlMock(customMessages?: {}, locale?: string): IntlShape;

// @public
export function createNumberJsFormatter(separators?: ISeparators): ValueFormatter;

// @public (undocumented)
export type DataAccessConfig = {
    valueFormatter: ValueFormatter;
    headerTranslator?: HeaderTranslator;
};

// @public
export type DataPoint = {
    readonly rawValue: DataValue;
    formattedValue(): null | string;
    readonly coordinates: DataPointCoordinates;
    readonly seriesDesc: DataSeriesDescriptor;
    readonly sliceDesc?: DataSliceDescriptor;
    readonly total?: boolean;
};

// @public (undocumented)
export type DataPointCoordinates = number[];

// @public
export type DataSeriesDescriptor = DataSeriesHeaders & DataSeriesDescriptorMethods & {
    readonly id: DataSeriesId;
    readonly measureDescriptor: IMeasureDescriptor;
    readonly measureDefinition: IMeasure;
    readonly attributeDescriptors?: IAttributeDescriptor[];
    readonly attributeDefinitions?: IAttribute[];
    readonly isSubtotal?: boolean;
    readonly isTotal?: boolean;
};

// @public (undocumented)
export type DataSeriesDescriptorMethods = {
    measureTitle(): string;
    measureFormat(): string;
    scopeTitles(): Array<string | null>;
};

// @public (undocumented)
export type DataSeriesHeaders = {
    readonly measureHeader: IResultMeasureHeader;
    readonly attributeHeaders?: IResultAttributeHeader[];
};

// @public (undocumented)
export type DataSeriesId = string;

// @public
export type DataSliceDescriptor = DataSliceHeaders & DataSliceDescriptorMethods & {
    readonly id: DataSliceId;
    readonly descriptors: IAttributeDescriptor[];
    readonly definitions: IAttribute[];
};

// @public (undocumented)
export type DataSliceDescriptorMethods = {
    readonly sliceTitles: () => Array<string | null>;
};

// @public
export type DataSliceHeaders = {
    readonly headers: Array<IResultAttributeHeader | IResultTotalHeader>;
    readonly isTotal?: boolean;
};

// @public (undocumented)
export type DataSliceId = string;

// @public
export class DataTooLargeToComputeSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class DataTooLargeToDisplaySdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class DataViewFacade {
    protected constructor(dataView: IDataView);
    // (undocumented)
    data(config?: DataAccessConfig): IDataAccessMethods;
    // (undocumented)
    readonly dataView: IDataView;
    // @internal (undocumented)
    def(): IExecutionDefinitionMethods;
    // (undocumented)
    readonly definition: IExecutionDefinition;
    // (undocumented)
    fingerprint(): string;
    // (undocumented)
    static for(dataView: IDataView): DataViewFacade;
    static forResult(result: IExecutionResult): DataViewFacade;
    // @internal (undocumented)
    meta(): IResultMetaMethods;
    // @internal (undocumented)
    rawData(): IResultDataMethods;
    // (undocumented)
    result(): IExecutionResult;
    // (undocumented)
    warnings(): IResultWarning[];
}

// @alpha
export class DataViewLoader {
    filterBy: (...filters: INullableFilter[]) => DataViewLoader;
    static for(backend: IAnalyticalBackend, workspace: string): DataViewLoader;
    loadAll: () => Promise<DataViewFacade>;
    loadWindow: (dataWindow: DataViewWindow) => Promise<DataViewFacade>;
    seriesFrom: (...measuresAndScopingAttributes: IAttributeOrMeasure[]) => DataViewLoader;
    slicesFrom: (...attributes: IAttribute[]) => DataViewLoader;
    sortBy: (...sorts: ISortItem[]) => DataViewLoader;
    withTotals: (...totals: ITotal[]) => DataViewLoader;
}

// @public
export type DataViewWindow = {
    offset: number[];
    size: number[];
};

// @public
export const DefaultColorPalette: IColorPalette;

// @public
export const DefaultDataAccessConfig: DataAccessConfig;

// @public
export function defaultErrorHandler(error: unknown): void;

// @public
export const DefaultLocale: ILocale;

// @internal
export class DerivedMeasureTitleSuffixFactory {
    constructor(locale: ILocale);
    getSuffix(overTimeComparisonType: OverTimeComparisonType): string;
}

// @public (undocumented)
export type DrillEventIntersectionElementHeader = IAttributeDescriptor | IMeasureDescriptor | ITotalDescriptor | IDrillIntersectionAttributeItem;

// @public
export class DynamicScriptLoadSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal
export function emptyHeaderTitleFromIntl(intl: IntlShape): string;

// @public
export const ErrorCodes: {
    BAD_REQUEST: string;
    UNAUTHORIZED: string;
    GEO_LOCATION_MISSING: string;
    GEO_MAPBOX_TOKEN_MISSING: string;
    DATA_TOO_LARGE_TO_DISPLAY: string;
    DATA_TOO_LARGE_TO_COMPUTE: string;
    NEGATIVE_VALUES: string;
    NO_DATA: string;
    NOT_FOUND: string;
    PROTECTED_REPORT: string;
    UNKNOWN_ERROR: string;
    CANCELLED: string;
    DYNAMIC_SCRIPT_LOAD_ERROR: string;
    TIMEOUT_ERROR: string;
    VISUALIZATION_CLASS_UNKNOWN: string;
};

// @public
export class ErrorComponent extends React_2.Component<IErrorProps> {
    // (undocumented)
    static defaultProps: Partial<IErrorProps>;
    // (undocumented)
    render(): React_2.JSX.Element;
}

// @public
export const Execute: (props: IExecuteProps) => React_2.JSX.Element;

// @public
export const ExecuteInsight: React_2.ComponentType<IExecuteInsightProps>;

// @public
export type ExplicitDrill = IDrillableItem | IHeaderPredicate;

// @internal
export function fillMissingFormat(item: IAttributeOrMeasure): IAttributeOrMeasure;

// @internal
export function fillMissingFormats<T extends IInsightDefinition>(insight: T): T;

// @internal
export function fillMissingTitles<T extends IInsightDefinition>(insight: T, locale: ILocale, maxArithmeticMeasureTitleLength?: number): T;

// @public (undocumented)
export type FilterOrMultiValuePlaceholder = ValueOrMultiValuePlaceholder<IFilter> | ValueOrMultiValuePlaceholder<IDateFilter> | ValueOrMultiValuePlaceholder<IMeasureFilter> | ValueOrMultiValuePlaceholder<IAttributeFilter> | ValueOrMultiValuePlaceholder<IAbsoluteDateFilter> | ValueOrMultiValuePlaceholder<IRelativeDateFilter> | ValueOrMultiValuePlaceholder<IPositiveAttributeFilter> | ValueOrMultiValuePlaceholder<INegativeAttributeFilter> | ValueOrMultiValuePlaceholder<IMeasureValueFilter> | ValueOrMultiValuePlaceholder<IRankingFilter>;

// @public
export type FilterOrPlaceholder = ValueOrPlaceholder<IFilter> | ValueOrPlaceholder<IDateFilter> | ValueOrPlaceholder<IMeasureFilter> | ValueOrPlaceholder<IAttributeFilter> | ValueOrPlaceholder<IAbsoluteDateFilter> | ValueOrPlaceholder<IRelativeDateFilter> | ValueOrPlaceholder<IPositiveAttributeFilter> | ValueOrPlaceholder<INegativeAttributeFilter> | ValueOrPlaceholder<IMeasureValueFilter> | ValueOrPlaceholder<IRankingFilter>;

// @public
export type FiltersOrPlaceholders = Array<FilterOrMultiValuePlaceholder>;

// @internal
export function fireDrillEvent(drillEventFunction: IDrillEventCallback, drillEventData: IDrillEvent, target: EventTarget): void;

// @public
export type Flatten<T> = T extends Array<infer A> ? A : T;

// @public
export class GeoLocationMissingSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class GeoTokenMissingSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal
export function getAttributeHeaderItemName(attributeHeaderItem: IResultAttributeHeaderItem | undefined): string | null | undefined;

// @internal (undocumented)
export function getDrillIntersection(drillItems: IMappingHeader[]): IDrillEventIntersectionElement[];

// @internal
export function getIntersectionAttributes(fromAttribute: IAttributeDescriptor, attributes: IAttributeDescriptor[]): IAttributeDescriptor[];

// @internal (undocumented)
export function getIntersectionPartAfter(intersection: IDrillEventIntersectionElement[], localIdentifier: string): IDrillEventIntersectionElement[];

// @internal
export function getIntl(locale?: ILocale): IntlShape;

// @internal
export function getMappingHeaderFormattedName(header: IMappingHeader | IResultMeasureHeader): string | undefined | null;

// @internal (undocumented)
export function getMappingHeaderIdentifier(header: IMappingHeader): string | undefined;

// @internal (undocumented)
export function getMappingHeaderLocalIdentifier(header: IMappingHeader): string;

// @internal (undocumented)
export function getMappingHeaderName(header: IMappingHeader | IResultMeasureHeader): string | undefined | null;

// @internal (undocumented)
export function getMappingHeaderUri(header: IMappingHeader): string | undefined;

// @internal (undocumented)
export function getTotalInfo(attributeHeaders: IResultAttributeHeader[]): {
    isTotal: boolean;
    isSubtotal: boolean;
};

// @internal
export function getTranslation(translationId: string | MessageDescriptor, locale: ILocale, values?: {}): string;

// @internal (undocumented)
export function getVisualizationType(type: ChartType): ChartType;

// @public
export abstract class GoodDataSdkError extends Error {
    protected constructor(seType: SdkErrorType, message?: string, cause?: any);
    // (undocumented)
    readonly cause?: any;
    getCause(): any | undefined;
    getErrorCode(): string;
    getMessage(): string;
    // (undocumented)
    readonly seType: SdkErrorType;
}

// @internal (undocumented)
export function hasMappingHeaderFormattedName(header: IMappingHeader): boolean;

// @internal (undocumented)
export function hasMappingHeaderLocalIdentifier(header: IMappingHeader): boolean;

// @public
export const HeaderPredicates: {
    attributeItemNameMatch: typeof attributeItemNameMatch;
    composedFromIdentifier: typeof composedFromIdentifier;
    composedFromUri: typeof composedFromUri;
    identifierMatch: typeof identifierMatch;
    localIdentifierMatch: typeof localIdentifierMatch;
    uriMatch: typeof uriMatch;
    objRefMatch: typeof objRefMatch;
    objMatch: typeof objMatch;
};

// @public (undocumented)
export type HeaderTranslator = (value: string | null) => string;

// @public (undocumented)
export type HeadlineElementType = "primaryValue" | "secondaryValue";

// @public (undocumented)
export type HeadlineType = "headline";

// @internal
export interface IArithmeticMeasureTitleProps {
    // (undocumented)
    masterMeasureLocalIdentifiers: string[];
    // (undocumented)
    operator: string;
}

// @internal (undocumented)
export interface IAvailableDrillTargetAttribute {
    // (undocumented)
    attribute: IAttributeDescriptor;
    // (undocumented)
    intersectionAttributes: IAttributeDescriptor[];
}

// @internal (undocumented)
export interface IAvailableDrillTargetMeasure {
    // (undocumented)
    attributes: IAttributeDescriptor[];
    // (undocumented)
    measure: IMeasureDescriptor;
}

// @internal (undocumented)
export interface IAvailableDrillTargets {
    // (undocumented)
    attributes?: IAvailableDrillTargetAttribute[];
    // (undocumented)
    measures?: IAvailableDrillTargetMeasure[];
}

// @public
export interface IBackendProviderProps {
    backend: IAnalyticalBackend;
    children?: React_2.ReactNode;
}

// @internal (undocumented)
export interface ICancelablePromise<T> {
    // (undocumented)
    cancel: (reason?: string) => void;
    // (undocumented)
    getHasCanceled: () => boolean;
    // (undocumented)
    getHasFulfilled: () => boolean;
    // (undocumented)
    promise: Promise<T>;
}

// @alpha
export interface IClientWorkspaceIdentifiers {
    children?: React.ReactNode;
    client?: string;
    dataProduct?: string;
    segment?: string;
    workspace?: string;
}

// @alpha
export interface IClientWorkspaceProviderCoreProps {
    backend?: IAnalyticalBackend;
    children: React_2.ReactNode;
}

// @alpha
export type IClientWorkspaceProviderProps = IClientWorkspaceProviderWithWorkspaceProps | IClientWorkspaceProviderWithClientAndDataProductProps;

// @alpha (undocumented)
export interface IClientWorkspaceProviderWithClientAndDataProductProps extends IClientWorkspaceProviderCoreProps {
    client: string;
    dataProduct: string;
}

// @alpha (undocumented)
export interface IClientWorkspaceProviderWithWorkspaceProps extends IClientWorkspaceProviderCoreProps {
    workspace: string;
}

// @internal (undocumented)
export interface IClientWorkspaceStatus {
    // (undocumented)
    isInitialized: boolean;
}

// @internal (undocumented)
export interface IColorAssignment {
    // (undocumented)
    color: IColor;
    // (undocumented)
    headerItem: IMappingHeader;
}

// @internal (undocumented)
export interface IColorsData {
    // (undocumented)
    colorAssignments: IColorAssignment[];
    // (undocumented)
    colorPalette: IColorPalette;
}

// @public
export interface IComposedPlaceholder<TReturn, TValue extends any[], TContext> {
    // (undocumented)
    computeValue: (values: PlaceholdersResolvedValues<TValue>, resolutionContext: TContext) => TReturn;
    // (undocumented)
    placeholders: TValue;
    // (undocumented)
    type: "IComposedPlaceholder";
    // (undocumented)
    use: IUseComposedPlaceholderHook<IComposedPlaceholder<TReturn, TValue, TContext>>;
}

// @public
export interface IDataAccessMethods {
    // (undocumented)
    series(): IDataSeriesCollection;
    // (undocumented)
    slices(): IDataSliceCollection;
}

// @public
export interface IDataSeries extends DataSeriesDescriptorMethods, Iterable<DataPoint> {
    // (undocumented)
    dataPoints(): DataPoint[];
    readonly descriptor: DataSeriesDescriptor;
    readonly id: DataSeriesId;
    // (undocumented)
    rawData(): DataValue[];
}

// @public
export interface IDataSeriesCollection extends Iterable<IDataSeries> {
    allForMeasure(localIdOrMeasure: string | IMeasure): Iterable<IDataSeries>;
    readonly count: number;
    firstForMeasure(localIdOrMeasure: string | IMeasure): IDataSeries;
    readonly fromMeasures: IMeasureDescriptor[];
    readonly fromMeasuresDef: IMeasure[];
    readonly scopingAttributes?: IAttributeDescriptor[];
    readonly scopingAttributesDef?: IAttribute[];
    toArray(): IDataSeries[];
}

// @public
export interface IDataSlice extends DataSliceDescriptorMethods, Iterable<DataPoint> {
    // (undocumented)
    dataPoints(): DataPoint[];
    readonly descriptor: DataSliceDescriptor;
    readonly id: DataSliceId;
    // (undocumented)
    rawData(): DataValue[];
}

// @public
export interface IDataSliceCollection extends Iterable<IDataSlice> {
    readonly count: number;
    readonly descriptors: Array<IAttributeDescriptor | ITotal>;
    toArray(): IDataSlice[];
}

// @public
export interface IDataVisualizationProps extends IVisualizationProps, IVisualizationCallbacks {
    execution: IPreparedExecution;
}

// @public
export function identifierMatch(identifier: string): IHeaderPredicate;

// @public (undocumented)
export type IDrillableItem = IDrillableItemUri | IDrillableItemIdentifier | (IDrillableItemUri & IDrillableItemIdentifier);

// @public (undocumented)
export interface IDrillableItemIdentifier {
    // (undocumented)
    identifier: string;
}

// @public (undocumented)
export interface IDrillableItemUri {
    // (undocumented)
    uri: string;
}

// @public (undocumented)
export interface IDrillConfig {
    // (undocumented)
    dataView: IDataView;
    // (undocumented)
    onDrill: OnFiredDrillEvent;
}

// @public (undocumented)
export interface IDrillEvent {
    // (undocumented)
    dataView: IDataView;
    // (undocumented)
    drillContext: IDrillEventContext;
}

// @public (undocumented)
export type IDrillEventCallback = (event: IDrillEvent) => void | boolean;

// @public
export interface IDrillEventContext {
    // (undocumented)
    columnIndex?: number;
    // (undocumented)
    element: VisElementType;
    // (undocumented)
    intersection?: IDrillEventIntersectionElement[];
    // (undocumented)
    points?: IDrillPoint[];
    // (undocumented)
    row?: any[];
    // (undocumented)
    rowIndex?: number;
    // (undocumented)
    type: VisType;
    // (undocumented)
    value?: string;
    // (undocumented)
    x?: number;
    // (undocumented)
    y?: number;
    // (undocumented)
    z?: number;
}

// @public
export interface IDrillEventContextGroup {
    // (undocumented)
    element: ChartElementType;
    // (undocumented)
    points: IDrillPoint[];
    // (undocumented)
    type: ChartType;
}

// @public
export interface IDrillEventContextHeadline {
    // (undocumented)
    element: HeadlineElementType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    type: HeadlineType;
    // (undocumented)
    value: string;
}

// @public
export interface IDrillEventContextPoint {
    // (undocumented)
    element: ChartElementType;
    // (undocumented)
    elementChartType?: ChartType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    type: ChartType;
    // (undocumented)
    value?: string;
    // (undocumented)
    x?: number;
    // (undocumented)
    y?: number;
    // (undocumented)
    z?: number;
}

// @public
export interface IDrillEventContextTable {
    // (undocumented)
    columnIndex: number;
    // (undocumented)
    element: TableElementType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    row: any[];
    // (undocumented)
    rowIndex: number;
    // (undocumented)
    type: TableType;
}

// @public
export interface IDrillEventContextXirr {
    // (undocumented)
    element: HeadlineElementType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    type: XirrType;
    // (undocumented)
    value: string;
}

// @public (undocumented)
export interface IDrillEventIntersectionElement {
    // (undocumented)
    header: DrillEventIntersectionElementHeader;
}

// @public (undocumented)
export interface IDrillIntersectionAttributeItem extends IAttributeDescriptor, IResultAttributeHeader {
}

// @public
export interface IDrillPoint {
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    type?: ChartType;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
}

// @public
export interface IErrorDescriptors {
    // (undocumented)
    [key: string]: {
        icon?: string;
        message: string;
        description: string;
    };
}

// @public
export interface IErrorProps {
    // (undocumented)
    className?: string;
    clientHeight?: any;
    // (undocumented)
    code?: string;
    // (undocumented)
    description?: string;
    height?: any;
    // (undocumented)
    icon?: string;
    // (undocumented)
    message: string;
    // (undocumented)
    style?: object;
    // (undocumented)
    width?: any;
}

// @public
export type IExecuteErrorComponent = ComponentType<IExecuteErrorComponentProps>;

// @public
export interface IExecuteErrorComponentProps {
    error: GoodDataSdkError;
}

// @public
export interface IExecuteInsightProps extends IWithLoadingEvents<IExecuteInsightProps> {
    backend?: IAnalyticalBackend;
    children: (executionResult: WithLoadingResult) => React_2.ReactElement | null;
    componentName?: string;
    dateFormat?: string | ((def: IExecutionDefinition, props: IExecuteInsightProps) => string);
    dimensions?: IDimension[] | ((def: IExecutionDefinition, props: IExecuteInsightProps) => IDimension[]);
    ErrorComponent?: IExecuteErrorComponent;
    executeByReference?: boolean;
    exportTitle?: string;
    filters?: INullableFilter[];
    insight: ObjRef;
    LoadingComponent?: IExecuteLoadingComponent;
    loadOnMount?: boolean;
    sorts?: ISortItem[] | ((def: IExecutionDefinition, props: IExecuteInsightProps) => ISortItem[]);
    window?: DataViewWindow;
    workspace?: string;
}

// @public
export type IExecuteLoadingComponent = ComponentType;

// @public
export interface IExecuteProps extends IWithLoadingEvents<IExecuteProps> {
    backend?: IAnalyticalBackend;
    children: (executionResult: WithLoadingResult) => React_2.ReactElement | null;
    componentName?: string;
    ErrorComponent?: IExecuteErrorComponent;
    exportTitle?: string;
    filters?: NullableFiltersOrPlaceholders;
    LoadingComponent?: IExecuteLoadingComponent;
    loadOnMount?: boolean;
    placeholdersResolutionContext?: any;
    seriesBy?: AttributesMeasuresOrPlaceholders;
    slicesBy?: AttributesOrPlaceholders;
    sortBy?: SortsOrPlaceholders;
    totals?: TotalsOrPlaceholders;
    window?: DataViewWindow;
    workspace?: string;
}

// @public
export interface IExecutionConfiguration {
    componentName?: string;
    filters?: NullableFiltersOrPlaceholders;
    placeholdersResolutionContext?: any;
    seriesBy: AttributesMeasuresOrPlaceholders;
    slicesBy?: AttributesOrPlaceholders;
    sortBy?: SortsOrPlaceholders;
    totals?: TotalsOrPlaceholders;
}

// @internal
export interface IExecutionDefinitionMethods {
    // (undocumented)
    attributes(): IAttribute[];
    bucket(localId: string): IBucket | undefined;
    // (undocumented)
    bucketCount(): number;
    bucketMeasures(localId: string): IMeasure[];
    // (undocumented)
    buckets(): IBucket[];
    // (undocumented)
    hasAttributes(): boolean;
    hasBuckets(): boolean;
    isBucketEmpty(localId: string): boolean;
    masterMeasureForDerived(localId: string): IMeasure | undefined;
    measure(localId: string): IMeasure | undefined;
    measureIndex(localId: string): number;
    // (undocumented)
    measures(): IMeasure[];
}

// @public (undocumented)
export type IExportFunction = (exportConfig: IExtendedExportConfig) => Promise<IExportResult>;

// @public (undocumented)
export interface IExtendedExportConfig extends IExportConfig {
    // (undocumented)
    includeFilterContext?: boolean;
}

// @internal
export function ignoreTitlesForSimpleMeasures<T extends IInsightDefinition>(insight: T): T;

// @public
export type IHeaderPredicate = (header: IMappingHeader, context: IHeaderPredicateContext) => boolean;

// @public
export interface IHeaderPredicateContext {
    // (undocumented)
    dv: DataViewFacade;
}

// @public (undocumented)
export interface IHighchartsCategoriesTree {
    // (undocumented)
    tick: IHighchartsParentTick;
}

// @public (undocumented)
export interface IHighchartsParentTick {
    // (undocumented)
    label: any;
    // (undocumented)
    leaves: number;
    // (undocumented)
    startAt: number;
}

// @internal (undocumented)
export interface IIntlWrapperProps {
    // (undocumented)
    children?: React_2.ReactNode;
    // (undocumented)
    locale?: string;
}

// @public
export interface IKpiProps extends IWithLoadingEvents<IRawExecuteProps> {
    backend?: IAnalyticalBackend;
    ErrorComponent?: React_2.ComponentType<IErrorProps>;
    filters?: INullableFilter[];
    LoadingComponent?: React_2.ComponentType<ILoadingProps>;
    locale?: string;
    measure: IMeasure;
    separators?: ISeparators;
    workspace?: string;
}

// @internal
export interface ILoadingInjectedProps {
    dataView?: IDataView;
    error?: string;
    // (undocumented)
    intl: IntlShape;
    isLoading: boolean;
    onDataTooLarge(data: any, errorMessage?: string): void;
    onExportReady(exportFunction: IExportFunction): void;
    onNegativeValues(): void;
}

// @public
export interface ILoadingProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    color?: string;
    // (undocumented)
    height?: any;
    // (undocumented)
    imageHeight?: any;
    // (undocumented)
    imageWidth?: any;
    // (undocumented)
    inline?: boolean;
    // (undocumented)
    speed?: number;
    // (undocumented)
    width?: any;
}

// @public (undocumented)
export interface ILoadingState {
    // (undocumented)
    isLoading: boolean;
}

// @public
export type ILocale = "en-US" | "de-DE" | "es-ES" | "fr-FR" | "ja-JP" | "nl-NL" | "pt-BR" | "pt-PT" | "zh-Hans" | "ru-RU" | "it-IT";

// @public (undocumented)
export type IMappingHeader = IAttributeDescriptor | IResultAttributeHeader | IMeasureDescriptor | ITotalDescriptor | IColorDescriptor;

// @internal
export interface IMeasureTitleProps {
    // (undocumented)
    alias?: string;
    // (undocumented)
    localIdentifier: string;
    // (undocumented)
    title?: string;
}

// @internal (undocumented)
export const IntlTranslationsProvider: React_2.FC<WithIntlProps<ITranslationsProviderProps>> & {
    WrappedComponent: React_2.ComponentType<ITranslationsProviderProps>;
};

// @internal (undocumented)
export const IntlWrapper: React_2.FC<IIntlWrapperProps>;

// @internal (undocumented)
export interface IOpenAsReportUiConfig {
    // (undocumented)
    supported?: boolean;
    // (undocumented)
    warningMessage?: string;
}

// @public
export type IPlaceholder<T> = {
    type: "IPlaceholder";
    id: string;
    defaultValue?: T;
    value?: T;
    validate?: (value: T) => void;
    use: IUsePlaceholderHook<IPlaceholder<T>>;
};

// @public
export interface IPlaceholderOptions<T> {
    id?: string;
    validate?: (value?: T) => void;
}

// @public
export interface IPlaceholdersProviderProps {
    // (undocumented)
    children: React_2.ReactNode;
    // (undocumented)
    initialValues?: [IPlaceholder<any>, any][];
}

// @internal
export interface IPushData {
    // (undocumented)
    availableDrillTargets?: IAvailableDrillTargets;
    // (undocumented)
    colors?: IColorsData;
    // (undocumented)
    dataView?: IDataView;
    // (undocumented)
    ignoreUndoRedo?: boolean;
    // (undocumented)
    initialProperties?: any;
    // (undocumented)
    openAsReport?: IOpenAsReportUiConfig;
    // (undocumented)
    properties?: {
        sortItems?: ISortItem[];
        totals?: ITotal[];
        controls?: Record<string, any>;
        bucketType?: string;
    };
    // (undocumented)
    propertiesMeta?: any;
}

// @public
export interface IRawExecuteProps extends IWithLoadingEvents<IRawExecuteProps> {
    children: (executionResult: WithLoadingResult) => React_2.ReactElement | null;
    ErrorComponent?: IExecuteErrorComponent;
    execution: IPreparedExecution;
    exportTitle?: string;
    LoadingComponent?: IExecuteLoadingComponent;
    loadOnMount?: boolean;
    window?: DataViewWindow;
}

// @internal
export interface IResultDataMethods {
    // (undocumented)
    columnTotals(): DataValue[][] | undefined;
    // (undocumented)
    data(): DataValue[][] | DataValue[];
    // (undocumented)
    dataAt(index: number): DataValue | DataValue[];
    // (undocumented)
    firstDimSize(): number;
    hasColumnTotals(): boolean;
    hasRowTotals(): boolean;
    hasTotals(): boolean;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    rowTotals(): DataValue[][] | undefined;
    // (undocumented)
    secondDimSize(): number;
    singleDimData(): DataValue[];
    // (undocumented)
    totalOfTotals(): DataValue[][][] | undefined;
    // (undocumented)
    totals(): DataValue[][][] | undefined;
    twoDimData(): DataValue[][];
}

// @internal
export interface IResultMetaMethods {
    // (undocumented)
    allHeaders(): IResultHeader[][][];
    // (undocumented)
    attributeDescriptors(): IAttributeDescriptor[];
    attributeDescriptorsForDim(dim: number): IAttributeDescriptor[];
    // (undocumented)
    attributeHeaders(): IResultAttributeHeader[][][];
    // (undocumented)
    attributeHeadersForDim(idx: number): IResultAttributeHeader[][];
    // (undocumented)
    dimensionItemDescriptors(dimIdx: number): IDimensionItemDescriptor[];
    // (undocumented)
    dimensions(): IDimensionDescriptor[];
    effectiveSortItems(): ISortItem[];
    hasNoHeadersInDim(dim: number): boolean;
    isDerivedMeasure(measureDescriptor: IMeasureDescriptor): boolean;
    isVirtualMeasure(measureDescriptor: IMeasureDescriptor): boolean;
    measureDescriptor(localId: string): IMeasureDescriptor | undefined;
    measureDescriptors(): IMeasureDescriptor[];
    // (undocumented)
    measureGroupDescriptor(): IMeasureGroupDescriptor | undefined;
}

// @public
export function isAnyPlaceholder<T>(obj: unknown): obj is AnyPlaceholder<T>;

// @public
export function isBadRequest(obj: unknown): obj is BadRequestSdkError;

// @internal (undocumented)
export const isCancelError: (obj: unknown) => obj is CancelError;

// @public
export function isCancelledSdkError(obj: unknown): obj is CancelledSdkError;

// @public
export function isComposedPlaceholder<TReturn, TValue extends any[], TContext>(obj: unknown): obj is IComposedPlaceholder<TReturn, TValue, TContext>;

// @public
export function isDataTooLargeToCompute(obj: unknown): obj is DataTooLargeToComputeSdkError;

// @public
export function isDataTooLargeToDisplay(obj: unknown): obj is DataTooLargeToDisplaySdkError;

// @public (undocumented)
export function isDrillableItem(item: unknown): item is IDrillableItem;

// @public (undocumented)
export function isDrillableItemIdentifier(item: unknown): item is IDrillableItemIdentifier;

// @public (undocumented)
export function isDrillableItemUri(item: unknown): item is IDrillableItemUri;

// @public (undocumented)
export function isDrillIntersectionAttributeItem(header: DrillEventIntersectionElementHeader): header is IDrillIntersectionAttributeItem;

// @public
export function isDynamicScriptLoadSdkError(obj: unknown): obj is DynamicScriptLoadSdkError;

export { ISeparators }

// @public (undocumented)
export function isExplicitDrill(obj: unknown): obj is ExplicitDrill;

// @public
export function isGeoLocationMissing(obj: unknown): obj is GeoLocationMissingSdkError;

// @public
export function isGeoTokenMissing(obj: unknown): obj is GeoTokenMissingSdkError;

// @public
export function isGoodDataSdkError(obj: unknown): obj is GoodDataSdkError;

// @public
export function isHeaderPredicate(obj: unknown): obj is IHeaderPredicate;

// @public
export const isLocale: (locale: unknown) => locale is ILocale;

// @public
export function isNegativeValues(obj: unknown): obj is NegativeValuesSdkError;

// @public
export function isNoDataSdkError(obj: unknown): obj is NoDataSdkError;

// @public
export function isNotFound(obj: unknown): obj is NotFoundSdkError;

// @public
export function isPlaceholder<T>(obj: unknown): obj is IPlaceholder<T>;

// @public
export function isProtectedReport(obj: unknown): obj is ProtectedReportSdkError;

// @internal (undocumented)
export function isSomeHeaderPredicateMatched(drillablePredicates: IHeaderPredicate[], header: IMappingHeader, dv: DataViewFacade): boolean;

// @public
export function isUnauthorized(obj: unknown): obj is UnauthorizedSdkError;

// @public
export function isUnknownSdkError(obj: unknown): obj is UnexpectedSdkError;

// @internal (undocumented)
export interface ITranslations {
    // (undocumented)
    [key: string]: string;
}

// @internal (undocumented)
export interface ITranslationsComponentProps {
    // (undocumented)
    emptyHeaderString: string;
    // (undocumented)
    intl: IntlShape;
    // (undocumented)
    numericSymbols: string[];
}

// @beta (undocumented)
export interface ITranslationsCustomizationContextProviderProps {
    children?: React_2.ReactNode;
    translations: Record<string, string>;
    translationsCustomizationIsLoading: boolean;
}

// @beta (undocumented)
export interface ITranslationsCustomizationProviderProps {
    backend?: IAnalyticalBackend;
    customize?(translations: Record<string, string>, settings?: IWorkspaceSettings): Record<string, string>;
    render(translations: Record<string, string>): JSX.Element;
    translations: Record<string, string>;
    workspace?: string;
}

// @internal (undocumented)
export interface ITranslationsProviderOwnProps {
    // (undocumented)
    children: any;
}

// @internal (undocumented)
export type ITranslationsProviderProps = ITranslationsProviderOwnProps & WrappedComponentProps;

// @public
export type IUseComposedPlaceholderHook<T extends IComposedPlaceholder<any, any, any>> = (resolutionContext: ComposedPlaceholderResolutionContext<T>) => PlaceholderResolvedValue<T>;

// @public
export interface IUseExecutionDataViewConfig {
    backend?: IAnalyticalBackend;
    execution?: IPreparedExecution | IExecutionConfiguration;
    window?: DataViewWindow;
    workspace?: string;
}

// @public
export interface IUseInsightDataViewConfig {
    backend?: IAnalyticalBackend;
    dateFormat?: string | ((def: IExecutionDefinition) => string);
    dimensions?: IDimension[] | ((def: IExecutionDefinition) => IDimension[]);
    executeByReference?: boolean;
    filters?: INullableFilter[];
    insight?: ObjRef;
    sorts?: ISortItem[] | ((def: IExecutionDefinition) => ISortItem[]);
    window?: DataViewWindow;
    workspace?: string;
}

// @public (undocumented)
export interface IUsePagedResourceResult<TItem> extends IUsePagedResourceState<TItem> {
    // (undocumented)
    isLoading: boolean;
}

// @public (undocumented)
export interface IUsePagedResourceState<TItem> {
    // (undocumented)
    items: Array<TItem | undefined>;
    // (undocumented)
    totalItemsCount: number | undefined;
}

// @public
export type IUsePlaceholderHook<T extends IPlaceholder<any>> = () => [
PlaceholderValue<T> | undefined,
(valueOrUpdateCallback: ValueOrUpdateCallback<PlaceholderValue<T> | undefined>) => void
];

// @public
export interface IVisualizationCallbacks {
    // @internal (undocumented)
    afterRender?: () => void;
    onDrill?: OnFiredDrillEvent;
    onError?: OnError;
    onExportReady?: OnExportReady;
    onLoadingChanged?: OnLoadingChanged;
    // @internal (undocumented)
    pushData?: (data: IPushData) => void;
}

// @public
export interface IVisualizationProps {
    drillableItems?: ExplicitDrill[];
    ErrorComponent?: React_2.ComponentType<IErrorProps>;
    exportTitle?: string;
    LoadingComponent?: React_2.ComponentType<ILoadingProps>;
    locale?: string;
}

// @internal
export interface IWithExecution<T> {
    events?: IWithLoadingEvents<T> | ((props: T) => IWithLoadingEvents<T>);
    execution: IPreparedExecution | ((props: T) => IPreparedExecution) | ((props: T) => Promise<IPreparedExecution>);
    exportTitle: string | ((props: T) => string);
    loadOnMount?: boolean | ((props: T) => boolean);
    shouldRefetch?: (prevProps: T, nextProps: T) => boolean;
    window?: DataViewWindow | ((props: T) => DataViewWindow | undefined);
}

// @internal
export interface IWithExecutionLoading<TProps> {
    events?: IWithLoadingEvents<TProps> | ((props: TProps) => IWithLoadingEvents<TProps>);
    exportTitle: string | ((props: TProps) => string);
    loadOnMount?: boolean | ((props: TProps) => boolean);
    promiseFactory: (props: TProps, window?: DataViewWindow) => Promise<DataViewFacade>;
    shouldRefetch?: (prevProps: TProps, nextProps: TProps) => boolean;
    window?: DataViewWindow | ((props: TProps) => DataViewWindow | undefined);
}

// @public (undocumented)
export interface IWithLoadingEvents<TProps> {
    onError?: (error: GoodDataSdkError, props: TProps) => void;
    onExportReady?: (exportFunction: IExportFunction, props: TProps) => void;
    onLoadingChanged?: (isLoading: boolean, props: TProps) => void;
    onLoadingFinish?: (result: DataViewFacade, props: TProps) => void;
    onLoadingStart?: (props: TProps) => void;
}

// @public
export interface IWorkspaceProviderProps {
    children?: React_2.ReactNode;
    workspace: string;
}

// @public
export const Kpi: React_2.ComponentType<IKpiProps>;

// @public
export class LoadingComponent extends React_2.Component<ILoadingProps> {
    // (undocumented)
    static defaultProps: Partial<ILoadingProps>;
    // (undocumented)
    render(): React_2.JSX.Element;
}

// @internal
export const LOCALES: string[];

// @public
export function localIdentifierMatch(localIdOrMeasure: string | IMeasure): IHeaderPredicate;

// @internal
export function makeCancelable<T>(promise: Promise<T>): ICancelablePromise<T>;

// @public
export type MeasureOf<T extends IMeasureDefinitionType> = T extends any ? IMeasure<T> : never;

// @public
export type MeasureOrPlaceholder = ValueOrPlaceholder<AnyMeasure>;

// @public
export type MeasuresOrPlaceholders = ValuesOrPlaceholders<AnyMeasure>;

// @internal (undocumented)
export const messages: Record<string, MessageDescriptor>;

// @internal (undocumented)
export const messagesMap: {
    [locale: string]: ITranslations;
};

// @public
export class NegativeValuesSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export function newComposedPlaceholder<TValue extends any[], TReturn = PlaceholdersResolvedValues<TValue>, TContext = UnionToIntersection<ComposedPlaceholderResolutionContext<Flatten<TValue>>>>(placeholders: [...TValue], computeValue?: (values: PlaceholdersResolvedValues<TValue>, resolutionContext: TContext) => TReturn): IComposedPlaceholder<TReturn, TValue, TContext>;

// @public
export function newErrorMapping(intl: IntlShape): IErrorDescriptors;

// @public
export function newPlaceholder<T>(defaultValue?: T, options?: IPlaceholderOptions<T>): IPlaceholder<T>;

// @public
export class NoDataSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class NotFoundSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export type NullableFilterOrPlaceholder = FilterOrPlaceholder | ValueOrPlaceholder<INullableFilter> | ValueOrPlaceholder<IFilter | null> | ValueOrPlaceholder<IDateFilter | null> | ValueOrPlaceholder<IMeasureFilter | null> | ValueOrPlaceholder<IAttributeFilter | null> | ValueOrPlaceholder<IAbsoluteDateFilter | null> | ValueOrPlaceholder<IRelativeDateFilter | null> | ValueOrPlaceholder<IPositiveAttributeFilter | null> | ValueOrPlaceholder<INegativeAttributeFilter | null> | ValueOrPlaceholder<IMeasureValueFilter | null> | ValueOrPlaceholder<IRankingFilter | null>;

// @public
export type NullableFiltersOrPlaceholders = Array<FilterOrMultiValuePlaceholder | ValueOrMultiValuePlaceholder<INullableFilter> | ValueOrMultiValuePlaceholder<IFilter | null> | ValueOrMultiValuePlaceholder<IDateFilter | null> | ValueOrMultiValuePlaceholder<IMeasureFilter | null> | ValueOrMultiValuePlaceholder<IAttributeFilter | null> | ValueOrMultiValuePlaceholder<IAbsoluteDateFilter | null> | ValueOrMultiValuePlaceholder<IRelativeDateFilter | null> | ValueOrMultiValuePlaceholder<IPositiveAttributeFilter | null> | ValueOrMultiValuePlaceholder<INegativeAttributeFilter | null> | ValueOrMultiValuePlaceholder<IMeasureValueFilter | null> | ValueOrMultiValuePlaceholder<IRankingFilter | null>>;

// @public
export function objMatch(obj: any): IHeaderPredicate;

// @public
export function objRefMatch(objRef: ObjRef): IHeaderPredicate;

// @public (undocumented)
export type OnError = (error: GoodDataSdkError) => void;

// @public (undocumented)
export type OnExportReady = (exportFunction: IExportFunction) => void;

// @public (undocumented)
export type OnFiredDrillEvent = IDrillEventCallback;

// @public (undocumented)
export type OnLoadingChanged = (loadingState: ILoadingState) => void;

// @internal (undocumented)
export type OverTimeComparisonType = "same_period_previous_year" | "previous_period" | "nothing";

// @internal (undocumented)
export const OverTimeComparisonTypes: {
    SAME_PERIOD_PREVIOUS_YEAR: "same_period_previous_year";
    PREVIOUS_PERIOD: "previous_period";
    NOTHING: "nothing";
};

// @beta (undocumented)
export const pickCorrectInsightWording: (translations: Record<string, string>, settings?: IWorkspaceSettings) => Record<string, string>;

// @beta
export const pickCorrectMetricWording: (translations: Record<string, string>, settings?: IWorkspaceSettings) => Record<string, string>;

// @beta (undocumented)
export const pickCorrectWording: (translations: Record<string, string>, settings?: IWorkspaceSettings) => Record<string, string>;

// @public
export type PlaceholderOf<T> = T extends any ? AnyPlaceholder<T> : never;

// @public
export type PlaceholderResolvedValue<T> = T extends Array<infer A> ? Flatten<PlaceholderResolvedValue<A>>[] : T extends IPlaceholder<infer B> ? B : T extends IComposedPlaceholder<infer C, any, any> ? C : T;

// @public
export function PlaceholdersProvider(props: IPlaceholdersProviderProps): JSX.Element;

// @public
export type PlaceholdersResolvedValues<Tuple extends any[]> = {
    [Index in keyof Tuple]: PlaceholderResolvedValue<Tuple[Index]>;
};

// @public
export type PlaceholdersValues<Tuple extends [...any[]]> = {
    [Index in keyof Tuple]: PlaceholderValue<Tuple[Index]>;
};

// @public
export type PlaceholderValue<T> = T extends IPlaceholder<infer A> ? A : T extends IComposedPlaceholder<infer B, any, any> ? B : T;

// @public
export class ProtectedReportSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal (undocumented)
export type PushDataCallback = (data: IPushData) => void;

// @public
export const RawExecute: React_2.ComponentClass<IRawExecuteProps, any>;

// @beta (undocumented)
export const removeAllInsightToReportTranslations: (translations: Record<string, string>) => Record<string, string>;

// @beta
export const removeAllWordingTranslationsWithSpecialSuffix: (translations: Record<string, string>) => Record<string, string>;

// @alpha
export const ResolvedClientWorkspaceProvider: React_2.FC<IClientWorkspaceIdentifiers>;

// @alpha
export function resolveLCMWorkspaceIdentifiers(backend: any, { client, dataProduct, workspace }: IClientWorkspaceIdentifiers): Promise<IClientWorkspaceIdentifiers>;

// @internal
export const resolveLocale: (locale: unknown) => ILocale;

// @public
export function resolveUseCancelablePromisesError<TError>(states: UseCancelablePromiseState<unknown, TError>[]): TError | undefined;

// @public
export function resolveUseCancelablePromisesStatus(cancelablePromisesStates: UseCancelablePromiseState<unknown, unknown>[], options?: {
    strategy?: "serial" | "parallel";
}): UseCancelablePromiseStatus;

// @public (undocumented)
export type SdkErrorType = keyof typeof ErrorCodes;

// @public
export type SortsOrPlaceholders = ValuesOrPlaceholders<ISortItem>;

// @internal (undocumented)
export type Subtract<T, K> = Pick<T, Exclude<keyof T, keyof K>>;

// @public (undocumented)
export type TableElementType = "cell";

// @public (undocumented)
export type TableType = "table";

// @internal
export function totalColumnTitleFromIntl(intl: IntlShape): string;

// @public
export type TotalsOrPlaceholders = ValuesOrPlaceholders<ITotal>;

// @beta (undocumented)
export const TranslationsCustomizationContextProvider: React_2.FC<ITranslationsCustomizationContextProviderProps>;

// @beta
export const TranslationsCustomizationProvider: React_2.FC<ITranslationsCustomizationProviderProps>;

// @internal (undocumented)
export class TranslationsProvider extends React_2.PureComponent<ITranslationsProviderProps> {
    // (undocumented)
    render(): any;
}

// @public
export class UnauthorizedSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
    // (undocumented)
    authenticationFlow?: AuthenticationFlow;
}

// @public
export class UnexpectedSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;

// @public
export function uriMatch(uri: string): IHeaderPredicate;

// @public
export const useBackend: (backend?: IAnalyticalBackend) => IAnalyticalBackend | undefined;

// @public
export const useBackendStrict: (backend?: IAnalyticalBackend, context?: string) => IAnalyticalBackend;

// @public
export function useCancelablePromise<TResult, TError = any>(options: UseCancelablePromiseOptions<TResult, TError>, deps?: DependencyList): UseCancelablePromiseState<TResult, TError>;

// @public
export type UseCancelablePromiseCallbacks<TResult, TError> = {
    onLoading?: () => void;
    onPending?: () => void;
    onCancel?: () => void;
    onSuccess?: (result: TResult) => void;
    onError?: (err: TError) => void;
};

// @public
export type UseCancelablePromiseErrorState<TError> = {
    result: undefined;
    error: TError;
    status: "error";
};

// @public
export type UseCancelablePromiseLoadingState = {
    result: undefined;
    error: undefined;
    status: "loading";
};

// @public
export type UseCancelablePromiseOptions<TResult, TError> = UseCancelablePromiseCallbacks<TResult, TError> & {
    promise: (() => Promise<TResult>) | undefined | null;
};

// @public
export type UseCancelablePromisePendingState = {
    result: undefined;
    error: undefined;
    status: "pending";
};

// @public
export type UseCancelablePromiseState<TResult, TError> = UseCancelablePromisePendingState | UseCancelablePromiseLoadingState | UseCancelablePromiseErrorState<TError> | UseCancelablePromiseSuccessState<TResult>;

// @public
export type UseCancelablePromiseStatus = "success" | "error" | "loading" | "pending";

// @public
export type UseCancelablePromiseSuccessState<TResult> = {
    result: TResult;
    error: undefined;
    status: "success";
};

// @alpha
export const useClientWorkspaceError: () => GoodDataSdkError | undefined;

// @alpha
export const useClientWorkspaceIdentifiers: () => IClientWorkspaceIdentifiers;

// @alpha
export const useClientWorkspaceInitialized: () => boolean;

// @alpha
export const useClientWorkspaceStatus: () => UseCancelablePromiseStatus;

// @public
export function useComposedPlaceholder<TContext, TPlaceholder extends IComposedPlaceholder<any, any, TContext>>(placeholder: TPlaceholder, resolutionContext?: TContext): PlaceholderResolvedValue<TPlaceholder>;

// @public
export function useDataExport({ execution, exportConfig, onCancel, onError, onLoading, onPending, onSuccess, }: {
    execution: IPreparedExecution | undefined | null;
    exportConfig?: IExportConfig;
} & UseDataExportCallbacks, deps?: DependencyList): UseDataExportState;

// @public
export type UseDataExportCallbacks = UseCancelablePromiseCallbacks<string, GoodDataSdkError>;

// @public
export type UseDataExportState = UseCancelablePromiseState<string, GoodDataSdkError>;

// @public
export function useExecutionDataView(config: IUseExecutionDataViewConfig & UseExecutionDataViewCallbacks, deps?: React.DependencyList): UseCancelablePromiseState<DataViewFacade, GoodDataSdkError>;

// @public
export type UseExecutionDataViewCallbacks = UseCancelablePromiseCallbacks<DataViewFacade, GoodDataSdkError>;

// @public
export function useInsightDataView(config: IUseInsightDataViewConfig & UseInsightDataViewCallbacks, deps?: React.DependencyList): UseCancelablePromiseState<DataViewFacade, GoodDataSdkError>;

// @public
export type UseInsightDataViewCallbacks = UseCancelablePromiseCallbacks<DataViewFacade, GoodDataSdkError>;

// @public
export function usePagedResource<TParams, TItem>(resourceFactory: (params: TParams) => Promise<IPagedResource<TItem>>, fetchParams: TParams[], fetchDeps: React.DependencyList, resetDeps: React.DependencyList, getCacheKey?: (params: TParams) => string, initialState?: IUsePagedResourceState<TItem>, preventResetPromises?: boolean): IUsePagedResourceResult<TItem>;

// @public
export function usePlaceholder<T extends IPlaceholder<any>>(placeholder?: T): [
PlaceholderValue<T> | undefined,
(valueOrUpdateCallback: ValueOrUpdateCallback<PlaceholderValue<T> | undefined>) => void
];

// @public
export function usePlaceholders<T extends IPlaceholder<any>[]>(placeholders: [...T]): [PlaceholdersValues<T>, (valueOrUpdateCallback: ValueOrUpdateCallback<PlaceholdersValues<T>>) => void];

// @internal
export const usePrevious: <T>(props: T) => T;

// @public
export function useResolveValuesWithPlaceholders<T extends any[], C>(values: [...T], resolutionContext?: C): PlaceholdersResolvedValues<T>;

// @public
export function useResolveValueWithPlaceholders<T, C>(value: T, resolutionContext?: C): PlaceholderResolvedValue<T>;

// @public
export const useWorkspace: (workspace?: string) => string | undefined;

// @public
export const useWorkspaceStrict: (workspace?: string, context?: string) => string;

// @public (undocumented)
export type ValueFormatter = (value: DataValue, format: string) => string;

// @public (undocumented)
export type ValueOrMultiValuePlaceholder<T> = ValueOrPlaceholder<T> | AnyPlaceholderOf<T[]>;

// @public
export type ValueOrPlaceholder<T> = T | AnyPlaceholderOf<T>;

// @public
export type ValuesOrPlaceholders<T> = AnyArrayOf<ValueOrMultiValuePlaceholder<T>>;

// @public (undocumented)
export type VisElementType = ChartElementType | HeadlineElementType | TableElementType | "pushpin";

// @public (undocumented)
export type VisType = ChartType | HeadlineType | TableType | XirrType;

// @internal (undocumented)
export type VisualizationEnvironment = "none" | "dashboards" | "analyticalDesigner";

// @internal (undocumented)
export function visualizationIsBetaWarning(): void;

// @internal (undocumented)
export const VisualizationTypes: {
    BAR: "bar";
    COLUMN: "column";
    LINE: "line";
    PIE: "pie";
    DONUT: "donut";
    TABLE: "table";
    HEADLINE: "headline";
    AREA: "area";
    SCATTER: "scatter";
    BUBBLE: "bubble";
    HEATMAP: "heatmap";
    GEO: "geo";
    PUSHPIN: "pushpin";
    COMBO: "combo";
    COMBO2: "combo2";
    HISTOGRAM: "histogram";
    BULLET: "bullet";
    TREEMAP: "treemap";
    WATERFALL: "waterfall";
    FUNNEL: "funnel";
    PYRAMID: "pyramid";
    PARETO: "pareto";
    ALLUVIAL: "alluvial";
    SANKEY: "sankey";
    DEPENDENCY_WHEEL: "dependencywheel";
    XIRR: "xirr";
    REPEATER: "repeater";
};

// @internal
export function withBackend<T extends {
    backend?: IAnalyticalBackend;
}>(Component: React_2.ComponentType<T>): React_2.ComponentType<T>;

// @internal
export function withContexts<T extends {
    backend?: IAnalyticalBackend;
    workspace?: string;
}>(Chart: React.ComponentType<T>): React.ComponentType<T>;

// @internal
export function withEntireDataView<T extends IDataVisualizationProps>(InnerComponent: React_2.ComponentClass<T & ILoadingInjectedProps>): React_2.ComponentClass<T>;

// @internal
export function withExecution<T>(params: IWithExecution<T>): (WrappedComponent: React.ComponentType<T & WithLoadingResult>) => React.ComponentClass<T, any>;

// @internal
export function withExecutionLoading<TProps>(params: IWithExecutionLoading<TProps>): (WrappedComponent: React_2.ComponentType<TProps & WithLoadingResult>) => React_2.ComponentClass<TProps>;

// @internal (undocumented)
export function withIntl<P>(WrappedComponent: React_2.FC<P> | React_2.ComponentClass<P>, customLocale?: ILocale, customMessages?: ITranslations): React_2.ComponentType<P>;

// @public (undocumented)
export type WithLoadingResult = {
    result: DataViewFacade | undefined;
    error: GoodDataSdkError | undefined;
    isLoading: boolean;
    reload: () => void;
};

// @beta (undocumented)
export function withTranslationsCustomization<T>(Component: React_2.ComponentType<T>): React_2.ComponentType<Omit<T, "translationsCustomizationIsLoading" | "translations">>;

// @internal
export function withWorkspace<T extends {
    workspace?: string;
}>(Component: React_2.ComponentType<T>): React_2.ComponentType<T>;

// @public
export const WorkspaceProvider: React_2.FC<IWorkspaceProviderProps>;

// @internal
export const wrapDisplayName: (hocName: string, BaseComponent?: React.ComponentType<any>) => <T>(Component: ComponentType<T>) => ComponentType<T>;

// @public (undocumented)
export type XirrType = "xirr";

```
