## API Report File for "@gooddata/sdk-ui"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AttributeDisplayFormType } from '@gooddata/sdk-model';
import { AuthenticationFlow } from '@gooddata/sdk-backend-spi';
import { ComponentClass } from 'react';
import { ComponentType } from 'react';
import { DataValue } from '@gooddata/sdk-model';
import { DependencyList } from 'react';
import { Dispatch } from 'react';
import { FC } from 'react';
import { ForecastDataValue } from '@gooddata/sdk-model';
import { IAbsoluteDateFilter } from '@gooddata/sdk-model';
import { IAnalyticalBackend } from '@gooddata/sdk-backend-spi';
import { IAttribute } from '@gooddata/sdk-model';
import { IAttributeDescriptor } from '@gooddata/sdk-model';
import { IAttributeFilter } from '@gooddata/sdk-model';
import { IAttributeOrMeasure } from '@gooddata/sdk-model';
import { IBucket } from '@gooddata/sdk-model';
import { IClusteringConfig } from '@gooddata/sdk-backend-spi';
import { ICollectionItemsResult } from '@gooddata/sdk-backend-spi';
import { IColor } from '@gooddata/sdk-model';
import { IColorDescriptor } from '@gooddata/sdk-model';
import { IColorPalette } from '@gooddata/sdk-model';
import { IDataView } from '@gooddata/sdk-backend-spi';
import { IDateFilter } from '@gooddata/sdk-model';
import { IDimension } from '@gooddata/sdk-model';
import { IDimensionDescriptor } from '@gooddata/sdk-model';
import { IDimensionItemDescriptor } from '@gooddata/sdk-model';
import { IExecutionContext } from '@gooddata/sdk-backend-spi';
import { IExecutionDefinition } from '@gooddata/sdk-model';
import { IExecutionResult } from '@gooddata/sdk-backend-spi';
import { IExecutionResultDataSourceMessage } from '@gooddata/sdk-backend-spi';
import { IExportConfig } from '@gooddata/sdk-backend-spi';
import { IExportResult } from '@gooddata/sdk-backend-spi';
import { IFilter } from '@gooddata/sdk-model';
import { IForecastConfig } from '@gooddata/sdk-backend-spi';
import { IInsightDefinition } from '@gooddata/sdk-model';
import { IMeasure } from '@gooddata/sdk-model';
import { IMeasureDefinitionType } from '@gooddata/sdk-model';
import { IMeasureDescriptor } from '@gooddata/sdk-model';
import { IMeasureFilter } from '@gooddata/sdk-model';
import { IMeasureGroupDescriptor } from '@gooddata/sdk-model';
import { IMeasureValueFilter } from '@gooddata/sdk-model';
import { INegativeAttributeFilter } from '@gooddata/sdk-model';
import { IntlShape } from 'react-intl';
import { INullableFilter } from '@gooddata/sdk-model';
import { IOutliersConfig } from '@gooddata/sdk-backend-spi';
import { IPagedResource } from '@gooddata/sdk-backend-spi';
import { IPositiveAttributeFilter } from '@gooddata/sdk-model';
import { IPreparedExecution } from '@gooddata/sdk-backend-spi';
import { IRankingFilter } from '@gooddata/sdk-model';
import { IRelativeDateFilter } from '@gooddata/sdk-model';
import { IRequestCorrelationMetadata } from '@gooddata/sdk-backend-spi';
import { IResultAttributeHeader } from '@gooddata/sdk-model';
import { IResultAttributeHeaderItem } from '@gooddata/sdk-model';
import { IResultHeader } from '@gooddata/sdk-model';
import { IResultMeasureHeader } from '@gooddata/sdk-model';
import { IResultTotalHeader } from '@gooddata/sdk-model';
import { IResultWarning } from '@gooddata/sdk-model';
import { ISeparators } from '@gooddata/sdk-model';
import { ISortItem } from '@gooddata/sdk-model';
import { ITotal } from '@gooddata/sdk-model';
import { ITotalDescriptor } from '@gooddata/sdk-model';
import { JSX } from 'react/jsx-runtime';
import { MessageDescriptor } from 'react-intl';
import { MutableRefObject } from 'react';
import { NamedExoticComponent } from 'react';
import { ObjRef } from '@gooddata/sdk-model';
import { PropsWithoutRef } from 'react';
import { ReactElement } from 'react';
import { ReactNode } from 'react';
import { Ref } from 'react';
import { RefAttributes } from 'react';
import { RefObject } from 'react';
import { SetStateAction } from 'react';
import { TotalType } from '@gooddata/sdk-model';
import { ValueOrUpdateCallback } from '@gooddata/sdk-backend-base';
import { WithIntlProps } from 'react-intl';
import { WrappedComponentProps } from 'react-intl';

// @internal
export function anomaliesTitleFromIntl(intl: IntlShape): string;

// @public
export type AnyArrayOf<T> = T[] | ArrayOf<T>;

// @public
export type AnyMeasure = IMeasure | MeasureOf<IMeasureDefinitionType>;

// @public
export type AnyPlaceholder<T = any> = IPlaceholder<T> | IComposedPlaceholder<T, any, any>;

// @public
export type AnyPlaceholderOf<T> = AnyPlaceholder<T> | PlaceholderOf<T>;

// @internal
export class ArithmeticMeasureTitleFactory {
    constructor(locale: ILocale, messages: Record<string, string>);
    getTitle(arithmeticMeasureProps: IArithmeticMeasureTitleProps, measureTitleProps: IMeasureTitleProps[]): string | null;
}

// @public
export type ArrayOf<T> = T extends any ? T[] : never;

// @public
export type AttributeFilterOrPlaceholder = ValueOrPlaceholder<IAttributeFilter> | ValueOrPlaceholder<IPositiveAttributeFilter> | ValueOrPlaceholder<INegativeAttributeFilter>;

// @public
export type AttributeFiltersOrPlaceholders = Array<ValueOrMultiValuePlaceholder<IAttributeFilter> | ValueOrMultiValuePlaceholder<IPositiveAttributeFilter> | ValueOrMultiValuePlaceholder<INegativeAttributeFilter>>;

// @public
export function attributeItemNameMatch(name: string): IHeaderPredicate;

// @public
export type AttributeMeasureOrPlaceholder = ValueOrPlaceholder<IAttribute | AnyMeasure> | ValueOrPlaceholder<IAttribute> | ValueOrPlaceholder<AnyMeasure>;

// @public
export type AttributeOrPlaceholder = ValueOrPlaceholder<IAttribute>;

// @public
export type AttributesMeasuresOrPlaceholders = Array<ValueOrMultiValuePlaceholder<IAttribute | AnyMeasure> | ValueOrMultiValuePlaceholder<IAttribute> | ValueOrMultiValuePlaceholder<AnyMeasure>>;

// @public
export type AttributesOrPlaceholders = ValuesOrPlaceholders<IAttribute>;

// @public
export function BackendProvider({ children, backend }: IBackendProviderProps): JSX.Element;

// @public
export function BackendProviderWithCorrelation({ backend: externalBackend, correlationData, children, }: IBackendProviderWithCorrelationProps): JSX.Element;

// @public
export class BadRequestSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal (undocumented)
export type BucketNameKeys = keyof typeof BucketNames;

// @internal
export const BucketNames: {
    readonly MEASURES: "measures";
    readonly SECONDARY_MEASURES: "secondary_measures";
    readonly TERTIARY_MEASURES: "tertiary_measures";
    readonly ATTRIBUTE: "attribute";
    readonly ATTRIBUTES: "attributes";
    readonly ATTRIBUTE_FROM: "attribute_from";
    readonly ATTRIBUTE_TO: "attribute_to";
    readonly VIEW: "view";
    readonly STACK: "stack";
    readonly TREND: "trend";
    readonly SEGMENT: "segment";
    readonly COLUMNS: "columns";
    readonly LOCATION: "location";
    readonly AREA: "area";
    readonly LONGITUDE: "longitude";
    readonly LATITUDE: "latitude";
    readonly SIZE: "size";
    readonly COLOR: "color";
    readonly TOOLTIP_TEXT: "tooltipText";
};

// @internal (undocumented)
export type BucketNameValues = (typeof BucketNames)[BucketNameKeys];

// @internal (undocumented)
export const buildAutomationUrl: IAutomationUrlBuilder;

// @internal (undocumented)
export const buildDashboardUrl: IDashboardUrlBuilder;

// @internal (undocumented)
export const buildWidgetUrl: IWidgetUrlBuilder;

// @internal (undocumented)
export class CancelError extends Error {
    constructor(reason?: string | undefined);
    getReason(): string | undefined;
    // (undocumented)
    reason?: string | undefined;
}

// @public
export class CancelledSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public (undocumented)
export type ChartElementType = "slice" | "bar" | "point" | "label" | "cell" | "target" | "primary" | "comparative";

// @public (undocumented)
export type ChartType = "bar" | "column" | "pie" | "line" | "area" | "donut" | "scatter" | "bubble" | "heatmap" | "geo" | "pushpin" | "choropleth" | "combo" | "combo2" | "histogram" | "bullet" | "treemap" | "waterfall" | "funnel" | "pyramid" | "pareto" | "alluvial" | "sankey" | "dependencywheel" | "repeater";

// @alpha
export function ClientWorkspaceProvider(props: IClientWorkspaceProviderProps): JSX.Element;

// @public
export class ClusteringNotReceivedSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal
export function clusterTitleFromIntl(intl: IntlShape): string;

// @alpha (undocumented)
export type CollectionItemsRequestOptions = {
    collectionId: string;
    limit?: number;
    bbox?: string;
    datetime?: string;
};

// @public
export function composedFromIdentifier(identifier: string): IHeaderPredicate;

// @public
export function composedFromUri(uri: string): IHeaderPredicate;

// @public
export type ComposedPlaceholderResolutionContext<T> = T extends IComposedPlaceholder<any, any, infer TContext> ? TContext : any;

// @public
export function compressForUrl<T>(data: T): string;

// @internal
export function convertDataWindowError(error: unknown): GoodDataSdkError;

// @public (undocumented)
export function convertDrillableItemsToPredicates(drillableItems: ExplicitDrill[] | undefined): IHeaderPredicate[];

// @public
export function convertError(error: unknown): GoodDataSdkError;

// @public
export function CorrelationProvider({ children, correlationData }: ICorrelationProviderProps): JSX.Element;

// @internal
export const createContextStore: <T>(name: string) => IContextStore<T>;

// @internal
export function createExportErrorFunction(error: GoodDataSdkError): IExportFunction;

// @internal
export function createExportFunction(result: IExecutionResult, exportTitle?: string): IExportFunction;

// @internal (undocumented)
export function createFocusHighchartsDatapointEvent(detail: IFocusHighchartsDatapointEventDetail): CustomEvent<IFocusHighchartsDatapointEventDetail>;

// @internal (undocumented)
export function createIntlMock(customMessages?: {}, locale?: string): IntlShape;

// @internal (undocumented)
export const createInvalidDatapoint: (input?: Partial<IInvalidDatapoint>) => {
    id: string;
    severity: IValidationSeverity;
    message: string;
};

// @internal (undocumented)
export function createInvalidNode(): IInvalidNode<Record<string, never>>;

// @internal (undocumented)
export function createInvalidNode<T extends Record<string, IInvalidNode<any>>>(input: Partial<IInvalidNode<T>> & {
    children: T;
}): IInvalidNode<T>;

// @internal (undocumented)
export function createInvalidNode<T extends Record<string, IInvalidNode<any>> = Record<string, never>>(input?: Partial<IInvalidNode<T>>): IInvalidNode<T>;

// @public
export function createNumberJsFormatter(separators?: ISeparators): ValueFormatter;

// @public (undocumented)
export type DataAccessConfig = {
    valueFormatter: ValueFormatter;
    headerTranslator?: HeaderTranslator;
};

// @public
export type DataPoint = {
    readonly rawValue: DataValue;
    formattedValue(): null | string;
    readonly formatable: boolean;
    readonly coordinates: DataPointCoordinates;
    readonly seriesDesc: DataSeriesDescriptor;
    readonly sliceDesc?: DataSliceDescriptor;
    readonly total?: boolean;
};

// @public (undocumented)
export type DataPointCoordinates = number[];

// @public
export type DataSeriesDescriptor = DataSeriesHeaders & DataSeriesDescriptorMethods & {
    readonly id: DataSeriesId;
    readonly measureDescriptor: IMeasureDescriptor;
    readonly measureDefinition: IMeasure;
    readonly attributeDescriptors?: IAttributeDescriptor[];
    readonly attributeDefinitions?: IAttribute[];
    readonly isSubtotal?: boolean;
    readonly isTotal?: boolean;
};

// @public (undocumented)
export type DataSeriesDescriptorMethods = {
    measureTitle(): string;
    measureFormat(): string;
    scopeTitles(): Array<string | null>;
};

// @public (undocumented)
export type DataSeriesHeaders = {
    readonly measureHeader: IResultMeasureHeader;
    readonly attributeHeaders?: IResultAttributeHeader[];
};

// @public (undocumented)
export type DataSeriesId = string;

// @public
export type DataSliceDescriptor = DataSliceHeaders & DataSliceDescriptorMethods & {
    readonly id: DataSliceId;
    readonly descriptors: IAttributeDescriptor[];
    readonly definitions: IAttribute[];
};

// @public (undocumented)
export type DataSliceDescriptorMethods = {
    readonly sliceTitles: () => Array<string | null>;
};

// @public
export type DataSliceHeaders = {
    readonly headers: Array<IResultAttributeHeader | IResultTotalHeader>;
    readonly isTotal?: boolean;
};

// @public (undocumented)
export type DataSliceId = string;

// @public
export class DataTooLargeToComputeSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class DataTooLargeToDisplaySdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class DataViewFacade {
    protected constructor(dataView: IDataView);
    // (undocumented)
    context(): IExecutionContext | undefined;
    // (undocumented)
    data(config?: DataAccessConfig): IDataAccessMethods;
    // @alpha
    dataSourceMessages(): ReadonlyArray<IExecutionResultDataSourceMessage>;
    // (undocumented)
    readonly dataView: IDataView;
    // @internal (undocumented)
    def(): IExecutionDefinitionMethods;
    // (undocumented)
    readonly definition: IExecutionDefinition;
    // (undocumented)
    fingerprint(): string;
    // (undocumented)
    static for(dataView: IDataView): DataViewFacade;
    static forResult(result: IExecutionResult): DataViewFacade;
    // @alpha
    getCollectionItemsForAttribute(attribute: IAttribute | string, options: CollectionItemsRequestOptions): Promise<ICollectionItemsResult>;
    // @internal (undocumented)
    meta(): IResultMetaMethods;
    // @internal (undocumented)
    rawData(): IResultDataMethods;
    // (undocumented)
    result(): IExecutionResult;
    // (undocumented)
    warnings(): IResultWarning[];
}

// @alpha
export class DataViewLoader {
    filterBy: (...filters: INullableFilter[]) => DataViewLoader;
    static for(backend: IAnalyticalBackend, workspace: string): DataViewLoader;
    loadAll: () => Promise<DataViewFacade>;
    loadWindow: (dataWindow: DataViewWindow) => Promise<DataViewFacade>;
    seriesFrom: (...measuresAndScopingAttributes: IAttributeOrMeasure[]) => DataViewLoader;
    slicesFrom: (...attributes: IAttribute[]) => DataViewLoader;
    sortBy: (...sorts: ISortItem[]) => DataViewLoader;
    withSignal: (signal: AbortSignal) => DataViewLoader;
    withTotals: (...totals: ITotal[]) => DataViewLoader;
}

// @public
export type DataViewWindow = {
    offset: number[];
    size: number[];
};

// @public
export function decompressFromUrl<T>(compressedData: string): T | undefined;

// @internal (undocumented)
export const DEFAULT_LANGUAGE = "en-US";

// @internal (undocumented)
export const DEFAULT_MESSAGES: {
    "en-US": Record<string, string>;
};

// @public
export const DefaultColorPalette: IColorPalette;

// @public
export const DefaultDataAccessConfig: DataAccessConfig;

// @public
export function defaultErrorHandler(error: unknown): void;

// @public
export const DefaultLocale: ILocale;

// @internal
export class DerivedMeasureTitleSuffixFactory {
    constructor(locale: ILocale, messages: Record<string, string>);
    getSuffix(overTimeComparisonType: OverTimeComparisonType): string;
}

// @public (undocumented)
export type DrillEventIntersectionElementHeader = IAttributeDescriptor | IMeasureDescriptor | ITotalDescriptor | IDrillIntersectionAttributeItem;

// @public
export class DynamicScriptLoadSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal
export function emptyHeaderTitleFromIntl(intl: IntlShape): string;

// @public
export const ErrorCodes: {
    BAD_REQUEST: string;
    UNAUTHORIZED: string;
    GEO_LOCATION_MISSING: string;
    GEO_MAPBOX_TOKEN_MISSING: string;
    DATA_TOO_LARGE_TO_DISPLAY: string;
    DATA_TOO_LARGE_TO_COMPUTE: string;
    HEADERS_TOO_LARGE: string;
    NEGATIVE_VALUES: string;
    NO_DATA: string;
    NOT_FOUND: string;
    PROTECTED_REPORT: string;
    UNKNOWN_ERROR: string;
    CANCELLED: string;
    DYNAMIC_SCRIPT_LOAD_ERROR: string;
    TIMEOUT_ERROR: string;
    VISUALIZATION_CLASS_UNKNOWN: string;
    FORECAST_NOT_RECEIVED: string;
    CLUSTERING_NOT_RECEIVED: string;
    RESULT_CACHE_MISSING: string;
};

// @public
export function ErrorComponent({ icon, className, width, height, style, message, description, clientHeight, }: IErrorProps): JSX.Element;

// @public
export function Execute(props: IExecuteProps): JSX.Element;

// @public
export const ExecuteInsight: ComponentType<IExecuteInsightProps>;

// @public
export type ExplicitDrill = IDrillableItem | IHeaderPredicate;

// @internal
export function fillMissingFormat(item: IAttributeOrMeasure): IAttributeOrMeasure;

// @internal
export function fillMissingFormats<T extends IInsightDefinition>(insight: T): T;

// @internal
export function fillMissingTitles<T extends IInsightDefinition>(insight: T, locale: ILocale, maxArithmeticMeasureTitleLength?: number): Promise<T>;

// @internal
export function fillMissingTitlesWithMessages<T extends IInsightDefinition>(insight: T, locale: ILocale, messages: ITranslations, maxArithmeticMeasureTitleLength?: number): T;

// @public (undocumented)
export type FilterOrMultiValuePlaceholder = ValueOrMultiValuePlaceholder<IFilter> | ValueOrMultiValuePlaceholder<IDateFilter> | ValueOrMultiValuePlaceholder<IMeasureFilter> | ValueOrMultiValuePlaceholder<IAttributeFilter> | ValueOrMultiValuePlaceholder<IAbsoluteDateFilter> | ValueOrMultiValuePlaceholder<IRelativeDateFilter> | ValueOrMultiValuePlaceholder<IPositiveAttributeFilter> | ValueOrMultiValuePlaceholder<INegativeAttributeFilter> | ValueOrMultiValuePlaceholder<IMeasureValueFilter> | ValueOrMultiValuePlaceholder<IRankingFilter>;

// @public
export type FilterOrPlaceholder = ValueOrPlaceholder<IFilter> | ValueOrPlaceholder<IDateFilter> | ValueOrPlaceholder<IMeasureFilter> | ValueOrPlaceholder<IAttributeFilter> | ValueOrPlaceholder<IAbsoluteDateFilter> | ValueOrPlaceholder<IRelativeDateFilter> | ValueOrPlaceholder<IPositiveAttributeFilter> | ValueOrPlaceholder<INegativeAttributeFilter> | ValueOrPlaceholder<IMeasureValueFilter> | ValueOrPlaceholder<IRankingFilter>;

// @public
export type FiltersOrPlaceholders = Array<FilterOrMultiValuePlaceholder>;

// @internal
export function fireDrillEvent(drillEventFunction: IDrillEventCallback | undefined, drillEventData: IDrillEvent, target: EventTarget): void;

// @public
export type Flatten<T> = T extends Array<infer A> ? A : T;

// @internal (undocumented)
export const FOCUS_HIGHCHARTS_DATAPOINT_EVENT = "gd:chart:focusDatapoint";

// @public
export class ForecastNotReceivedSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal
export function forwardRefWithGenerics<T, P>(render: (props: PropsWithoutRef<P>, ref: Ref<T>) => ReactNode): (props: PropsWithoutRef<P> & RefAttributes<T>) => ReactNode;

// @public
export class GeoLocationMissingSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class GeoTokenMissingSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal
export function getAttributeHeaderItemName(attributeHeaderItem: IResultAttributeHeaderItem | undefined): string | null | undefined;

// @internal
export function getChartClickCoordinates(targetElement: HTMLElement | EventTarget | null | undefined, containerSelector: string): IChartCoordinates;

// @internal (undocumented)
export function getDrillIntersection(drillItems: IMappingHeader[]): IDrillEventIntersectionElement[];

// @internal
export function getIntersectionAttributes(fromAttribute: IAttributeDescriptor, attributes: IAttributeDescriptor[]): IAttributeDescriptor[];

// @internal (undocumented)
export function getIntersectionPartAfter(intersection: IDrillEventIntersectionElement[], localIdentifier: string): IDrillEventIntersectionElement[];

// @internal
export function getIntl(locale: ILocale | undefined, messages: Record<string, string>): IntlShape;

// @internal (undocumented)
export const getInvalidDatapointsInTree: <T extends IInvalidNode<any>>(rootNode: T) => IInvalidDatapoint[];

// @internal (undocumented)
export const getInvalidNodeAtPath: <T extends IInvalidNode<any>, P extends IInvalidNodePath<T>>(node: T, path?: P) => IInvalidNodeAtPath<T, P>;

// @internal
export function getMappingHeaderFormattedName(header: IMappingHeader | IResultMeasureHeader | undefined): string | undefined | null;

// @internal (undocumented)
export function getMappingHeaderIdentifier(header: IMappingHeader): string | undefined;

// @internal (undocumented)
export function getMappingHeaderLocalIdentifier(header: IMappingHeader): string;

// @internal (undocumented)
export function getMappingHeaderName(header: IMappingHeader | IResultMeasureHeader | undefined): string | undefined | null;

// @internal (undocumented)
export function getMappingHeaderUri(header: IMappingHeader): string | undefined;

// @internal
export function getMultiLayerDrillTargets(layerDataViews: Array<DataViewFacade | null>, primaryDataView: DataViewFacade | null): IAvailableDrillTargets | undefined;

// @internal
export function getObjectDiff(prevObj: Record<string, any> | null, currObj: Record<string, any>, equalityFn?: (A: any, B: any) => boolean): {
    hasChanged: boolean;
    DEEP_CHANGES?: Record<string, any> | undefined;
    CHANGED?: string[] | undefined;
    REMOVED?: string[] | undefined;
    NEW?: string[] | undefined;
};

// @internal (undocumented)
export function getTotalInfo(attributeHeaders: IResultAttributeHeader[]): {
    isTotal: boolean;
    isSubtotal: boolean;
};

// @internal
export function getTranslation(translationId: string | MessageDescriptor, locale: ILocale, messages: Record<string, string>, values?: {}): string;

// @internal (undocumented)
export const getUpdatedInvalidTree: <T extends IInvalidNode<any>, P extends IInvalidNodePath<T>>(rootNode: T, updater: (node: IInvalidNodeAtPath<T, P>) => IInvalidNodeAtPath<T, P>, path?: P) => T;

// @internal (undocumented)
export function getVisualizationType(type: ChartType): ChartType;

// @public
export abstract class GoodDataSdkError extends Error {
    protected constructor(seType: SdkErrorType, message?: string, cause?: any | undefined);
    // (undocumented)
    readonly cause?: any | undefined;
    getCause(): any;
    getErrorCode(): string;
    getMessage(): string;
    // (undocumented)
    readonly seType: SdkErrorType;
}

// @internal (undocumented)
export function hasMappingHeaderFormattedName(header: IMappingHeader): boolean;

// @internal (undocumented)
export function hasMappingHeaderLocalIdentifier(header: IMappingHeader): boolean;

// @public
export const HeaderPredicates: {
    attributeItemNameMatch: typeof attributeItemNameMatch;
    composedFromIdentifier: typeof composedFromIdentifier;
    composedFromUri: typeof composedFromUri;
    identifierMatch: typeof identifierMatch;
    localIdentifierMatch: typeof localIdentifierMatch;
    uriMatch: typeof uriMatch;
    objRefMatch: typeof objRefMatch;
    objMatch: typeof objMatch;
};

// @public (undocumented)
export type HeaderTranslator = (value: string | null) => string;

// @public (undocumented)
export type HeadlineElementType = "primaryValue" | "secondaryValue";

// @public (undocumented)
export type HeadlineType = "headline";

// @internal
export interface IArithmeticMeasureTitleProps {
    // (undocumented)
    masterMeasureLocalIdentifiers: string[];
    // (undocumented)
    operator: string;
}

// @internal (undocumented)
export type IAutomationUrlBuilder = (workspaceId?: string, dashboardId?: string, automationId?: string) => string | undefined;

// @internal (undocumented)
export interface IAvailableDrillTargetAttribute {
    // (undocumented)
    attribute: IAttributeDescriptor;
    drillTargetDisplayFormType?: AttributeDisplayFormType;
    // (undocumented)
    intersectionAttributes: IAttributeDescriptor[];
}

// @internal (undocumented)
export interface IAvailableDrillTargetMeasure {
    // (undocumented)
    attributes: IAttributeDescriptor[];
    // (undocumented)
    measure: IMeasureDescriptor;
}

// @internal (undocumented)
export interface IAvailableDrillTargets {
    // (undocumented)
    attributes?: IAvailableDrillTargetAttribute[];
    // (undocumented)
    measures?: IAvailableDrillTargetMeasure[];
}

// @public
export interface IBackendProviderProps {
    backend: IAnalyticalBackend;
    children?: ReactNode;
}

// @public
export interface IBackendProviderWithCorrelationProps {
    backend?: IAnalyticalBackend;
    children?: ReactNode;
    correlationData: IRequestCorrelationMetadata;
}

// @internal (undocumented)
export interface ICancelablePromise<T> {
    // (undocumented)
    cancel: (reason?: string) => void;
    // (undocumented)
    getHasCanceled: () => boolean;
    // (undocumented)
    getHasFulfilled: () => boolean;
    // (undocumented)
    promise: Promise<T>;
}

// @internal
export interface IChartCoordinates {
    // (undocumented)
    chartX?: number;
    // (undocumented)
    chartY?: number;
}

// @alpha
export interface IClientWorkspaceIdentifiers {
    children?: ReactNode;
    client?: string;
    dataProduct?: string;
    segment?: string;
    workspace?: string;
}

// @alpha
export interface IClientWorkspaceProviderCoreProps {
    backend?: IAnalyticalBackend;
    children: ReactNode;
}

// @alpha
export type IClientWorkspaceProviderProps = IClientWorkspaceProviderWithWorkspaceProps | IClientWorkspaceProviderWithClientAndDataProductProps;

// @alpha (undocumented)
export interface IClientWorkspaceProviderWithClientAndDataProductProps extends IClientWorkspaceProviderCoreProps {
    client: string;
    dataProduct: string;
}

// @alpha (undocumented)
export interface IClientWorkspaceProviderWithWorkspaceProps extends IClientWorkspaceProviderCoreProps {
    workspace: string;
}

// @internal (undocumented)
export interface IClientWorkspaceStatus {
    // (undocumented)
    isInitialized: boolean;
}

// @internal (undocumented)
export interface IColorAssignment {
    // (undocumented)
    color: IColor | undefined;
    // (undocumented)
    headerItem: IMappingHeader;
}

// @internal (undocumented)
export interface IColorsData {
    // (undocumented)
    colorAssignments: IColorAssignment[];
    // (undocumented)
    colorPalette: IColorPalette;
}

// @public
export interface IComposedPlaceholder<TReturn, TValue extends any[], TContext> {
    // (undocumented)
    computeValue: (values: PlaceholdersResolvedValues<TValue>, resolutionContext: TContext) => TReturn;
    // (undocumented)
    placeholders: TValue;
    // (undocumented)
    type: "IComposedPlaceholder";
    // (undocumented)
    use: IUseComposedPlaceholderHook<IComposedPlaceholder<TReturn, TValue, TContext>>;
}

// @internal (undocumented)
export type IContextStore<T> = IContextStoreProvider<T> & {
    useContextStore: IUseContextStore<T>;
    useContextStoreOptional: IUseContextStore<T, true>;
    useContextStoreValues: <K extends readonly (keyof T)[]>(keys: K, equalityFn?: (a: Pick<T, K[number]>, b: Pick<T, K[number]>) => boolean) => Pick<T, K[number]>;
    useContextStoreValuesOptional: <K extends readonly (keyof T)[]>(keys: K, equalityFn?: (a: Pick<T, K[number]>, b: Pick<T, K[number]>) => boolean) => Pick<T, K[number]> | undefined;
    createSelector: <SelectorResult>(selector: IContextStoreSelector<T, SelectorResult>) => IContextStoreSelector<T, SelectorResult>;
};

// @internal (undocumented)
export type IContextStoreProvider<T> = FC<{
    value: T;
    children: ReactNode;
}>;

// @internal (undocumented)
export type IContextStoreSelector<T, SelectorResult> = (state: T) => SelectorResult;

// @public
export interface ICorrelationProviderProps {
    children?: ReactNode;
    correlationData: Record<string, string>;
}

// @internal (undocumented)
export type IDashboardUrlBuilder = (workspaceId?: string, dashboardId?: string, tabId?: string) => string | undefined;

// @public
export interface IDataAccessMethods {
    // @alpha (undocumented)
    asTable(): ITableData;
    // (undocumented)
    series(): IDataSeriesCollection;
    // (undocumented)
    slices(): IDataSliceCollection;
}

// @public
export interface IDataSeries extends DataSeriesDescriptorMethods, Iterable<DataPoint> {
    // (undocumented)
    dataPoints(): DataPoint[];
    readonly descriptor: DataSeriesDescriptor;
    readonly id: DataSeriesId;
    // (undocumented)
    rawData(): DataValue[];
}

// @public
export interface IDataSeriesCollection extends Iterable<IDataSeries> {
    allForMeasure(localIdOrMeasure: string | IMeasure): Iterable<IDataSeries>;
    readonly count: number;
    firstForMeasure(localIdOrMeasure: string | IMeasure): IDataSeries;
    readonly fromMeasures: IMeasureDescriptor[];
    readonly fromMeasuresDef: IMeasure[];
    readonly scopingAttributes?: IAttributeDescriptor[];
    readonly scopingAttributesDef?: IAttribute[];
    toArray(): IDataSeries[];
}

// @public
export interface IDataSlice extends DataSliceDescriptorMethods, Iterable<DataPoint> {
    // (undocumented)
    dataPoints(): DataPoint[];
    readonly descriptor: DataSliceDescriptor;
    readonly id: DataSliceId;
    // (undocumented)
    rawData(): DataValue[];
}

// @public
export interface IDataSliceCollection extends Iterable<IDataSlice> {
    readonly count: number;
    readonly descriptors: Array<IAttributeDescriptor | ITotal>;
    toArray(): IDataSlice[];
}

// @public
export interface IDataVisualizationProps extends IVisualizationProps, IVisualizationCallbacks {
    // @beta
    clusteringConfig?: IClusteringConfig;
    // @internal
    enableExecutionCancelling?: boolean;
    execution: IPreparedExecution;
    // @alpha
    executions?: IPreparedExecution[];
    // @beta
    forecastConfig?: IForecastConfig;
    // @beta
    outliersConfig?: IOutliersConfig;
}

// @public
export function identifierMatch(identifier: string): IHeaderPredicate;

// @public (undocumented)
export type IDrillableItem = IDrillableItemUri | IDrillableItemIdentifier | (IDrillableItemUri & IDrillableItemIdentifier);

// @public (undocumented)
export interface IDrillableItemIdentifier {
    // (undocumented)
    identifier: string;
}

// @public (undocumented)
export interface IDrillableItemUri {
    // (undocumented)
    uri: string;
}

// @public (undocumented)
export interface IDrillConfig {
    // (undocumented)
    dataView: IDataView;
    // (undocumented)
    onDrill: OnFiredDrillEvent;
}

// @public (undocumented)
export interface IDrillEvent {
    // (undocumented)
    chartX?: number;
    // (undocumented)
    chartY?: number;
    // (undocumented)
    dataView: IDataView;
    // (undocumented)
    drillContext: IDrillEventContext;
    enableDrillMenuPositioningAtCursor?: boolean;
    // (undocumented)
    target?: HTMLElement;
}

// @public (undocumented)
export type IDrillEventCallback = (event: IDrillEvent) => void | boolean;

// @public
export interface IDrillEventContext {
    // (undocumented)
    chartId?: string;
    // (undocumented)
    columnIndex?: number;
    // (undocumented)
    element: VisElementType;
    // (undocumented)
    intersection?: IDrillEventIntersectionElement[];
    // (undocumented)
    pointIndex?: number;
    // (undocumented)
    points?: IDrillPoint[];
    // (undocumented)
    row?: any[];
    // (undocumented)
    rowIndex?: number;
    // (undocumented)
    seriesIndex?: number;
    // (undocumented)
    type: VisType;
    // (undocumented)
    value?: string | null;
    // (undocumented)
    x?: number;
    // (undocumented)
    y?: number | null;
    // (undocumented)
    z?: number;
}

// @public
export interface IDrillEventContextGroup {
    // (undocumented)
    element: ChartElementType;
    // (undocumented)
    points: IDrillPoint[];
    // (undocumented)
    type: ChartType;
}

// @public
export interface IDrillEventContextHeadline {
    // (undocumented)
    element: HeadlineElementType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    type: HeadlineType;
    // (undocumented)
    value: string | null;
}

// @public
export interface IDrillEventContextPoint {
    // (undocumented)
    chartId?: string;
    // (undocumented)
    element: ChartElementType;
    // (undocumented)
    elementChartType?: ChartType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    pointIndex?: number;
    // (undocumented)
    seriesIndex?: number;
    // (undocumented)
    type: ChartType;
    // (undocumented)
    value?: string;
    // (undocumented)
    x?: number;
    // (undocumented)
    y?: number;
    // (undocumented)
    z?: number;
}

// @public
export interface IDrillEventContextTable {
    // (undocumented)
    columnIndex: number;
    // (undocumented)
    element: TableElementType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    row: any[];
    // (undocumented)
    rowIndex: number;
    // (undocumented)
    type: TableType;
}

// @public
export interface IDrillEventContextXirr {
    // (undocumented)
    element: HeadlineElementType;
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    type: XirrType;
    // (undocumented)
    value: string | null;
}

// @public (undocumented)
export interface IDrillEventIntersectionElement {
    // (undocumented)
    header: DrillEventIntersectionElementHeader;
}

// @public (undocumented)
export interface IDrillIntersectionAttributeItem extends IAttributeDescriptor, IResultAttributeHeader {
}

// @public
export interface IDrillPoint {
    // (undocumented)
    intersection: IDrillEventIntersectionElement[];
    // (undocumented)
    type?: ChartType;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number | null;
}

// @public
export interface IErrorDescriptors {
    // (undocumented)
    [key: string]: {
        icon?: string;
        message: string;
        description: string;
    };
}

// @public
export interface IErrorProps {
    // (undocumented)
    className?: string;
    clientHeight?: any;
    // (undocumented)
    code?: string;
    // (undocumented)
    description?: string;
    height?: any;
    // (undocumented)
    icon?: string;
    // (undocumented)
    message: string;
    // (undocumented)
    style?: object;
    // (undocumented)
    width?: any;
}

// @public
export type IExecuteErrorComponent = ComponentType<IExecuteErrorComponentProps>;

// @public
export interface IExecuteErrorComponentProps {
    error: GoodDataSdkError;
}

// @public
export interface IExecuteInsightProps extends IWithLoadingEvents<IExecuteInsightProps> {
    backend?: IAnalyticalBackend;
    children: (executionResult: WithLoadingResult) => ReactElement | null;
    componentName?: string;
    dateFormat?: string | ((def: IExecutionDefinition, props: IExecuteInsightProps) => string);
    dimensions?: IDimension[] | ((def: IExecutionDefinition, props: IExecuteInsightProps) => IDimension[]);
    enableExecutionCancelling?: boolean;
    ErrorComponent?: IExecuteErrorComponent;
    executeByReference?: boolean;
    exportTitle?: string;
    filters?: INullableFilter[];
    insight: ObjRef;
    LoadingComponent?: IExecuteLoadingComponent;
    loadOnMount?: boolean;
    sorts?: ISortItem[] | ((def: IExecutionDefinition, props: IExecuteInsightProps) => ISortItem[]);
    window?: DataViewWindow;
    workspace?: string;
}

// @public
export type IExecuteLoadingComponent = ComponentType;

// @public
export interface IExecuteProps extends IWithLoadingEvents<IExecuteProps> {
    backend?: IAnalyticalBackend;
    children: (executionResult: WithLoadingResult) => ReactElement | null;
    componentName?: string;
    enableExecutionCancelling?: boolean;
    ErrorComponent?: IExecuteErrorComponent;
    exportTitle?: string;
    filters?: NullableFiltersOrPlaceholders;
    LoadingComponent?: IExecuteLoadingComponent;
    loadOnMount?: boolean;
    placeholdersResolutionContext?: any;
    seriesBy?: AttributesMeasuresOrPlaceholders;
    slicesBy?: AttributesOrPlaceholders;
    sortBy?: SortsOrPlaceholders;
    totals?: TotalsOrPlaceholders;
    window?: DataViewWindow;
    workspace?: string;
}

// @public
export interface IExecutionConfiguration {
    componentName?: string;
    filters?: NullableFiltersOrPlaceholders;
    placeholdersResolutionContext?: any;
    seriesBy: AttributesMeasuresOrPlaceholders;
    slicesBy?: AttributesOrPlaceholders;
    sortBy?: SortsOrPlaceholders;
    totals?: TotalsOrPlaceholders;
}

// @internal
export interface IExecutionDefinitionMethods {
    // (undocumented)
    attributes(): IAttribute[];
    bucket(localId: string): IBucket | undefined;
    // (undocumented)
    bucketCount(): number;
    bucketMeasures(localId: string): IMeasure[];
    // (undocumented)
    buckets(): IBucket[];
    // (undocumented)
    hasAttributes(): boolean;
    hasBuckets(): boolean;
    isBucketEmpty(localId: string): boolean;
    masterMeasureForDerived(localId: string): IMeasure | undefined;
    measure(localId: string): IMeasure | undefined;
    measureIndex(localId: string): number;
    // (undocumented)
    measures(): IMeasure[];
}

// @public (undocumented)
export type IExportFunction = (exportConfig: IExtendedExportConfig) => Promise<IExportResult>;

// @public (undocumented)
export interface IExtendedExportConfig extends IExportConfig {
    // (undocumented)
    includeFilterContext?: boolean;
}

// @internal (undocumented)
export interface IFocusHighchartsDatapointEventDetail {
    // (undocumented)
    chartId: string;
    // (undocumented)
    pointIndex: number;
    // (undocumented)
    seriesIndex: number;
}

// @internal
export function ignoreTitlesForSimpleMeasures<T extends IInsightDefinition>(insight: T): T;

// @public
export type IHeaderPredicate = (header: IMappingHeader, context: IHeaderPredicateContext) => boolean;

// @public
export interface IHeaderPredicateContext {
    // (undocumented)
    dv: DataViewFacade;
}

// @public (undocumented)
export interface IHighchartsCategoriesTree {
    // (undocumented)
    tick: IHighchartsParentTick;
}

// @public (undocumented)
export interface IHighchartsParentTick {
    // (undocumented)
    label: any;
    // (undocumented)
    leaves: number;
    // (undocumented)
    startAt: number;
}

// @internal (undocumented)
export interface IIntlWrapperProps {
    // (undocumented)
    children?: ReactNode;
    // (undocumented)
    locale?: string;
    // (undocumented)
    messages?: Record<string, string>;
}

// @internal (undocumented)
export type IInvalidDatapoint = {
    id: string;
    severity: IValidationSeverity;
    message: string;
};

// @internal (undocumented)
export type IInvalidNode<Children extends Record<string, IInvalidNode<any>> = Record<string, IInvalidNode<any>>> = {
    id: string;
    invalidDatapoints: IInvalidDatapoint[];
    children: Children;
};

// @internal (undocumented)
export type IInvalidNodeAtPath<T extends IInvalidNode, Path extends IInvalidNodePath<T>> = Path extends [] ? T : Path extends [infer K, ...infer Rest] ? K extends keyof T["children"] ? T["children"][K] extends IInvalidNode ? Rest extends IInvalidNodePath<T["children"][K]> ? IInvalidNodeAtPath<T["children"][K], Rest> : never : T["children"][K] : never : never;

// @internal (undocumented)
export type IInvalidNodePath<T extends IInvalidNode> = [] | (T["children"] extends never ? never : {
    [K in keyof T["children"]]: [K] | [K, ...IInvalidNodePath<T["children"][K]>];
}[keyof T["children"]] | [keyof T["children"]] | IUnionPaths<T>);

// @public
export interface IKpiProps extends IWithLoadingEvents<IRawExecuteProps> {
    backend?: IAnalyticalBackend;
    ErrorComponent?: ComponentType<IErrorProps>;
    filters?: INullableFilter[];
    LoadingComponent?: ComponentType<ILoadingProps>;
    locale?: string;
    measure: IMeasure;
    separators?: ISeparators;
    workspace?: string;
}

// @internal
export interface ILoadingInjectedProps {
    dataView?: IDataView;
    error?: string;
    // (undocumented)
    intl: IntlShape;
    isLoading: boolean;
    onDataTooLarge(data: any, errorMessage?: string): void;
    onExportReady(exportFunction: IExportFunction): void;
    onNegativeValues(): void;
    seType?: GoodDataSdkError["seType"];
}

// @public
export interface ILoadingProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    color?: string;
    // (undocumented)
    height?: any;
    // (undocumented)
    imageHeight?: any;
    // (undocumented)
    imageWidth?: any;
    // (undocumented)
    inline?: boolean;
    // (undocumented)
    speed?: number;
    // (undocumented)
    width?: any;
}

// @public (undocumented)
export interface ILoadingState {
    // (undocumented)
    isLoading: boolean;
}

// @public
export type ILocale = "en-US" | "en-US-x-24h" | "de-DE" | "es-ES" | "fr-FR" | "ja-JP" | "nl-NL" | "pt-BR" | "pt-PT" | "zh-Hans" | "ru-RU" | "it-IT" | "es-419" | "fr-CA" | "en-GB" | "en-AU" | "fi-FI" | "zh-Hant" | "zh-HK" | "tr-TR" | "pl-PL" | "ko-KR" | "sl-SI";

// @public (undocumented)
export type IMappingHeader = IAttributeDescriptor | IResultAttributeHeader | IMeasureDescriptor | ITotalDescriptor | IColorDescriptor;

// @internal
export interface IMeasureTitleProps {
    // (undocumented)
    alias?: string;
    // (undocumented)
    localIdentifier: string;
    // (undocumented)
    title?: string;
}

// @internal (undocumented)
function Intl_2({ children, customLocale, customMessages, forTest, }: {
    children: ReactNode;
    customLocale?: ILocale;
    customMessages?: ITranslations;
    forTest?: boolean;
}): JSX.Element | null;
export { Intl_2 as Intl }

// @internal (undocumented)
export const IntlTranslationsProvider: FC<WithIntlProps<ITranslationsProviderProps>> & {
    WrappedComponent: ComponentType<ITranslationsProviderProps>;
};

// @internal (undocumented)
export function IntlWrapper({ locale, children }: IIntlWrapperProps): JSX.Element | null;

// @internal (undocumented)
export interface IOpenAsReportUiConfig {
    // (undocumented)
    supported?: boolean;
    // (undocumented)
    warningMessage?: string;
}

// @public
export interface IOrganizationProviderProps {
    children?: ReactNode;
    organization?: string;
}

// @public
export type IPlaceholder<T> = {
    type: "IPlaceholder";
    id: string;
    defaultValue?: T;
    value?: T;
    validate?: (value: T) => void;
    use: IUsePlaceholderHook<IPlaceholder<T>>;
};

// @public
export interface IPlaceholderOptions<T> {
    id?: string;
    validate?: (value?: T) => void;
}

// @public
export interface IPlaceholdersProviderProps {
    // (undocumented)
    children: ReactNode;
    // (undocumented)
    initialValues?: [IPlaceholder<any>, any][];
}

// @internal
export interface IPushData {
    // (undocumented)
    availableDrillTargets?: IAvailableDrillTargets;
    // (undocumented)
    colors?: IColorsData;
    // (undocumented)
    dataView?: IDataView;
    // (undocumented)
    ignoreUndoRedo?: boolean;
    // (undocumented)
    initialProperties?: any;
    // (undocumented)
    openAsReport?: IOpenAsReportUiConfig;
    // (undocumented)
    properties?: {
        sortItems?: ISortItem[];
        totals?: ITotal[];
        controls?: Record<string, any>;
        bucketType?: string;
    };
    // (undocumented)
    propertiesMeta?: any;
}

// @public
export interface IRawExecuteProps extends IWithLoadingEvents<IRawExecuteProps> {
    children: (executionResult: WithLoadingResult) => ReactElement | null;
    enableExecutionCancelling?: boolean;
    ErrorComponent?: IExecuteErrorComponent;
    execution: IPreparedExecution;
    exportTitle?: string;
    LoadingComponent?: IExecuteLoadingComponent;
    loadOnMount?: boolean;
    window?: DataViewWindow;
}

// @internal
export interface IResultDataMethods {
    // (undocumented)
    columnTotals(): DataValue[][] | undefined;
    // (undocumented)
    data(): DataValue[][] | DataValue[];
    // (undocumented)
    dataAt(index: number): DataValue | DataValue[];
    // (undocumented)
    firstDimSize(): number;
    forecastTwoDimData(): ForecastDataValue[][];
    hasColumnTotals(): boolean;
    hasRowTotals(): boolean;
    hasTotals(): boolean;
    // (undocumented)
    isEmpty(): boolean;
    outliersTwoDimData(): DataValue[][];
    // (undocumented)
    rowTotals(): DataValue[][] | undefined;
    // (undocumented)
    secondDimSize(): number;
    singleDimData(): DataValue[];
    // (undocumented)
    totalOfTotals(): DataValue[][][] | undefined;
    // (undocumented)
    totals(): DataValue[][][] | undefined;
    twoDimData(): DataValue[][];
}

// @internal
export interface IResultMetaMethods {
    // (undocumented)
    allHeaders(): IResultHeader[][][];
    // (undocumented)
    attributeDescriptors(): IAttributeDescriptor[];
    attributeDescriptorsForDim(dim: number): IAttributeDescriptor[];
    // (undocumented)
    attributeHeaders(): IResultAttributeHeader[][][];
    // (undocumented)
    attributeHeadersForDim(idx: number): IResultAttributeHeader[][];
    // (undocumented)
    dimensionItemDescriptors(dimIdx: number): IDimensionItemDescriptor[];
    // (undocumented)
    dimensions(): IDimensionDescriptor[];
    effectiveSortItems(): ISortItem[];
    hasNoHeadersInDim(dim: number): boolean;
    isDerivedMeasure(measureDescriptor: IMeasureDescriptor): boolean;
    isVirtualMeasure(measureDescriptor: IMeasureDescriptor): boolean;
    measureDescriptor(localId: string): IMeasureDescriptor | undefined;
    measureDescriptors(): IMeasureDescriptor[];
    // (undocumented)
    measureGroupDescriptor(): IMeasureGroupDescriptor | undefined;
}

// @public
export function isAnyPlaceholder<T>(obj: unknown): obj is AnyPlaceholder<T>;

// @alpha
export function isAttributeColumnDefinition(columnDefinition: unknown): columnDefinition is ITableAttributeColumnDefinition;

// @alpha (undocumented)
export function isAttributeScope(scope: unknown): scope is ITableDataAttributeScope;

// @alpha (undocumented)
export function isAttributeTotalScope(scope: unknown): scope is ITableDataAttributeTotalScope;

// @public
export function isBadRequest(obj: unknown): obj is BadRequestSdkError;

// @internal (undocumented)
export const isCancelError: (obj: unknown) => obj is CancelError;

// @public
export function isCancelledSdkError(obj: unknown): obj is CancelledSdkError;

// @public
export function isClusteringNotReceived(obj: unknown): obj is ClusteringNotReceivedSdkError;

// @public
export function isComposedPlaceholder<TReturn, TValue extends any[], TContext>(obj: unknown): obj is IComposedPlaceholder<TReturn, TValue, TContext>;

// @public
export function isDataTooLargeToCompute(obj: unknown): obj is DataTooLargeToComputeSdkError;

// @public
export function isDataTooLargeToDisplay(obj: unknown): obj is DataTooLargeToDisplaySdkError;

// @public (undocumented)
export function isDrillableItem(item: unknown): item is IDrillableItem;

// @public (undocumented)
export function isDrillableItemIdentifier(item: unknown): item is IDrillableItemIdentifier;

// @public (undocumented)
export function isDrillableItemUri(item: unknown): item is IDrillableItemUri;

// @public (undocumented)
export function isDrillIntersectionAttributeItem(header: DrillEventIntersectionElementHeader): header is IDrillIntersectionAttributeItem;

// @public (undocumented)
export function isDrillIntersectionDateAttributeItem(header: DrillEventIntersectionElementHeader): header is IDrillIntersectionAttributeItem;

// @public
export function isDynamicScriptLoadSdkError(obj: unknown): obj is DynamicScriptLoadSdkError;

// @alpha
export function isEmptyValueColumnDefinition(columnDefinition: unknown): columnDefinition is ITableValueColumnDefinition & {
    isEmpty: true;
    isTransposed: false;
    attributeHeader: IResultAttributeHeader;
    attributeDescriptor: IAttributeDescriptor;
};

export { ISeparators }

// @public (undocumented)
export function isExplicitDrill(obj: unknown): obj is ExplicitDrill;

// @public
export function isForecastNotReceived(obj: unknown): obj is ForecastNotReceivedSdkError;

// @public
export function isGeoLocationMissing(obj: unknown): obj is GeoLocationMissingSdkError;

// @public
export function isGeoTokenMissing(obj: unknown): obj is GeoTokenMissingSdkError;

// @public
export function isGoodDataSdkError(obj: unknown): obj is GoodDataSdkError;

// @alpha
export function isGrandTotalColumnDefinition(columnDefinition: unknown): columnDefinition is ITableGrandTotalColumnDefinition;

// @alpha
export function isGrandTotalRowDefinition(row: ITableRowDefinition): row is ITableGrandTotalRowDefinition;

// @public
export function isHeaderPredicate(obj: unknown): obj is IHeaderPredicate;

// @public
export const isLocale: (locale: unknown) => locale is ILocale;

// @alpha
export function isMeasureGroupHeaderColumnDefinition(columnDefinition: unknown): columnDefinition is ITableMeasureGroupHeaderColumnDefinition;

// @alpha (undocumented)
export function isMeasureGroupScope(scope: unknown): scope is ITableDataMeasureGroupScope;

// @alpha
export function isMeasureGroupValueColumnDefinition(columnDefinition: unknown): columnDefinition is ITableMeasureGroupValueColumnDefinition;

// @alpha (undocumented)
export function isMeasureScope(scope: unknown): scope is ITableDataMeasureScope;

// @alpha (undocumented)
export function isMeasureTotalScope(scope: unknown): scope is ITableDataMeasureTotalScope;

// @public
export function isNegativeValues(obj: unknown): obj is NegativeValuesSdkError;

// @public
export function isNoDataSdkError(obj: unknown): obj is NoDataSdkError;

// @public
export function isNotFound(obj: unknown): obj is NotFoundSdkError;

// @public
export function isPlaceholder<T>(obj: unknown): obj is IPlaceholder<T>;

// @public
export function isProtectedReport(obj: unknown): obj is ProtectedReportSdkError;

// @public
export function isResultCacheMissingSdkError(obj: unknown): obj is ResultCacheMissingSdkError;

// @internal (undocumented)
export function isSomeHeaderPredicateMatched(drillablePredicates: IHeaderPredicate[], header: IMappingHeader, dv: DataViewFacade): boolean;

// @alpha
export function isStandardGrandTotalColumnDefinition(columnDefinition: unknown): columnDefinition is ITableGrandTotalColumnDefinition & {
    isEmpty: false;
    isTransposed: false;
    totalHeader: IResultTotalHeader;
    measureDescriptor: IMeasureDescriptor;
};

// @alpha
export function isStandardSubtotalColumnDefinition(columnDefinition: unknown): columnDefinition is ITableSubtotalColumnDefinition & {
    isEmpty: false;
    isTransposed: false;
    totalHeader: IResultTotalHeader;
    measureDescriptor: IMeasureDescriptor;
};

// @alpha
export function isStandardValueColumnDefinition(columnDefinition: unknown): columnDefinition is ITableValueColumnDefinition & {
    isEmpty: false;
    isTransposed: false;
    measureHeader: IResultMeasureHeader;
    measureDescriptor: IMeasureDescriptor;
};

// @alpha
export function isSubtotalColumnDefinition(columnDefinition: unknown): columnDefinition is ITableSubtotalColumnDefinition;

// @alpha
export function isSubtotalRowDefinition(row: ITableRowDefinition): row is ITableSubtotalRowDefinition;

// @alpha
export function isTableAttributeHeaderValue(obj: unknown): obj is ITableAttributeHeaderValue;

// @alpha
export function isTableGrandTotalHeaderValue(obj: unknown): obj is ITableGrandTotalHeaderValue;

// @alpha
export function isTableGrandTotalMeasureValue(obj: unknown): obj is ITableGrandTotalMeasureValue;

// @alpha
export function isTableGrandTotalSubtotalMeasureValue(obj: unknown): obj is ITableGrandTotalSubtotalMeasureValue;

// @alpha
export function isTableMeasureHeaderValue(obj: unknown): obj is ITableMeasureHeaderValue;

// @alpha
export function isTableMeasureValue(obj: unknown): obj is ITableMeasureValue;

// @alpha
export function isTableOverallTotalMeasureValue(obj: unknown): obj is ITableOverallTotalMeasureValue;

// @alpha
export function isTableSubtotalMeasureValue(obj: unknown): obj is ITableSubtotalMeasureValue;

// @alpha
export function isTableTotalHeaderValue(obj: unknown): obj is ITableTotalHeaderValue;

// @alpha
export function isTransposedValueColumnDefinition(columnDefinition: unknown): columnDefinition is ITableValueColumnDefinition & {
    isEmpty: false;
    isTransposed: true;
    attributeHeader: IResultAttributeHeader;
    attributeDescriptor: IAttributeDescriptor;
};

// @public
export function isUnauthorized(obj: unknown): obj is UnauthorizedSdkError;

// @public
export function isUnknownSdkError(obj: unknown): obj is UnexpectedSdkError;

// @alpha
export function isValueColumnDefinition(columnDefinition: unknown): columnDefinition is ITableValueColumnDefinition;

// @alpha
export function isValueRowDefinition(row: ITableRowDefinition): row is ITableValueRowDefinition;

// @alpha
export interface ITableAttributeColumnDefinition {
    attributeDescriptor: IAttributeDescriptor;
    columnIndex: number;
    rowHeaderIndex: number;
    type: "attribute";
}

// @alpha
export interface ITableAttributeHeaderValue {
    columnDefinition: ITableAttributeColumnDefinition;
    columnIndex: number;
    formattedValue: string | null;
    rowDefinition: ITableValueRowDefinition | ITableSubtotalRowDefinition;
    rowIndex: number;
    type: "attributeHeader";
    value: IResultAttributeHeader;
}

// @alpha
export type ITableColumnDefinition = ITableAttributeColumnDefinition | ITableValueColumnDefinition | ITableMeasureGroupHeaderColumnDefinition | ITableMeasureGroupValueColumnDefinition | ITableSubtotalColumnDefinition | ITableGrandTotalColumnDefinition;

// @alpha
export type ITableData = {
    columnDefinitions: ITableColumnDefinition[];
    rowDefinitions: ITableRowDefinition[];
    data: ITableDataValue[][];
    isPivoted: boolean;
    isTransposed: boolean;
};

// @alpha (undocumented)
export interface ITableDataAttributeScope {
    // (undocumented)
    descriptor: IAttributeDescriptor;
    // (undocumented)
    header: IResultAttributeHeader;
    // (undocumented)
    type: "attributeScope";
}

// @alpha (undocumented)
export interface ITableDataAttributeTotalScope {
    // (undocumented)
    descriptor: IAttributeDescriptor;
    // (undocumented)
    header: IResultTotalHeader;
    // (undocumented)
    type: "attributeTotalScope";
}

// @alpha
export type ITableDataHeaderScope = ITableDataAttributeScope | ITableDataAttributeTotalScope | ITableDataMeasureScope | ITableDataMeasureTotalScope | ITableDataMeasureGroupScope;

// @alpha (undocumented)
export interface ITableDataMeasureGroupScope {
    // (undocumented)
    descriptor: IMeasureGroupDescriptor;
    // (undocumented)
    type: "measureGroupScope";
}

// @alpha (undocumented)
export interface ITableDataMeasureScope {
    // (undocumented)
    descriptor: IMeasureDescriptor;
    // (undocumented)
    header: IResultMeasureHeader;
    // (undocumented)
    type: "measureScope";
}

// @alpha (undocumented)
export interface ITableDataMeasureTotalScope {
    // (undocumented)
    descriptor: IMeasureDescriptor;
    // (undocumented)
    header: IResultTotalHeader;
    // (undocumented)
    type: "measureTotalScope";
}

// @alpha
export type ITableDataValue = ITableAttributeHeaderValue | ITableMeasureHeaderValue | ITableTotalHeaderValue | ITableMeasureValue | ITableSubtotalMeasureValue | ITableGrandTotalHeaderValue | ITableGrandTotalMeasureValue | ITableGrandTotalSubtotalMeasureValue | ITableOverallTotalMeasureValue;

// @alpha
export type ITableGrandTotalColumnDefinition = {
    type: "grandTotal";
    columnIndex: number;
    columnHeaderIndex: number;
    columnScope: ITableDataHeaderScope[];
} & (/**
* Handles case, when pivoting and measures are in rows.
*/ {
    isEmpty: false;
    isTransposed: true;
    totalHeader: IResultTotalHeader;
    attributeDescriptor: IAttributeDescriptor;
} | /**
* Handles standard pivoting case without transposition.
*/ {
    isEmpty: false;
    isTransposed: false;
    totalHeader: IResultTotalHeader;
    measureDescriptor: IMeasureDescriptor;
});

// @alpha
export interface ITableGrandTotalHeaderValue {
    columnDefinition: ITableAttributeColumnDefinition | ITableMeasureGroupHeaderColumnDefinition;
    columnIndex: number;
    formattedValue: string | null;
    rowDefinition: ITableGrandTotalRowDefinition;
    rowIndex: number;
    type: "grandTotalHeader";
}

// @alpha
export interface ITableGrandTotalMeasureValue {
    columnDefinition: ITableValueColumnDefinition | ITableGrandTotalColumnDefinition | ITableMeasureGroupValueColumnDefinition;
    columnIndex: number;
    formattedValue: string | null;
    rowDefinition: ITableValueRowDefinition | ITableGrandTotalRowDefinition;
    rowIndex: number;
    type: "grandTotalValue";
    value: DataValue;
}

// @alpha (undocumented)
export interface ITableGrandTotalRowDefinition {
    // (undocumented)
    attributeDescriptor: IAttributeDescriptor;
    // (undocumented)
    measureDescriptors: IMeasureDescriptor[];
    // (undocumented)
    rowGrandTotalIndex: number;
    // (undocumented)
    rowIndex: number;
    // (undocumented)
    totalType: TotalType;
    // (undocumented)
    type: "grandTotal";
}

// @alpha
export interface ITableGrandTotalSubtotalMeasureValue {
    columnDefinition: ITableSubtotalColumnDefinition | ITableGrandTotalColumnDefinition;
    columnIndex: number;
    formattedValue: string | null;
    rowDefinition: ITableSubtotalRowDefinition | ITableGrandTotalRowDefinition;
    rowIndex: number;
    type: "grandTotalSubtotalValue";
    value: DataValue;
}

// @alpha
export interface ITableMeasureGroupHeaderColumnDefinition {
    attributeDescriptors: IAttributeDescriptor[];
    columnIndex: number;
    measureGroupDescriptor: IMeasureGroupDescriptor;
    type: "measureGroupHeader";
}

// @alpha
export interface ITableMeasureGroupValueColumnDefinition {
    columnIndex: number;
    measureGroupDescriptor: IMeasureGroupDescriptor;
    type: "measureGroupValue";
}

// @alpha
export interface ITableMeasureHeaderValue {
    columnDefinition: ITableMeasureGroupHeaderColumnDefinition;
    columnIndex: number;
    formattedValue: string | null;
    rowDefinition: ITableValueRowDefinition;
    rowIndex: number;
    type: "measureHeader";
    value: IResultMeasureHeader;
}

// @alpha
export interface ITableMeasureValue {
    columnDefinition: ITableValueColumnDefinition | ITableMeasureGroupValueColumnDefinition;
    columnIndex: number;
    formattedValue: string | null;
    rowDefinition: ITableValueRowDefinition | ITableSubtotalRowDefinition;
    rowIndex: number;
    type: "value";
    value: DataValue;
}

// @alpha
export interface ITableOverallTotalMeasureValue {
    columnDefinition: ITableGrandTotalColumnDefinition;
    columnIndex: number;
    formattedValue: string | null;
    rowDefinition: ITableGrandTotalRowDefinition;
    rowIndex: number;
    type: "overallTotalValue";
    value: DataValue;
}

// @alpha
export type ITableRowDefinition = ITableValueRowDefinition | ITableSubtotalRowDefinition | ITableGrandTotalRowDefinition;

// @alpha
export type ITableSubtotalColumnDefinition = {
    type: "subtotal";
    columnIndex: number;
    columnHeaderIndex: number;
    columnScope: ITableDataHeaderScope[];
} & (/**
* Handles case, when pivoting and measures are in rows.
*/ {
    isEmpty: false;
    isTransposed: true;
    totalHeader: IResultTotalHeader;
    attributeDescriptor: IAttributeDescriptor;
}
/**
* Handles standard pivoting case without transposition.
*/
| {
    isEmpty: false;
    isTransposed: false;
    totalHeader: IResultTotalHeader;
    measureDescriptor: IMeasureDescriptor;
});

// @alpha
export interface ITableSubtotalMeasureValue {
    columnDefinition: ITableValueColumnDefinition | ITableSubtotalColumnDefinition;
    columnIndex: number;
    formattedValue: string | null;
    rowDefinition: ITableValueRowDefinition | ITableSubtotalRowDefinition;
    rowIndex: number;
    type: "subtotalValue";
    value: DataValue;
}

// @alpha (undocumented)
export interface ITableSubtotalRowDefinition {
    // (undocumented)
    rowIndex: number;
    // (undocumented)
    rowScope: ITableDataHeaderScope[];
    // (undocumented)
    type: "subtotal";
}

// @alpha
export interface ITableTotalHeaderValue {
    columnDefinition: ITableValueColumnDefinition | ITableSubtotalColumnDefinition | ITableMeasureGroupHeaderColumnDefinition | ITableAttributeColumnDefinition;
    columnIndex: number;
    formattedValue: string | null;
    rowDefinition: ITableValueRowDefinition | ITableSubtotalRowDefinition;
    rowIndex: number;
    type: "totalHeader";
    value: IResultTotalHeader;
}

// @alpha
export type ITableValueColumnDefinition = {
    type: "value";
    columnIndex: number;
    columnHeaderIndex: number;
    columnScope: ITableDataHeaderScope[];
} & (/**
* Handles case, when pivoting and measures are in rows.
*/ {
    isEmpty: false;
    isTransposed: true;
    attributeHeader: IResultAttributeHeader;
    attributeDescriptor: IAttributeDescriptor;
}
/**
* Handles standard pivoting case without transposition.
*/
| {
    isEmpty: false;
    isTransposed: false;
    measureHeader: IResultMeasureHeader;
    measureDescriptor: IMeasureDescriptor;
}
/**
* Handles case, when pivoting, but there are no measures.
*/
| {
    isEmpty: true;
    isTransposed: false;
    attributeHeader: IResultAttributeHeader;
    attributeDescriptor: IAttributeDescriptor;
});

// @alpha (undocumented)
export interface ITableValueRowDefinition {
    // (undocumented)
    rowIndex: number;
    // (undocumented)
    rowScope: ITableDataHeaderScope[];
    // (undocumented)
    type: "value";
}

// @internal (undocumented)
export interface ITranslations {
    // (undocumented)
    [key: string]: string;
}

// @internal (undocumented)
export interface ITranslationsComponentProps {
    // (undocumented)
    emptyHeaderString: string;
    // (undocumented)
    intl: IntlShape;
    // (undocumented)
    numericSymbols: string[];
}

// @internal (undocumented)
export interface ITranslationsProviderOwnProps {
    // (undocumented)
    children: any;
}

// @internal (undocumented)
export type ITranslationsProviderProps = ITranslationsProviderOwnProps & WrappedComponentProps;

// @internal
export type IUnionPaths<T extends IInvalidNode> = T["children"] extends never ? never : {
    [K in keyof T["children"]]: T["children"][K]["children"] extends never ? never : [K, keyof T["children"][K]["children"]] | [K, ...IUnionPaths<T["children"][K]>];
}[keyof T["children"]];

// @public
export type IUseComposedPlaceholderHook<T extends IComposedPlaceholder<any, any, any>> = (resolutionContext: ComposedPlaceholderResolutionContext<T>) => PlaceholderResolvedValue<T>;

// @internal (undocumented)
export type IUseContextStore<T, IsOptional = false> = <SelectorResult>(selector?: IContextStoreSelector<T, SelectorResult>, equalityFn?: (a: SelectorResult, b: SelectorResult) => boolean) => IsOptional extends false ? SelectorResult : SelectorResult | undefined;

// @public
export interface IUseExecutionDataViewConfig {
    backend?: IAnalyticalBackend;
    enableExecutionCancelling?: boolean;
    execution?: IPreparedExecution | IExecutionConfiguration;
    window?: DataViewWindow;
    workspace?: string;
}

// @public
export interface IUseInsightDataViewConfig {
    backend?: IAnalyticalBackend;
    dateFormat?: string | ((def: IExecutionDefinition) => string);
    dimensions?: IDimension[] | ((def: IExecutionDefinition) => IDimension[]);
    enableExecutionCancelling?: boolean;
    executeByReference?: boolean;
    filters?: INullableFilter[];
    insight?: ObjRef;
    sorts?: ISortItem[] | ((def: IExecutionDefinition) => ISortItem[]);
    window?: DataViewWindow;
    workspace?: string;
}

// @public (undocumented)
export interface IUsePagedResourceResult<TItem> extends IUsePagedResourceState<TItem> {
    // (undocumented)
    isLoading: boolean;
}

// @public (undocumented)
export interface IUsePagedResourceState<TItem> {
    // (undocumented)
    items: Array<TItem | undefined>;
    // (undocumented)
    totalItemsCount: number | undefined;
}

// @public
export type IUsePlaceholderHook<T extends IPlaceholder<any>> = () => [
PlaceholderValue<T> | undefined,
(valueOrUpdateCallback: ValueOrUpdateCallback<PlaceholderValue<T> | undefined>) => void
];

// @internal (undocumented)
export type IValidationContextValue<T extends IInvalidNode> = {
    rootNode: T;
    setInvalidDatapoints: <P extends IInvalidNodePath<T>>(setter: (currentNode: IInvalidNodeAtPath<T, P>) => Array<IInvalidDatapoint | undefined | null | false>, path?: P) => void;
    getInvalidDatapoints: <P extends IInvalidNodePath<T>>(args?: {
        path?: P;
        recursive?: boolean;
    }) => IInvalidDatapoint[];
    isValid: boolean;
    registerChild: (child: IInvalidNode) => () => void;
};

// @internal (undocumented)
export type IValidationSeverity = "error" | "warning" | "info";

// @public
export interface IVisualizationCallbacks {
    // @internal (undocumented)
    afterRender?: () => void;
    // @alpha
    onDataView?: OnDataView;
    onDrill?: OnFiredDrillEvent;
    onError?: OnError;
    onExportReady?: OnExportReady;
    onLoadingChanged?: OnLoadingChanged;
    // @internal (undocumented)
    pushData?: (data: IPushData) => void;
}

// @public
export interface IVisualizationProps {
    drillableItems?: ExplicitDrill[];
    ErrorComponent?: ComponentType<IErrorProps>;
    exportTitle?: string;
    LoadingComponent?: ComponentType<ILoadingProps>;
    locale?: string;
}

// @internal (undocumented)
export type IWidgetUrlBuilder = (workspaceId?: string, dashboardId?: string, widgetId?: string, tabId?: string) => string | undefined;

// @internal
export interface IWithExecution<T> {
    enableExecutionCancelling?: boolean | ((props: T) => boolean);
    events?: IWithLoadingEvents<T> | ((props: T) => IWithLoadingEvents<T>);
    execution: IPreparedExecution | ((props: T) => IPreparedExecution) | ((props: T) => Promise<IPreparedExecution>);
    exportTitle: string | ((props: T) => string);
    loadOnMount?: boolean | ((props: T) => boolean);
    shouldRefetch?: (prevProps: T, nextProps: T) => boolean;
    window?: DataViewWindow | ((props: T) => DataViewWindow | undefined);
}

// @internal
export interface IWithExecutionLoading<TProps> {
    enableExecutionCancelling?: boolean | ((props: TProps) => boolean);
    events?: IWithLoadingEvents<TProps> | ((props: TProps) => IWithLoadingEvents<TProps>);
    exportTitle: string | ((props: TProps) => string);
    loadOnMount?: boolean | ((props: TProps) => boolean);
    promiseFactory: (props: TProps, window?: DataViewWindow, signal?: AbortSignal) => Promise<DataViewFacade>;
    shouldRefetch?: (prevProps: TProps, nextProps: TProps) => boolean;
    window?: DataViewWindow | ((props: TProps) => DataViewWindow | undefined);
}

// @public (undocumented)
export interface IWithLoadingEvents<TProps> {
    onError?: (error: GoodDataSdkError, props: TProps) => void;
    onExportReady?: (exportFunction: IExportFunction, props: TProps) => void;
    onLoadingChanged?: (isLoading: boolean, props: TProps) => void;
    onLoadingFinish?: (result: DataViewFacade, props: TProps) => void;
    onLoadingStart?: (props: TProps) => void;
}

// @public
export interface IWorkspaceProviderProps {
    children?: ReactNode;
    workspace: string;
}

// @public
export const Kpi: ComponentType<IKpiProps>;

// @public
export function LoadingComponent({ className, color, speed, inline, height, width, imageHeight, imageWidth, }: ILoadingProps): JSX.Element;

// @internal
export const LOCALES: string[];

// @public
export function localIdentifierMatch(localIdOrMeasure: string | IMeasure): IHeaderPredicate;

// @internal
export function makeCancelable<T>(promise: (signal: AbortSignal) => Promise<T>, enableAbortController?: boolean): ICancelablePromise<T>;

// @public
export type MeasureOf<T extends IMeasureDefinitionType> = T extends any ? IMeasure<T> : never;

// @public
export type MeasureOrPlaceholder = ValueOrPlaceholder<AnyMeasure>;

// @public
export type MeasuresOrPlaceholders = ValuesOrPlaceholders<AnyMeasure>;

// @internal (undocumented)
export const messages: Record<string, MessageDescriptor>;

// @internal (undocumented)
export const navigate: (url?: string) => void;

// @public
export class NegativeValuesSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export function newComposedPlaceholder<TValue extends any[], TReturn = PlaceholdersResolvedValues<TValue>, TContext = UnionToIntersection<ComposedPlaceholderResolutionContext<Flatten<TValue>>>>(placeholders: [...TValue], computeValue?: (values: PlaceholdersResolvedValues<TValue>, resolutionContext: TContext) => TReturn): IComposedPlaceholder<TReturn, TValue, TContext>;

// @public
export function newErrorMapping(intl: IntlShape): IErrorDescriptors;

// @public
export function newPlaceholder<T>(defaultValue?: T, options?: IPlaceholderOptions<T>): IPlaceholder<T>;

// @public
export class NoDataSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export class NotFoundSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export type NullableFilterOrPlaceholder = FilterOrPlaceholder | ValueOrPlaceholder<INullableFilter> | ValueOrPlaceholder<IFilter | null> | ValueOrPlaceholder<IDateFilter | null> | ValueOrPlaceholder<IMeasureFilter | null> | ValueOrPlaceholder<IAttributeFilter | null> | ValueOrPlaceholder<IAbsoluteDateFilter | null> | ValueOrPlaceholder<IRelativeDateFilter | null> | ValueOrPlaceholder<IPositiveAttributeFilter | null> | ValueOrPlaceholder<INegativeAttributeFilter | null> | ValueOrPlaceholder<IMeasureValueFilter | null> | ValueOrPlaceholder<IRankingFilter | null>;

// @public
export type NullableFiltersOrPlaceholders = Array<FilterOrMultiValuePlaceholder | ValueOrMultiValuePlaceholder<INullableFilter> | ValueOrMultiValuePlaceholder<IFilter | null> | ValueOrMultiValuePlaceholder<IDateFilter | null> | ValueOrMultiValuePlaceholder<IMeasureFilter | null> | ValueOrMultiValuePlaceholder<IAttributeFilter | null> | ValueOrMultiValuePlaceholder<IAbsoluteDateFilter | null> | ValueOrMultiValuePlaceholder<IRelativeDateFilter | null> | ValueOrMultiValuePlaceholder<IPositiveAttributeFilter | null> | ValueOrMultiValuePlaceholder<INegativeAttributeFilter | null> | ValueOrMultiValuePlaceholder<IMeasureValueFilter | null> | ValueOrMultiValuePlaceholder<IRankingFilter | null>>;

// @public
export function objMatch(obj: any): IHeaderPredicate;

// @public
export function objRefMatch(objRef: ObjRef): IHeaderPredicate;

// @alpha (undocumented)
export type OnDataView = (dataView: DataViewFacade) => void;

// @public (undocumented)
export type OnError = (error: GoodDataSdkError) => void;

// @public (undocumented)
export type OnExportReady = (exportFunction: IExportFunction) => void;

// @public (undocumented)
export type OnFiredDrillEvent = IDrillEventCallback;

// @public (undocumented)
export type OnLoadingChanged = (loadingState: ILoadingState) => void;

// @public
export function OrganizationProvider({ organization, children }: IOrganizationProviderProps): JSX.Element;

// @internal (undocumented)
export type OverTimeComparisonType = "same_period_previous_year" | "previous_period" | "nothing";

// @internal (undocumented)
export const OverTimeComparisonTypes: {
    SAME_PERIOD_PREVIOUS_YEAR: "same_period_previous_year";
    PREVIOUS_PERIOD: "previous_period";
    NOTHING: "nothing";
};

// @public
export type PlaceholderOf<T> = T extends any ? AnyPlaceholder<T> : never;

// @public
export type PlaceholderResolvedValue<T> = T extends Array<infer A> ? Flatten<PlaceholderResolvedValue<A>>[] : T extends IPlaceholder<infer B> ? B : T extends IComposedPlaceholder<infer C, any, any> ? C : T;

// @public
export function PlaceholdersProvider({ children, initialValues }: IPlaceholdersProviderProps): ReactElement;

// @public
export type PlaceholdersResolvedValues<Tuple extends any[]> = {
    [Index in keyof Tuple]: PlaceholderResolvedValue<Tuple[Index]>;
};

// @public
export type PlaceholdersValues<Tuple extends [...any[]]> = {
    [Index in keyof Tuple]: PlaceholderValue<Tuple[Index]>;
};

// @public
export type PlaceholderValue<T> = T extends IPlaceholder<infer A> ? A : T extends IComposedPlaceholder<infer B, any, any> ? B : T;

// @public
export class ProtectedReportSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @internal (undocumented)
export type PushDataCallback = (data: IPushData) => void;

// @public
export const RawExecute: ComponentType<IRawExecuteProps>;

// @alpha
export function ResolvedClientWorkspaceProvider(props: IClientWorkspaceIdentifiers): JSX.Element;

// @alpha
export function resolveLCMWorkspaceIdentifiers(backend: any, { client, dataProduct, workspace }: IClientWorkspaceIdentifiers): IClientWorkspaceIdentifiers;

// @internal
export const resolveLocale: (locale: unknown) => ILocale;

// @internal
export const resolveLocaleDefaultMessages: (locale: string, messagesMap: {
    [locale: string]: ITranslations;
}) => ITranslations;

// @internal (undocumented)
export const resolveMessages: (locale: string) => Promise<ITranslations>;

// @public
export function resolveUseCancelablePromisesError<TError>(states: UseCancelablePromiseState<unknown, TError>[]): TError | undefined;

// @public
export function resolveUseCancelablePromisesStatus(cancelablePromisesStates: UseCancelablePromiseState<unknown, unknown>[], options?: {
    strategy?: "serial" | "parallel";
}): UseCancelablePromiseStatus;

// @public
export class ResultCacheMissingSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public (undocumented)
export type SdkErrorType = keyof typeof ErrorCodes;

// @public
export type SortsOrPlaceholders = ValuesOrPlaceholders<ISortItem>;

// @internal (undocumented)
export type Subtract<T, K> = Pick<T, Exclude<keyof T, keyof K>>;

// @public (undocumented)
export type TableElementType = "cell";

// @public (undocumented)
export type TableType = "table";

// @internal
export function totalColumnTitleFromIntl(intl: IntlShape): string;

// @public
export type TotalsOrPlaceholders = ValuesOrPlaceholders<ITotal>;

// @internal (undocumented)
export const TranslationsProvider: NamedExoticComponent<ITranslationsProviderProps>;

// @public
export class UnauthorizedSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
    // (undocumented)
    authenticationFlow?: AuthenticationFlow;
}

// @public
export class UnexpectedSdkError extends GoodDataSdkError {
    constructor(message?: string, cause?: Error);
}

// @public
export type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;

// @public
export function uriMatch(uri: string): IHeaderPredicate;

// @internal
export const useAutoupdateRef: <T>(value: T) => RefObject<T>;

// @public
export const useBackend: (backend?: IAnalyticalBackend) => IAnalyticalBackend | undefined;

// @public
export const useBackendStrict: (backend?: IAnalyticalBackend, context?: string) => IAnalyticalBackend;

// @public
export const useBackendWithCorrelation: (backend?: IAnalyticalBackend, correlationMetadata?: IRequestCorrelationMetadata) => IAnalyticalBackend | undefined;

// @public
export function useCancelablePromise<TResult, TError = any>(options: UseCancelablePromiseOptions<TResult, TError>, deps?: DependencyList): UseCancelablePromiseState<TResult, TError>;

// @public
export type UseCancelablePromiseCallbacks<TResult, TError> = {
    onLoading?: () => void;
    onPending?: () => void;
    onCancel?: () => void;
    onSuccess?: (result: TResult) => void;
    onError?: (err: TError) => void;
};

// @public
export type UseCancelablePromiseErrorState<TError> = {
    result: undefined;
    error: TError;
    status: "error";
};

// @public
export type UseCancelablePromiseLoadingState = {
    result: undefined;
    error: undefined;
    status: "loading";
};

// @public
export type UseCancelablePromiseOptions<TResult, TError> = UseCancelablePromiseCallbacks<TResult, TError> & {
    promise: ((signal: AbortSignal) => Promise<TResult>) | undefined | null;
    enableAbortController?: boolean;
};

// @public
export type UseCancelablePromisePendingState = {
    result: undefined;
    error: undefined;
    status: "pending";
};

// @public
export type UseCancelablePromiseState<TResult, TError> = UseCancelablePromisePendingState | UseCancelablePromiseLoadingState | UseCancelablePromiseErrorState<TError> | UseCancelablePromiseSuccessState<TResult>;

// @public
export type UseCancelablePromiseStatus = "success" | "error" | "loading" | "pending";

// @public
export type UseCancelablePromiseSuccessState<TResult> = {
    result: TResult;
    error: undefined;
    status: "success";
};

// @alpha
export const useClientWorkspaceError: () => GoodDataSdkError | undefined;

// @alpha
export const useClientWorkspaceIdentifiers: () => IClientWorkspaceIdentifiers;

// @alpha
export const useClientWorkspaceInitialized: () => boolean;

// @alpha
export const useClientWorkspaceStatus: () => UseCancelablePromiseStatus;

// @internal (undocumented)
export const useCombineRefs: <T>(...refs: Array<MutableRefObject<T> | ((instance: T) => void) | undefined | null | false>) => (instance: T) => void;

// @public
export function useComposedPlaceholder<TContext, TPlaceholder extends IComposedPlaceholder<any, any, TContext>>(placeholder: TPlaceholder, resolutionContext?: TContext): PlaceholderResolvedValue<TPlaceholder>;

// @public
export const useCorrelationData: () => Record<string, string>;

// @public
export function useDataExport({ execution, exportConfig, onCancel, onError, onLoading, onPending, onSuccess, }: {
    execution: IPreparedExecution | undefined | null;
    exportConfig?: IExportConfig;
} & UseDataExportCallbacks, deps?: DependencyList): UseDataExportState;

// @public
export type UseDataExportCallbacks = UseCancelablePromiseCallbacks<string, GoodDataSdkError>;

// @public
export type UseDataExportState = UseCancelablePromiseState<string, GoodDataSdkError>;

// @internal
export const useDebouncedState: <T>(initialValue: T, delay: number) => UseDebouncedStateOutput<T>;

// @internal
export type UseDebouncedStateOutput<T> = [
/**
* The current value.
*/
T,
(value: T) => void,
/**
* The debounced value.
*/
T,
(value: T) => void
];

// @public
export function useExecutionDataView(config: IUseExecutionDataViewConfig & UseExecutionDataViewCallbacks, deps?: DependencyList): UseCancelablePromiseState<DataViewFacade, GoodDataSdkError>;

// @public
export type UseExecutionDataViewCallbacks = UseCancelablePromiseCallbacks<DataViewFacade, GoodDataSdkError>;

// @public
export function useInsightDataView(config: IUseInsightDataViewConfig & UseInsightDataViewCallbacks, deps?: DependencyList): UseCancelablePromiseState<DataViewFacade, GoodDataSdkError>;

// @public
export type UseInsightDataViewCallbacks = UseCancelablePromiseCallbacks<DataViewFacade, GoodDataSdkError>;

// @public
export const useLocalStorage: <T>(key: string, initialValue: T) => [T, (value: T) => void];

// @internal
export function useObjectDiff(obj: Record<string, any>, equalityFn?: (A: any, B: any) => boolean): {
    hasChanged: boolean;
    DEEP_CHANGES?: Record<string, any> | undefined;
    CHANGED?: string[] | undefined;
    REMOVED?: string[] | undefined;
    NEW?: string[] | undefined;
};

// @public
export const useOrganization: () => string | undefined;

// @public
export function usePagedResource<TParams, TItem>(resourceFactory: (params: TParams) => Promise<IPagedResource<TItem>>, fetchParams: TParams[], fetchDeps: DependencyList, resetDeps: DependencyList, getCacheKey?: (params: TParams) => string, initialState?: IUsePagedResourceState<TItem>, preventResetPromises?: boolean): IUsePagedResourceResult<TItem>;

// @public
export function usePlaceholder<T extends IPlaceholder<any>>(placeholder?: T): [
PlaceholderValue<T> | undefined,
(valueOrUpdateCallback: ValueOrUpdateCallback<PlaceholderValue<T> | undefined>) => void
];

// @public
export function usePlaceholders<T extends IPlaceholder<any>[]>(placeholders: [...T]): [PlaceholdersValues<T>, (valueOrUpdateCallback: ValueOrUpdateCallback<PlaceholdersValues<T>>) => void];

// @internal
export const usePrevious: <T>(value: T) => T;

// @internal
export const usePropState: <T>(prop: T) => readonly [T, Dispatch<SetStateAction<T>>];

// @internal (undocumented)
export function useResolveMessages(locale: ILocale, resolveMessages: (locale: string) => Promise<ITranslations>, defaultMessages: Record<string, ITranslations>): Record<string, ITranslations>;

// @public
export function useResolveValuesWithPlaceholders<T extends any[], C>(values: [...T], resolutionContext?: C): PlaceholdersResolvedValues<T>;

// @public
export function useResolveValueWithPlaceholders<T, C>(value: T, resolutionContext?: C): PlaceholderResolvedValue<T>;

// @internal (undocumented)
export const useValidationContextValue: <T extends IInvalidNode>(initialValue: T) => IValidationContextValue<T>;

// @public
export const useWorkspace: (workspace?: string) => string | undefined;

// @public
export const useWorkspaceStrict: (workspace?: string, context?: string) => string;

// @internal (undocumented)
export const ValidationContextStore: IContextStore<IValidationContextValue<any>>;

// @internal (undocumented)
export const validationSeverity: ["info", "warning", "error"];

// @public (undocumented)
export type ValueFormatter = (value: DataValue, format: string) => string;

// @public (undocumented)
export type ValueOrMultiValuePlaceholder<T> = ValueOrPlaceholder<T> | AnyPlaceholderOf<T[]>;

// @public
export type ValueOrPlaceholder<T> = T | AnyPlaceholderOf<T>;

// @public
export type ValuesOrPlaceholders<T> = AnyArrayOf<ValueOrMultiValuePlaceholder<T>>;

// @public (undocumented)
export type VisElementType = ChartElementType | HeadlineElementType | TableElementType | "pushpin";

// @public (undocumented)
export type VisType = ChartType | HeadlineType | TableType | XirrType;

// @internal (undocumented)
export type VisualizationEnvironment = "none" | "dashboards" | "analyticalDesigner";

// @internal (undocumented)
export function visualizationIsBetaWarning(): void;

// @internal (undocumented)
export const VisualizationTypes: {
    BAR: "bar";
    COLUMN: "column";
    LINE: "line";
    PIE: "pie";
    DONUT: "donut";
    TABLE: "table";
    HEADLINE: "headline";
    AREA: "area";
    SCATTER: "scatter";
    BUBBLE: "bubble";
    HEATMAP: "heatmap";
    GEO: "geo";
    PUSHPIN: "pushpin";
    CHOROPLETH: "choropleth";
    COMBO: "combo";
    COMBO2: "combo2";
    HISTOGRAM: "histogram";
    BULLET: "bullet";
    TREEMAP: "treemap";
    WATERFALL: "waterfall";
    FUNNEL: "funnel";
    PYRAMID: "pyramid";
    PARETO: "pareto";
    ALLUVIAL: "alluvial";
    SANKEY: "sankey";
    DEPENDENCY_WHEEL: "dependencywheel";
    XIRR: "xirr";
    REPEATER: "repeater";
};

// @internal
export function withBackend<T extends {
    backend?: IAnalyticalBackend;
}>(Component: ComponentType<T>): ComponentType<T>;

// @internal
export function withContexts<T extends {
    backend?: IAnalyticalBackend;
    workspace?: string;
}>(Chart: ComponentType<T>): ComponentType<T>;

// @internal
export function withEntireDataView<T extends IDataVisualizationProps>(InnerComponent: ComponentType<T & ILoadingInjectedProps>): ComponentType<T>;

// @internal
export function withExecution<T>({ execution, events, loadOnMount, shouldRefetch, window, exportTitle, enableExecutionCancelling, }: IWithExecution<T>): (WrappedComponent: ComponentType<T & WithLoadingResult>) => ComponentType<T>;

// @internal
export function withExecutionLoading<TProps>({ promiseFactory, loadOnMount, events, shouldRefetch, window, exportTitle, enableExecutionCancelling, }: IWithExecutionLoading<TProps>): (WrappedComponent: ComponentType<TProps & WithLoadingResult>) => ComponentType<TProps>;

// @internal (undocumented)
export function withIntl<P>(WrappedComponent: FC<P> | ComponentClass<P>, customLocale?: ILocale, customMessages?: ITranslations): ComponentType<P>;

// @internal (undocumented)
export function withIntlForTest<P>(WrappedComponent: FC<P> | ComponentClass<P>, customLocale?: ILocale, customMessages?: ITranslations): ComponentType<P>;

// @public (undocumented)
export type WithLoadingResult = {
    result: DataViewFacade | undefined;
    error: GoodDataSdkError | undefined;
    isLoading: boolean;
    reload: () => void;
};

// @internal
export function withWorkspace<T extends {
    workspace?: string;
}>(Component: ComponentType<T>): ComponentType<T>;

// @public
export function WorkspaceProvider({ children, workspace }: IWorkspaceProviderProps): JSX.Element;

// @internal
export const wrapDisplayName: (hocName: string, BaseComponent?: ComponentType<any>) => (<T>(Component: ComponentType<T>) => ComponentType<T>);

// @public (undocumented)
export type XirrType = "xirr";

```
