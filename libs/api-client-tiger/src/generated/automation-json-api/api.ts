// (C) 2025 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 */
export interface AutomationAFM {
    /**
     * Attributes to be used in the computation.
     */
    attributes: Array<AutomationAttributeItem>;
    /**
     * Various filter types to filter the execution result.
     */
    filters: Array<AutomationAFMFiltersInner>;
    /**
     * Metrics to be computed.
     */
    measures: Array<AutomationMeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     */
    auxMeasures?: Array<AutomationMeasureItem>;
}
/**
 * @type AutomationAFMFiltersInner
 */
export type AutomationAFMFiltersInner =
    | AutomationAbstractMeasureValueFilter
    | AutomationFilterDefinitionForSimpleMeasure
    | AutomationInlineFilterDefinition;

/**
 * A datetime filter specifying exact from and to values.
 */
export interface AutomationAbsoluteDateFilter {
    absoluteDateFilter: AutomationAbsoluteDateFilterAbsoluteDateFilter;
}
export interface AutomationAbsoluteDateFilterAbsoluteDateFilter {
    from: string;
    to: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
    dataset: AutomationAfmObjectIdentifierDataset;
}
/**
 * @type AutomationAbstractMeasureValueFilter
 */
export type AutomationAbstractMeasureValueFilter =
    | AutomationComparisonMeasureValueFilter
    | AutomationRangeMeasureValueFilter
    | AutomationRankingFilter;

export interface AutomationAdHocAutomation {
    title?: string;
    description?: string;
    /**
     * A list of tags.
     */
    tags?: Array<string>;
    /**
     * Additional details to be included in the automated message.
     */
    details?: { [key: string]: string };
    metadata?: AutomationAutomationMetadata | null;
    alert?: AutomationAutomationAlert;
    tabularExports?: Array<AutomationAutomationTabularExport>;
    visualExports?: Array<AutomationAutomationVisualExport>;
    imageExports?: Array<AutomationAutomationImageExport>;
    rawExports?: Array<AutomationAutomationRawExport>;
    slidesExports?: Array<AutomationAutomationSlidesExport>;
    dashboardTabularExports?: Array<AutomationAutomationDashboardTabularExport>;
    /**
     * External recipients of the automation action results.
     */
    externalRecipients?: Array<AutomationAutomationExternalRecipient>;
    notificationChannel?: AutomationDeclarativeNotificationChannelIdentifier;
    recipients?: Array<AutomationDeclarativeUserIdentifier>;
    analyticalDashboard?: AutomationDeclarativeAnalyticalDashboardIdentifier;
}
/**
 * @type AutomationAfmIdentifier
 * Reference to the attribute label to which the filter should be applied.
 */
export type AutomationAfmIdentifier = AutomationAfmLocalIdentifier | AutomationAfmObjectIdentifier;

export interface AutomationAfmLocalIdentifier {
    localIdentifier: string;
}
/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 */
export interface AutomationAfmObjectIdentifier {
    identifier: AutomationAfmObjectIdentifierIdentifier;
}
/**
 * Reference to the date attribute to use.
 */
export interface AutomationAfmObjectIdentifierAttribute {
    identifier: AutomationAfmObjectIdentifierAttributeIdentifier;
}
export interface AutomationAfmObjectIdentifierAttributeIdentifier {
    id: string;
    type: AutomationAfmObjectIdentifierAttributeIdentifierTypeEnum;
}

export const AutomationAfmObjectIdentifierAttributeIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
} as const;

export type AutomationAfmObjectIdentifierAttributeIdentifierTypeEnum =
    (typeof AutomationAfmObjectIdentifierAttributeIdentifierTypeEnum)[keyof typeof AutomationAfmObjectIdentifierAttributeIdentifierTypeEnum];

/**
 * Reference to the metric, fact or attribute object to use for the metric.
 */
export interface AutomationAfmObjectIdentifierCore {
    identifier: AutomationAfmObjectIdentifierCoreIdentifier;
}
export interface AutomationAfmObjectIdentifierCoreIdentifier {
    id: string;
    type: AutomationAfmObjectIdentifierCoreIdentifierTypeEnum;
}

export const AutomationAfmObjectIdentifierCoreIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
    LABEL: "label",
    FACT: "fact",
    METRIC: "metric",
} as const;

export type AutomationAfmObjectIdentifierCoreIdentifierTypeEnum =
    (typeof AutomationAfmObjectIdentifierCoreIdentifierTypeEnum)[keyof typeof AutomationAfmObjectIdentifierCoreIdentifierTypeEnum];

/**
 * Reference to the date dataset to which the filter should be applied.
 */
export interface AutomationAfmObjectIdentifierDataset {
    identifier: AutomationAfmObjectIdentifierDatasetIdentifier;
}
export interface AutomationAfmObjectIdentifierDatasetIdentifier {
    id: string;
    type: AutomationAfmObjectIdentifierDatasetIdentifierTypeEnum;
}

export const AutomationAfmObjectIdentifierDatasetIdentifierTypeEnum = {
    DATASET: "dataset",
} as const;

export type AutomationAfmObjectIdentifierDatasetIdentifierTypeEnum =
    (typeof AutomationAfmObjectIdentifierDatasetIdentifierTypeEnum)[keyof typeof AutomationAfmObjectIdentifierDatasetIdentifierTypeEnum];

export interface AutomationAfmObjectIdentifierIdentifier {
    type: AutomationAfmObjectIdentifierIdentifierTypeEnum;
    id: string;
}

export const AutomationAfmObjectIdentifierIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
} as const;

export type AutomationAfmObjectIdentifierIdentifierTypeEnum =
    (typeof AutomationAfmObjectIdentifierIdentifierTypeEnum)[keyof typeof AutomationAfmObjectIdentifierIdentifierTypeEnum];

export interface AutomationAfmObjectIdentifierLabel {
    identifier: AutomationAfmObjectIdentifierLabelIdentifier;
}
export interface AutomationAfmObjectIdentifierLabelIdentifier {
    type: AutomationAfmObjectIdentifierLabelIdentifierTypeEnum;
    id: string;
}

export const AutomationAfmObjectIdentifierLabelIdentifierTypeEnum = {
    LABEL: "label",
} as const;

export type AutomationAfmObjectIdentifierLabelIdentifierTypeEnum =
    (typeof AutomationAfmObjectIdentifierLabelIdentifierTypeEnum)[keyof typeof AutomationAfmObjectIdentifierLabelIdentifierTypeEnum];

export interface AutomationAlertAfm {
    /**
     * Attributes to be used in the computation.
     */
    attributes?: Array<AutomationAttributeItem>;
    /**
     * Various filter types to filter execution result.
     */
    filters: Array<AutomationFilterDefinition>;
    /**
     * Metrics to be computed. One metric if the alert condition is evaluated to a scalar. Two metrics when they should be evaluated to each other.
     */
    measures: Array<AutomationMeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     */
    auxMeasures?: Array<AutomationMeasureItem>;
}
/**
 * @type AutomationAlertCondition
 * Alert trigger condition.
 */
export type AutomationAlertCondition =
    | AutomationComparisonWrapper
    | AutomationRangeWrapper
    | AutomationRelativeWrapper;

/**
 * @type AutomationAlertConditionOperand
 * Operand of the alert condition.
 */
export type AutomationAlertConditionOperand = AutomationLocalIdentifier | AutomationValue;

export interface AutomationAlertDescription {
    metric: string;
    condition: string;
    currentValues?: Array<AutomationAlertEvaluationRow>;
    attribute?: string;
    totalValueCount?: number;
    triggeredCount?: number;
    triggeredAt?: string;
    threshold?: number;
    formattedThreshold?: string;
    lowerThreshold?: number;
    upperThreshold?: number;
    remainingAlertEvaluationCount?: number;
    status?: AutomationAlertDescriptionStatusEnum;
    errorMessage?: string;
    traceId?: string;
}

export const AutomationAlertDescriptionStatusEnum = {
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    INTERNAL_ERROR: "INTERNAL_ERROR",
    TIMEOUT: "TIMEOUT",
} as const;

export type AutomationAlertDescriptionStatusEnum =
    (typeof AutomationAlertDescriptionStatusEnum)[keyof typeof AutomationAlertDescriptionStatusEnum];

export interface AutomationAlertEvaluationRow {
    primaryMetric?: AutomationMetricRecord;
    secondaryMetric?: AutomationMetricRecord;
    computedMetric?: AutomationMetricRecord;
    labelValue?: string;
}
export interface AutomationArithmeticMeasure {
    /**
     * Arithmetic operator. DIFFERENCE - m₁−m₂ - the difference between two metrics. CHANGE - (m₁−m₂)÷m₂ - the relative difference between two metrics.
     */
    operator: AutomationArithmeticMeasureOperatorEnum;
    left: AutomationLocalIdentifier;
    right: AutomationLocalIdentifier;
}

export const AutomationArithmeticMeasureOperatorEnum = {
    DIFFERENCE: "DIFFERENCE",
    CHANGE: "CHANGE",
} as const;

export type AutomationArithmeticMeasureOperatorEnum =
    (typeof AutomationArithmeticMeasureOperatorEnum)[keyof typeof AutomationArithmeticMeasureOperatorEnum];

/**
 * Metric representing arithmetics between other metrics.
 */
export interface AutomationArithmeticMeasureDefinition {
    arithmeticMeasure: AutomationArithmeticMeasureDefinitionArithmeticMeasure;
}
export interface AutomationArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of metrics to apply arithmetic operation by chosen operator.
     */
    measureIdentifiers: Array<AutomationAfmLocalIdentifier>;
    /**
     * Arithmetic operator describing operation between metrics.
     */
    operator: AutomationArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

export const AutomationArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum = {
    SUM: "SUM",
    DIFFERENCE: "DIFFERENCE",
    MULTIPLICATION: "MULTIPLICATION",
    RATIO: "RATIO",
    CHANGE: "CHANGE",
} as const;

export type AutomationArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum =
    (typeof AutomationArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum)[keyof typeof AutomationArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum];

/**
 * @type AutomationAttributeElements
 */
export type AutomationAttributeElements =
    | AutomationAttributeElementsByRef
    | AutomationAttributeElementsByValue;

export interface AutomationAttributeElementsByRef {
    /**
     * List of attribute elements by reference
     */
    uris: Array<string | null>;
}
export interface AutomationAttributeElementsByValue {
    /**
     * List of attribute elements by value
     */
    values: Array<string | null>;
}
/**
 * @type AutomationAttributeFilter
 * Abstract filter definition type attributes
 */
export type AutomationAttributeFilter = AutomationNegativeAttributeFilter | AutomationPositiveAttributeFilter;

export interface AutomationAttributeFilterByDate {
    filterLocalIdentifier: string;
    isCommonDate: boolean;
}
/**
 * Filter on specific set of label values.
 */
export interface AutomationAttributeFilterElements {
    /**
     * Set of label values.
     */
    values: Array<string | null>;
}
export interface AutomationAttributeFilterParent {
    filterLocalIdentifier: string;
    over: AutomationOver;
}
export interface AutomationAttributeItem {
    /**
     * Local identifier of the attribute. This can be used to reference the attribute in other parts of the execution definition.
     */
    localIdentifier: string;
    label: AutomationAfmObjectIdentifierLabel;
    /**
     * Indicates whether to show all values of given attribute even if the data bound to those values is not available.
     */
    showAllValues?: boolean;
}
export interface AutomationAutomationAlert {
    execution: AutomationAlertAfm;
    condition: AutomationAutomationAlertCondition;
    /**
     * Trigger behavior for the alert. ALWAYS - alert is triggered every time the condition is met. ONCE - alert is triggered only once when the condition is met.
     */
    trigger?: AutomationAutomationAlertTriggerEnum;
}

export const AutomationAutomationAlertTriggerEnum = {
    ALWAYS: "ALWAYS",
    ONCE: "ONCE",
} as const;

export type AutomationAutomationAlertTriggerEnum =
    (typeof AutomationAutomationAlertTriggerEnum)[keyof typeof AutomationAutomationAlertTriggerEnum];

/**
 * @type AutomationAutomationAlertCondition
 */
export type AutomationAutomationAlertCondition =
    | AutomationComparisonWrapper
    | AutomationRangeWrapper
    | AutomationRelativeWrapper;

export interface AutomationAutomationDashboardTabularExport {
    requestPayload: AutomationDashboardTabularExportRequestV2;
}
export interface AutomationAutomationExternalRecipient {
    /**
     * E-mail address to send notifications from.
     */
    email: string;
}
export interface AutomationAutomationImageExport {
    requestPayload: AutomationImageExportRequest;
}
/**
 * Additional information for the automation.
 */
export interface AutomationAutomationMetadata {
    [key: string]: any;

    widget?: string;
    visibleFilters?: Array<AutomationVisibleFilter>;
}
export interface AutomationAutomationNotification extends AutomationNotificationContent {
    content: AutomationWebhookMessage;
}
export interface AutomationAutomationRawExport {
    requestPayload: AutomationRawExportAutomationRequest;
}
export interface AutomationAutomationSlidesExport {
    requestPayload: AutomationSlidesExportRequest;
}
export interface AutomationAutomationTabularExport {
    requestPayload: AutomationTabularExportRequest;
}
export interface AutomationAutomationVisualExport {
    requestPayload: AutomationVisualExportRequest;
}
/**
 * Bounding filter for this relative date filter. This can be used to limit the range of the relative date filter to a specific date range.
 */
export interface AutomationBoundedFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: AutomationBoundedFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\'). If null, then start of the range is unbounded.
     */
    from?: number | null;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...). If null, then end of the range is unbounded.
     */
    to?: number | null;
}

export const AutomationBoundedFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_QUARTER: "DAY_OF_QUARTER",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type AutomationBoundedFilterGranularityEnum =
    (typeof AutomationBoundedFilterGranularityEnum)[keyof typeof AutomationBoundedFilterGranularityEnum];

export interface AutomationComparison {
    operator: AutomationComparisonOperatorEnum;
    left: AutomationLocalIdentifier;
    right: AutomationAlertConditionOperand;
}

export const AutomationComparisonOperatorEnum = {
    GREATER_THAN: "GREATER_THAN",
    GREATER_THAN_OR_EQUAL_TO: "GREATER_THAN_OR_EQUAL_TO",
    LESS_THAN: "LESS_THAN",
    LESS_THAN_OR_EQUAL_TO: "LESS_THAN_OR_EQUAL_TO",
    EQUAL_TO: "EQUAL_TO",
    NOT_EQUAL_TO: "NOT_EQUAL_TO",
} as const;

export type AutomationComparisonOperatorEnum =
    (typeof AutomationComparisonOperatorEnum)[keyof typeof AutomationComparisonOperatorEnum];

/**
 * Filter the result by comparing specified metric to given constant value, using given comparison operator.
 */
export interface AutomationComparisonMeasureValueFilter {
    comparisonMeasureValueFilter: AutomationComparisonMeasureValueFilterComparisonMeasureValueFilter;
}
export interface AutomationComparisonMeasureValueFilterComparisonMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AutomationAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: AutomationComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum;
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: AutomationAfmIdentifier;
}

export const AutomationComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum = {
    GREATER_THAN: "GREATER_THAN",
    GREATER_THAN_OR_EQUAL_TO: "GREATER_THAN_OR_EQUAL_TO",
    LESS_THAN: "LESS_THAN",
    LESS_THAN_OR_EQUAL_TO: "LESS_THAN_OR_EQUAL_TO",
    EQUAL_TO: "EQUAL_TO",
    NOT_EQUAL_TO: "NOT_EQUAL_TO",
} as const;

export type AutomationComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum =
    (typeof AutomationComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum)[keyof typeof AutomationComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum];

export interface AutomationComparisonWrapper {
    comparison: AutomationComparison;
}
/**
 * Custom label object override.
 */
export interface AutomationCustomLabel {
    /**
     * Override value.
     */
    title: string;
}
/**
 * Custom metric object override.
 */
export interface AutomationCustomMetric {
    /**
     * Metric title override.
     */
    title: string;
    /**
     * Format override.
     */
    format: string;
}
/**
 * Custom cell value overrides (IDs will be replaced with specified values).
 */
export interface AutomationCustomOverride {
    /**
     * Map of CustomLabels with keys used as placeholders in document.
     */
    labels?: { [key: string]: AutomationCustomLabel };
    /**
     * Map of CustomMetrics with keys used as placeholders in document.
     */
    metrics?: { [key: string]: AutomationCustomMetric };
}
export interface AutomationDashboardAttributeFilter {
    attributeFilter: AutomationDashboardAttributeFilterAttributeFilter;
}
export interface AutomationDashboardAttributeFilterAttributeFilter {
    displayForm: AutomationIdentifierRef;
    negativeSelection: boolean;
    attributeElements: AutomationAttributeElements;
    filterElementsBy?: Array<AutomationAttributeFilterParent>;
    filterElementsByDate?: Array<AutomationAttributeFilterByDate>;
    validateElementsBy?: Array<AutomationIdentifierRef>;
    title?: string;
    selectionMode?: AutomationDashboardAttributeFilterAttributeFilterSelectionModeEnum;
    localIdentifier?: string;
}

export const AutomationDashboardAttributeFilterAttributeFilterSelectionModeEnum = {
    SINGLE: "single",
    MULTI: "multi",
} as const;

export type AutomationDashboardAttributeFilterAttributeFilterSelectionModeEnum =
    (typeof AutomationDashboardAttributeFilterAttributeFilterSelectionModeEnum)[keyof typeof AutomationDashboardAttributeFilterAttributeFilterSelectionModeEnum];

export interface AutomationDashboardDateFilter {
    dateFilter: AutomationDashboardDateFilterDateFilter;
}
export interface AutomationDashboardDateFilterDateFilter {
    type: AutomationDashboardDateFilterDateFilterTypeEnum;
    granularity: AutomationDashboardDateFilterDateFilterGranularityEnum;
    from?: AutomationDashboardDateFilterDateFilterFrom;
    to?: AutomationDashboardDateFilterDateFilterFrom;
    dataSet?: AutomationIdentifierRef;
    attribute?: AutomationIdentifierRef;
    boundedFilter?: AutomationRelativeBoundedDateFilter;
    localIdentifier?: string;
}

export const AutomationDashboardDateFilterDateFilterTypeEnum = {
    RELATIVE: "relative",
    ABSOLUTE: "absolute",
} as const;

export type AutomationDashboardDateFilterDateFilterTypeEnum =
    (typeof AutomationDashboardDateFilterDateFilterTypeEnum)[keyof typeof AutomationDashboardDateFilterDateFilterTypeEnum];
export const AutomationDashboardDateFilterDateFilterGranularityEnum = {
    ALL_TIME_GRANULARITY: "ALL_TIME_GRANULARITY",
    GDC_TIME_YEAR: "GDC.time.year",
    GDC_TIME_WEEK_US: "GDC.time.week_us",
    GDC_TIME_WEEK_IN_YEAR: "GDC.time.week_in_year",
    GDC_TIME_WEEK_IN_QUARTER: "GDC.time.week_in_quarter",
    GDC_TIME_WEEK: "GDC.time.week",
    GDC_TIME_EUWEEK_IN_YEAR: "GDC.time.euweek_in_year",
    GDC_TIME_EUWEEK_IN_QUARTER: "GDC.time.euweek_in_quarter",
    GDC_TIME_QUARTER: "GDC.time.quarter",
    GDC_TIME_QUARTER_IN_YEAR: "GDC.time.quarter_in_year",
    GDC_TIME_MONTH: "GDC.time.month",
    GDC_TIME_MONTH_IN_QUARTER: "GDC.time.month_in_quarter",
    GDC_TIME_MONTH_IN_YEAR: "GDC.time.month_in_year",
    GDC_TIME_DAY_IN_YEAR: "GDC.time.day_in_year",
    GDC_TIME_DAY_IN_QUARTER: "GDC.time.day_in_quarter",
    GDC_TIME_DAY_IN_MONTH: "GDC.time.day_in_month",
    GDC_TIME_DAY_IN_WEEK: "GDC.time.day_in_week",
    GDC_TIME_DAY_IN_EUWEEK: "GDC.time.day_in_euweek",
    GDC_TIME_DATE: "GDC.time.date",
    GDC_TIME_HOUR: "GDC.time.hour",
    GDC_TIME_HOUR_IN_DAY: "GDC.time.hour_in_day",
    GDC_TIME_MINUTE: "GDC.time.minute",
    GDC_TIME_MINUTE_IN_HOUR: "GDC.time.minute_in_hour",
} as const;

export type AutomationDashboardDateFilterDateFilterGranularityEnum =
    (typeof AutomationDashboardDateFilterDateFilterGranularityEnum)[keyof typeof AutomationDashboardDateFilterDateFilterGranularityEnum];

/**
 * @type AutomationDashboardDateFilterDateFilterFrom
 */
export type AutomationDashboardDateFilterDateFilterFrom = number | string;

/**
 * Additional settings.
 */
export interface AutomationDashboardExportSettings {
    /**
     * If true, the export will contain the information about the export – exported date, dashboard filters, etc.
     */
    exportInfo?: boolean;
    /**
     * Merge equal headers in neighbouring cells. Used for [XLSX] format only.
     */
    mergeHeaders?: boolean;
    /**
     * Set page size. (PDF)
     */
    pageSize?: AutomationDashboardExportSettingsPageSizeEnum;
    /**
     * Set page orientation. (PDF)
     */
    pageOrientation?: AutomationDashboardExportSettingsPageOrientationEnum;
}

export const AutomationDashboardExportSettingsPageSizeEnum = {
    A3: "A3",
    A4: "A4",
    LETTER: "LETTER",
} as const;

export type AutomationDashboardExportSettingsPageSizeEnum =
    (typeof AutomationDashboardExportSettingsPageSizeEnum)[keyof typeof AutomationDashboardExportSettingsPageSizeEnum];
export const AutomationDashboardExportSettingsPageOrientationEnum = {
    PORTRAIT: "PORTRAIT",
    LANDSCAPE: "LANDSCAPE",
} as const;

export type AutomationDashboardExportSettingsPageOrientationEnum =
    (typeof AutomationDashboardExportSettingsPageOrientationEnum)[keyof typeof AutomationDashboardExportSettingsPageOrientationEnum];

/**
 * @type AutomationDashboardFilter
 */
export type AutomationDashboardFilter = AutomationDashboardAttributeFilter | AutomationDashboardDateFilter;

/**
 * Export request object describing the export properties for dashboard tabular exports (v2 with dashboardId).
 */
export interface AutomationDashboardTabularExportRequestV2 {
    /**
     * Requested tabular export type.
     */
    format: AutomationDashboardTabularExportRequestV2FormatEnum;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    /**
     * List of filters that will be used instead of the default dashboard filters.
     */
    dashboardFiltersOverride?: Array<AutomationDashboardFilter>;
    /**
     * Dashboard identifier
     */
    dashboardId: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds?: Array<string>;
    settings?: AutomationDashboardExportSettings;
}

export const AutomationDashboardTabularExportRequestV2FormatEnum = {
    XLSX: "XLSX",
    PDF: "PDF",
} as const;

export type AutomationDashboardTabularExportRequestV2FormatEnum =
    (typeof AutomationDashboardTabularExportRequestV2FormatEnum)[keyof typeof AutomationDashboardTabularExportRequestV2FormatEnum];

/**
 * @type AutomationDateFilter
 * Abstract filter definition type for dates.
 */
export type AutomationDateFilter = AutomationAbsoluteDateFilter | AutomationRelativeDateFilter;

export interface AutomationDateValue {
    value: string;
}
/**
 * An analytical dashboard identifier.
 */
export interface AutomationDeclarativeAnalyticalDashboardIdentifier {
    /**
     * Identifier of the analytical dashboard.
     */
    id: string;
    /**
     * A type.
     */
    type: AutomationDeclarativeAnalyticalDashboardIdentifierTypeEnum;
}

export const AutomationDeclarativeAnalyticalDashboardIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
} as const;

export type AutomationDeclarativeAnalyticalDashboardIdentifierTypeEnum =
    (typeof AutomationDeclarativeAnalyticalDashboardIdentifierTypeEnum)[keyof typeof AutomationDeclarativeAnalyticalDashboardIdentifierTypeEnum];

/**
 * A notification channel identifier.
 */
export interface AutomationDeclarativeNotificationChannelIdentifier {
    /**
     * Notification channel identifier.
     */
    id: string;
    /**
     * A type.
     */
    type: AutomationDeclarativeNotificationChannelIdentifierTypeEnum;
}

export const AutomationDeclarativeNotificationChannelIdentifierTypeEnum = {
    NOTIFICATION_CHANNEL: "notificationChannel",
} as const;

export type AutomationDeclarativeNotificationChannelIdentifierTypeEnum =
    (typeof AutomationDeclarativeNotificationChannelIdentifierTypeEnum)[keyof typeof AutomationDeclarativeNotificationChannelIdentifierTypeEnum];

/**
 * A user identifier.
 */
export interface AutomationDeclarativeUserIdentifier {
    /**
     * User identifier.
     */
    id: string;
    /**
     * A type.
     */
    type: AutomationDeclarativeUserIdentifierTypeEnum;
}

export const AutomationDeclarativeUserIdentifierTypeEnum = {
    USER: "user",
} as const;

export type AutomationDeclarativeUserIdentifierTypeEnum =
    (typeof AutomationDeclarativeUserIdentifierTypeEnum)[keyof typeof AutomationDeclarativeUserIdentifierTypeEnum];

/**
 * Default SMTP destination for notifications.
 */
export interface AutomationDefaultSmtp {
    /**
     * E-mail address to send notifications from. Currently this does not have any effect. E-mail \'no-reply@gooddata.com\' is used instead.
     */
    fromEmail?: string;
    /**
     * An optional e-mail name to send notifications from. Currently this does not have any effect. E-mail from name \'GoodData\' is used instead.
     */
    fromEmailName?: string;
    /**
     * The destination type.
     */
    type: AutomationDefaultSmtpTypeEnum;
}

export const AutomationDefaultSmtpTypeEnum = {
    DEFAULT_SMTP: "DEFAULT_SMTP",
} as const;

export type AutomationDefaultSmtpTypeEnum =
    (typeof AutomationDefaultSmtpTypeEnum)[keyof typeof AutomationDefaultSmtpTypeEnum];

/**
 * Various settings affecting the process of AFM execution or its result
 */
export interface AutomationExecutionSettings {
    /**
     * Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     */
    dataSamplingPercentage?: number;
    /**
     * Specifies the timestamp of the execution from which relative filters are resolved. If not set, the current time is used.
     */
    timestamp?: string;
}
export interface AutomationExportResult {
    fileName: string;
    exportId: string;
    status: AutomationExportResultStatusEnum;
    fileUri?: string;
    expiresAt?: string;
    fileSize?: number;
    errorMessage?: string;
    traceId?: string;
    triggeredAt?: string;
}

export const AutomationExportResultStatusEnum = {
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    INTERNAL_ERROR: "INTERNAL_ERROR",
    TIMEOUT: "TIMEOUT",
} as const;

export type AutomationExportResultStatusEnum =
    (typeof AutomationExportResultStatusEnum)[keyof typeof AutomationExportResultStatusEnum];

/**
 * @type AutomationFilterDefinition
 * Abstract filter definition type
 */
export type AutomationFilterDefinition =
    | AutomationAbsoluteDateFilter
    | AutomationComparisonMeasureValueFilter
    | AutomationInlineFilterDefinition
    | AutomationNegativeAttributeFilter
    | AutomationPositiveAttributeFilter
    | AutomationRangeMeasureValueFilter
    | AutomationRankingFilter
    | AutomationRelativeDateFilter;

/**
 * @type AutomationFilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple metric.
 */
export type AutomationFilterDefinitionForSimpleMeasure = AutomationAttributeFilter | AutomationDateFilter;

export interface AutomationIdentifierRef {
    identifier?: AutomationIdentifierRefIdentifier;
}
export interface AutomationIdentifierRefIdentifier {
    id: string;
    type: AutomationIdentifierRefIdentifierTypeEnum;
}

export const AutomationIdentifierRefIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    ATTRIBUTE_HIERARCHY: "attributeHierarchy",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    AGGREGATED_FACT: "aggregatedFact",
    LABEL: "label",
    METRIC: "metric",
    USER_DATA_FILTER: "userDataFilter",
    EXPORT_DEFINITION: "exportDefinition",
    AUTOMATION: "automation",
    AUTOMATION_RESULT: "automationResult",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
    WORKSPACE_SETTINGS: "workspaceSettings",
    CUSTOM_APPLICATION_SETTING: "customApplicationSetting",
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
    WORKSPACE_DATA_FILTER_SETTING: "workspaceDataFilterSetting",
    FILTER_VIEW: "filterView",
} as const;

export type AutomationIdentifierRefIdentifierTypeEnum =
    (typeof AutomationIdentifierRefIdentifierTypeEnum)[keyof typeof AutomationIdentifierRefIdentifierTypeEnum];

/**
 * Export request object describing the export properties and metadata for image exports.
 */
export interface AutomationImageExportRequest {
    /**
     * Requested resulting file type.
     */
    format: AutomationImageExportRequestFormatEnum;
    /**
     * File name to be used for retrieving the image document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds: Array<string>;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
}

export const AutomationImageExportRequestFormatEnum = {
    PNG: "PNG",
} as const;

export type AutomationImageExportRequestFormatEnum =
    (typeof AutomationImageExportRequestFormatEnum)[keyof typeof AutomationImageExportRequestFormatEnum];

/**
 * In-platform destination for notifications.
 */
export interface AutomationInPlatform {
    /**
     * The destination type.
     */
    type: AutomationInPlatformTypeEnum;
}

export const AutomationInPlatformTypeEnum = {
    IN_PLATFORM: "IN_PLATFORM",
} as const;

export type AutomationInPlatformTypeEnum =
    (typeof AutomationInPlatformTypeEnum)[keyof typeof AutomationInPlatformTypeEnum];

/**
 * Filter in form of direct MAQL query.
 */
export interface AutomationInlineFilterDefinition {
    inline: AutomationInlineFilterDefinitionInline;
}
export interface AutomationInlineFilterDefinitionInline {
    /**
     * MAQL query representing the filter.
     */
    filter: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
}
/**
 * Metric defined by the raw MAQL query.
 */
export interface AutomationInlineMeasureDefinition {
    inline: AutomationInlineMeasureDefinitionInline;
}
export interface AutomationInlineMeasureDefinitionInline {
    /**
     * MAQL query defining the metric.
     */
    maql: string;
}
export interface AutomationLocalIdentifier {
    /**
     * Local identifier of the metric to be compared.
     */
    localIdentifier: string;
    /**
     * Metric format.
     */
    format?: string | null;
    /**
     * Metric title.
     */
    title?: string | null;
}
/**
 * @type AutomationMeasureDefinition
 * Abstract metric definition type
 */
export type AutomationMeasureDefinition =
    | AutomationArithmeticMeasureDefinition
    | AutomationInlineMeasureDefinition
    | AutomationPopMeasureDefinition
    | AutomationSimpleMeasureDefinition;

/**
 * Metric is a quantity that is calculated from the data.
 */
export interface AutomationMeasureItem {
    /**
     * Local identifier of the metric. This can be used to reference the metric in other parts of the execution definition.
     */
    localIdentifier: string;
    definition: AutomationMeasureItemDefinition;
}
/**
 * @type AutomationMeasureItemDefinition
 */
export type AutomationMeasureItemDefinition =
    | AutomationArithmeticMeasureDefinition
    | AutomationInlineMeasureDefinition
    | AutomationPopDatasetMeasureDefinition
    | AutomationPopDateMeasureDefinition
    | AutomationPopMeasureDefinition
    | AutomationSimpleMeasureDefinition;

/**
 * @type AutomationMeasureValueFilter
 * Abstract filter definition type filtering by the value of the metric.
 */
export type AutomationMeasureValueFilter =
    | AutomationComparisonMeasureValueFilter
    | AutomationRangeMeasureValueFilter;

export interface AutomationMetricRecord {
    value: number;
    formattedValue?: string;
}
/**
 * Filter able to limit element values by label and related selected negated elements.
 */
export interface AutomationNegativeAttributeFilter {
    negativeAttributeFilter: AutomationNegativeAttributeFilterNegativeAttributeFilter;
}
export interface AutomationNegativeAttributeFilterNegativeAttributeFilter {
    notIn: AutomationAttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: AutomationAfmIdentifier;
}
export interface AutomationNotification {
    id: string;
    workspaceId?: string;
    automationId?: string;
    data: AutomationNotificationData;
    isRead: boolean;
    createdAt: string;
}
/**
 * @type AutomationNotificationChannelDestination
 */
export type AutomationNotificationChannelDestination =
    | AutomationDefaultSmtp
    | AutomationInPlatform
    | AutomationSmtp
    | AutomationWebhook;

export interface AutomationNotificationContent {
    type: string;
}
/**
 * @type AutomationNotificationData
 */
export type AutomationNotificationData = AutomationAutomationNotification | AutomationTestNotification;

export interface AutomationNotificationFilter {
    title: string;
    filter: string;
}
export interface AutomationNotifications {
    data: Array<AutomationNotification>;
    meta: AutomationNotificationsMeta;
}
export interface AutomationNotificationsMeta {
    total?: AutomationNotificationsMetaTotal;
}
export interface AutomationNotificationsMetaTotal {
    unread: number;
    all: number;
}
export interface AutomationOver {
    attributes: Array<AutomationIdentifierRef>;
}
/**
 * Custom CSS styles for the table. (PDF, HTML)
 */
export interface AutomationPdfTableStyle {
    /**
     * CSS selector where to apply given properties.
     */
    selector: string;
    /**
     * List of CSS properties.
     */
    properties?: Array<AutomationPdfTableStyleProperty>;
}
/**
 * CSS property.
 */
export interface AutomationPdfTableStyleProperty {
    /**
     * CSS property key.
     */
    key: string;
    /**
     * CSS property value.
     */
    value: string;
}
/**
 * Combination of the date data set to use and how many periods ago to calculate the previous period for.
 */
export interface AutomationPopDataset {
    dataset: AutomationAfmObjectIdentifierDataset;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}
/**
 * Previous period type of metric.
 */
export interface AutomationPopDatasetMeasureDefinition {
    previousPeriodMeasure: AutomationPopDatasetMeasureDefinitionPreviousPeriodMeasure;
}
export interface AutomationPopDatasetMeasureDefinitionPreviousPeriodMeasure {
    measureIdentifier: AutomationAfmLocalIdentifier;
    /**
     * Specification of which date data sets to use for determining the period to calculate the previous period for.
     */
    dateDatasets: Array<AutomationPopDataset>;
}
/**
 * Combination of the date attribute to use and how many periods ago to calculate the PoP for.
 */
export interface AutomationPopDate {
    attribute: AutomationAfmObjectIdentifierAttribute;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}
/**
 * Period over period type of metric.
 */
export interface AutomationPopDateMeasureDefinition {
    overPeriodMeasure: AutomationPopDateMeasureDefinitionOverPeriodMeasure;
}
export interface AutomationPopDateMeasureDefinitionOverPeriodMeasure {
    measureIdentifier: AutomationAfmLocalIdentifier;
    /**
     * Attributes to use for determining the period to calculate the PoP for.
     */
    dateAttributes: Array<AutomationPopDate>;
}
/**
 * @type AutomationPopMeasureDefinition
 */
export type AutomationPopMeasureDefinition =
    | AutomationPopDatasetMeasureDefinition
    | AutomationPopDateMeasureDefinition;

/**
 * Filter able to limit element values by label and related selected elements.
 */
export interface AutomationPositiveAttributeFilter {
    positiveAttributeFilter: AutomationPositiveAttributeFilterPositiveAttributeFilter;
}
export interface AutomationPositiveAttributeFilterPositiveAttributeFilter {
    in: AutomationAttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: AutomationAfmIdentifier;
}
export interface AutomationRange {
    operator: AutomationRangeOperatorEnum;
    measure: AutomationLocalIdentifier;
    from: AutomationValue;
    to: AutomationValue;
}

export const AutomationRangeOperatorEnum = {
    BETWEEN: "BETWEEN",
    NOT_BETWEEN: "NOT_BETWEEN",
} as const;

export type AutomationRangeOperatorEnum =
    (typeof AutomationRangeOperatorEnum)[keyof typeof AutomationRangeOperatorEnum];

/**
 * Filter the result by comparing specified metric to given range of values.
 */
export interface AutomationRangeMeasureValueFilter {
    rangeMeasureValueFilter: AutomationRangeMeasureValueFilterRangeMeasureValueFilter;
}
export interface AutomationRangeMeasureValueFilterRangeMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AutomationAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: AutomationRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum;
    from: number;
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: AutomationAfmIdentifier;
}

export const AutomationRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum = {
    BETWEEN: "BETWEEN",
    NOT_BETWEEN: "NOT_BETWEEN",
} as const;

export type AutomationRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum =
    (typeof AutomationRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum)[keyof typeof AutomationRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum];

export interface AutomationRangeWrapper {
    range: AutomationRange;
}
/**
 * Filter the result on top/bottom N values according to given metric(s).
 */
export interface AutomationRankingFilter {
    rankingFilter: AutomationRankingFilterRankingFilter;
}
export interface AutomationRankingFilterRankingFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AutomationAfmIdentifier>;
    /**
     * References to the metrics to be used when filtering.
     */
    measures: Array<AutomationAfmIdentifier>;
    /**
     * The type of ranking to use, TOP or BOTTOM.
     */
    operator: AutomationRankingFilterRankingFilterOperatorEnum;
    /**
     * Number of top/bottom values to filter.
     */
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
}

export const AutomationRankingFilterRankingFilterOperatorEnum = {
    TOP: "TOP",
    BOTTOM: "BOTTOM",
} as const;

export type AutomationRankingFilterRankingFilterOperatorEnum =
    (typeof AutomationRankingFilterRankingFilterOperatorEnum)[keyof typeof AutomationRankingFilterRankingFilterOperatorEnum];

/**
 * Custom label object override.
 */
export interface AutomationRawCustomLabel {
    /**
     * Override value.
     */
    title: string;
}
/**
 * Custom metric object override.
 */
export interface AutomationRawCustomMetric {
    /**
     * Metric title override.
     */
    title: string;
}
/**
 * Custom cell value overrides (IDs will be replaced with specified values).
 */
export interface AutomationRawCustomOverride {
    /**
     * Map of CustomLabels with keys used as placeholders in export result.
     */
    labels?: { [key: string]: AutomationRawCustomLabel };
    /**
     * Map of CustomMetrics with keys used as placeholders in export result.
     */
    metrics?: { [key: string]: AutomationRawCustomMetric };
}
/**
 * Export request object describing the export properties and overrides for raw exports.
 */
export interface AutomationRawExportAutomationRequest {
    /**
     * Requested resulting file type.
     */
    format: AutomationRawExportAutomationRequestFormatEnum;
    execution: AutomationAFM;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    customOverride?: AutomationRawCustomOverride;
    executionSettings?: AutomationExecutionSettings;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
}

export const AutomationRawExportAutomationRequestFormatEnum = {
    ARROW_FILE: "ARROW_FILE",
    ARROW_STREAM: "ARROW_STREAM",
    CSV: "CSV",
} as const;

export type AutomationRawExportAutomationRequestFormatEnum =
    (typeof AutomationRawExportAutomationRequestFormatEnum)[keyof typeof AutomationRawExportAutomationRequestFormatEnum];

export interface AutomationRelative {
    /**
     * Relative condition operator. INCREASES_BY - the metric increases by the specified value. DECREASES_BY - the metric decreases by the specified value. CHANGES_BY - the metric increases or decreases by the specified value.
     */
    operator: AutomationRelativeOperatorEnum;
    measure: AutomationArithmeticMeasure;
    threshold: AutomationValue;
}

export const AutomationRelativeOperatorEnum = {
    INCREASES_BY: "INCREASES_BY",
    DECREASES_BY: "DECREASES_BY",
    CHANGES_BY: "CHANGES_BY",
} as const;

export type AutomationRelativeOperatorEnum =
    (typeof AutomationRelativeOperatorEnum)[keyof typeof AutomationRelativeOperatorEnum];

export interface AutomationRelativeBoundedDateFilter {
    granularity: AutomationRelativeBoundedDateFilterGranularityEnum;
    from?: number;
    to?: number;
}

export const AutomationRelativeBoundedDateFilterGranularityEnum = {
    ALL_TIME_GRANULARITY: "ALL_TIME_GRANULARITY",
    GDC_TIME_YEAR: "GDC.time.year",
    GDC_TIME_WEEK_US: "GDC.time.week_us",
    GDC_TIME_WEEK_IN_YEAR: "GDC.time.week_in_year",
    GDC_TIME_WEEK_IN_QUARTER: "GDC.time.week_in_quarter",
    GDC_TIME_WEEK: "GDC.time.week",
    GDC_TIME_EUWEEK_IN_YEAR: "GDC.time.euweek_in_year",
    GDC_TIME_EUWEEK_IN_QUARTER: "GDC.time.euweek_in_quarter",
    GDC_TIME_QUARTER: "GDC.time.quarter",
    GDC_TIME_QUARTER_IN_YEAR: "GDC.time.quarter_in_year",
    GDC_TIME_MONTH: "GDC.time.month",
    GDC_TIME_MONTH_IN_QUARTER: "GDC.time.month_in_quarter",
    GDC_TIME_MONTH_IN_YEAR: "GDC.time.month_in_year",
    GDC_TIME_DAY_IN_YEAR: "GDC.time.day_in_year",
    GDC_TIME_DAY_IN_QUARTER: "GDC.time.day_in_quarter",
    GDC_TIME_DAY_IN_MONTH: "GDC.time.day_in_month",
    GDC_TIME_DAY_IN_WEEK: "GDC.time.day_in_week",
    GDC_TIME_DAY_IN_EUWEEK: "GDC.time.day_in_euweek",
    GDC_TIME_DATE: "GDC.time.date",
    GDC_TIME_HOUR: "GDC.time.hour",
    GDC_TIME_HOUR_IN_DAY: "GDC.time.hour_in_day",
    GDC_TIME_MINUTE: "GDC.time.minute",
    GDC_TIME_MINUTE_IN_HOUR: "GDC.time.minute_in_hour",
} as const;

export type AutomationRelativeBoundedDateFilterGranularityEnum =
    (typeof AutomationRelativeBoundedDateFilterGranularityEnum)[keyof typeof AutomationRelativeBoundedDateFilterGranularityEnum];

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension. The \'from\' and \'to\' properties mark the boundaries of the interval. If \'from\' is omitted, all values earlier than \'to\' are included. If \'to\' is omitted, all values later than \'from\' are included. It is not allowed to omit both.
 */
export interface AutomationRelativeDateFilter {
    relativeDateFilter: AutomationRelativeDateFilterRelativeDateFilter;
}
export interface AutomationRelativeDateFilterRelativeDateFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: AutomationRelativeDateFilterRelativeDateFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     */
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    boundedFilter?: AutomationBoundedFilter;
    dataset: AutomationAfmObjectIdentifierDataset;
}

export const AutomationRelativeDateFilterRelativeDateFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_QUARTER: "DAY_OF_QUARTER",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type AutomationRelativeDateFilterRelativeDateFilterGranularityEnum =
    (typeof AutomationRelativeDateFilterRelativeDateFilterGranularityEnum)[keyof typeof AutomationRelativeDateFilterRelativeDateFilterGranularityEnum];

export interface AutomationRelativeWrapper {
    relative: AutomationRelative;
}
/**
 * Additional settings.
 */
export interface AutomationSettings {
    /**
     * If true, the export will contain the information about the export – exported date, filters, etc. Works only with `visualizationObject`. (XLSX, PDF)
     */
    exportInfo?: boolean;
    /**
     * Merge equal headers in neighbouring cells. (XLSX)
     */
    mergeHeaders?: boolean;
    /**
     * Print applied filters on top of the document. (PDF/HTML when visualizationObject is given)
     * @deprecated
     */
    showFilters?: boolean;
    /**
     * Page size and orientation. (PDF)
     * @deprecated
     */
    pdfPageSize?: string;
    /**
     * Custom CSS styles for the table. (PDF, HTML)
     * @deprecated
     */
    pdfTableStyle?: Array<AutomationPdfTableStyle>;
    /**
     * Top left header content. (PDF)
     * @deprecated
     */
    pdfTopLeftContent?: string;
    /**
     * Top right header content. (PDF)
     * @deprecated
     */
    pdfTopRightContent?: string;
    /**
     * Set page size. (PDF)
     */
    pageSize?: AutomationSettingsPageSizeEnum;
    /**
     * Set page orientation. (PDF)
     */
    pageOrientation?: AutomationSettingsPageOrientationEnum;
}

export const AutomationSettingsPageSizeEnum = {
    A3: "A3",
    A4: "A4",
    LETTER: "LETTER",
} as const;

export type AutomationSettingsPageSizeEnum =
    (typeof AutomationSettingsPageSizeEnum)[keyof typeof AutomationSettingsPageSizeEnum];
export const AutomationSettingsPageOrientationEnum = {
    PORTRAIT: "PORTRAIT",
    LANDSCAPE: "LANDSCAPE",
} as const;

export type AutomationSettingsPageOrientationEnum =
    (typeof AutomationSettingsPageOrientationEnum)[keyof typeof AutomationSettingsPageOrientationEnum];

/**
 * Metric defined by referencing a MAQL metric or an LDM fact object with aggregation.
 */
export interface AutomationSimpleMeasureDefinition {
    measure: AutomationSimpleMeasureDefinitionMeasure;
}
export interface AutomationSimpleMeasureDefinitionMeasure {
    item: AutomationAfmObjectIdentifierCore;
    /**
     * Definition of aggregation type of the metric.
     */
    aggregation?: AutomationSimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true, compute the percentage of given metric values (broken down by AFM attributes) to the total (not broken down).
     */
    computeRatio?: boolean;
    /**
     * Metrics can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     */
    filters?: Array<AutomationFilterDefinitionForSimpleMeasure>;
}

export const AutomationSimpleMeasureDefinitionMeasureAggregationEnum = {
    SUM: "SUM",
    COUNT: "COUNT",
    AVG: "AVG",
    MIN: "MIN",
    MAX: "MAX",
    MEDIAN: "MEDIAN",
    RUNSUM: "RUNSUM",
    APPROXIMATE_COUNT: "APPROXIMATE_COUNT",
} as const;

export type AutomationSimpleMeasureDefinitionMeasureAggregationEnum =
    (typeof AutomationSimpleMeasureDefinitionMeasureAggregationEnum)[keyof typeof AutomationSimpleMeasureDefinitionMeasureAggregationEnum];

/**
 * Export request object describing the export properties and metadata for slides exports.
 */
export interface AutomationSlidesExportRequest {
    /**
     * Requested resulting file type.
     */
    format: AutomationSlidesExportRequestFormatEnum;
    /**
     * File name to be used for retrieving the pdf document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId?: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds?: Array<string>;
    /**
     * List of visualization ids to be exported. Note that only one visualization is currently supported.
     */
    visualizationIds?: Array<string>;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
    /**
     * Export template identifier.
     */
    templateId?: string | null;
}

export const AutomationSlidesExportRequestFormatEnum = {
    PDF: "PDF",
    PPTX: "PPTX",
} as const;

export type AutomationSlidesExportRequestFormatEnum =
    (typeof AutomationSlidesExportRequestFormatEnum)[keyof typeof AutomationSlidesExportRequestFormatEnum];

/**
 * Custom SMTP destination for notifications. The properties host, port, username, and password are required on create and update
 */
export interface AutomationSmtp {
    /**
     * E-mail address to send notifications from.
     */
    fromEmail?: string;
    /**
     * An optional e-mail name to send notifications from.
     */
    fromEmailName?: string;
    /**
     * The SMTP server address.
     */
    host?: string;
    /**
     * The SMTP server port.
     */
    port?: AutomationSmtpPortEnum;
    /**
     * The SMTP server username.
     */
    username?: string;
    /**
     * The SMTP server password.
     */
    password?: string;
    /**
     * The destination type.
     */
    type: AutomationSmtpTypeEnum;
}

export const AutomationSmtpPortEnum = {
    NUMBER_25: 25,
    NUMBER_465: 465,
    NUMBER_587: 587,
    NUMBER_2525: 2525,
} as const;

export type AutomationSmtpPortEnum = (typeof AutomationSmtpPortEnum)[keyof typeof AutomationSmtpPortEnum];
export const AutomationSmtpTypeEnum = {
    SMTP: "SMTP",
} as const;

export type AutomationSmtpTypeEnum = (typeof AutomationSmtpTypeEnum)[keyof typeof AutomationSmtpTypeEnum];

/**
 * Export request object describing the export properties and overrides for tabular exports.
 */
export interface AutomationTabularExportRequest {
    /**
     * Expected file format.
     */
    format: AutomationTabularExportRequestFormatEnum;
    /**
     * Execution result identifier.
     */
    executionResult?: string;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    settings?: AutomationSettings;
    customOverride?: AutomationCustomOverride;
    /**
     * Visualization object identifier. Alternative to executionResult property.
     */
    visualizationObject?: string;
    /**
     * Optional custom filters (as array of IFilter objects defined in UI SDK) to be applied when visualizationObject is given. Those filters override the original filters defined in the visualization.
     */
    visualizationObjectCustomFilters?: Array<object>;
    /**
     * Analytical dashboard identifier. Optional identifier, which informs the system that the export is related to a specific dashboard.
     */
    relatedDashboardId?: string;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
}

export const AutomationTabularExportRequestFormatEnum = {
    CSV: "CSV",
    XLSX: "XLSX",
    HTML: "HTML",
    PDF: "PDF",
} as const;

export type AutomationTabularExportRequestFormatEnum =
    (typeof AutomationTabularExportRequestFormatEnum)[keyof typeof AutomationTabularExportRequestFormatEnum];

/**
 * Request body with notification channel destination to test.
 */
export interface AutomationTestDestinationRequest {
    destination: AutomationTestDestinationRequestDestination;
    /**
     * External recipients of the test result.
     */
    externalRecipients?: Array<AutomationAutomationExternalRecipient> | null;
}
/**
 * @type AutomationTestDestinationRequestDestination
 */
export type AutomationTestDestinationRequestDestination =
    | AutomationDefaultSmtp
    | AutomationInPlatform
    | AutomationSmtp
    | AutomationWebhook;

export interface AutomationTestNotification extends AutomationNotificationContent {
    message: string;
}
/**
 * Response from notification channel testing.
 */
export interface AutomationTestResponse {
    /**
     * A flag indicating whether test passed or not.
     */
    successful: boolean;
    /**
     * Field containing more details in case of a failure. Details are available to a privileged user only.
     */
    error?: string;
}
export interface AutomationTriggerAutomationRequest {
    automation: AutomationAdHocAutomation;
}
export interface AutomationValue {
    /**
     * Value of the alert threshold to compare the metric to.
     */
    value: number;
}
export interface AutomationVisibleFilter {
    localIdentifier?: string;
    title?: string;
    /**
     * Indicates if the filter is an all-time date filter. Such a filter is not included in report computation, so there is no filter with the same \'localIdentifier\' to be found. In such cases, this flag is used to inform the server to not search for the filter in the definitions and include it anyways.
     */
    isAllTimeDateFilter?: boolean;
}
/**
 * Export request object describing the export properties and metadata for dashboard PDF exports.
 */
export interface AutomationVisualExportRequest {
    /**
     * File name to be used for retrieving the pdf document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId: string;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object;
}
/**
 * Webhook destination for notifications. The property url is required on create and update.
 */
export interface AutomationWebhook {
    /**
     * The webhook URL.
     */
    url?: string;
    /**
     * Bearer token for the webhook.
     */
    token?: string | null;
    /**
     * Flag indicating if webhook has a token.
     */
    hasToken?: boolean | null;
    /**
     * The destination type.
     */
    type: AutomationWebhookTypeEnum;
}

export const AutomationWebhookTypeEnum = {
    WEBHOOK: "WEBHOOK",
} as const;

export type AutomationWebhookTypeEnum =
    (typeof AutomationWebhookTypeEnum)[keyof typeof AutomationWebhookTypeEnum];

export interface AutomationWebhookAutomationInfo {
    id: string;
    title?: string;
    dashboardTitle?: string;
    dashboardURL: string;
    isCustomDashboardURL: boolean;
}
export interface AutomationWebhookMessage {
    timestamp: string;
    data: AutomationWebhookMessageData;
    type: AutomationWebhookMessageTypeEnum;
}

export const AutomationWebhookMessageTypeEnum = {
    AUTOMATION_TASK_COMPLETED: "automation-task.completed",
    AUTOMATION_TASK_LIMIT_EXCEEDED: "automation-task.limit-exceeded",
} as const;

export type AutomationWebhookMessageTypeEnum =
    (typeof AutomationWebhookMessageTypeEnum)[keyof typeof AutomationWebhookMessageTypeEnum];

export interface AutomationWebhookMessageData {
    automation: AutomationWebhookAutomationInfo;
    recipients?: Array<AutomationWebhookRecipient>;
    details?: { [key: string]: string };
    remainingActionCount?: number;
    tabularExports?: Array<AutomationExportResult>;
    visualExports?: Array<AutomationExportResult>;
    imageExports?: Array<AutomationExportResult>;
    rawExports?: Array<AutomationExportResult>;
    slidesExports?: Array<AutomationExportResult>;
    dashboardTabularExports?: Array<AutomationExportResult>;
    alert?: AutomationAlertDescription;
    filters?: Array<AutomationNotificationFilter>;
    notificationSource?: string;
}
export interface AutomationWebhookRecipient {
    id: string;
    email: string;
}

/**
 * ActionsAutomation - axios parameter creator
 * @export
 */
export const ActionsAutomationAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {string} [workspaceId] Workspace ID to filter notifications by.
         * @param {boolean} [isRead] Filter notifications by read status.
         * @param {string} [page] Zero-based page index (0..N)
         * @param {string} [size] The size of the page to be returned.
         * @param {Array<'total' | 'ALL'>} [metaInclude] Additional meta information to include in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (
            workspaceId?: string,
            isRead?: boolean,
            page?: string,
            size?: string,
            metaInclude?: Array<"total" | "ALL">,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter["workspaceId"] = workspaceId;
            }

            if (isRead !== undefined) {
                localVarQueryParameter["isRead"] = isRead;
            }

            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude);
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {string} notificationId Notification ID to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotification: async (
            notificationId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists("markAsReadNotification", "notificationId", notificationId);
            const localVarPath = `/api/v1/actions/notifications/{notificationId}/markAsRead`.replace(
                `{${"notificationId"}}`,
                encodeURIComponent(String(notificationId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {string} [workspaceId] Workspace ID where to mark notifications as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotificationAll: async (
            workspaceId?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/notifications/markAsRead`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter["workspaceId"] = workspaceId;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {AutomationTestDestinationRequest} [automationTestDestinationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel: async (
            notificationChannelId: string,
            automationTestDestinationRequest?: AutomationTestDestinationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists(
                "testExistingNotificationChannel",
                "notificationChannelId",
                notificationChannelId,
            );
            const localVarPath = `/api/v1/actions/notificationChannels/{notificationChannelId}/test`.replace(
                `{${"notificationChannelId"}}`,
                encodeURIComponent(String(notificationChannelId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof automationTestDestinationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      automationTestDestinationRequest !== undefined ? automationTestDestinationRequest : {},
                  )
                : automationTestDestinationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {AutomationTestDestinationRequest} automationTestDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel: async (
            automationTestDestinationRequest: AutomationTestDestinationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'automationTestDestinationRequest' is not null or undefined
            assertParamExists(
                "testNotificationChannel",
                "automationTestDestinationRequest",
                automationTestDestinationRequest,
            );
            const localVarPath = `/api/v1/actions/notificationChannels/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof automationTestDestinationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      automationTestDestinationRequest !== undefined ? automationTestDestinationRequest : {},
                  )
                : automationTestDestinationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {string} workspaceId
         * @param {AutomationTriggerAutomationRequest} automationTriggerAutomationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerAutomation: async (
            workspaceId: string,
            automationTriggerAutomationRequest: AutomationTriggerAutomationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("triggerAutomation", "workspaceId", workspaceId);
            // verify required parameter 'automationTriggerAutomationRequest' is not null or undefined
            assertParamExists(
                "triggerAutomation",
                "automationTriggerAutomationRequest",
                automationTriggerAutomationRequest,
            );
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/trigger`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof automationTriggerAutomationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      automationTriggerAutomationRequest !== undefined
                          ? automationTriggerAutomationRequest
                          : {},
                  )
                : automationTriggerAutomationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {string} workspaceId
         * @param {string} automationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerExistingAutomation: async (
            workspaceId: string,
            automationId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("triggerExistingAutomation", "workspaceId", workspaceId);
            // verify required parameter 'automationId' is not null or undefined
            assertParamExists("triggerExistingAutomation", "automationId", automationId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/{automationId}/trigger`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"automationId"}}`, encodeURIComponent(String(automationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsAutomation - functional programming interface
 * @export
 */
export const ActionsAutomationFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsAutomationAxiosParamCreator(configuration);
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {string} [workspaceId] Workspace ID to filter notifications by.
         * @param {boolean} [isRead] Filter notifications by read status.
         * @param {string} [page] Zero-based page index (0..N)
         * @param {string} [size] The size of the page to be returned.
         * @param {Array<'total' | 'ALL'>} [metaInclude] Additional meta information to include in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(
            workspaceId?: string,
            isRead?: boolean,
            page?: string,
            size?: string,
            metaInclude?: Array<"total" | "ALL">,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationNotifications>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(
                workspaceId,
                isRead,
                page,
                size,
                metaInclude,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {string} notificationId Notification ID to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsReadNotification(
            notificationId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsReadNotification(
                notificationId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {string} [workspaceId] Workspace ID where to mark notifications as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsReadNotificationAll(
            workspaceId?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsReadNotificationAll(
                workspaceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {AutomationTestDestinationRequest} [automationTestDestinationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testExistingNotificationChannel(
            notificationChannelId: string,
            automationTestDestinationRequest?: AutomationTestDestinationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testExistingNotificationChannel(
                notificationChannelId,
                automationTestDestinationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {AutomationTestDestinationRequest} automationTestDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testNotificationChannel(
            automationTestDestinationRequest: AutomationTestDestinationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testNotificationChannel(
                automationTestDestinationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {string} workspaceId
         * @param {AutomationTriggerAutomationRequest} automationTriggerAutomationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerAutomation(
            workspaceId: string,
            automationTriggerAutomationRequest: AutomationTriggerAutomationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerAutomation(
                workspaceId,
                automationTriggerAutomationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {string} workspaceId
         * @param {string} automationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerExistingAutomation(
            workspaceId: string,
            automationId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerExistingAutomation(
                workspaceId,
                automationId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsAutomation - factory interface
 * @export
 */
export const ActionsAutomationFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsAutomationFp(configuration);
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {ActionsAutomationGetNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(
            requestParameters: ActionsAutomationGetNotificationsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AutomationNotifications> {
            return localVarFp
                .getNotifications(
                    requestParameters.workspaceId,
                    requestParameters.isRead,
                    requestParameters.page,
                    requestParameters.size,
                    requestParameters.metaInclude,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {ActionsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotification(
            requestParameters: ActionsAutomationMarkAsReadNotificationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .markAsReadNotification(requestParameters.notificationId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {ActionsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotificationAll(
            requestParameters: ActionsAutomationMarkAsReadNotificationAllRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .markAsReadNotificationAll(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {ActionsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel(
            requestParameters: ActionsAutomationTestExistingNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AutomationTestResponse> {
            return localVarFp
                .testExistingNotificationChannel(
                    requestParameters.notificationChannelId,
                    requestParameters.automationTestDestinationRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {ActionsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel(
            requestParameters: ActionsAutomationTestNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AutomationTestResponse> {
            return localVarFp
                .testNotificationChannel(requestParameters.automationTestDestinationRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {ActionsAutomationTriggerAutomationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerAutomation(
            requestParameters: ActionsAutomationTriggerAutomationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .triggerAutomation(
                    requestParameters.workspaceId,
                    requestParameters.automationTriggerAutomationRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {ActionsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerExistingAutomation(
            requestParameters: ActionsAutomationTriggerExistingAutomationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .triggerExistingAutomation(
                    requestParameters.workspaceId,
                    requestParameters.automationId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsAutomation - interface
 * @export
 * @interface ActionsAutomation
 */
export interface ActionsAutomationInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {ActionsAutomationGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    getNotifications(
        requestParameters: ActionsAutomationGetNotificationsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationNotifications>;

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {ActionsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    markAsReadNotification(
        requestParameters: ActionsAutomationMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {ActionsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    markAsReadNotificationAll(
        requestParameters: ActionsAutomationMarkAsReadNotificationAllRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {ActionsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    testExistingNotificationChannel(
        requestParameters: ActionsAutomationTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationTestResponse>;

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {ActionsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    testNotificationChannel(
        requestParameters: ActionsAutomationTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationTestResponse>;

    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {ActionsAutomationTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    triggerAutomation(
        requestParameters: ActionsAutomationTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {ActionsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    triggerExistingAutomation(
        requestParameters: ActionsAutomationTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for getNotifications operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationGetNotificationsRequest
 */
export interface ActionsAutomationGetNotificationsRequest {
    /**
     * Workspace ID to filter notifications by.
     * @type {string}
     * @memberof ActionsAutomationGetNotifications
     */
    readonly workspaceId?: string;

    /**
     * Filter notifications by read status.
     * @type {boolean}
     * @memberof ActionsAutomationGetNotifications
     */
    readonly isRead?: boolean;

    /**
     * Zero-based page index (0..N)
     * @type {string}
     * @memberof ActionsAutomationGetNotifications
     */
    readonly page?: string;

    /**
     * The size of the page to be returned.
     * @type {string}
     * @memberof ActionsAutomationGetNotifications
     */
    readonly size?: string;

    /**
     * Additional meta information to include in the response.
     * @type {Array<'total' | 'ALL'>}
     * @memberof ActionsAutomationGetNotifications
     */
    readonly metaInclude?: Array<"total" | "ALL">;
}

/**
 * Request parameters for markAsReadNotification operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationMarkAsReadNotificationRequest
 */
export interface ActionsAutomationMarkAsReadNotificationRequest {
    /**
     * Notification ID to mark as read.
     * @type {string}
     * @memberof ActionsAutomationMarkAsReadNotification
     */
    readonly notificationId: string;
}

/**
 * Request parameters for markAsReadNotificationAll operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationMarkAsReadNotificationAllRequest
 */
export interface ActionsAutomationMarkAsReadNotificationAllRequest {
    /**
     * Workspace ID where to mark notifications as read.
     * @type {string}
     * @memberof ActionsAutomationMarkAsReadNotificationAll
     */
    readonly workspaceId?: string;
}

/**
 * Request parameters for testExistingNotificationChannel operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationTestExistingNotificationChannelRequest
 */
export interface ActionsAutomationTestExistingNotificationChannelRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsAutomationTestExistingNotificationChannel
     */
    readonly notificationChannelId: string;

    /**
     *
     * @type {AutomationTestDestinationRequest}
     * @memberof ActionsAutomationTestExistingNotificationChannel
     */
    readonly automationTestDestinationRequest?: AutomationTestDestinationRequest;
}

/**
 * Request parameters for testNotificationChannel operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationTestNotificationChannelRequest
 */
export interface ActionsAutomationTestNotificationChannelRequest {
    /**
     *
     * @type {AutomationTestDestinationRequest}
     * @memberof ActionsAutomationTestNotificationChannel
     */
    readonly automationTestDestinationRequest: AutomationTestDestinationRequest;
}

/**
 * Request parameters for triggerAutomation operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationTriggerAutomationRequest
 */
export interface ActionsAutomationTriggerAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsAutomationTriggerAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AutomationTriggerAutomationRequest}
     * @memberof ActionsAutomationTriggerAutomation
     */
    readonly automationTriggerAutomationRequest: AutomationTriggerAutomationRequest;
}

/**
 * Request parameters for triggerExistingAutomation operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationTriggerExistingAutomationRequest
 */
export interface ActionsAutomationTriggerExistingAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsAutomationTriggerExistingAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsAutomationTriggerExistingAutomation
     */
    readonly automationId: string;
}

/**
 * ActionsAutomation - object-oriented interface
 * @export
 * @class ActionsAutomation
 * @extends {BaseAPI}
 */
export class ActionsAutomation extends BaseAPI implements ActionsAutomationInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {ActionsAutomationGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public getNotifications(
        requestParameters: ActionsAutomationGetNotificationsRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomationFp(this.configuration)
            .getNotifications(
                requestParameters.workspaceId,
                requestParameters.isRead,
                requestParameters.page,
                requestParameters.size,
                requestParameters.metaInclude,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {ActionsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public markAsReadNotification(
        requestParameters: ActionsAutomationMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomationFp(this.configuration)
            .markAsReadNotification(requestParameters.notificationId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {ActionsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public markAsReadNotificationAll(
        requestParameters: ActionsAutomationMarkAsReadNotificationAllRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomationFp(this.configuration)
            .markAsReadNotificationAll(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {ActionsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public testExistingNotificationChannel(
        requestParameters: ActionsAutomationTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomationFp(this.configuration)
            .testExistingNotificationChannel(
                requestParameters.notificationChannelId,
                requestParameters.automationTestDestinationRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {ActionsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public testNotificationChannel(
        requestParameters: ActionsAutomationTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomationFp(this.configuration)
            .testNotificationChannel(requestParameters.automationTestDestinationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {ActionsAutomationTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public triggerAutomation(
        requestParameters: ActionsAutomationTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomationFp(this.configuration)
            .triggerAutomation(
                requestParameters.workspaceId,
                requestParameters.automationTriggerAutomationRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {ActionsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public triggerExistingAutomation(
        requestParameters: ActionsAutomationTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomationFp(this.configuration)
            .triggerExistingAutomation(requestParameters.workspaceId, requestParameters.automationId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * AutomationsAutomation - axios parameter creator
 * @export
 */
export const AutomationsAutomationAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {string} workspaceId
         * @param {AutomationTriggerAutomationRequest} automationTriggerAutomationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerAutomation: async (
            workspaceId: string,
            automationTriggerAutomationRequest: AutomationTriggerAutomationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("triggerAutomation", "workspaceId", workspaceId);
            // verify required parameter 'automationTriggerAutomationRequest' is not null or undefined
            assertParamExists(
                "triggerAutomation",
                "automationTriggerAutomationRequest",
                automationTriggerAutomationRequest,
            );
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/trigger`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof automationTriggerAutomationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      automationTriggerAutomationRequest !== undefined
                          ? automationTriggerAutomationRequest
                          : {},
                  )
                : automationTriggerAutomationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {string} workspaceId
         * @param {string} automationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerExistingAutomation: async (
            workspaceId: string,
            automationId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("triggerExistingAutomation", "workspaceId", workspaceId);
            // verify required parameter 'automationId' is not null or undefined
            assertParamExists("triggerExistingAutomation", "automationId", automationId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/{automationId}/trigger`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"automationId"}}`, encodeURIComponent(String(automationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AutomationsAutomation - functional programming interface
 * @export
 */
export const AutomationsAutomationFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AutomationsAutomationAxiosParamCreator(configuration);
    return {
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {string} workspaceId
         * @param {AutomationTriggerAutomationRequest} automationTriggerAutomationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerAutomation(
            workspaceId: string,
            automationTriggerAutomationRequest: AutomationTriggerAutomationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerAutomation(
                workspaceId,
                automationTriggerAutomationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {string} workspaceId
         * @param {string} automationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerExistingAutomation(
            workspaceId: string,
            automationId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerExistingAutomation(
                workspaceId,
                automationId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * AutomationsAutomation - factory interface
 * @export
 */
export const AutomationsAutomationFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = AutomationsAutomationFp(configuration);
    return {
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {AutomationsAutomationTriggerAutomationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerAutomation(
            requestParameters: AutomationsAutomationTriggerAutomationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .triggerAutomation(
                    requestParameters.workspaceId,
                    requestParameters.automationTriggerAutomationRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {AutomationsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerExistingAutomation(
            requestParameters: AutomationsAutomationTriggerExistingAutomationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .triggerExistingAutomation(
                    requestParameters.workspaceId,
                    requestParameters.automationId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutomationsAutomation - interface
 * @export
 * @interface AutomationsAutomation
 */
export interface AutomationsAutomationInterface {
    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {AutomationsAutomationTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsAutomationInterface
     */
    triggerAutomation(
        requestParameters: AutomationsAutomationTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {AutomationsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsAutomationInterface
     */
    triggerExistingAutomation(
        requestParameters: AutomationsAutomationTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for triggerAutomation operation in AutomationsAutomation.
 * @export
 * @interface AutomationsAutomationTriggerAutomationRequest
 */
export interface AutomationsAutomationTriggerAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof AutomationsAutomationTriggerAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AutomationTriggerAutomationRequest}
     * @memberof AutomationsAutomationTriggerAutomation
     */
    readonly automationTriggerAutomationRequest: AutomationTriggerAutomationRequest;
}

/**
 * Request parameters for triggerExistingAutomation operation in AutomationsAutomation.
 * @export
 * @interface AutomationsAutomationTriggerExistingAutomationRequest
 */
export interface AutomationsAutomationTriggerExistingAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof AutomationsAutomationTriggerExistingAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof AutomationsAutomationTriggerExistingAutomation
     */
    readonly automationId: string;
}

/**
 * AutomationsAutomation - object-oriented interface
 * @export
 * @class AutomationsAutomation
 * @extends {BaseAPI}
 */
export class AutomationsAutomation extends BaseAPI implements AutomationsAutomationInterface {
    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {AutomationsAutomationTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsAutomation
     */
    public triggerAutomation(
        requestParameters: AutomationsAutomationTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return AutomationsAutomationFp(this.configuration)
            .triggerAutomation(
                requestParameters.workspaceId,
                requestParameters.automationTriggerAutomationRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {AutomationsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsAutomation
     */
    public triggerExistingAutomation(
        requestParameters: AutomationsAutomationTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return AutomationsAutomationFp(this.configuration)
            .triggerExistingAutomation(requestParameters.workspaceId, requestParameters.automationId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * NotificationChannelsAutomation - axios parameter creator
 * @export
 */
export const NotificationChannelsAutomationAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {string} [workspaceId] Workspace ID to filter notifications by.
         * @param {boolean} [isRead] Filter notifications by read status.
         * @param {string} [page] Zero-based page index (0..N)
         * @param {string} [size] The size of the page to be returned.
         * @param {Array<'total' | 'ALL'>} [metaInclude] Additional meta information to include in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (
            workspaceId?: string,
            isRead?: boolean,
            page?: string,
            size?: string,
            metaInclude?: Array<"total" | "ALL">,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter["workspaceId"] = workspaceId;
            }

            if (isRead !== undefined) {
                localVarQueryParameter["isRead"] = isRead;
            }

            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude);
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {string} notificationId Notification ID to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotification: async (
            notificationId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists("markAsReadNotification", "notificationId", notificationId);
            const localVarPath = `/api/v1/actions/notifications/{notificationId}/markAsRead`.replace(
                `{${"notificationId"}}`,
                encodeURIComponent(String(notificationId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {string} [workspaceId] Workspace ID where to mark notifications as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotificationAll: async (
            workspaceId?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/notifications/markAsRead`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter["workspaceId"] = workspaceId;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {AutomationTestDestinationRequest} [automationTestDestinationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel: async (
            notificationChannelId: string,
            automationTestDestinationRequest?: AutomationTestDestinationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists(
                "testExistingNotificationChannel",
                "notificationChannelId",
                notificationChannelId,
            );
            const localVarPath = `/api/v1/actions/notificationChannels/{notificationChannelId}/test`.replace(
                `{${"notificationChannelId"}}`,
                encodeURIComponent(String(notificationChannelId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof automationTestDestinationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      automationTestDestinationRequest !== undefined ? automationTestDestinationRequest : {},
                  )
                : automationTestDestinationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {AutomationTestDestinationRequest} automationTestDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel: async (
            automationTestDestinationRequest: AutomationTestDestinationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'automationTestDestinationRequest' is not null or undefined
            assertParamExists(
                "testNotificationChannel",
                "automationTestDestinationRequest",
                automationTestDestinationRequest,
            );
            const localVarPath = `/api/v1/actions/notificationChannels/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof automationTestDestinationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      automationTestDestinationRequest !== undefined ? automationTestDestinationRequest : {},
                  )
                : automationTestDestinationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * NotificationChannelsAutomation - functional programming interface
 * @export
 */
export const NotificationChannelsAutomationFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationChannelsAutomationAxiosParamCreator(configuration);
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {string} [workspaceId] Workspace ID to filter notifications by.
         * @param {boolean} [isRead] Filter notifications by read status.
         * @param {string} [page] Zero-based page index (0..N)
         * @param {string} [size] The size of the page to be returned.
         * @param {Array<'total' | 'ALL'>} [metaInclude] Additional meta information to include in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(
            workspaceId?: string,
            isRead?: boolean,
            page?: string,
            size?: string,
            metaInclude?: Array<"total" | "ALL">,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationNotifications>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(
                workspaceId,
                isRead,
                page,
                size,
                metaInclude,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {string} notificationId Notification ID to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsReadNotification(
            notificationId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsReadNotification(
                notificationId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {string} [workspaceId] Workspace ID where to mark notifications as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsReadNotificationAll(
            workspaceId?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsReadNotificationAll(
                workspaceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {AutomationTestDestinationRequest} [automationTestDestinationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testExistingNotificationChannel(
            notificationChannelId: string,
            automationTestDestinationRequest?: AutomationTestDestinationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testExistingNotificationChannel(
                notificationChannelId,
                automationTestDestinationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {AutomationTestDestinationRequest} automationTestDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testNotificationChannel(
            automationTestDestinationRequest: AutomationTestDestinationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutomationTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testNotificationChannel(
                automationTestDestinationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * NotificationChannelsAutomation - factory interface
 * @export
 */
export const NotificationChannelsAutomationFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = NotificationChannelsAutomationFp(configuration);
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {NotificationChannelsAutomationGetNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(
            requestParameters: NotificationChannelsAutomationGetNotificationsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AutomationNotifications> {
            return localVarFp
                .getNotifications(
                    requestParameters.workspaceId,
                    requestParameters.isRead,
                    requestParameters.page,
                    requestParameters.size,
                    requestParameters.metaInclude,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {NotificationChannelsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotification(
            requestParameters: NotificationChannelsAutomationMarkAsReadNotificationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .markAsReadNotification(requestParameters.notificationId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {NotificationChannelsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotificationAll(
            requestParameters: NotificationChannelsAutomationMarkAsReadNotificationAllRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .markAsReadNotificationAll(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {NotificationChannelsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel(
            requestParameters: NotificationChannelsAutomationTestExistingNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AutomationTestResponse> {
            return localVarFp
                .testExistingNotificationChannel(
                    requestParameters.notificationChannelId,
                    requestParameters.automationTestDestinationRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {NotificationChannelsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel(
            requestParameters: NotificationChannelsAutomationTestNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AutomationTestResponse> {
            return localVarFp
                .testNotificationChannel(requestParameters.automationTestDestinationRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationChannelsAutomation - interface
 * @export
 * @interface NotificationChannelsAutomation
 */
export interface NotificationChannelsAutomationInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {NotificationChannelsAutomationGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomationInterface
     */
    getNotifications(
        requestParameters: NotificationChannelsAutomationGetNotificationsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationNotifications>;

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {NotificationChannelsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomationInterface
     */
    markAsReadNotification(
        requestParameters: NotificationChannelsAutomationMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {NotificationChannelsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomationInterface
     */
    markAsReadNotificationAll(
        requestParameters: NotificationChannelsAutomationMarkAsReadNotificationAllRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {NotificationChannelsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomationInterface
     */
    testExistingNotificationChannel(
        requestParameters: NotificationChannelsAutomationTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationTestResponse>;

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {NotificationChannelsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomationInterface
     */
    testNotificationChannel(
        requestParameters: NotificationChannelsAutomationTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationTestResponse>;
}

/**
 * Request parameters for getNotifications operation in NotificationChannelsAutomation.
 * @export
 * @interface NotificationChannelsAutomationGetNotificationsRequest
 */
export interface NotificationChannelsAutomationGetNotificationsRequest {
    /**
     * Workspace ID to filter notifications by.
     * @type {string}
     * @memberof NotificationChannelsAutomationGetNotifications
     */
    readonly workspaceId?: string;

    /**
     * Filter notifications by read status.
     * @type {boolean}
     * @memberof NotificationChannelsAutomationGetNotifications
     */
    readonly isRead?: boolean;

    /**
     * Zero-based page index (0..N)
     * @type {string}
     * @memberof NotificationChannelsAutomationGetNotifications
     */
    readonly page?: string;

    /**
     * The size of the page to be returned.
     * @type {string}
     * @memberof NotificationChannelsAutomationGetNotifications
     */
    readonly size?: string;

    /**
     * Additional meta information to include in the response.
     * @type {Array<'total' | 'ALL'>}
     * @memberof NotificationChannelsAutomationGetNotifications
     */
    readonly metaInclude?: Array<"total" | "ALL">;
}

/**
 * Request parameters for markAsReadNotification operation in NotificationChannelsAutomation.
 * @export
 * @interface NotificationChannelsAutomationMarkAsReadNotificationRequest
 */
export interface NotificationChannelsAutomationMarkAsReadNotificationRequest {
    /**
     * Notification ID to mark as read.
     * @type {string}
     * @memberof NotificationChannelsAutomationMarkAsReadNotification
     */
    readonly notificationId: string;
}

/**
 * Request parameters for markAsReadNotificationAll operation in NotificationChannelsAutomation.
 * @export
 * @interface NotificationChannelsAutomationMarkAsReadNotificationAllRequest
 */
export interface NotificationChannelsAutomationMarkAsReadNotificationAllRequest {
    /**
     * Workspace ID where to mark notifications as read.
     * @type {string}
     * @memberof NotificationChannelsAutomationMarkAsReadNotificationAll
     */
    readonly workspaceId?: string;
}

/**
 * Request parameters for testExistingNotificationChannel operation in NotificationChannelsAutomation.
 * @export
 * @interface NotificationChannelsAutomationTestExistingNotificationChannelRequest
 */
export interface NotificationChannelsAutomationTestExistingNotificationChannelRequest {
    /**
     *
     * @type {string}
     * @memberof NotificationChannelsAutomationTestExistingNotificationChannel
     */
    readonly notificationChannelId: string;

    /**
     *
     * @type {AutomationTestDestinationRequest}
     * @memberof NotificationChannelsAutomationTestExistingNotificationChannel
     */
    readonly automationTestDestinationRequest?: AutomationTestDestinationRequest;
}

/**
 * Request parameters for testNotificationChannel operation in NotificationChannelsAutomation.
 * @export
 * @interface NotificationChannelsAutomationTestNotificationChannelRequest
 */
export interface NotificationChannelsAutomationTestNotificationChannelRequest {
    /**
     *
     * @type {AutomationTestDestinationRequest}
     * @memberof NotificationChannelsAutomationTestNotificationChannel
     */
    readonly automationTestDestinationRequest: AutomationTestDestinationRequest;
}

/**
 * NotificationChannelsAutomation - object-oriented interface
 * @export
 * @class NotificationChannelsAutomation
 * @extends {BaseAPI}
 */
export class NotificationChannelsAutomation
    extends BaseAPI
    implements NotificationChannelsAutomationInterface
{
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {NotificationChannelsAutomationGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomation
     */
    public getNotifications(
        requestParameters: NotificationChannelsAutomationGetNotificationsRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsAutomationFp(this.configuration)
            .getNotifications(
                requestParameters.workspaceId,
                requestParameters.isRead,
                requestParameters.page,
                requestParameters.size,
                requestParameters.metaInclude,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {NotificationChannelsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomation
     */
    public markAsReadNotification(
        requestParameters: NotificationChannelsAutomationMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsAutomationFp(this.configuration)
            .markAsReadNotification(requestParameters.notificationId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {NotificationChannelsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomation
     */
    public markAsReadNotificationAll(
        requestParameters: NotificationChannelsAutomationMarkAsReadNotificationAllRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsAutomationFp(this.configuration)
            .markAsReadNotificationAll(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {NotificationChannelsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomation
     */
    public testExistingNotificationChannel(
        requestParameters: NotificationChannelsAutomationTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsAutomationFp(this.configuration)
            .testExistingNotificationChannel(
                requestParameters.notificationChannelId,
                requestParameters.automationTestDestinationRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {NotificationChannelsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomation
     */
    public testNotificationChannel(
        requestParameters: NotificationChannelsAutomationTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsAutomationFp(this.configuration)
            .testNotificationChannel(requestParameters.automationTestDestinationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
