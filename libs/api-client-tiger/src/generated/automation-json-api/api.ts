// (C) 2024 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 *
 * @export
 * @interface AlertDescription
 */
export interface AlertDescription {
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    metric: string;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    condition: string;
    /**
     *
     * @type {Array<AlertEvaluationRow>}
     * @memberof AlertDescription
     */
    currentValues?: Array<AlertEvaluationRow>;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    attribute?: string;
    /**
     *
     * @type {number}
     * @memberof AlertDescription
     */
    totalValueCount?: number;
    /**
     *
     * @type {number}
     * @memberof AlertDescription
     */
    triggeredCount?: number;
    /**
     *
     * @type {number}
     * @memberof AlertDescription
     */
    threshold?: number;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    formattedThreshold?: string;
    /**
     *
     * @type {number}
     * @memberof AlertDescription
     */
    lowerThreshold?: number;
    /**
     *
     * @type {number}
     * @memberof AlertDescription
     */
    upperThreshold?: number;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    status?: AlertDescriptionStatusEnum;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    errorMessage?: string;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    traceId?: string;
}

export const AlertDescriptionStatusEnum = {
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    INTERNAL_ERROR: "INTERNAL_ERROR",
    TIMEOUT: "TIMEOUT",
} as const;

export type AlertDescriptionStatusEnum =
    typeof AlertDescriptionStatusEnum[keyof typeof AlertDescriptionStatusEnum];

/**
 *
 * @export
 * @interface AlertEvaluationRow
 */
export interface AlertEvaluationRow {
    /**
     *
     * @type {MetricRecord}
     * @memberof AlertEvaluationRow
     */
    primaryMetric?: MetricRecord;
    /**
     *
     * @type {MetricRecord}
     * @memberof AlertEvaluationRow
     */
    secondaryMetric?: MetricRecord;
    /**
     *
     * @type {MetricRecord}
     * @memberof AlertEvaluationRow
     */
    computedMetric?: MetricRecord;
    /**
     *
     * @type {string}
     * @memberof AlertEvaluationRow
     */
    labelValue?: string;
}
/**
 *
 * @export
 * @interface AutomationNotification
 */
export interface AutomationNotification extends NotificationContent {
    /**
     *
     * @type {WebhookMessage}
     * @memberof AutomationNotification
     */
    content: WebhookMessage;
}
/**
 *
 * @export
 * @interface AutomationNotificationAllOf
 */
export interface AutomationNotificationAllOf {
    /**
     *
     * @type {WebhookMessage}
     * @memberof AutomationNotificationAllOf
     */
    content?: WebhookMessage;
}
/**
 * Default SMTP destination for notifications.
 * @export
 * @interface DefaultSmtp
 */
export interface DefaultSmtp {
    /**
     * E-mail address to send notifications from. Currently this does not have any effect. E-mail \'no-reply@gooddata.com\' is used instead.
     * @type {string}
     * @memberof DefaultSmtp
     */
    fromEmail?: string;
    /**
     * An optional e-mail name to send notifications from. Currently this does not have any effect. E-mail from name \'GoodData\' is used instead.
     * @type {string}
     * @memberof DefaultSmtp
     */
    fromEmailName?: string;
    /**
     * The destination type.
     * @type {string}
     * @memberof DefaultSmtp
     */
    type: DefaultSmtpTypeEnum;
}

export const DefaultSmtpTypeEnum = {
    DEFAULT_SMTP: "DEFAULT_SMTP",
} as const;

export type DefaultSmtpTypeEnum = typeof DefaultSmtpTypeEnum[keyof typeof DefaultSmtpTypeEnum];

/**
 *
 * @export
 * @interface ExportResult
 */
export interface ExportResult {
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    fileName: string;
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    exportId: string;
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    status: ExportResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    fileUri?: string;
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    errorMessage?: string;
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    traceId?: string;
}

export const ExportResultStatusEnum = {
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    INTERNAL_ERROR: "INTERNAL_ERROR",
    TIMEOUT: "TIMEOUT",
} as const;

export type ExportResultStatusEnum = typeof ExportResultStatusEnum[keyof typeof ExportResultStatusEnum];

/**
 * In-platform destination for notifications.
 * @export
 * @interface InPlatform
 */
export interface InPlatform {
    /**
     * The destination type.
     * @type {string}
     * @memberof InPlatform
     */
    type: InPlatformTypeEnum;
}

export const InPlatformTypeEnum = {
    IN_PLATFORM: "IN_PLATFORM",
} as const;

export type InPlatformTypeEnum = typeof InPlatformTypeEnum[keyof typeof InPlatformTypeEnum];

/**
 *
 * @export
 * @interface MetricRecord
 */
export interface MetricRecord {
    /**
     *
     * @type {number}
     * @memberof MetricRecord
     */
    value: number;
    /**
     *
     * @type {string}
     * @memberof MetricRecord
     */
    formattedValue?: string;
}
/**
 *
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    workspaceId?: string;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    automationId?: string;
    /**
     *
     * @type {AutomationNotification | TestNotification}
     * @memberof Notification
     */
    data: AutomationNotification | TestNotification;
    /**
     *
     * @type {boolean}
     * @memberof Notification
     */
    isRead: boolean;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    createdAt: string;
}
/**
 * @type NotificationChannelDestination
 * @export
 */
export type NotificationChannelDestination = DefaultSmtp | InPlatform | Smtp | Webhook;

/**
 *
 * @export
 * @interface NotificationContent
 */
export interface NotificationContent {
    /**
     *
     * @type {string}
     * @memberof NotificationContent
     */
    type: string;
}
/**
 * Custom SMTP destination for notifications. The properties host, port, username, and password are required on create and update
 * @export
 * @interface Smtp
 */
export interface Smtp {
    /**
     * E-mail address to send notifications from.
     * @type {string}
     * @memberof Smtp
     */
    fromEmail?: string;
    /**
     * An optional e-mail name to send notifications from.
     * @type {string}
     * @memberof Smtp
     */
    fromEmailName?: string;
    /**
     * The SMTP server address.
     * @type {string}
     * @memberof Smtp
     */
    host?: string;
    /**
     * The SMTP server port.
     * @type {number}
     * @memberof Smtp
     */
    port?: SmtpPortEnum;
    /**
     * The SMTP server username.
     * @type {string}
     * @memberof Smtp
     */
    username?: string;
    /**
     * The SMTP server password.
     * @type {string}
     * @memberof Smtp
     */
    password?: string;
    /**
     * The destination type.
     * @type {string}
     * @memberof Smtp
     */
    type: SmtpTypeEnum;
}

export const SmtpPortEnum = {
    NUMBER_25: 25,
    NUMBER_465: 465,
    NUMBER_587: 587,
    NUMBER_2525: 2525,
} as const;

export type SmtpPortEnum = typeof SmtpPortEnum[keyof typeof SmtpPortEnum];
export const SmtpTypeEnum = {
    SMTP: "SMTP",
} as const;

export type SmtpTypeEnum = typeof SmtpTypeEnum[keyof typeof SmtpTypeEnum];

/**
 * Request body with notification channel destination to test.
 * @export
 * @interface TestDestinationRequest
 */
export interface TestDestinationRequest {
    /**
     *
     * @type {DefaultSmtp | InPlatform | Smtp | Webhook}
     * @memberof TestDestinationRequest
     */
    destination: DefaultSmtp | InPlatform | Smtp | Webhook;
}
/**
 *
 * @export
 * @interface TestNotification
 */
export interface TestNotification extends NotificationContent {
    /**
     *
     * @type {string}
     * @memberof TestNotification
     */
    message: string;
}
/**
 *
 * @export
 * @interface TestNotificationAllOf
 */
export interface TestNotificationAllOf {
    /**
     *
     * @type {string}
     * @memberof TestNotificationAllOf
     */
    message?: string;
}
/**
 * Response from notification channel testing.
 * @export
 * @interface TestResponse
 */
export interface TestResponse {
    /**
     * A flag indicating whether test passed or not.
     * @type {boolean}
     * @memberof TestResponse
     */
    successful: boolean;
    /**
     * Field containing more details in case of a failure. Details are available to a privileged user only.
     * @type {string}
     * @memberof TestResponse
     */
    error?: string;
}
/**
 * Webhook destination for notifications. The property url is required on create and update.
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * The webhook URL.
     * @type {string}
     * @memberof Webhook
     */
    url?: string;
    /**
     * Bearer token for the webhook.
     * @type {string}
     * @memberof Webhook
     */
    token?: string | null;
    /**
     * Flag indicating if webhook has a token.
     * @type {boolean}
     * @memberof Webhook
     */
    hasToken?: boolean | null;
    /**
     * The destination type.
     * @type {string}
     * @memberof Webhook
     */
    type: WebhookTypeEnum;
}

export const WebhookTypeEnum = {
    WEBHOOK: "WEBHOOK",
} as const;

export type WebhookTypeEnum = typeof WebhookTypeEnum[keyof typeof WebhookTypeEnum];

/**
 *
 * @export
 * @interface WebhookAutomationInfo
 */
export interface WebhookAutomationInfo {
    /**
     *
     * @type {string}
     * @memberof WebhookAutomationInfo
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof WebhookAutomationInfo
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof WebhookAutomationInfo
     */
    dashboardURL: string;
}
/**
 *
 * @export
 * @interface WebhookMessage
 */
export interface WebhookMessage {
    /**
     *
     * @type {string}
     * @memberof WebhookMessage
     */
    timestamp: string;
    /**
     *
     * @type {WebhookMessageData}
     * @memberof WebhookMessage
     */
    data: WebhookMessageData;
    /**
     *
     * @type {string}
     * @memberof WebhookMessage
     */
    type: WebhookMessageTypeEnum;
}

export const WebhookMessageTypeEnum = {
    COMPLETED: "automation-task.completed",
    LIMIT_EXCEEDED: "automation-task.limit-exceeded",
} as const;

export type WebhookMessageTypeEnum = typeof WebhookMessageTypeEnum[keyof typeof WebhookMessageTypeEnum];

/**
 *
 * @export
 * @interface WebhookMessageData
 */
export interface WebhookMessageData {
    /**
     *
     * @type {WebhookAutomationInfo}
     * @memberof WebhookMessageData
     */
    automation: WebhookAutomationInfo;
    /**
     *
     * @type {Array<WebhookRecipient>}
     * @memberof WebhookMessageData
     */
    recipients?: Array<WebhookRecipient>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof WebhookMessageData
     */
    details?: { [key: string]: string };
    /**
     *
     * @type {number}
     * @memberof WebhookMessageData
     */
    remainingActionCount?: number;
    /**
     *
     * @type {Array<ExportResult>}
     * @memberof WebhookMessageData
     */
    tabularExports?: Array<ExportResult>;
    /**
     *
     * @type {Array<ExportResult>}
     * @memberof WebhookMessageData
     */
    visualExports?: Array<ExportResult>;
    /**
     *
     * @type {AlertDescription}
     * @memberof WebhookMessageData
     */
    alert?: AlertDescription;
}
/**
 *
 * @export
 * @interface WebhookRecipient
 */
export interface WebhookRecipient {
    /**
     *
     * @type {string}
     * @memberof WebhookRecipient
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof WebhookRecipient
     */
    email: string;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {string} [workspaceId] Workspace ID to filter notifications by.
         * @param {string} [page] Zero-based page index (0..N)
         * @param {string} [size] The size of the page to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (
            workspaceId?: string,
            page?: string,
            size?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter["workspaceId"] = workspaceId;
            }

            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {string} notificationId Notification ID to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotification: async (
            notificationId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists("markAsReadNotification", "notificationId", notificationId);
            const localVarPath = `/api/v1/notifications/{notificationId}/markAsRead`.replace(
                `{${"notificationId"}}`,
                encodeURIComponent(String(notificationId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel: async (
            notificationChannelId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists(
                "testExistingNotificationChannel",
                "notificationChannelId",
                notificationChannelId,
            );
            const localVarPath = `/api/v1/actions/notificationChannels/{notificationChannelId}/test`.replace(
                `{${"notificationChannelId"}}`,
                encodeURIComponent(String(notificationChannelId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {TestDestinationRequest} testDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel: async (
            testDestinationRequest: TestDestinationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'testDestinationRequest' is not null or undefined
            assertParamExists("testNotificationChannel", "testDestinationRequest", testDestinationRequest);
            const localVarPath = `/api/v1/actions/notificationChannels/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof testDestinationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testDestinationRequest !== undefined ? testDestinationRequest : {})
                : testDestinationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {string} [workspaceId] Workspace ID to filter notifications by.
         * @param {string} [page] Zero-based page index (0..N)
         * @param {string} [size] The size of the page to be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(
            workspaceId?: string,
            page?: string,
            size?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(
                workspaceId,
                page,
                size,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {string} notificationId Notification ID to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsReadNotification(
            notificationId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsReadNotification(
                notificationId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testExistingNotificationChannel(
            notificationChannelId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testExistingNotificationChannel(
                notificationChannelId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {TestDestinationRequest} testDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testNotificationChannel(
            testDestinationRequest: TestDestinationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testNotificationChannel(
                testDestinationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {ActionsApiGetNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(
            requestParameters: ActionsApiGetNotificationsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<Notification>> {
            return localVarFp
                .getNotifications(
                    requestParameters.workspaceId,
                    requestParameters.page,
                    requestParameters.size,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {ActionsApiMarkAsReadNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotification(
            requestParameters: ActionsApiMarkAsReadNotificationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .markAsReadNotification(requestParameters.notificationId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {ActionsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel(
            requestParameters: ActionsApiTestExistingNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testExistingNotificationChannel(requestParameters.notificationChannelId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {ActionsApiTestNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel(
            requestParameters: ActionsApiTestNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testNotificationChannel(requestParameters.testDestinationRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {ActionsApiGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getNotifications(
        requestParameters: ActionsApiGetNotificationsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<Notification>>;

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {ActionsApiMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    markAsReadNotification(
        requestParameters: ActionsApiMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {ActionsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    testExistingNotificationChannel(
        requestParameters: ActionsApiTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {ActionsApiTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    testNotificationChannel(
        requestParameters: ActionsApiTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;
}

/**
 * Request parameters for getNotifications operation in ActionsApi.
 * @export
 * @interface ActionsApiGetNotificationsRequest
 */
export interface ActionsApiGetNotificationsRequest {
    /**
     * Workspace ID to filter notifications by.
     * @type {string}
     * @memberof ActionsApiGetNotifications
     */
    readonly workspaceId?: string;

    /**
     * Zero-based page index (0..N)
     * @type {string}
     * @memberof ActionsApiGetNotifications
     */
    readonly page?: string;

    /**
     * The size of the page to be returned.
     * @type {string}
     * @memberof ActionsApiGetNotifications
     */
    readonly size?: string;
}

/**
 * Request parameters for markAsReadNotification operation in ActionsApi.
 * @export
 * @interface ActionsApiMarkAsReadNotificationRequest
 */
export interface ActionsApiMarkAsReadNotificationRequest {
    /**
     * Notification ID to mark as read.
     * @type {string}
     * @memberof ActionsApiMarkAsReadNotification
     */
    readonly notificationId: string;
}

/**
 * Request parameters for testExistingNotificationChannel operation in ActionsApi.
 * @export
 * @interface ActionsApiTestExistingNotificationChannelRequest
 */
export interface ActionsApiTestExistingNotificationChannelRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiTestExistingNotificationChannel
     */
    readonly notificationChannelId: string;
}

/**
 * Request parameters for testNotificationChannel operation in ActionsApi.
 * @export
 * @interface ActionsApiTestNotificationChannelRequest
 */
export interface ActionsApiTestNotificationChannelRequest {
    /**
     *
     * @type {TestDestinationRequest}
     * @memberof ActionsApiTestNotificationChannel
     */
    readonly testDestinationRequest: TestDestinationRequest;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {ActionsApiGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getNotifications(
        requestParameters: ActionsApiGetNotificationsRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .getNotifications(
                requestParameters.workspaceId,
                requestParameters.page,
                requestParameters.size,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {ActionsApiMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public markAsReadNotification(
        requestParameters: ActionsApiMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .markAsReadNotification(requestParameters.notificationId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {ActionsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public testExistingNotificationChannel(
        requestParameters: ActionsApiTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .testExistingNotificationChannel(requestParameters.notificationChannelId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {ActionsApiTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public testNotificationChannel(
        requestParameters: ActionsApiTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .testNotificationChannel(requestParameters.testDestinationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * NotificationChannelsApi - axios parameter creator
 * @export
 */
export const NotificationChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel: async (
            notificationChannelId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists(
                "testExistingNotificationChannel",
                "notificationChannelId",
                notificationChannelId,
            );
            const localVarPath = `/api/v1/actions/notificationChannels/{notificationChannelId}/test`.replace(
                `{${"notificationChannelId"}}`,
                encodeURIComponent(String(notificationChannelId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {TestDestinationRequest} testDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel: async (
            testDestinationRequest: TestDestinationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'testDestinationRequest' is not null or undefined
            assertParamExists("testNotificationChannel", "testDestinationRequest", testDestinationRequest);
            const localVarPath = `/api/v1/actions/notificationChannels/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof testDestinationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testDestinationRequest !== undefined ? testDestinationRequest : {})
                : testDestinationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * NotificationChannelsApi - functional programming interface
 * @export
 */
export const NotificationChannelsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationChannelsApiAxiosParamCreator(configuration);
    return {
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testExistingNotificationChannel(
            notificationChannelId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testExistingNotificationChannel(
                notificationChannelId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {TestDestinationRequest} testDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testNotificationChannel(
            testDestinationRequest: TestDestinationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testNotificationChannel(
                testDestinationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * NotificationChannelsApi - factory interface
 * @export
 */
export const NotificationChannelsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = NotificationChannelsApiFp(configuration);
    return {
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {NotificationChannelsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel(
            requestParameters: NotificationChannelsApiTestExistingNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testExistingNotificationChannel(requestParameters.notificationChannelId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {NotificationChannelsApiTestNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel(
            requestParameters: NotificationChannelsApiTestNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testNotificationChannel(requestParameters.testDestinationRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationChannelsApi - interface
 * @export
 * @interface NotificationChannelsApi
 */
export interface NotificationChannelsApiInterface {
    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {NotificationChannelsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApiInterface
     */
    testExistingNotificationChannel(
        requestParameters: NotificationChannelsApiTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {NotificationChannelsApiTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApiInterface
     */
    testNotificationChannel(
        requestParameters: NotificationChannelsApiTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;
}

/**
 * Request parameters for testExistingNotificationChannel operation in NotificationChannelsApi.
 * @export
 * @interface NotificationChannelsApiTestExistingNotificationChannelRequest
 */
export interface NotificationChannelsApiTestExistingNotificationChannelRequest {
    /**
     *
     * @type {string}
     * @memberof NotificationChannelsApiTestExistingNotificationChannel
     */
    readonly notificationChannelId: string;
}

/**
 * Request parameters for testNotificationChannel operation in NotificationChannelsApi.
 * @export
 * @interface NotificationChannelsApiTestNotificationChannelRequest
 */
export interface NotificationChannelsApiTestNotificationChannelRequest {
    /**
     *
     * @type {TestDestinationRequest}
     * @memberof NotificationChannelsApiTestNotificationChannel
     */
    readonly testDestinationRequest: TestDestinationRequest;
}

/**
 * NotificationChannelsApi - object-oriented interface
 * @export
 * @class NotificationChannelsApi
 * @extends {BaseAPI}
 */
export class NotificationChannelsApi extends BaseAPI implements NotificationChannelsApiInterface {
    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {NotificationChannelsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApi
     */
    public testExistingNotificationChannel(
        requestParameters: NotificationChannelsApiTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsApiFp(this.configuration)
            .testExistingNotificationChannel(requestParameters.notificationChannelId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {NotificationChannelsApiTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApi
     */
    public testNotificationChannel(
        requestParameters: NotificationChannelsApiTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsApiFp(this.configuration)
            .testNotificationChannel(requestParameters.testDestinationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
