// (C) 2026 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 */
export interface AutomationAFM {
    /**
     * Attributes to be used in the computation.
     */
    attributes: Array<AutomationAttributeItem>;
    /**
     * Various filter types to filter the execution result.
     */
    filters: Array<AutomationAFMFiltersInner>;
    /**
     * Metrics to be computed.
     */
    measures: Array<AutomationMeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     */
    auxMeasures?: Array<AutomationMeasureItem>;
}

/**
 * @type AutomationAFMFiltersInner
 */
export type AutomationAFMFiltersInner =
    | AutomationAbstractMeasureValueFilter
    | AutomationFilterDefinitionForSimpleMeasure
    | AutomationInlineFilterDefinition;

/**
 * A datetime filter specifying exact from and to values.
 */
export interface AutomationAbsoluteDateFilter {
    absoluteDateFilter: AutomationAbsoluteDateFilterAbsoluteDateFilter;
}

export interface AutomationAbsoluteDateFilterAbsoluteDateFilter {
    from: string;
    to: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
    /**
     * If true, rows with undefined (NULL) date values will be included in the result. The filter becomes: (date_condition) OR (date IS NULL). If false or not set, standard behavior applies (NULLs excluded by the date condition).
     */
    includeEmptyValues?: boolean;
    dataset: AutomationAfmObjectIdentifierDataset;
}

/**
 * @type AutomationAbstractMeasureValueFilter
 */
export type AutomationAbstractMeasureValueFilter =
    | AutomationComparisonMeasureValueFilter
    | AutomationCompoundMeasureValueFilter
    | AutomationRangeMeasureValueFilter
    | AutomationRankingFilter;

export interface AutomationAdHocAutomation {
    title?: string;
    description?: string;
    /**
     * A list of tags.
     */
    tags?: Array<string>;
    /**
     * Additional details to be included in the automated message.
     */
    details?: { [key: string]: string };
    metadata?: AutomationAutomationMetadata | null;
    alert?: AutomationAutomationAlert;
    tabularExports?: Array<AutomationAutomationTabularExport>;
    visualExports?: Array<AutomationAutomationVisualExport>;
    imageExports?: Array<AutomationAutomationImageExport>;
    rawExports?: Array<AutomationAutomationRawExport>;
    slidesExports?: Array<AutomationAutomationSlidesExport>;
    dashboardTabularExports?: Array<AutomationAutomationDashboardTabularExport>;
    /**
     * External recipients of the automation action results.
     */
    externalRecipients?: Array<AutomationAutomationExternalRecipient>;
    notificationChannel?: AutomationDeclarativeNotificationChannelIdentifier;
    recipients?: Array<AutomationDeclarativeUserIdentifier>;
    analyticalDashboard?: AutomationDeclarativeAnalyticalDashboardIdentifier;
}

/**
 * @type AutomationAfmIdentifier
 * Reference to the attribute label to which the filter should be applied.
 */
export type AutomationAfmIdentifier = AutomationAfmLocalIdentifier | AutomationAfmObjectIdentifier;

export interface AutomationAfmLocalIdentifier {
    localIdentifier: string;
}

/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 */
export interface AutomationAfmObjectIdentifier {
    identifier: AutomationAfmObjectIdentifierIdentifier;
}

/**
 * Reference to the date attribute to use.
 */
export interface AutomationAfmObjectIdentifierAttribute {
    identifier: AutomationAfmObjectIdentifierAttributeIdentifier;
}

export interface AutomationAfmObjectIdentifierAttributeIdentifier {
    id: string;
    type: AutomationAfmObjectIdentifierAttributeIdentifierTypeEnum;
}

export type AutomationAfmObjectIdentifierAttributeIdentifierTypeEnum = "attribute";

/**
 * Reference to the metric, fact or attribute object to use for the metric.
 */
export interface AutomationAfmObjectIdentifierCore {
    identifier: AutomationAfmObjectIdentifierCoreIdentifier;
}

export interface AutomationAfmObjectIdentifierCoreIdentifier {
    id: string;
    type: AutomationAfmObjectIdentifierCoreIdentifierTypeEnum;
}

export type AutomationAfmObjectIdentifierCoreIdentifierTypeEnum = "attribute" | "label" | "fact" | "metric";

/**
 * Date dataset used for anomaly detection.
 */
export interface AutomationAfmObjectIdentifierDataset {
    identifier: AutomationAfmObjectIdentifierDatasetIdentifier;
}

export interface AutomationAfmObjectIdentifierDatasetIdentifier {
    id: string;
    type: AutomationAfmObjectIdentifierDatasetIdentifierTypeEnum;
}

export type AutomationAfmObjectIdentifierDatasetIdentifierTypeEnum = "dataset";

export interface AutomationAfmObjectIdentifierIdentifier {
    type: AutomationAfmObjectIdentifierIdentifierTypeEnum;
    id: string;
}

export type AutomationAfmObjectIdentifierIdentifierTypeEnum =
    | "analyticalDashboard"
    | "attribute"
    | "dashboardPlugin"
    | "dataset"
    | "fact"
    | "label"
    | "metric"
    | "prompt"
    | "visualizationObject"
    | "filterContext";

export interface AutomationAfmObjectIdentifierLabel {
    identifier: AutomationAfmObjectIdentifierLabelIdentifier;
}

export interface AutomationAfmObjectIdentifierLabelIdentifier {
    type: AutomationAfmObjectIdentifierLabelIdentifierTypeEnum;
    id: string;
}

export type AutomationAfmObjectIdentifierLabelIdentifierTypeEnum = "label";

export interface AutomationAlertAfm {
    /**
     * Attributes to be used in the computation.
     */
    attributes?: Array<AutomationAttributeItem>;
    /**
     * Various filter types to filter execution result. For anomaly detection, exactly one dataset is specified in the condition. The AFM may contain multiple date filters for different datasets, but only the date filter matching the dataset from the condition is used for anomaly detection.
     */
    filters: Array<AutomationFilterDefinition>;
    /**
     * Metrics to be computed. One metric if the alert condition is evaluated to a scalar. Two metrics when they should be evaluated to each other.
     */
    measures: Array<AutomationMeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     */
    auxMeasures?: Array<AutomationMeasureItem>;
}

/**
 * @type AutomationAlertCondition
 * Alert trigger condition.
 */
export type AutomationAlertCondition =
    | AutomationAnomalyDetectionWrapper
    | AutomationComparisonWrapper
    | AutomationRangeWrapper
    | AutomationRelativeWrapper;

/**
 * @type AutomationAlertConditionOperand
 * Operand of the alert condition.
 */
export type AutomationAlertConditionOperand = AutomationLocalIdentifier | AutomationValue;

export interface AutomationAlertDescription {
    metric: string;
    condition: string;
    currentValues?: Array<AutomationAlertEvaluationRow>;
    attribute?: string;
    totalValueCount?: number;
    triggeredCount?: number;
    triggeredAt?: string;
    threshold?: number;
    formattedThreshold?: string;
    lowerThreshold?: number;
    upperThreshold?: number;
    remainingAlertEvaluationCount?: number;
    status?: AutomationAlertDescriptionStatusEnum;
    errorMessage?: string;
    traceId?: string;
}

export type AutomationAlertDescriptionStatusEnum = "SUCCESS" | "ERROR" | "INTERNAL_ERROR" | "TIMEOUT";

export interface AutomationAlertEvaluationRow {
    primaryMetric?: AutomationMetricRecord;
    secondaryMetric?: AutomationMetricRecord;
    computedMetric?: AutomationMetricRecord;
    labelValue?: string;
}

export interface AutomationAnomalyDetection {
    measure: AutomationLocalIdentifier;
    /**
     * Sensitivity level for anomaly detection
     */
    sensitivity: AutomationAnomalyDetectionSensitivityEnum;
    /**
     * Date granularity for anomaly detection. Only time-based granularities are supported (HOUR, DAY, WEEK, MONTH, QUARTER, YEAR).
     */
    granularity: AutomationAnomalyDetectionGranularityEnum;
    dataset: AutomationAfmObjectIdentifierDataset;
}

export type AutomationAnomalyDetectionSensitivityEnum = "LOW" | "MEDIUM" | "HIGH";
export type AutomationAnomalyDetectionGranularityEnum =
    | "HOUR"
    | "DAY"
    | "WEEK"
    | "MONTH"
    | "QUARTER"
    | "YEAR";

export interface AutomationAnomalyDetectionWrapper {
    anomaly: AutomationAnomalyDetection;
}

export interface AutomationArithmeticMeasure {
    /**
     * Arithmetic operator. DIFFERENCE - m₁−m₂ - the difference between two metrics. CHANGE - (m₁−m₂)÷m₂ - the relative difference between two metrics.
     */
    operator: AutomationArithmeticMeasureOperatorEnum;
    left: AutomationLocalIdentifier;
    right: AutomationLocalIdentifier;
}

export type AutomationArithmeticMeasureOperatorEnum = "DIFFERENCE" | "CHANGE";

/**
 * Metric representing arithmetics between other metrics.
 */
export interface AutomationArithmeticMeasureDefinition {
    arithmeticMeasure: AutomationArithmeticMeasureDefinitionArithmeticMeasure;
}

export interface AutomationArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of metrics to apply arithmetic operation by chosen operator.
     */
    measureIdentifiers: Array<AutomationAfmLocalIdentifier>;
    /**
     * Arithmetic operator describing operation between metrics.
     */
    operator: AutomationArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

export type AutomationArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum =
    | "SUM"
    | "DIFFERENCE"
    | "MULTIPLICATION"
    | "RATIO"
    | "CHANGE";

/**
 * @type AutomationAttributeElements
 */
export type AutomationAttributeElements =
    | AutomationAttributeElementsByRef
    | AutomationAttributeElementsByValue;

export interface AutomationAttributeElementsByRef {
    /**
     * List of attribute elements by reference
     */
    uris: Array<string | null>;
}

export interface AutomationAttributeElementsByValue {
    /**
     * List of attribute elements by value
     */
    values: Array<string | null>;
}

/**
 * @type AutomationAttributeFilter
 * Abstract filter definition type attributes
 */
export type AutomationAttributeFilter = AutomationNegativeAttributeFilter | AutomationPositiveAttributeFilter;

export interface AutomationAttributeFilterByDate {
    filterLocalIdentifier: string;
    isCommonDate: boolean;
}

/**
 * Filter on specific set of label values.
 */
export interface AutomationAttributeFilterElements {
    /**
     * Set of label values.
     */
    values: Array<string | null>;
}

export interface AutomationAttributeFilterParent {
    filterLocalIdentifier: string;
    over: AutomationOver;
}

export interface AutomationAttributeItem {
    /**
     * Local identifier of the attribute. This can be used to reference the attribute in other parts of the execution definition.
     */
    localIdentifier: string;
    label: AutomationAfmObjectIdentifierLabel;
    /**
     * Indicates whether to show all values of given attribute even if the data bound to those values is not available.
     */
    showAllValues?: boolean;
}

export interface AutomationAutomationAlert {
    execution: AutomationAlertAfm;
    condition: AutomationAutomationAlertCondition;
    /**
     * Trigger behavior for the alert. ALWAYS - alert is triggered every time the condition is met. ONCE - alert is triggered only once when the condition is met.
     */
    trigger?: AutomationAutomationAlertTriggerEnum;
}

export type AutomationAutomationAlertTriggerEnum = "ALWAYS" | "ONCE";

/**
 * @type AutomationAutomationAlertCondition
 */
export type AutomationAutomationAlertCondition =
    | AutomationAnomalyDetectionWrapper
    | AutomationComparisonWrapper
    | AutomationRangeWrapper
    | AutomationRelativeWrapper;

export interface AutomationAutomationDashboardTabularExport {
    requestPayload: AutomationDashboardTabularExportRequestV2;
}

export interface AutomationAutomationExternalRecipient {
    /**
     * E-mail address to send notifications from.
     */
    email: string;
}

export interface AutomationAutomationImageExport {
    requestPayload: AutomationImageExportRequest;
}

/**
 * Additional information for the automation.
 */
export interface AutomationAutomationMetadata {
    [key: string]: any;

    widget?: string;
    visibleFilters?: Array<AutomationVisibleFilter>;
}

export interface AutomationAutomationNotification extends AutomationNotificationContent {
    content: AutomationWebhookMessage;
}

export interface AutomationAutomationRawExport {
    requestPayload: AutomationRawExportAutomationRequest;
}

export interface AutomationAutomationSlidesExport {
    requestPayload: AutomationSlidesExportRequest;
}

export interface AutomationAutomationTabularExport {
    requestPayload: AutomationTabularExportRequest;
}

export interface AutomationAutomationVisualExport {
    requestPayload: AutomationVisualExportRequest;
}

/**
 * Bounding filter for this relative date filter. This can be used to limit the range of the relative date filter to a specific date range.
 */
export interface AutomationBoundedFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: AutomationBoundedFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\'). If null, then start of the range is unbounded.
     */
    from?: number | null;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...). If null, then end of the range is unbounded.
     */
    to?: number | null;
}

export type AutomationBoundedFilterGranularityEnum =
    | "MINUTE"
    | "HOUR"
    | "DAY"
    | "WEEK"
    | "MONTH"
    | "QUARTER"
    | "YEAR"
    | "MINUTE_OF_HOUR"
    | "HOUR_OF_DAY"
    | "DAY_OF_WEEK"
    | "DAY_OF_MONTH"
    | "DAY_OF_QUARTER"
    | "DAY_OF_YEAR"
    | "WEEK_OF_YEAR"
    | "MONTH_OF_YEAR"
    | "QUARTER_OF_YEAR"
    | "FISCAL_MONTH"
    | "FISCAL_QUARTER"
    | "FISCAL_YEAR";

export interface AutomationComparison {
    operator: AutomationComparisonOperatorEnum;
    left: AutomationLocalIdentifier;
    right: AutomationAlertConditionOperand;
}

export type AutomationComparisonOperatorEnum =
    | "GREATER_THAN"
    | "GREATER_THAN_OR_EQUAL_TO"
    | "LESS_THAN"
    | "LESS_THAN_OR_EQUAL_TO"
    | "EQUAL_TO"
    | "NOT_EQUAL_TO";

/**
 * Condition that compares the metric value to a given constant value using a comparison operator.
 */
export interface AutomationComparisonCondition {
    comparison: AutomationComparisonConditionComparison;
}

export interface AutomationComparisonConditionComparison {
    operator: AutomationComparisonConditionComparisonOperatorEnum;
    value: number;
}

export type AutomationComparisonConditionComparisonOperatorEnum =
    | "GREATER_THAN"
    | "GREATER_THAN_OR_EQUAL_TO"
    | "LESS_THAN"
    | "LESS_THAN_OR_EQUAL_TO"
    | "EQUAL_TO"
    | "NOT_EQUAL_TO";

/**
 * Filter the result by comparing specified metric to given constant value, using given comparison operator.
 */
export interface AutomationComparisonMeasureValueFilter {
    comparisonMeasureValueFilter: AutomationComparisonMeasureValueFilterComparisonMeasureValueFilter;
}

export interface AutomationComparisonMeasureValueFilterComparisonMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AutomationAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: AutomationComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum;
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: AutomationAfmIdentifier;
}

export type AutomationComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum =
    | "GREATER_THAN"
    | "GREATER_THAN_OR_EQUAL_TO"
    | "LESS_THAN"
    | "LESS_THAN_OR_EQUAL_TO"
    | "EQUAL_TO"
    | "NOT_EQUAL_TO";

export interface AutomationComparisonWrapper {
    comparison: AutomationComparison;
}

/**
 * Filter the result by applying multiple comparison and/or range conditions combined with OR logic. If conditions list is empty, no filtering is applied (all rows are returned).
 */
export interface AutomationCompoundMeasureValueFilter {
    compoundMeasureValueFilter: AutomationCompoundMeasureValueFilterCompoundMeasureValueFilter;
}

export interface AutomationCompoundMeasureValueFilterCompoundMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AutomationAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    /**
     * List of conditions to apply. Conditions are combined with OR logic. Each condition can be either a comparison (e.g., > 100) or a range (e.g., BETWEEN 10 AND 50). If empty, no filtering is applied and all rows are returned.
     */
    conditions: Array<AutomationMeasureValueCondition>;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: AutomationAfmIdentifier;
}

/**
 * Custom label object override.
 */
export interface AutomationCustomLabel {
    /**
     * Override value.
     */
    title: string;
}

/**
 * Custom metric object override.
 */
export interface AutomationCustomMetric {
    /**
     * Metric title override.
     */
    title: string;
    /**
     * Format override.
     */
    format: string;
}

/**
 * Custom cell value overrides (IDs will be replaced with specified values).
 */
export interface AutomationCustomOverride {
    /**
     * Map of CustomLabels with keys used as placeholders in document.
     */
    labels?: { [key: string]: AutomationCustomLabel };
    /**
     * Map of CustomMetrics with keys used as placeholders in document.
     */
    metrics?: { [key: string]: AutomationCustomMetric };
}

export interface AutomationDashboardAttributeFilter {
    attributeFilter: AutomationDashboardAttributeFilterAttributeFilter;
}

export interface AutomationDashboardAttributeFilterAttributeFilter {
    displayForm: AutomationIdentifierRef;
    negativeSelection: boolean;
    attributeElements: AutomationAttributeElements;
    filterElementsBy?: Array<AutomationAttributeFilterParent>;
    filterElementsByDate?: Array<AutomationAttributeFilterByDate>;
    validateElementsBy?: Array<AutomationIdentifierRef>;
    title?: string;
    selectionMode?: AutomationDashboardAttributeFilterAttributeFilterSelectionModeEnum;
    localIdentifier?: string;
}

export type AutomationDashboardAttributeFilterAttributeFilterSelectionModeEnum = "single" | "multi";

export interface AutomationDashboardDateFilter {
    dateFilter: AutomationDashboardDateFilterDateFilter;
}

export interface AutomationDashboardDateFilterDateFilter {
    type: AutomationDashboardDateFilterDateFilterTypeEnum;
    granularity: AutomationDashboardDateFilterDateFilterGranularityEnum;
    from?: AutomationDashboardDateFilterDateFilterFrom;
    to?: AutomationDashboardDateFilterDateFilterFrom;
    dataSet?: AutomationIdentifierRef;
    attribute?: AutomationIdentifierRef;
    boundedFilter?: AutomationRelativeBoundedDateFilter;
    includeEmptyValues?: boolean;
    localIdentifier?: string;
}

export type AutomationDashboardDateFilterDateFilterTypeEnum = "relative" | "absolute";
export type AutomationDashboardDateFilterDateFilterGranularityEnum =
    | "ALL_TIME_GRANULARITY"
    | "GDC.time.year"
    | "GDC.time.week_us"
    | "GDC.time.week_in_year"
    | "GDC.time.week_in_quarter"
    | "GDC.time.week"
    | "GDC.time.euweek_in_year"
    | "GDC.time.euweek_in_quarter"
    | "GDC.time.quarter"
    | "GDC.time.quarter_in_year"
    | "GDC.time.month"
    | "GDC.time.month_in_quarter"
    | "GDC.time.month_in_year"
    | "GDC.time.day_in_year"
    | "GDC.time.day_in_quarter"
    | "GDC.time.day_in_month"
    | "GDC.time.day_in_week"
    | "GDC.time.day_in_euweek"
    | "GDC.time.date"
    | "GDC.time.hour"
    | "GDC.time.hour_in_day"
    | "GDC.time.minute"
    | "GDC.time.minute_in_hour"
    | "GDC.time.fiscal_month"
    | "GDC.time.fiscal_quarter"
    | "GDC.time.fiscal_year";

/**
 * @type AutomationDashboardDateFilterDateFilterFrom
 */
export type AutomationDashboardDateFilterDateFilterFrom = number | string;

/**
 * Additional settings.
 */
export interface AutomationDashboardExportSettings {
    /**
     * If true, the export will contain the information about the export – exported date, dashboard filters, etc.
     */
    exportInfo?: boolean;
    /**
     * Merge equal headers in neighbouring cells. Used for [XLSX] format only.
     */
    mergeHeaders?: boolean;
    /**
     * Set page size. (PDF)
     */
    pageSize?: AutomationDashboardExportSettingsPageSizeEnum;
    /**
     * Set page orientation. (PDF)
     */
    pageOrientation?: AutomationDashboardExportSettingsPageOrientationEnum;
}

export type AutomationDashboardExportSettingsPageSizeEnum = "A3" | "A4" | "LETTER";
export type AutomationDashboardExportSettingsPageOrientationEnum = "PORTRAIT" | "LANDSCAPE";

/**
 * @type AutomationDashboardFilter
 */
export type AutomationDashboardFilter = AutomationDashboardAttributeFilter | AutomationDashboardDateFilter;

/**
 * Export request object describing the export properties for dashboard tabular exports (v2 with dashboardId).
 */
export interface AutomationDashboardTabularExportRequestV2 {
    /**
     * Requested tabular export type.
     */
    format: AutomationDashboardTabularExportRequestV2FormatEnum;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    /**
     * List of filters that will be used instead of the default dashboard filters.
     */
    dashboardFiltersOverride?: Array<AutomationDashboardFilter>;
    /**
     * Map of tab-specific filter overrides. Key is tabId, value is list of filters for that tab.
     */
    dashboardTabsFiltersOverrides?: { [key: string]: Array<AutomationDashboardFilter> };
    /**
     * Dashboard identifier
     */
    dashboardId: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds?: Array<string>;
    settings?: AutomationDashboardExportSettings;
}

export type AutomationDashboardTabularExportRequestV2FormatEnum = "XLSX" | "PDF";

/**
 * @type AutomationDateFilter
 * Abstract filter definition type for dates.
 */
export type AutomationDateFilter = AutomationAbsoluteDateFilter | AutomationRelativeDateFilter;

export interface AutomationDateValue {
    value: string;
}

/**
 * An analytical dashboard identifier.
 */
export interface AutomationDeclarativeAnalyticalDashboardIdentifier {
    /**
     * Identifier of the analytical dashboard.
     */
    id: string;
    /**
     * A type.
     */
    type: AutomationDeclarativeAnalyticalDashboardIdentifierTypeEnum;
}

export type AutomationDeclarativeAnalyticalDashboardIdentifierTypeEnum = "analyticalDashboard";

/**
 * A notification channel identifier.
 */
export interface AutomationDeclarativeNotificationChannelIdentifier {
    /**
     * Notification channel identifier.
     */
    id: string;
    /**
     * A type.
     */
    type: AutomationDeclarativeNotificationChannelIdentifierTypeEnum;
}

export type AutomationDeclarativeNotificationChannelIdentifierTypeEnum = "notificationChannel";

/**
 * A user identifier.
 */
export interface AutomationDeclarativeUserIdentifier {
    /**
     * User identifier.
     */
    id: string;
    /**
     * A type.
     */
    type: AutomationDeclarativeUserIdentifierTypeEnum;
}

export type AutomationDeclarativeUserIdentifierTypeEnum = "user";

/**
 * Default SMTP destination for notifications.
 */
export interface AutomationDefaultSmtp {
    /**
     * E-mail address to send notifications from. Currently this does not have any effect. E-mail \'no-reply@gooddata.com\' is used instead.
     */
    fromEmail?: string;
    /**
     * An optional e-mail name to send notifications from. Currently this does not have any effect. E-mail from name \'GoodData\' is used instead.
     */
    fromEmailName?: string;
    /**
     * The destination type.
     */
    type: AutomationDefaultSmtpTypeEnum;
}

export type AutomationDefaultSmtpTypeEnum = "DEFAULT_SMTP";

/**
 * Various settings affecting the process of AFM execution or its result
 */
export interface AutomationExecutionSettings {
    /**
     * Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     */
    dataSamplingPercentage?: number;
    /**
     * Specifies the timestamp of the execution from which relative filters are resolved. If not set, the current time is used.
     */
    timestamp?: string;
}

export interface AutomationExportResult {
    fileName: string;
    exportId: string;
    status: AutomationExportResultStatusEnum;
    fileUri?: string;
    expiresAt?: string;
    fileSize?: number;
    errorMessage?: string;
    traceId?: string;
    triggeredAt?: string;
}

export type AutomationExportResultStatusEnum = "SUCCESS" | "ERROR" | "INTERNAL_ERROR" | "TIMEOUT";

/**
 * @type AutomationFilterDefinition
 * Abstract filter definition type
 */
export type AutomationFilterDefinition =
    | AutomationAbsoluteDateFilter
    | AutomationComparisonMeasureValueFilter
    | AutomationCompoundMeasureValueFilter
    | AutomationInlineFilterDefinition
    | AutomationNegativeAttributeFilter
    | AutomationPositiveAttributeFilter
    | AutomationRangeMeasureValueFilter
    | AutomationRankingFilter
    | AutomationRelativeDateFilter;

/**
 * @type AutomationFilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple metric.
 */
export type AutomationFilterDefinitionForSimpleMeasure = AutomationAttributeFilter | AutomationDateFilter;

export interface AutomationIdentifierRef {
    identifier?: AutomationIdentifierRefIdentifier;
}

export interface AutomationIdentifierRefIdentifier {
    id: string;
    type: AutomationIdentifierRefIdentifierTypeEnum;
}

export type AutomationIdentifierRefIdentifierTypeEnum =
    | "analyticalDashboard"
    | "attribute"
    | "attributeHierarchy"
    | "dashboardPlugin"
    | "dataset"
    | "fact"
    | "aggregatedFact"
    | "label"
    | "metric"
    | "userDataFilter"
    | "exportDefinition"
    | "automation"
    | "automationResult"
    | "memoryItem"
    | "knowledgeRecommendation"
    | "prompt"
    | "visualizationObject"
    | "filterContext"
    | "workspaceSettings"
    | "customApplicationSetting"
    | "workspaceDataFilter"
    | "workspaceDataFilterSetting"
    | "filterView";

/**
 * Export request object describing the export properties and metadata for image exports.
 */
export interface AutomationImageExportRequest {
    /**
     * Requested resulting file type.
     */
    format: AutomationImageExportRequestFormatEnum;
    /**
     * File name to be used for retrieving the image document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds: Array<string>;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
}

export type AutomationImageExportRequestFormatEnum = "PNG";

/**
 * In-platform destination for notifications.
 */
export interface AutomationInPlatform {
    /**
     * The destination type.
     */
    type: AutomationInPlatformTypeEnum;
}

export type AutomationInPlatformTypeEnum = "IN_PLATFORM";

/**
 * Filter in form of direct MAQL query.
 */
export interface AutomationInlineFilterDefinition {
    inline: AutomationInlineFilterDefinitionInline;
}

export interface AutomationInlineFilterDefinitionInline {
    /**
     * MAQL query representing the filter.
     */
    filter: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
}

/**
 * Metric defined by the raw MAQL query.
 */
export interface AutomationInlineMeasureDefinition {
    inline: AutomationInlineMeasureDefinitionInline;
}

export interface AutomationInlineMeasureDefinitionInline {
    /**
     * MAQL query defining the metric.
     */
    maql: string;
}

export interface AutomationLocalIdentifier {
    /**
     * Local identifier of the metric to be compared.
     */
    localIdentifier: string;
    /**
     * Metric format.
     */
    format?: string | null;
    /**
     * Metric title.
     */
    title?: string | null;
}

/**
 * @type AutomationMeasureDefinition
 * Abstract metric definition type
 */
export type AutomationMeasureDefinition =
    | AutomationArithmeticMeasureDefinition
    | AutomationInlineMeasureDefinition
    | AutomationPopMeasureDefinition
    | AutomationSimpleMeasureDefinition;

/**
 * Metric is a quantity that is calculated from the data.
 */
export interface AutomationMeasureItem {
    /**
     * Local identifier of the metric. This can be used to reference the metric in other parts of the execution definition.
     */
    localIdentifier: string;
    definition: AutomationMeasureItemDefinition;
}

/**
 * @type AutomationMeasureItemDefinition
 */
export type AutomationMeasureItemDefinition =
    | AutomationArithmeticMeasureDefinition
    | AutomationInlineMeasureDefinition
    | AutomationPopDatasetMeasureDefinition
    | AutomationPopDateMeasureDefinition
    | AutomationPopMeasureDefinition
    | AutomationSimpleMeasureDefinition;

/**
 * @type AutomationMeasureValueCondition
 * A condition for filtering by measure value. Can be either a comparison or a range condition.
 */
export type AutomationMeasureValueCondition = AutomationComparisonCondition | AutomationRangeCondition;

/**
 * @type AutomationMeasureValueFilter
 * Abstract filter definition type filtering by the value of the metric.
 */
export type AutomationMeasureValueFilter =
    | AutomationComparisonMeasureValueFilter
    | AutomationCompoundMeasureValueFilter
    | AutomationRangeMeasureValueFilter;

export interface AutomationMetricRecord {
    value: number;
    formattedValue?: string;
}

/**
 * Filter able to limit element values by label and related selected negated elements.
 */
export interface AutomationNegativeAttributeFilter {
    negativeAttributeFilter: AutomationNegativeAttributeFilterNegativeAttributeFilter;
}

export interface AutomationNegativeAttributeFilterNegativeAttributeFilter {
    notIn: AutomationAttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: AutomationAfmIdentifier;
}

export interface AutomationNotification {
    id: string;
    workspaceId?: string;
    automationId?: string;
    data: AutomationNotificationData;
    isRead: boolean;
    createdAt: string;
}

/**
 * @type AutomationNotificationChannelDestination
 */
export type AutomationNotificationChannelDestination =
    | AutomationDefaultSmtp
    | AutomationInPlatform
    | AutomationSmtp
    | AutomationWebhook;

export interface AutomationNotificationContent {
    type: string;
}

/**
 * @type AutomationNotificationData
 */
export type AutomationNotificationData = AutomationAutomationNotification | AutomationTestNotification;

export interface AutomationNotificationFilter {
    title: string;
    filter: string;
}

export interface AutomationNotifications {
    data: Array<AutomationNotification>;
    meta: AutomationNotificationsMeta;
}

export interface AutomationNotificationsMeta {
    total?: AutomationNotificationsMetaTotal;
}

export interface AutomationNotificationsMetaTotal {
    unread: number;
    all: number;
}

export interface AutomationOver {
    attributes: Array<AutomationIdentifierRef>;
}

/**
 * Custom CSS styles for the table. (PDF, HTML)
 */
export interface AutomationPdfTableStyle {
    /**
     * CSS selector where to apply given properties.
     */
    selector: string;
    /**
     * List of CSS properties.
     */
    properties?: Array<AutomationPdfTableStyleProperty>;
}

/**
 * CSS property.
 */
export interface AutomationPdfTableStyleProperty {
    /**
     * CSS property key.
     */
    key: string;
    /**
     * CSS property value.
     */
    value: string;
}

/**
 * Combination of the date data set to use and how many periods ago to calculate the previous period for.
 */
export interface AutomationPopDataset {
    dataset: AutomationAfmObjectIdentifierDataset;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}

/**
 * Previous period type of metric.
 */
export interface AutomationPopDatasetMeasureDefinition {
    previousPeriodMeasure: AutomationPopDatasetMeasureDefinitionPreviousPeriodMeasure;
}

export interface AutomationPopDatasetMeasureDefinitionPreviousPeriodMeasure {
    measureIdentifier: AutomationAfmLocalIdentifier;
    /**
     * Specification of which date data sets to use for determining the period to calculate the previous period for.
     */
    dateDatasets: Array<AutomationPopDataset>;
}

/**
 * Combination of the date attribute to use and how many periods ago to calculate the PoP for.
 */
export interface AutomationPopDate {
    attribute: AutomationAfmObjectIdentifierAttribute;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}

/**
 * Period over period type of metric.
 */
export interface AutomationPopDateMeasureDefinition {
    overPeriodMeasure: AutomationPopDateMeasureDefinitionOverPeriodMeasure;
}

export interface AutomationPopDateMeasureDefinitionOverPeriodMeasure {
    measureIdentifier: AutomationAfmLocalIdentifier;
    /**
     * Attributes to use for determining the period to calculate the PoP for.
     */
    dateAttributes: Array<AutomationPopDate>;
}

/**
 * @type AutomationPopMeasureDefinition
 */
export type AutomationPopMeasureDefinition =
    | AutomationPopDatasetMeasureDefinition
    | AutomationPopDateMeasureDefinition;

/**
 * Filter able to limit element values by label and related selected elements.
 */
export interface AutomationPositiveAttributeFilter {
    positiveAttributeFilter: AutomationPositiveAttributeFilterPositiveAttributeFilter;
}

export interface AutomationPositiveAttributeFilterPositiveAttributeFilter {
    in: AutomationAttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: AutomationAfmIdentifier;
}

export interface AutomationRange {
    operator: AutomationRangeOperatorEnum;
    measure: AutomationLocalIdentifier;
    from: AutomationValue;
    to: AutomationValue;
}

export type AutomationRangeOperatorEnum = "BETWEEN" | "NOT_BETWEEN";

/**
 * Condition that checks if the metric value is within a given range.
 */
export interface AutomationRangeCondition {
    range: AutomationRangeConditionRange;
}

export interface AutomationRangeConditionRange {
    operator: AutomationRangeConditionRangeOperatorEnum;
    from: number;
    to: number;
}

export type AutomationRangeConditionRangeOperatorEnum = "BETWEEN" | "NOT_BETWEEN";

/**
 * Filter the result by comparing specified metric to given range of values.
 */
export interface AutomationRangeMeasureValueFilter {
    rangeMeasureValueFilter: AutomationRangeMeasureValueFilterRangeMeasureValueFilter;
}

export interface AutomationRangeMeasureValueFilterRangeMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AutomationAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: AutomationRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum;
    from: number;
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: AutomationAfmIdentifier;
}

export type AutomationRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum = "BETWEEN" | "NOT_BETWEEN";

export interface AutomationRangeWrapper {
    range: AutomationRange;
}

/**
 * Filter the result on top/bottom N values according to given metric(s).
 */
export interface AutomationRankingFilter {
    rankingFilter: AutomationRankingFilterRankingFilter;
}

export interface AutomationRankingFilterRankingFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AutomationAfmIdentifier>;
    /**
     * References to the metrics to be used when filtering.
     */
    measures: Array<AutomationAfmIdentifier>;
    /**
     * The type of ranking to use, TOP or BOTTOM.
     */
    operator: AutomationRankingFilterRankingFilterOperatorEnum;
    /**
     * Number of top/bottom values to filter.
     */
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
}

export type AutomationRankingFilterRankingFilterOperatorEnum = "TOP" | "BOTTOM";

/**
 * Custom label object override.
 */
export interface AutomationRawCustomLabel {
    /**
     * Override value.
     */
    title: string;
}

/**
 * Custom metric object override.
 */
export interface AutomationRawCustomMetric {
    /**
     * Metric title override.
     */
    title: string;
}

/**
 * Custom cell value overrides (IDs will be replaced with specified values).
 */
export interface AutomationRawCustomOverride {
    /**
     * Map of CustomLabels with keys used as placeholders in export result.
     */
    labels?: { [key: string]: AutomationRawCustomLabel };
    /**
     * Map of CustomMetrics with keys used as placeholders in export result.
     */
    metrics?: { [key: string]: AutomationRawCustomMetric };
}

/**
 * Export request object describing the export properties and overrides for raw exports.
 */
export interface AutomationRawExportAutomationRequest {
    /**
     * Requested resulting file type.
     */
    format: AutomationRawExportAutomationRequestFormatEnum;
    execution: AutomationAFM;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    customOverride?: AutomationRawCustomOverride;
    executionSettings?: AutomationExecutionSettings;
    /**
     * Set column delimiter. (CSV)
     */
    delimiter?: string;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
}

export type AutomationRawExportAutomationRequestFormatEnum = "ARROW_FILE" | "ARROW_STREAM" | "CSV";

export interface AutomationRelative {
    /**
     * Relative condition operator. INCREASES_BY - the metric increases by the specified value. DECREASES_BY - the metric decreases by the specified value. CHANGES_BY - the metric increases or decreases by the specified value.
     */
    operator: AutomationRelativeOperatorEnum;
    measure: AutomationArithmeticMeasure;
    threshold: AutomationValue;
}

export type AutomationRelativeOperatorEnum = "INCREASES_BY" | "DECREASES_BY" | "CHANGES_BY";

export interface AutomationRelativeBoundedDateFilter {
    granularity: AutomationRelativeBoundedDateFilterGranularityEnum;
    from?: number;
    to?: number;
}

export type AutomationRelativeBoundedDateFilterGranularityEnum =
    | "ALL_TIME_GRANULARITY"
    | "GDC.time.year"
    | "GDC.time.week_us"
    | "GDC.time.week_in_year"
    | "GDC.time.week_in_quarter"
    | "GDC.time.week"
    | "GDC.time.euweek_in_year"
    | "GDC.time.euweek_in_quarter"
    | "GDC.time.quarter"
    | "GDC.time.quarter_in_year"
    | "GDC.time.month"
    | "GDC.time.month_in_quarter"
    | "GDC.time.month_in_year"
    | "GDC.time.day_in_year"
    | "GDC.time.day_in_quarter"
    | "GDC.time.day_in_month"
    | "GDC.time.day_in_week"
    | "GDC.time.day_in_euweek"
    | "GDC.time.date"
    | "GDC.time.hour"
    | "GDC.time.hour_in_day"
    | "GDC.time.minute"
    | "GDC.time.minute_in_hour"
    | "GDC.time.fiscal_month"
    | "GDC.time.fiscal_quarter"
    | "GDC.time.fiscal_year";

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension. The \'from\' and \'to\' properties mark the boundaries of the interval. If \'from\' is omitted, all values earlier than \'to\' are included. If \'to\' is omitted, all values later than \'from\' are included. It is not allowed to omit both.
 */
export interface AutomationRelativeDateFilter {
    relativeDateFilter: AutomationRelativeDateFilterRelativeDateFilter;
}

export interface AutomationRelativeDateFilterRelativeDateFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: AutomationRelativeDateFilterRelativeDateFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     */
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    boundedFilter?: AutomationBoundedFilter;
    /**
     * If true, rows with undefined (NULL) date values will be included in the result. The filter becomes: (date_condition) OR (date IS NULL). If false or not set, standard behavior applies (NULLs excluded by the date condition).
     */
    includeEmptyValues?: boolean;
    dataset: AutomationAfmObjectIdentifierDataset;
}

export type AutomationRelativeDateFilterRelativeDateFilterGranularityEnum =
    | "MINUTE"
    | "HOUR"
    | "DAY"
    | "WEEK"
    | "MONTH"
    | "QUARTER"
    | "YEAR"
    | "MINUTE_OF_HOUR"
    | "HOUR_OF_DAY"
    | "DAY_OF_WEEK"
    | "DAY_OF_MONTH"
    | "DAY_OF_QUARTER"
    | "DAY_OF_YEAR"
    | "WEEK_OF_YEAR"
    | "MONTH_OF_YEAR"
    | "QUARTER_OF_YEAR"
    | "FISCAL_MONTH"
    | "FISCAL_QUARTER"
    | "FISCAL_YEAR";

export interface AutomationRelativeWrapper {
    relative: AutomationRelative;
}

/**
 * Additional settings.
 */
export interface AutomationSettings {
    /**
     * If true, the export will contain the information about the export – exported date, filters, etc. Works only with `visualizationObject`. (XLSX, PDF)
     */
    exportInfo?: boolean;
    /**
     * Merge equal headers in neighbouring cells. (XLSX)
     */
    mergeHeaders?: boolean;
    /**
     * Print applied filters on top of the document. (PDF/HTML when visualizationObject is given)
     * @deprecated
     */
    showFilters?: boolean;
    /**
     * Page size and orientation. (PDF)
     * @deprecated
     */
    pdfPageSize?: string;
    /**
     * Custom CSS styles for the table. (PDF, HTML)
     * @deprecated
     */
    pdfTableStyle?: Array<AutomationPdfTableStyle>;
    /**
     * Top left header content. (PDF)
     * @deprecated
     */
    pdfTopLeftContent?: string;
    /**
     * Top right header content. (PDF)
     * @deprecated
     */
    pdfTopRightContent?: string;
    /**
     * Set page size. (PDF)
     */
    pageSize?: AutomationSettingsPageSizeEnum;
    /**
     * Set page orientation. (PDF)
     */
    pageOrientation?: AutomationSettingsPageOrientationEnum;
    /**
     * Set column delimiter. (CSV)
     */
    delimiter?: string;
}

export type AutomationSettingsPageSizeEnum = "A3" | "A4" | "LETTER";
export type AutomationSettingsPageOrientationEnum = "PORTRAIT" | "LANDSCAPE";

/**
 * Metric defined by referencing a MAQL metric or an LDM fact object with aggregation.
 */
export interface AutomationSimpleMeasureDefinition {
    measure: AutomationSimpleMeasureDefinitionMeasure;
}

export interface AutomationSimpleMeasureDefinitionMeasure {
    item: AutomationAfmObjectIdentifierCore;
    /**
     * Definition of aggregation type of the metric.
     */
    aggregation?: AutomationSimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true, compute the percentage of given metric values (broken down by AFM attributes) to the total (not broken down).
     */
    computeRatio?: boolean;
    /**
     * Metrics can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     */
    filters?: Array<AutomationFilterDefinitionForSimpleMeasure>;
}

export type AutomationSimpleMeasureDefinitionMeasureAggregationEnum =
    | "SUM"
    | "COUNT"
    | "AVG"
    | "MIN"
    | "MAX"
    | "MEDIAN"
    | "RUNSUM"
    | "APPROXIMATE_COUNT";

/**
 * Export request object describing the export properties and metadata for slides exports.
 */
export interface AutomationSlidesExportRequest {
    /**
     * Requested resulting file type.
     */
    format: AutomationSlidesExportRequestFormatEnum;
    /**
     * File name to be used for retrieving the pdf document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId?: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds?: Array<string>;
    /**
     * List of visualization ids to be exported. Note that only one visualization is currently supported.
     */
    visualizationIds?: Array<string>;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
    /**
     * Export template identifier.
     */
    templateId?: string | null;
}

export type AutomationSlidesExportRequestFormatEnum = "PDF" | "PPTX";

/**
 * Custom SMTP destination for notifications. The properties host, port, username, and password are required on create and update
 */
export interface AutomationSmtp {
    /**
     * E-mail address to send notifications from.
     */
    fromEmail?: string;
    /**
     * An optional e-mail name to send notifications from.
     */
    fromEmailName?: string;
    /**
     * The SMTP server address.
     */
    host?: string;
    /**
     * The SMTP server port.
     */
    port?: AutomationSmtpPortEnum;
    /**
     * The SMTP server username.
     */
    username?: string;
    /**
     * The SMTP server password.
     */
    password?: string;
    /**
     * The destination type.
     */
    type: AutomationSmtpTypeEnum;
}

export type AutomationSmtpPortEnum = 25 | 465 | 587 | 2525;
export type AutomationSmtpTypeEnum = "SMTP";

/**
 * Export request object describing the export properties and overrides for tabular exports.
 */
export interface AutomationTabularExportRequest {
    /**
     * Expected file format.
     */
    format: AutomationTabularExportRequestFormatEnum;
    /**
     * Execution result identifier.
     */
    executionResult?: string;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    settings?: AutomationSettings;
    customOverride?: AutomationCustomOverride;
    /**
     * Visualization object identifier. Alternative to executionResult property.
     */
    visualizationObject?: string;
    /**
     * Optional custom filters (as array of IFilter objects defined in UI SDK) to be applied when visualizationObject is given. Those filters override the original filters defined in the visualization.
     */
    visualizationObjectCustomFilters?: Array<object>;
    /**
     * Analytical dashboard identifier. Optional identifier, which informs the system that the export is related to a specific dashboard.
     */
    relatedDashboardId?: string;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
}

export type AutomationTabularExportRequestFormatEnum = "CSV" | "XLSX" | "HTML" | "PDF";

/**
 * Request body with notification channel destination to test.
 */
export interface AutomationTestDestinationRequest {
    destination: AutomationTestDestinationRequestDestination;
    /**
     * External recipients of the test result.
     */
    externalRecipients?: Array<AutomationAutomationExternalRecipient> | null;
}

/**
 * @type AutomationTestDestinationRequestDestination
 */
export type AutomationTestDestinationRequestDestination =
    | AutomationDefaultSmtp
    | AutomationInPlatform
    | AutomationSmtp
    | AutomationWebhook;

export interface AutomationTestNotification extends AutomationNotificationContent {
    message: string;
}

/**
 * Response from notification channel testing.
 */
export interface AutomationTestResponse {
    /**
     * A flag indicating whether test passed or not.
     */
    successful: boolean;
    /**
     * Field containing more details in case of a failure. Details are available to a privileged user only.
     */
    error?: string;
}

export interface AutomationTriggerAutomationRequest {
    automation: AutomationAdHocAutomation;
}

export interface AutomationValue {
    /**
     * Value of the alert threshold to compare the metric to.
     */
    value: number;
}

export interface AutomationVisibleFilter {
    localIdentifier?: string;
    title?: string;
    /**
     * Indicates if the filter is an all-time date filter. Such a filter is not included in report computation, so there is no filter with the same \'localIdentifier\' to be found. In such cases, this flag is used to inform the server to not search for the filter in the definitions and include it anyways.
     */
    isAllTimeDateFilter?: boolean;
}

/**
 * Export request object describing the export properties and metadata for dashboard PDF exports.
 */
export interface AutomationVisualExportRequest {
    /**
     * File name to be used for retrieving the pdf document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId: string;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object;
}

/**
 * Webhook destination for notifications. The property url is required on create and update.
 */
export interface AutomationWebhook {
    /**
     * The webhook URL.
     */
    url?: string;
    /**
     * Bearer token for the webhook.
     */
    token?: string | null;
    /**
     * Flag indicating if webhook has a token.
     */
    hasToken?: boolean | null;
    /**
     * Hmac secret key for the webhook signature.
     */
    secretKey?: string | null;
    /**
     * Flag indicating if webhook has a hmac secret key.
     */
    hasSecretKey?: boolean | null;
    /**
     * The destination type.
     */
    type: AutomationWebhookTypeEnum;
}

export type AutomationWebhookTypeEnum = "WEBHOOK";

export interface AutomationWebhookAutomationInfo {
    id: string;
    title?: string;
    dashboardTitle?: string;
    dashboardURL: string;
    isCustomDashboardURL: boolean;
}

export interface AutomationWebhookMessage {
    timestamp: string;
    data: AutomationWebhookMessageData;
    type: AutomationWebhookMessageTypeEnum;
}

export type AutomationWebhookMessageTypeEnum = "automation-task.completed" | "automation-task.limit-exceeded";

export interface AutomationWebhookMessageData {
    automation: AutomationWebhookAutomationInfo;
    recipients?: Array<AutomationWebhookRecipient>;
    details?: { [key: string]: string };
    remainingActionCount?: number;
    tabularExports?: Array<AutomationExportResult>;
    visualExports?: Array<AutomationExportResult>;
    imageExports?: Array<AutomationExportResult>;
    rawExports?: Array<AutomationExportResult>;
    slidesExports?: Array<AutomationExportResult>;
    dashboardTabularExports?: Array<AutomationExportResult>;
    alert?: AutomationAlertDescription;
    filters?: Array<AutomationNotificationFilter>;
    notificationSource?: string;
}

export interface AutomationWebhookRecipient {
    id: string;
    email: string;
}

// ActionsAutomation FP - ActionsAutomationAxiosParamCreator
/**
 * Get latest in-platform notifications for the current user.
 * @summary Get latest notifications.
 * @param {string} [workspaceId] Workspace ID to filter notifications by.
 * @param {boolean} [isRead] Filter notifications by read status.
 * @param {string} [page] Zero-based page index (0..N)
 * @param {string} [size] The size of the page to be returned.
 * @param {Array<'total' | 'ALL'>} [metaInclude] Additional meta information to include in the response.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomationAxiosParamCreator_GetNotifications(
    workspaceId?: string,
    isRead?: boolean,
    page?: string,
    size?: string,
    metaInclude?: Array<"total" | "ALL">,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    const localVarPath = `/api/v1/actions/notifications`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (workspaceId !== undefined) {
        localVarQueryParameter["workspaceId"] = workspaceId;
    }

    if (isRead !== undefined) {
        localVarQueryParameter["isRead"] = isRead;
    }

    if (page !== undefined) {
        localVarQueryParameter["page"] = page;
    }

    if (size !== undefined) {
        localVarQueryParameter["size"] = size;
    }

    if (metaInclude) {
        localVarQueryParameter["metaInclude"] = Array.from(metaInclude);
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsAutomation FP - ActionsAutomationAxiosParamCreator
/**
 * Mark in-platform notification by its ID as read.
 * @summary Mark notification as read.
 * @param {string} notificationId Notification ID to mark as read.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomationAxiosParamCreator_MarkAsReadNotification(
    notificationId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'notificationId' is not null or undefined
    assertParamExists("markAsReadNotification", "notificationId", notificationId);
    const localVarPath = `/api/v1/actions/notifications/{notificationId}/markAsRead`.replace(
        `{${"notificationId"}}`,
        encodeURIComponent(String(notificationId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsAutomation FP - ActionsAutomationAxiosParamCreator
/**
 * Mark all user in-platform notifications as read.
 * @summary Mark all notifications as read.
 * @param {string} [workspaceId] Workspace ID where to mark notifications as read.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomationAxiosParamCreator_MarkAsReadNotificationAll(
    workspaceId?: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    const localVarPath = `/api/v1/actions/notifications/markAsRead`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (workspaceId !== undefined) {
        localVarQueryParameter["workspaceId"] = workspaceId;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsAutomation FP - ActionsAutomationAxiosParamCreator
/**
 * Tests the existing notification channel by sending a test notification.
 * @summary Test existing notification channel.
 * @param {string} notificationChannelId
 * @param {AutomationTestDestinationRequest} [automationTestDestinationRequest]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomationAxiosParamCreator_TestExistingNotificationChannel(
    notificationChannelId: string,
    automationTestDestinationRequest?: AutomationTestDestinationRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'notificationChannelId' is not null or undefined
    assertParamExists("testExistingNotificationChannel", "notificationChannelId", notificationChannelId);
    const localVarPath = `/api/v1/actions/notificationChannels/{notificationChannelId}/test`.replace(
        `{${"notificationChannelId"}}`,
        encodeURIComponent(String(notificationChannelId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof automationTestDestinationRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
              automationTestDestinationRequest !== undefined ? automationTestDestinationRequest : {},
          )
        : automationTestDestinationRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsAutomation FP - ActionsAutomationAxiosParamCreator
/**
 * Tests the notification channel by sending a test notification.
 * @summary Test notification channel.
 * @param {AutomationTestDestinationRequest} automationTestDestinationRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomationAxiosParamCreator_TestNotificationChannel(
    automationTestDestinationRequest: AutomationTestDestinationRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'automationTestDestinationRequest' is not null or undefined
    assertParamExists(
        "testNotificationChannel",
        "automationTestDestinationRequest",
        automationTestDestinationRequest,
    );
    const localVarPath = `/api/v1/actions/notificationChannels/test`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof automationTestDestinationRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
              automationTestDestinationRequest !== undefined ? automationTestDestinationRequest : {},
          )
        : automationTestDestinationRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsAutomation FP - ActionsAutomationAxiosParamCreator
/**
 * Trigger the automation in the request.
 * @summary Trigger automation.
 * @param {string} workspaceId
 * @param {AutomationTriggerAutomationRequest} automationTriggerAutomationRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomationAxiosParamCreator_TriggerAutomation(
    workspaceId: string,
    automationTriggerAutomationRequest: AutomationTriggerAutomationRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("triggerAutomation", "workspaceId", workspaceId);
    // verify required parameter 'automationTriggerAutomationRequest' is not null or undefined
    assertParamExists(
        "triggerAutomation",
        "automationTriggerAutomationRequest",
        automationTriggerAutomationRequest,
    );
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/trigger`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof automationTriggerAutomationRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
              automationTriggerAutomationRequest !== undefined ? automationTriggerAutomationRequest : {},
          )
        : automationTriggerAutomationRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsAutomation FP - ActionsAutomationAxiosParamCreator
/**
 * Trigger the existing automation to execute immediately.
 * @summary Trigger existing automation.
 * @param {string} workspaceId
 * @param {string} automationId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomationAxiosParamCreator_TriggerExistingAutomation(
    workspaceId: string,
    automationId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("triggerExistingAutomation", "workspaceId", workspaceId);
    // verify required parameter 'automationId' is not null or undefined
    assertParamExists("triggerExistingAutomation", "automationId", automationId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/{automationId}/trigger`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"automationId"}}`, encodeURIComponent(String(automationId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsAutomation Api FP
/**
 * Get latest in-platform notifications for the current user.
 * @summary Get latest notifications.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsAutomationGetNotificationsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomation_GetNotifications(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsAutomationGetNotificationsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AutomationNotifications> {
    const localVarAxiosArgs = await ActionsAutomationAxiosParamCreator_GetNotifications(
        requestParameters.workspaceId,
        requestParameters.isRead,
        requestParameters.page,
        requestParameters.size,
        requestParameters.metaInclude,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsAutomation Api FP
/**
 * Mark in-platform notification by its ID as read.
 * @summary Mark notification as read.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomation_MarkAsReadNotification(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsAutomationMarkAsReadNotificationRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await ActionsAutomationAxiosParamCreator_MarkAsReadNotification(
        requestParameters.notificationId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsAutomation Api FP
/**
 * Mark all user in-platform notifications as read.
 * @summary Mark all notifications as read.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomation_MarkAsReadNotificationAll(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsAutomationMarkAsReadNotificationAllRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await ActionsAutomationAxiosParamCreator_MarkAsReadNotificationAll(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsAutomation Api FP
/**
 * Tests the existing notification channel by sending a test notification.
 * @summary Test existing notification channel.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomation_TestExistingNotificationChannel(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsAutomationTestExistingNotificationChannelRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AutomationTestResponse> {
    const localVarAxiosArgs = await ActionsAutomationAxiosParamCreator_TestExistingNotificationChannel(
        requestParameters.notificationChannelId,
        requestParameters.automationTestDestinationRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsAutomation Api FP
/**
 * Tests the notification channel by sending a test notification.
 * @summary Test notification channel.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomation_TestNotificationChannel(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsAutomationTestNotificationChannelRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AutomationTestResponse> {
    const localVarAxiosArgs = await ActionsAutomationAxiosParamCreator_TestNotificationChannel(
        requestParameters.automationTestDestinationRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsAutomation Api FP
/**
 * Trigger the automation in the request.
 * @summary Trigger automation.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsAutomationTriggerAutomationRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomation_TriggerAutomation(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsAutomationTriggerAutomationRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await ActionsAutomationAxiosParamCreator_TriggerAutomation(
        requestParameters.workspaceId,
        requestParameters.automationTriggerAutomationRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsAutomation Api FP
/**
 * Trigger the existing automation to execute immediately.
 * @summary Trigger existing automation.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsAutomation_TriggerExistingAutomation(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsAutomationTriggerExistingAutomationRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await ActionsAutomationAxiosParamCreator_TriggerExistingAutomation(
        requestParameters.workspaceId,
        requestParameters.automationId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * ActionsAutomation - interface
 * @export
 * @interface ActionsAutomation
 */
export interface ActionsAutomationInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {ActionsAutomationGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    getNotifications(
        requestParameters: ActionsAutomationGetNotificationsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationNotifications>;

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {ActionsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    markAsReadNotification(
        requestParameters: ActionsAutomationMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {ActionsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    markAsReadNotificationAll(
        requestParameters: ActionsAutomationMarkAsReadNotificationAllRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {ActionsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    testExistingNotificationChannel(
        requestParameters: ActionsAutomationTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationTestResponse>;

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {ActionsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    testNotificationChannel(
        requestParameters: ActionsAutomationTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationTestResponse>;

    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {ActionsAutomationTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    triggerAutomation(
        requestParameters: ActionsAutomationTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {ActionsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomationInterface
     */
    triggerExistingAutomation(
        requestParameters: ActionsAutomationTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for getNotifications operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationGetNotificationsRequest
 */
export interface ActionsAutomationGetNotificationsRequest {
    /**
     * Workspace ID to filter notifications by.
     * @type {string}
     * @memberof ActionsAutomationGetNotifications
     */
    readonly workspaceId?: string;

    /**
     * Filter notifications by read status.
     * @type {boolean}
     * @memberof ActionsAutomationGetNotifications
     */
    readonly isRead?: boolean;

    /**
     * Zero-based page index (0..N)
     * @type {string}
     * @memberof ActionsAutomationGetNotifications
     */
    readonly page?: string;

    /**
     * The size of the page to be returned.
     * @type {string}
     * @memberof ActionsAutomationGetNotifications
     */
    readonly size?: string;

    /**
     * Additional meta information to include in the response.
     * @type {Array<'total' | 'ALL'>}
     * @memberof ActionsAutomationGetNotifications
     */
    readonly metaInclude?: Array<"total" | "ALL">;
}

/**
 * Request parameters for markAsReadNotification operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationMarkAsReadNotificationRequest
 */
export interface ActionsAutomationMarkAsReadNotificationRequest {
    /**
     * Notification ID to mark as read.
     * @type {string}
     * @memberof ActionsAutomationMarkAsReadNotification
     */
    readonly notificationId: string;
}

/**
 * Request parameters for markAsReadNotificationAll operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationMarkAsReadNotificationAllRequest
 */
export interface ActionsAutomationMarkAsReadNotificationAllRequest {
    /**
     * Workspace ID where to mark notifications as read.
     * @type {string}
     * @memberof ActionsAutomationMarkAsReadNotificationAll
     */
    readonly workspaceId?: string;
}

/**
 * Request parameters for testExistingNotificationChannel operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationTestExistingNotificationChannelRequest
 */
export interface ActionsAutomationTestExistingNotificationChannelRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsAutomationTestExistingNotificationChannel
     */
    readonly notificationChannelId: string;

    /**
     *
     * @type {AutomationTestDestinationRequest}
     * @memberof ActionsAutomationTestExistingNotificationChannel
     */
    readonly automationTestDestinationRequest?: AutomationTestDestinationRequest;
}

/**
 * Request parameters for testNotificationChannel operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationTestNotificationChannelRequest
 */
export interface ActionsAutomationTestNotificationChannelRequest {
    /**
     *
     * @type {AutomationTestDestinationRequest}
     * @memberof ActionsAutomationTestNotificationChannel
     */
    readonly automationTestDestinationRequest: AutomationTestDestinationRequest;
}

/**
 * Request parameters for triggerAutomation operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationTriggerAutomationRequest
 */
export interface ActionsAutomationTriggerAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsAutomationTriggerAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AutomationTriggerAutomationRequest}
     * @memberof ActionsAutomationTriggerAutomation
     */
    readonly automationTriggerAutomationRequest: AutomationTriggerAutomationRequest;
}

/**
 * Request parameters for triggerExistingAutomation operation in ActionsAutomation.
 * @export
 * @interface ActionsAutomationTriggerExistingAutomationRequest
 */
export interface ActionsAutomationTriggerExistingAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsAutomationTriggerExistingAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsAutomationTriggerExistingAutomation
     */
    readonly automationId: string;
}

/**
 * ActionsAutomation - object-oriented interface
 * @export
 * @class ActionsAutomation
 * @extends {BaseAPI}
 */
export class ActionsAutomation extends BaseAPI implements ActionsAutomationInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {ActionsAutomationGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public getNotifications(
        requestParameters: ActionsAutomationGetNotificationsRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomation_GetNotifications(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {ActionsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public markAsReadNotification(
        requestParameters: ActionsAutomationMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomation_MarkAsReadNotification(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {ActionsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public markAsReadNotificationAll(
        requestParameters: ActionsAutomationMarkAsReadNotificationAllRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomation_MarkAsReadNotificationAll(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {ActionsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public testExistingNotificationChannel(
        requestParameters: ActionsAutomationTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomation_TestExistingNotificationChannel(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {ActionsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public testNotificationChannel(
        requestParameters: ActionsAutomationTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomation_TestNotificationChannel(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {ActionsAutomationTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public triggerAutomation(
        requestParameters: ActionsAutomationTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomation_TriggerAutomation(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {ActionsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsAutomation
     */
    public triggerExistingAutomation(
        requestParameters: ActionsAutomationTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsAutomation_TriggerExistingAutomation(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}

// AutomationsAutomation FP - AutomationsAutomationAxiosParamCreator
/**
 * Trigger the automation in the request.
 * @summary Trigger automation.
 * @param {string} workspaceId
 * @param {AutomationTriggerAutomationRequest} automationTriggerAutomationRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function AutomationsAutomationAxiosParamCreator_TriggerAutomation(
    workspaceId: string,
    automationTriggerAutomationRequest: AutomationTriggerAutomationRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("triggerAutomation", "workspaceId", workspaceId);
    // verify required parameter 'automationTriggerAutomationRequest' is not null or undefined
    assertParamExists(
        "triggerAutomation",
        "automationTriggerAutomationRequest",
        automationTriggerAutomationRequest,
    );
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/trigger`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof automationTriggerAutomationRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
              automationTriggerAutomationRequest !== undefined ? automationTriggerAutomationRequest : {},
          )
        : automationTriggerAutomationRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// AutomationsAutomation FP - AutomationsAutomationAxiosParamCreator
/**
 * Trigger the existing automation to execute immediately.
 * @summary Trigger existing automation.
 * @param {string} workspaceId
 * @param {string} automationId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function AutomationsAutomationAxiosParamCreator_TriggerExistingAutomation(
    workspaceId: string,
    automationId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("triggerExistingAutomation", "workspaceId", workspaceId);
    // verify required parameter 'automationId' is not null or undefined
    assertParamExists("triggerExistingAutomation", "automationId", automationId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/{automationId}/trigger`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"automationId"}}`, encodeURIComponent(String(automationId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// AutomationsAutomation Api FP
/**
 * Trigger the automation in the request.
 * @summary Trigger automation.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {AutomationsAutomationTriggerAutomationRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function AutomationsAutomation_TriggerAutomation(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: AutomationsAutomationTriggerAutomationRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await AutomationsAutomationAxiosParamCreator_TriggerAutomation(
        requestParameters.workspaceId,
        requestParameters.automationTriggerAutomationRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// AutomationsAutomation Api FP
/**
 * Trigger the existing automation to execute immediately.
 * @summary Trigger existing automation.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {AutomationsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function AutomationsAutomation_TriggerExistingAutomation(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: AutomationsAutomationTriggerExistingAutomationRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await AutomationsAutomationAxiosParamCreator_TriggerExistingAutomation(
        requestParameters.workspaceId,
        requestParameters.automationId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * AutomationsAutomation - interface
 * @export
 * @interface AutomationsAutomation
 */
export interface AutomationsAutomationInterface {
    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {AutomationsAutomationTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsAutomationInterface
     */
    triggerAutomation(
        requestParameters: AutomationsAutomationTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {AutomationsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsAutomationInterface
     */
    triggerExistingAutomation(
        requestParameters: AutomationsAutomationTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for triggerAutomation operation in AutomationsAutomation.
 * @export
 * @interface AutomationsAutomationTriggerAutomationRequest
 */
export interface AutomationsAutomationTriggerAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof AutomationsAutomationTriggerAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AutomationTriggerAutomationRequest}
     * @memberof AutomationsAutomationTriggerAutomation
     */
    readonly automationTriggerAutomationRequest: AutomationTriggerAutomationRequest;
}

/**
 * Request parameters for triggerExistingAutomation operation in AutomationsAutomation.
 * @export
 * @interface AutomationsAutomationTriggerExistingAutomationRequest
 */
export interface AutomationsAutomationTriggerExistingAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof AutomationsAutomationTriggerExistingAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof AutomationsAutomationTriggerExistingAutomation
     */
    readonly automationId: string;
}

/**
 * AutomationsAutomation - object-oriented interface
 * @export
 * @class AutomationsAutomation
 * @extends {BaseAPI}
 */
export class AutomationsAutomation extends BaseAPI implements AutomationsAutomationInterface {
    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {AutomationsAutomationTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsAutomation
     */
    public triggerAutomation(
        requestParameters: AutomationsAutomationTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return AutomationsAutomation_TriggerAutomation(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {AutomationsAutomationTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsAutomation
     */
    public triggerExistingAutomation(
        requestParameters: AutomationsAutomationTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return AutomationsAutomation_TriggerExistingAutomation(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}

// NotificationChannelsAutomation FP - NotificationChannelsAutomationAxiosParamCreator
/**
 * Get latest in-platform notifications for the current user.
 * @summary Get latest notifications.
 * @param {string} [workspaceId] Workspace ID to filter notifications by.
 * @param {boolean} [isRead] Filter notifications by read status.
 * @param {string} [page] Zero-based page index (0..N)
 * @param {string} [size] The size of the page to be returned.
 * @param {Array<'total' | 'ALL'>} [metaInclude] Additional meta information to include in the response.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function NotificationChannelsAutomationAxiosParamCreator_GetNotifications(
    workspaceId?: string,
    isRead?: boolean,
    page?: string,
    size?: string,
    metaInclude?: Array<"total" | "ALL">,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    const localVarPath = `/api/v1/actions/notifications`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (workspaceId !== undefined) {
        localVarQueryParameter["workspaceId"] = workspaceId;
    }

    if (isRead !== undefined) {
        localVarQueryParameter["isRead"] = isRead;
    }

    if (page !== undefined) {
        localVarQueryParameter["page"] = page;
    }

    if (size !== undefined) {
        localVarQueryParameter["size"] = size;
    }

    if (metaInclude) {
        localVarQueryParameter["metaInclude"] = Array.from(metaInclude);
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// NotificationChannelsAutomation FP - NotificationChannelsAutomationAxiosParamCreator
/**
 * Mark in-platform notification by its ID as read.
 * @summary Mark notification as read.
 * @param {string} notificationId Notification ID to mark as read.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function NotificationChannelsAutomationAxiosParamCreator_MarkAsReadNotification(
    notificationId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'notificationId' is not null or undefined
    assertParamExists("markAsReadNotification", "notificationId", notificationId);
    const localVarPath = `/api/v1/actions/notifications/{notificationId}/markAsRead`.replace(
        `{${"notificationId"}}`,
        encodeURIComponent(String(notificationId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// NotificationChannelsAutomation FP - NotificationChannelsAutomationAxiosParamCreator
/**
 * Mark all user in-platform notifications as read.
 * @summary Mark all notifications as read.
 * @param {string} [workspaceId] Workspace ID where to mark notifications as read.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function NotificationChannelsAutomationAxiosParamCreator_MarkAsReadNotificationAll(
    workspaceId?: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    const localVarPath = `/api/v1/actions/notifications/markAsRead`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (workspaceId !== undefined) {
        localVarQueryParameter["workspaceId"] = workspaceId;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// NotificationChannelsAutomation FP - NotificationChannelsAutomationAxiosParamCreator
/**
 * Tests the existing notification channel by sending a test notification.
 * @summary Test existing notification channel.
 * @param {string} notificationChannelId
 * @param {AutomationTestDestinationRequest} [automationTestDestinationRequest]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function NotificationChannelsAutomationAxiosParamCreator_TestExistingNotificationChannel(
    notificationChannelId: string,
    automationTestDestinationRequest?: AutomationTestDestinationRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'notificationChannelId' is not null or undefined
    assertParamExists("testExistingNotificationChannel", "notificationChannelId", notificationChannelId);
    const localVarPath = `/api/v1/actions/notificationChannels/{notificationChannelId}/test`.replace(
        `{${"notificationChannelId"}}`,
        encodeURIComponent(String(notificationChannelId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof automationTestDestinationRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
              automationTestDestinationRequest !== undefined ? automationTestDestinationRequest : {},
          )
        : automationTestDestinationRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// NotificationChannelsAutomation FP - NotificationChannelsAutomationAxiosParamCreator
/**
 * Tests the notification channel by sending a test notification.
 * @summary Test notification channel.
 * @param {AutomationTestDestinationRequest} automationTestDestinationRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function NotificationChannelsAutomationAxiosParamCreator_TestNotificationChannel(
    automationTestDestinationRequest: AutomationTestDestinationRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'automationTestDestinationRequest' is not null or undefined
    assertParamExists(
        "testNotificationChannel",
        "automationTestDestinationRequest",
        automationTestDestinationRequest,
    );
    const localVarPath = `/api/v1/actions/notificationChannels/test`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof automationTestDestinationRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
              automationTestDestinationRequest !== undefined ? automationTestDestinationRequest : {},
          )
        : automationTestDestinationRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// NotificationChannelsAutomation Api FP
/**
 * Get latest in-platform notifications for the current user.
 * @summary Get latest notifications.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {NotificationChannelsAutomationGetNotificationsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function NotificationChannelsAutomation_GetNotifications(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: NotificationChannelsAutomationGetNotificationsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AutomationNotifications> {
    const localVarAxiosArgs = await NotificationChannelsAutomationAxiosParamCreator_GetNotifications(
        requestParameters.workspaceId,
        requestParameters.isRead,
        requestParameters.page,
        requestParameters.size,
        requestParameters.metaInclude,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// NotificationChannelsAutomation Api FP
/**
 * Mark in-platform notification by its ID as read.
 * @summary Mark notification as read.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {NotificationChannelsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function NotificationChannelsAutomation_MarkAsReadNotification(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: NotificationChannelsAutomationMarkAsReadNotificationRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await NotificationChannelsAutomationAxiosParamCreator_MarkAsReadNotification(
        requestParameters.notificationId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// NotificationChannelsAutomation Api FP
/**
 * Mark all user in-platform notifications as read.
 * @summary Mark all notifications as read.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {NotificationChannelsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function NotificationChannelsAutomation_MarkAsReadNotificationAll(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: NotificationChannelsAutomationMarkAsReadNotificationAllRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await NotificationChannelsAutomationAxiosParamCreator_MarkAsReadNotificationAll(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// NotificationChannelsAutomation Api FP
/**
 * Tests the existing notification channel by sending a test notification.
 * @summary Test existing notification channel.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {NotificationChannelsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function NotificationChannelsAutomation_TestExistingNotificationChannel(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: NotificationChannelsAutomationTestExistingNotificationChannelRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AutomationTestResponse> {
    const localVarAxiosArgs =
        await NotificationChannelsAutomationAxiosParamCreator_TestExistingNotificationChannel(
            requestParameters.notificationChannelId,
            requestParameters.automationTestDestinationRequest,
            options || {},
            configuration,
        );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// NotificationChannelsAutomation Api FP
/**
 * Tests the notification channel by sending a test notification.
 * @summary Test notification channel.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {NotificationChannelsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function NotificationChannelsAutomation_TestNotificationChannel(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: NotificationChannelsAutomationTestNotificationChannelRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AutomationTestResponse> {
    const localVarAxiosArgs = await NotificationChannelsAutomationAxiosParamCreator_TestNotificationChannel(
        requestParameters.automationTestDestinationRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * NotificationChannelsAutomation - interface
 * @export
 * @interface NotificationChannelsAutomation
 */
export interface NotificationChannelsAutomationInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {NotificationChannelsAutomationGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomationInterface
     */
    getNotifications(
        requestParameters: NotificationChannelsAutomationGetNotificationsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationNotifications>;

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {NotificationChannelsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomationInterface
     */
    markAsReadNotification(
        requestParameters: NotificationChannelsAutomationMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {NotificationChannelsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomationInterface
     */
    markAsReadNotificationAll(
        requestParameters: NotificationChannelsAutomationMarkAsReadNotificationAllRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {NotificationChannelsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomationInterface
     */
    testExistingNotificationChannel(
        requestParameters: NotificationChannelsAutomationTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationTestResponse>;

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {NotificationChannelsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomationInterface
     */
    testNotificationChannel(
        requestParameters: NotificationChannelsAutomationTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AutomationTestResponse>;
}

/**
 * Request parameters for getNotifications operation in NotificationChannelsAutomation.
 * @export
 * @interface NotificationChannelsAutomationGetNotificationsRequest
 */
export interface NotificationChannelsAutomationGetNotificationsRequest {
    /**
     * Workspace ID to filter notifications by.
     * @type {string}
     * @memberof NotificationChannelsAutomationGetNotifications
     */
    readonly workspaceId?: string;

    /**
     * Filter notifications by read status.
     * @type {boolean}
     * @memberof NotificationChannelsAutomationGetNotifications
     */
    readonly isRead?: boolean;

    /**
     * Zero-based page index (0..N)
     * @type {string}
     * @memberof NotificationChannelsAutomationGetNotifications
     */
    readonly page?: string;

    /**
     * The size of the page to be returned.
     * @type {string}
     * @memberof NotificationChannelsAutomationGetNotifications
     */
    readonly size?: string;

    /**
     * Additional meta information to include in the response.
     * @type {Array<'total' | 'ALL'>}
     * @memberof NotificationChannelsAutomationGetNotifications
     */
    readonly metaInclude?: Array<"total" | "ALL">;
}

/**
 * Request parameters for markAsReadNotification operation in NotificationChannelsAutomation.
 * @export
 * @interface NotificationChannelsAutomationMarkAsReadNotificationRequest
 */
export interface NotificationChannelsAutomationMarkAsReadNotificationRequest {
    /**
     * Notification ID to mark as read.
     * @type {string}
     * @memberof NotificationChannelsAutomationMarkAsReadNotification
     */
    readonly notificationId: string;
}

/**
 * Request parameters for markAsReadNotificationAll operation in NotificationChannelsAutomation.
 * @export
 * @interface NotificationChannelsAutomationMarkAsReadNotificationAllRequest
 */
export interface NotificationChannelsAutomationMarkAsReadNotificationAllRequest {
    /**
     * Workspace ID where to mark notifications as read.
     * @type {string}
     * @memberof NotificationChannelsAutomationMarkAsReadNotificationAll
     */
    readonly workspaceId?: string;
}

/**
 * Request parameters for testExistingNotificationChannel operation in NotificationChannelsAutomation.
 * @export
 * @interface NotificationChannelsAutomationTestExistingNotificationChannelRequest
 */
export interface NotificationChannelsAutomationTestExistingNotificationChannelRequest {
    /**
     *
     * @type {string}
     * @memberof NotificationChannelsAutomationTestExistingNotificationChannel
     */
    readonly notificationChannelId: string;

    /**
     *
     * @type {AutomationTestDestinationRequest}
     * @memberof NotificationChannelsAutomationTestExistingNotificationChannel
     */
    readonly automationTestDestinationRequest?: AutomationTestDestinationRequest;
}

/**
 * Request parameters for testNotificationChannel operation in NotificationChannelsAutomation.
 * @export
 * @interface NotificationChannelsAutomationTestNotificationChannelRequest
 */
export interface NotificationChannelsAutomationTestNotificationChannelRequest {
    /**
     *
     * @type {AutomationTestDestinationRequest}
     * @memberof NotificationChannelsAutomationTestNotificationChannel
     */
    readonly automationTestDestinationRequest: AutomationTestDestinationRequest;
}

/**
 * NotificationChannelsAutomation - object-oriented interface
 * @export
 * @class NotificationChannelsAutomation
 * @extends {BaseAPI}
 */
export class NotificationChannelsAutomation
    extends BaseAPI
    implements NotificationChannelsAutomationInterface
{
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {NotificationChannelsAutomationGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomation
     */
    public getNotifications(
        requestParameters: NotificationChannelsAutomationGetNotificationsRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsAutomation_GetNotifications(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {NotificationChannelsAutomationMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomation
     */
    public markAsReadNotification(
        requestParameters: NotificationChannelsAutomationMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsAutomation_MarkAsReadNotification(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {NotificationChannelsAutomationMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomation
     */
    public markAsReadNotificationAll(
        requestParameters: NotificationChannelsAutomationMarkAsReadNotificationAllRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsAutomation_MarkAsReadNotificationAll(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {NotificationChannelsAutomationTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomation
     */
    public testExistingNotificationChannel(
        requestParameters: NotificationChannelsAutomationTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsAutomation_TestExistingNotificationChannel(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {NotificationChannelsAutomationTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsAutomation
     */
    public testNotificationChannel(
        requestParameters: NotificationChannelsAutomationTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsAutomation_TestNotificationChannel(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}
