// (C) 2025 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 */
export interface ExportAFM {
    /**
     * Attributes to be used in the computation.
     */
    attributes: Array<ExportAttributeItem>;
    /**
     * Various filter types to filter the execution result.
     */
    filters: Array<ExportFilterDefinition>;
    /**
     * Metrics to be computed.
     */
    measures: Array<ExportMeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     */
    auxMeasures?: Array<ExportMeasureItem>;
}
/**
 * A datetime filter specifying exact from and to values.
 */
export interface ExportAbsoluteDateFilter {
    absoluteDateFilter: ExportAbsoluteDateFilterAbsoluteDateFilter;
}
export interface ExportAbsoluteDateFilterAbsoluteDateFilter {
    from: string;
    to: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
    dataset: ExportAfmObjectIdentifierDataset;
}
/**
 * @type ExportAbstractMeasureValueFilter
 */
export type ExportAbstractMeasureValueFilter =
    | ExportComparisonMeasureValueFilter
    | ExportRangeMeasureValueFilter
    | ExportRankingFilter;

/**
 * @type ExportAfmIdentifier
 * Reference to the attribute label to which the filter should be applied.
 */
export type ExportAfmIdentifier = ExportAfmLocalIdentifier | ExportAfmObjectIdentifier;

export interface ExportAfmLocalIdentifier {
    localIdentifier: string;
}
/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 */
export interface ExportAfmObjectIdentifier {
    identifier: ExportAfmObjectIdentifierIdentifier;
}
/**
 * Reference to the date attribute to use.
 */
export interface ExportAfmObjectIdentifierAttribute {
    identifier: ExportAfmObjectIdentifierAttributeIdentifier;
}
export interface ExportAfmObjectIdentifierAttributeIdentifier {
    id: string;
    type: ExportAfmObjectIdentifierAttributeIdentifierTypeEnum;
}

export const ExportAfmObjectIdentifierAttributeIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
} as const;

export type ExportAfmObjectIdentifierAttributeIdentifierTypeEnum =
    (typeof ExportAfmObjectIdentifierAttributeIdentifierTypeEnum)[keyof typeof ExportAfmObjectIdentifierAttributeIdentifierTypeEnum];

/**
 * Reference to the metric, fact or attribute object to use for the metric.
 */
export interface ExportAfmObjectIdentifierCore {
    identifier: ExportAfmObjectIdentifierCoreIdentifier;
}
export interface ExportAfmObjectIdentifierCoreIdentifier {
    id: string;
    type: ExportAfmObjectIdentifierCoreIdentifierTypeEnum;
}

export const ExportAfmObjectIdentifierCoreIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
    LABEL: "label",
    FACT: "fact",
    METRIC: "metric",
} as const;

export type ExportAfmObjectIdentifierCoreIdentifierTypeEnum =
    (typeof ExportAfmObjectIdentifierCoreIdentifierTypeEnum)[keyof typeof ExportAfmObjectIdentifierCoreIdentifierTypeEnum];

/**
 * Reference to the date dataset to which the filter should be applied.
 */
export interface ExportAfmObjectIdentifierDataset {
    identifier: ExportAfmObjectIdentifierDatasetIdentifier;
}
export interface ExportAfmObjectIdentifierDatasetIdentifier {
    id: string;
    type: ExportAfmObjectIdentifierDatasetIdentifierTypeEnum;
}

export const ExportAfmObjectIdentifierDatasetIdentifierTypeEnum = {
    DATASET: "dataset",
} as const;

export type ExportAfmObjectIdentifierDatasetIdentifierTypeEnum =
    (typeof ExportAfmObjectIdentifierDatasetIdentifierTypeEnum)[keyof typeof ExportAfmObjectIdentifierDatasetIdentifierTypeEnum];

export interface ExportAfmObjectIdentifierIdentifier {
    type: ExportAfmObjectIdentifierIdentifierTypeEnum;
    id: string;
}

export const ExportAfmObjectIdentifierIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
} as const;

export type ExportAfmObjectIdentifierIdentifierTypeEnum =
    (typeof ExportAfmObjectIdentifierIdentifierTypeEnum)[keyof typeof ExportAfmObjectIdentifierIdentifierTypeEnum];

export interface ExportAfmObjectIdentifierLabel {
    identifier: ExportAfmObjectIdentifierLabelIdentifier;
}
export interface ExportAfmObjectIdentifierLabelIdentifier {
    type: ExportAfmObjectIdentifierLabelIdentifierTypeEnum;
    id: string;
}

export const ExportAfmObjectIdentifierLabelIdentifierTypeEnum = {
    LABEL: "label",
} as const;

export type ExportAfmObjectIdentifierLabelIdentifierTypeEnum =
    (typeof ExportAfmObjectIdentifierLabelIdentifierTypeEnum)[keyof typeof ExportAfmObjectIdentifierLabelIdentifierTypeEnum];

/**
 * Metric representing arithmetics between other metrics.
 */
export interface ExportArithmeticMeasureDefinition {
    arithmeticMeasure: ExportArithmeticMeasureDefinitionArithmeticMeasure;
}
export interface ExportArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of metrics to apply arithmetic operation by chosen operator.
     */
    measureIdentifiers: Array<ExportAfmLocalIdentifier>;
    /**
     * Arithmetic operator describing operation between metrics.
     */
    operator: ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

export const ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum = {
    SUM: "SUM",
    DIFFERENCE: "DIFFERENCE",
    MULTIPLICATION: "MULTIPLICATION",
    RATIO: "RATIO",
    CHANGE: "CHANGE",
} as const;

export type ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum =
    (typeof ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum)[keyof typeof ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum];

/**
 * @type ExportAttributeElements
 */
export type ExportAttributeElements = ExportAttributeElementsByRef | ExportAttributeElementsByValue;

export interface ExportAttributeElementsByRef {
    /**
     * List of attribute elements by reference
     */
    uris: Array<string | null>;
}
export interface ExportAttributeElementsByValue {
    /**
     * List of attribute elements by value
     */
    values: Array<string | null>;
}
/**
 * @type ExportAttributeFilter
 * Abstract filter definition type attributes
 */
export type ExportAttributeFilter = ExportNegativeAttributeFilter | ExportPositiveAttributeFilter;

export interface ExportAttributeFilterByDate {
    filterLocalIdentifier: string;
    isCommonDate: boolean;
}
/**
 * Filter on specific set of label values.
 */
export interface ExportAttributeFilterElements {
    /**
     * Set of label values.
     */
    values: Array<string | null>;
}
export interface ExportAttributeFilterParent {
    filterLocalIdentifier: string;
    over: ExportOver;
}
export interface ExportAttributeItem {
    /**
     * Local identifier of the attribute. This can be used to reference the attribute in other parts of the execution definition.
     */
    localIdentifier: string;
    label: ExportAfmObjectIdentifierLabel;
    /**
     * Indicates whether to show all values of given attribute even if the data bound to those values is not available.
     */
    showAllValues?: boolean;
}
/**
 * Bounding filter for this relative date filter. This can be used to limit the range of the relative date filter to a specific date range.
 */
export interface ExportBoundedFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: ExportBoundedFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\'). If null, then start of the range is unbounded.
     */
    from?: number | null;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...). If null, then end of the range is unbounded.
     */
    to?: number | null;
}

export const ExportBoundedFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_QUARTER: "DAY_OF_QUARTER",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type ExportBoundedFilterGranularityEnum =
    (typeof ExportBoundedFilterGranularityEnum)[keyof typeof ExportBoundedFilterGranularityEnum];

/**
 * Filter the result by comparing specified metric to given constant value, using given comparison operator.
 */
export interface ExportComparisonMeasureValueFilter {
    comparisonMeasureValueFilter: ExportComparisonMeasureValueFilterComparisonMeasureValueFilter;
}
export interface ExportComparisonMeasureValueFilterComparisonMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<ExportAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum;
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: ExportAfmIdentifier;
}

export const ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum = {
    GREATER_THAN: "GREATER_THAN",
    GREATER_THAN_OR_EQUAL_TO: "GREATER_THAN_OR_EQUAL_TO",
    LESS_THAN: "LESS_THAN",
    LESS_THAN_OR_EQUAL_TO: "LESS_THAN_OR_EQUAL_TO",
    EQUAL_TO: "EQUAL_TO",
    NOT_EQUAL_TO: "NOT_EQUAL_TO",
} as const;

export type ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum =
    (typeof ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum)[keyof typeof ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum];

/**
 * Custom label object override.
 */
export interface ExportCustomLabel {
    /**
     * Override value.
     */
    title: string;
}
/**
 * Custom metric object override.
 */
export interface ExportCustomMetric {
    /**
     * Metric title override.
     */
    title: string;
    /**
     * Format override.
     */
    format: string;
}
/**
 * Custom cell value overrides (IDs will be replaced with specified values).
 */
export interface ExportCustomOverride {
    /**
     * Map of CustomLabels with keys used as placeholders in document.
     */
    labels?: { [key: string]: ExportCustomLabel };
    /**
     * Map of CustomMetrics with keys used as placeholders in document.
     */
    metrics?: { [key: string]: ExportCustomMetric };
}
export interface ExportDashboardAttributeFilter {
    attributeFilter: ExportDashboardAttributeFilterAttributeFilter;
}
export interface ExportDashboardAttributeFilterAttributeFilter {
    displayForm: ExportIdentifierRef;
    negativeSelection: boolean;
    attributeElements: ExportAttributeElements;
    filterElementsBy?: Array<ExportAttributeFilterParent>;
    filterElementsByDate?: Array<ExportAttributeFilterByDate>;
    validateElementsBy?: Array<ExportIdentifierRef>;
    title?: string;
    selectionMode?: ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum;
    localIdentifier?: string;
}

export const ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum = {
    SINGLE: "single",
    MULTI: "multi",
} as const;

export type ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum =
    (typeof ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum)[keyof typeof ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum];

export interface ExportDashboardDateFilter {
    dateFilter: ExportDashboardDateFilterDateFilter;
}
export interface ExportDashboardDateFilterDateFilter {
    type: ExportDashboardDateFilterDateFilterTypeEnum;
    granularity: ExportDashboardDateFilterDateFilterGranularityEnum;
    from?: ExportDashboardDateFilterDateFilterFrom;
    to?: ExportDashboardDateFilterDateFilterFrom;
    dataSet?: ExportIdentifierRef;
    attribute?: ExportIdentifierRef;
    boundedFilter?: ExportRelativeBoundedDateFilter;
    localIdentifier?: string;
}

export const ExportDashboardDateFilterDateFilterTypeEnum = {
    RELATIVE: "relative",
    ABSOLUTE: "absolute",
} as const;

export type ExportDashboardDateFilterDateFilterTypeEnum =
    (typeof ExportDashboardDateFilterDateFilterTypeEnum)[keyof typeof ExportDashboardDateFilterDateFilterTypeEnum];
export const ExportDashboardDateFilterDateFilterGranularityEnum = {
    ALL_TIME_GRANULARITY: "ALL_TIME_GRANULARITY",
    GDC_TIME_YEAR: "GDC.time.year",
    GDC_TIME_WEEK_US: "GDC.time.week_us",
    GDC_TIME_WEEK_IN_YEAR: "GDC.time.week_in_year",
    GDC_TIME_WEEK_IN_QUARTER: "GDC.time.week_in_quarter",
    GDC_TIME_WEEK: "GDC.time.week",
    GDC_TIME_EUWEEK_IN_YEAR: "GDC.time.euweek_in_year",
    GDC_TIME_EUWEEK_IN_QUARTER: "GDC.time.euweek_in_quarter",
    GDC_TIME_QUARTER: "GDC.time.quarter",
    GDC_TIME_QUARTER_IN_YEAR: "GDC.time.quarter_in_year",
    GDC_TIME_MONTH: "GDC.time.month",
    GDC_TIME_MONTH_IN_QUARTER: "GDC.time.month_in_quarter",
    GDC_TIME_MONTH_IN_YEAR: "GDC.time.month_in_year",
    GDC_TIME_DAY_IN_YEAR: "GDC.time.day_in_year",
    GDC_TIME_DAY_IN_QUARTER: "GDC.time.day_in_quarter",
    GDC_TIME_DAY_IN_MONTH: "GDC.time.day_in_month",
    GDC_TIME_DAY_IN_WEEK: "GDC.time.day_in_week",
    GDC_TIME_DAY_IN_EUWEEK: "GDC.time.day_in_euweek",
    GDC_TIME_DATE: "GDC.time.date",
    GDC_TIME_HOUR: "GDC.time.hour",
    GDC_TIME_HOUR_IN_DAY: "GDC.time.hour_in_day",
    GDC_TIME_MINUTE: "GDC.time.minute",
    GDC_TIME_MINUTE_IN_HOUR: "GDC.time.minute_in_hour",
} as const;

export type ExportDashboardDateFilterDateFilterGranularityEnum =
    (typeof ExportDashboardDateFilterDateFilterGranularityEnum)[keyof typeof ExportDashboardDateFilterDateFilterGranularityEnum];

/**
 * @type ExportDashboardDateFilterDateFilterFrom
 */
export type ExportDashboardDateFilterDateFilterFrom = number | string;

/**
 * Additional settings.
 */
export interface ExportDashboardExportSettings {
    /**
     * If true, the export will contain the information about the export – exported date, dashboard filters, etc.
     */
    exportInfo?: boolean;
    /**
     * Merge equal headers in neighbouring cells. Used for [XLSX] format only.
     */
    mergeHeaders?: boolean;
    /**
     * Set page size. (PDF)
     */
    pageSize?: ExportDashboardExportSettingsPageSizeEnum;
    /**
     * Set page orientation. (PDF)
     */
    pageOrientation?: ExportDashboardExportSettingsPageOrientationEnum;
}

export const ExportDashboardExportSettingsPageSizeEnum = {
    A3: "A3",
    A4: "A4",
    LETTER: "LETTER",
} as const;

export type ExportDashboardExportSettingsPageSizeEnum =
    (typeof ExportDashboardExportSettingsPageSizeEnum)[keyof typeof ExportDashboardExportSettingsPageSizeEnum];
export const ExportDashboardExportSettingsPageOrientationEnum = {
    PORTRAIT: "PORTRAIT",
    LANDSCAPE: "LANDSCAPE",
} as const;

export type ExportDashboardExportSettingsPageOrientationEnum =
    (typeof ExportDashboardExportSettingsPageOrientationEnum)[keyof typeof ExportDashboardExportSettingsPageOrientationEnum];

/**
 * @type ExportDashboardFilter
 */
export type ExportDashboardFilter = ExportDashboardAttributeFilter | ExportDashboardDateFilter;

/**
 * Export request object describing the export properties for dashboard tabular exports.
 */
export interface ExportDashboardTabularExportRequest {
    /**
     * Requested tabular export type.
     */
    format: ExportDashboardTabularExportRequestFormatEnum;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    /**
     * List of filters that will be used instead of the default dashboard filters.
     */
    dashboardFiltersOverride?: Array<ExportDashboardFilter>;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds?: Array<string>;
    settings?: ExportDashboardExportSettings;
}

export const ExportDashboardTabularExportRequestFormatEnum = {
    XLSX: "XLSX",
    PDF: "PDF",
} as const;

export type ExportDashboardTabularExportRequestFormatEnum =
    (typeof ExportDashboardTabularExportRequestFormatEnum)[keyof typeof ExportDashboardTabularExportRequestFormatEnum];

/**
 * @type ExportDateFilter
 * Abstract filter definition type for dates.
 */
export type ExportDateFilter = ExportAbsoluteDateFilter | ExportRelativeDateFilter;

export interface ExportDateValue {
    value: string;
}
/**
 * Various settings affecting the process of AFM execution or its result
 */
export interface ExportExecutionSettings {
    /**
     * Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     */
    dataSamplingPercentage?: number;
    /**
     * Specifies the timestamp of the execution from which relative filters are resolved. If not set, the current time is used.
     */
    timestamp?: string;
}
export interface ExportExportResponse {
    exportResult: string;
}
/**
 * @type ExportFilterDefinition
 * Abstract filter definition type
 */
export type ExportFilterDefinition =
    | ExportAbsoluteDateFilter
    | ExportComparisonMeasureValueFilter
    | ExportInlineFilterDefinition
    | ExportNegativeAttributeFilter
    | ExportPositiveAttributeFilter
    | ExportRangeMeasureValueFilter
    | ExportRankingFilter
    | ExportRelativeDateFilter;

/**
 * @type ExportFilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple metric.
 */
export type ExportFilterDefinitionForSimpleMeasure = ExportAttributeFilter | ExportDateFilter;

export interface ExportGetSlidesExport202ResponseInner {
    short?: number;
    char?: string;
    int?: number;
    long?: number;
    float?: number;
    double?: number;
    direct?: boolean;
    readOnly?: boolean;
}
export interface ExportIdentifierRef {
    identifier?: ExportIdentifierRefIdentifier;
}
export interface ExportIdentifierRefIdentifier {
    id: string;
    type: ExportIdentifierRefIdentifierTypeEnum;
}

export const ExportIdentifierRefIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    ATTRIBUTE_HIERARCHY: "attributeHierarchy",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    AGGREGATED_FACT: "aggregatedFact",
    LABEL: "label",
    METRIC: "metric",
    USER_DATA_FILTER: "userDataFilter",
    EXPORT_DEFINITION: "exportDefinition",
    AUTOMATION: "automation",
    AUTOMATION_RESULT: "automationResult",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
    WORKSPACE_SETTINGS: "workspaceSettings",
    CUSTOM_APPLICATION_SETTING: "customApplicationSetting",
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
    WORKSPACE_DATA_FILTER_SETTING: "workspaceDataFilterSetting",
    FILTER_VIEW: "filterView",
} as const;

export type ExportIdentifierRefIdentifierTypeEnum =
    (typeof ExportIdentifierRefIdentifierTypeEnum)[keyof typeof ExportIdentifierRefIdentifierTypeEnum];

/**
 * Export request object describing the export properties and metadata for image exports.
 */
export interface ExportImageExportRequest {
    /**
     * Requested resulting file type.
     */
    format: ExportImageExportRequestFormatEnum;
    /**
     * File name to be used for retrieving the image document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds: Array<string>;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
}

export const ExportImageExportRequestFormatEnum = {
    PNG: "PNG",
} as const;

export type ExportImageExportRequestFormatEnum =
    (typeof ExportImageExportRequestFormatEnum)[keyof typeof ExportImageExportRequestFormatEnum];

/**
 * Filter in form of direct MAQL query.
 */
export interface ExportInlineFilterDefinition {
    inline: ExportInlineFilterDefinitionInline;
}
export interface ExportInlineFilterDefinitionInline {
    /**
     * MAQL query representing the filter.
     */
    filter: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
}
/**
 * Metric defined by the raw MAQL query.
 */
export interface ExportInlineMeasureDefinition {
    inline: ExportInlineMeasureDefinitionInline;
}
export interface ExportInlineMeasureDefinitionInline {
    /**
     * MAQL query defining the metric.
     */
    maql: string;
}
/**
 * @type ExportMeasureDefinition
 * Abstract metric definition type
 */
export type ExportMeasureDefinition =
    | ExportArithmeticMeasureDefinition
    | ExportInlineMeasureDefinition
    | ExportPopMeasureDefinition
    | ExportSimpleMeasureDefinition;

/**
 * Metric is a quantity that is calculated from the data.
 */
export interface ExportMeasureItem {
    /**
     * Local identifier of the metric. This can be used to reference the metric in other parts of the execution definition.
     */
    localIdentifier: string;
    definition: ExportMeasureDefinition;
}
/**
 * @type ExportMeasureValueFilter
 * Abstract filter definition type filtering by the value of the metric.
 */
export type ExportMeasureValueFilter = ExportComparisonMeasureValueFilter | ExportRangeMeasureValueFilter;

/**
 * Filter able to limit element values by label and related selected negated elements.
 */
export interface ExportNegativeAttributeFilter {
    negativeAttributeFilter: ExportNegativeAttributeFilterNegativeAttributeFilter;
}
export interface ExportNegativeAttributeFilterNegativeAttributeFilter {
    notIn: ExportAttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: ExportAfmIdentifier;
}
export interface ExportOver {
    attributes: Array<ExportIdentifierRef>;
}
/**
 * Custom CSS styles for the table. (PDF, HTML)
 */
export interface ExportPdfTableStyle {
    /**
     * CSS selector where to apply given properties.
     */
    selector: string;
    /**
     * List of CSS properties.
     */
    properties?: Array<ExportPdfTableStyleProperty>;
}
/**
 * CSS property.
 */
export interface ExportPdfTableStyleProperty {
    /**
     * CSS property key.
     */
    key: string;
    /**
     * CSS property value.
     */
    value: string;
}
/**
 * Combination of the date data set to use and how many periods ago to calculate the previous period for.
 */
export interface ExportPopDataset {
    dataset: ExportAfmObjectIdentifierDataset;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}
/**
 * Previous period type of metric.
 */
export interface ExportPopDatasetMeasureDefinition {
    previousPeriodMeasure: ExportPopDatasetMeasureDefinitionPreviousPeriodMeasure;
}
export interface ExportPopDatasetMeasureDefinitionPreviousPeriodMeasure {
    measureIdentifier: ExportAfmLocalIdentifier;
    /**
     * Specification of which date data sets to use for determining the period to calculate the previous period for.
     */
    dateDatasets: Array<ExportPopDataset>;
}
/**
 * Combination of the date attribute to use and how many periods ago to calculate the PoP for.
 */
export interface ExportPopDate {
    attribute: ExportAfmObjectIdentifierAttribute;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}
/**
 * Period over period type of metric.
 */
export interface ExportPopDateMeasureDefinition {
    overPeriodMeasure: ExportPopDateMeasureDefinitionOverPeriodMeasure;
}
export interface ExportPopDateMeasureDefinitionOverPeriodMeasure {
    measureIdentifier: ExportAfmLocalIdentifier;
    /**
     * Attributes to use for determining the period to calculate the PoP for.
     */
    dateAttributes: Array<ExportPopDate>;
}
/**
 * @type ExportPopMeasureDefinition
 */
export type ExportPopMeasureDefinition = ExportPopDatasetMeasureDefinition | ExportPopDateMeasureDefinition;

/**
 * Filter able to limit element values by label and related selected elements.
 */
export interface ExportPositiveAttributeFilter {
    positiveAttributeFilter: ExportPositiveAttributeFilterPositiveAttributeFilter;
}
export interface ExportPositiveAttributeFilterPositiveAttributeFilter {
    in: ExportAttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: ExportAfmIdentifier;
}
/**
 * Filter the result by comparing specified metric to given range of values.
 */
export interface ExportRangeMeasureValueFilter {
    rangeMeasureValueFilter: ExportRangeMeasureValueFilterRangeMeasureValueFilter;
}
export interface ExportRangeMeasureValueFilterRangeMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<ExportAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum;
    from: number;
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: ExportAfmIdentifier;
}

export const ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum = {
    BETWEEN: "BETWEEN",
    NOT_BETWEEN: "NOT_BETWEEN",
} as const;

export type ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum =
    (typeof ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum)[keyof typeof ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum];

/**
 * Filter the result on top/bottom N values according to given metric(s).
 */
export interface ExportRankingFilter {
    rankingFilter: ExportRankingFilterRankingFilter;
}
export interface ExportRankingFilterRankingFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<ExportAfmIdentifier>;
    /**
     * References to the metrics to be used when filtering.
     */
    measures: Array<ExportAfmIdentifier>;
    /**
     * The type of ranking to use, TOP or BOTTOM.
     */
    operator: ExportRankingFilterRankingFilterOperatorEnum;
    /**
     * Number of top/bottom values to filter.
     */
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
}

export const ExportRankingFilterRankingFilterOperatorEnum = {
    TOP: "TOP",
    BOTTOM: "BOTTOM",
} as const;

export type ExportRankingFilterRankingFilterOperatorEnum =
    (typeof ExportRankingFilterRankingFilterOperatorEnum)[keyof typeof ExportRankingFilterRankingFilterOperatorEnum];

/**
 * Custom label object override.
 */
export interface ExportRawCustomLabel {
    /**
     * Override value.
     */
    title: string;
}
/**
 * Custom metric object override.
 */
export interface ExportRawCustomMetric {
    /**
     * Metric title override.
     */
    title: string;
}
/**
 * Custom cell value overrides (IDs will be replaced with specified values).
 */
export interface ExportRawCustomOverride {
    /**
     * Map of CustomLabels with keys used as placeholders in export result.
     */
    labels?: { [key: string]: ExportRawCustomLabel };
    /**
     * Map of CustomMetrics with keys used as placeholders in export result.
     */
    metrics?: { [key: string]: ExportRawCustomMetric };
}
/**
 * Export request object describing the export properties and overrides for raw exports.
 */
export interface ExportRawExportRequest {
    /**
     * Requested resulting file type.
     */
    format: ExportRawExportRequestFormatEnum;
    execution: ExportAFM;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    customOverride?: ExportRawCustomOverride;
    executionSettings?: ExportExecutionSettings;
}

export const ExportRawExportRequestFormatEnum = {
    ARROW_FILE: "ARROW_FILE",
    ARROW_STREAM: "ARROW_STREAM",
    CSV: "CSV",
} as const;

export type ExportRawExportRequestFormatEnum =
    (typeof ExportRawExportRequestFormatEnum)[keyof typeof ExportRawExportRequestFormatEnum];

export interface ExportRelativeBoundedDateFilter {
    granularity: ExportRelativeBoundedDateFilterGranularityEnum;
    from?: number;
    to?: number;
}

export const ExportRelativeBoundedDateFilterGranularityEnum = {
    ALL_TIME_GRANULARITY: "ALL_TIME_GRANULARITY",
    GDC_TIME_YEAR: "GDC.time.year",
    GDC_TIME_WEEK_US: "GDC.time.week_us",
    GDC_TIME_WEEK_IN_YEAR: "GDC.time.week_in_year",
    GDC_TIME_WEEK_IN_QUARTER: "GDC.time.week_in_quarter",
    GDC_TIME_WEEK: "GDC.time.week",
    GDC_TIME_EUWEEK_IN_YEAR: "GDC.time.euweek_in_year",
    GDC_TIME_EUWEEK_IN_QUARTER: "GDC.time.euweek_in_quarter",
    GDC_TIME_QUARTER: "GDC.time.quarter",
    GDC_TIME_QUARTER_IN_YEAR: "GDC.time.quarter_in_year",
    GDC_TIME_MONTH: "GDC.time.month",
    GDC_TIME_MONTH_IN_QUARTER: "GDC.time.month_in_quarter",
    GDC_TIME_MONTH_IN_YEAR: "GDC.time.month_in_year",
    GDC_TIME_DAY_IN_YEAR: "GDC.time.day_in_year",
    GDC_TIME_DAY_IN_QUARTER: "GDC.time.day_in_quarter",
    GDC_TIME_DAY_IN_MONTH: "GDC.time.day_in_month",
    GDC_TIME_DAY_IN_WEEK: "GDC.time.day_in_week",
    GDC_TIME_DAY_IN_EUWEEK: "GDC.time.day_in_euweek",
    GDC_TIME_DATE: "GDC.time.date",
    GDC_TIME_HOUR: "GDC.time.hour",
    GDC_TIME_HOUR_IN_DAY: "GDC.time.hour_in_day",
    GDC_TIME_MINUTE: "GDC.time.minute",
    GDC_TIME_MINUTE_IN_HOUR: "GDC.time.minute_in_hour",
} as const;

export type ExportRelativeBoundedDateFilterGranularityEnum =
    (typeof ExportRelativeBoundedDateFilterGranularityEnum)[keyof typeof ExportRelativeBoundedDateFilterGranularityEnum];

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension. The \'from\' and \'to\' properties mark the boundaries of the interval. If \'from\' is omitted, all values earlier than \'to\' are included. If \'to\' is omitted, all values later than \'from\' are included. It is not allowed to omit both.
 */
export interface ExportRelativeDateFilter {
    relativeDateFilter: ExportRelativeDateFilterRelativeDateFilter;
}
export interface ExportRelativeDateFilterRelativeDateFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: ExportRelativeDateFilterRelativeDateFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     */
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    boundedFilter?: ExportBoundedFilter;
    dataset: ExportAfmObjectIdentifierDataset;
}

export const ExportRelativeDateFilterRelativeDateFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_QUARTER: "DAY_OF_QUARTER",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type ExportRelativeDateFilterRelativeDateFilterGranularityEnum =
    (typeof ExportRelativeDateFilterRelativeDateFilterGranularityEnum)[keyof typeof ExportRelativeDateFilterRelativeDateFilterGranularityEnum];

/**
 * Additional settings.
 */
export interface ExportSettings {
    /**
     * If true, the export will contain the information about the export – exported date, filters, etc. Works only with `visualizationObject`. (XLSX, PDF)
     */
    exportInfo?: boolean;
    /**
     * Merge equal headers in neighbouring cells. (XLSX)
     */
    mergeHeaders?: boolean;
    /**
     * Print applied filters on top of the document. (PDF/HTML when visualizationObject is given)
     * @deprecated
     */
    showFilters?: boolean;
    /**
     * Page size and orientation. (PDF)
     * @deprecated
     */
    pdfPageSize?: string;
    /**
     * Custom CSS styles for the table. (PDF, HTML)
     * @deprecated
     */
    pdfTableStyle?: Array<ExportPdfTableStyle>;
    /**
     * Top left header content. (PDF)
     * @deprecated
     */
    pdfTopLeftContent?: string;
    /**
     * Top right header content. (PDF)
     * @deprecated
     */
    pdfTopRightContent?: string;
    /**
     * Set page size. (PDF)
     */
    pageSize?: ExportSettingsPageSizeEnum;
    /**
     * Set page orientation. (PDF)
     */
    pageOrientation?: ExportSettingsPageOrientationEnum;
}

export const ExportSettingsPageSizeEnum = {
    A3: "A3",
    A4: "A4",
    LETTER: "LETTER",
} as const;

export type ExportSettingsPageSizeEnum =
    (typeof ExportSettingsPageSizeEnum)[keyof typeof ExportSettingsPageSizeEnum];
export const ExportSettingsPageOrientationEnum = {
    PORTRAIT: "PORTRAIT",
    LANDSCAPE: "LANDSCAPE",
} as const;

export type ExportSettingsPageOrientationEnum =
    (typeof ExportSettingsPageOrientationEnum)[keyof typeof ExportSettingsPageOrientationEnum];

/**
 * Metric defined by referencing a MAQL metric or an LDM fact object with aggregation.
 */
export interface ExportSimpleMeasureDefinition {
    measure: ExportSimpleMeasureDefinitionMeasure;
}
export interface ExportSimpleMeasureDefinitionMeasure {
    item: ExportAfmObjectIdentifierCore;
    /**
     * Definition of aggregation type of the metric.
     */
    aggregation?: ExportSimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true, compute the percentage of given metric values (broken down by AFM attributes) to the total (not broken down).
     */
    computeRatio?: boolean;
    /**
     * Metrics can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     */
    filters?: Array<ExportFilterDefinitionForSimpleMeasure>;
}

export const ExportSimpleMeasureDefinitionMeasureAggregationEnum = {
    SUM: "SUM",
    COUNT: "COUNT",
    AVG: "AVG",
    MIN: "MIN",
    MAX: "MAX",
    MEDIAN: "MEDIAN",
    RUNSUM: "RUNSUM",
    APPROXIMATE_COUNT: "APPROXIMATE_COUNT",
} as const;

export type ExportSimpleMeasureDefinitionMeasureAggregationEnum =
    (typeof ExportSimpleMeasureDefinitionMeasureAggregationEnum)[keyof typeof ExportSimpleMeasureDefinitionMeasureAggregationEnum];

/**
 * Export request object describing the export properties and metadata for slides exports.
 */
export interface ExportSlidesExportRequest {
    /**
     * Requested resulting file type.
     */
    format: ExportSlidesExportRequestFormatEnum;
    /**
     * File name to be used for retrieving the pdf document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId?: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds?: Array<string>;
    /**
     * List of visualization ids to be exported. Note that only one visualization is currently supported.
     */
    visualizationIds?: Array<string>;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
    /**
     * Export template identifier.
     */
    templateId?: string | null;
}

export const ExportSlidesExportRequestFormatEnum = {
    PDF: "PDF",
    PPTX: "PPTX",
} as const;

export type ExportSlidesExportRequestFormatEnum =
    (typeof ExportSlidesExportRequestFormatEnum)[keyof typeof ExportSlidesExportRequestFormatEnum];

/**
 * Export request object describing the export properties and overrides for tabular exports.
 */
export interface ExportTabularExportRequest {
    /**
     * Expected file format.
     */
    format: ExportTabularExportRequestFormatEnum;
    /**
     * Execution result identifier.
     */
    executionResult?: string;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    settings?: ExportSettings;
    customOverride?: ExportCustomOverride;
    /**
     * Visualization object identifier. Alternative to executionResult property.
     */
    visualizationObject?: string;
    /**
     * Optional custom filters (as array of IFilter objects defined in UI SDK) to be applied when visualizationObject is given. Those filters override the original filters defined in the visualization.
     */
    visualizationObjectCustomFilters?: Array<object>;
    /**
     * Analytical dashboard identifier. Optional identifier, which informs the system that the export is related to a specific dashboard.
     */
    relatedDashboardId?: string;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
}

export const ExportTabularExportRequestFormatEnum = {
    CSV: "CSV",
    XLSX: "XLSX",
    HTML: "HTML",
    PDF: "PDF",
} as const;

export type ExportTabularExportRequestFormatEnum =
    (typeof ExportTabularExportRequestFormatEnum)[keyof typeof ExportTabularExportRequestFormatEnum];

/**
 * Export request object describing the export properties and metadata for dashboard PDF exports.
 */
export interface ExportVisualExportRequest {
    /**
     * File name to be used for retrieving the pdf document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId: string;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object;
}

/**
 * ActionsExport - axios parameter creator
 * @export
 */
export const ActionsExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {ExportDashboardTabularExportRequest} exportDashboardTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardExportRequest: async (
            workspaceId: string,
            dashboardId: string,
            exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createDashboardExportRequest", "workspaceId", workspaceId);
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists("createDashboardExportRequest", "dashboardId", dashboardId);
            // verify required parameter 'exportDashboardTabularExportRequest' is not null or undefined
            assertParamExists(
                "createDashboardExportRequest",
                "exportDashboardTabularExportRequest",
                exportDashboardTabularExportRequest,
            );
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/export/tabular`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportDashboardTabularExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      exportDashboardTabularExportRequest !== undefined
                          ? exportDashboardTabularExportRequest
                          : {},
                  )
                : exportDashboardTabularExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {string} workspaceId
         * @param {ExportImageExportRequest} exportImageExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageExport: async (
            workspaceId: string,
            exportImageExportRequest: ExportImageExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createImageExport", "workspaceId", workspaceId);
            // verify required parameter 'exportImageExportRequest' is not null or undefined
            assertParamExists("createImageExport", "exportImageExportRequest", exportImageExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportImageExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportImageExportRequest !== undefined ? exportImageExportRequest : {})
                : exportImageExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {ExportVisualExportRequest} exportVisualExportRequest
         * @param {boolean} [xGdcDebug]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport: async (
            workspaceId: string,
            exportVisualExportRequest: ExportVisualExportRequest,
            xGdcDebug?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createPdfExport", "workspaceId", workspaceId);
            // verify required parameter 'exportVisualExportRequest' is not null or undefined
            assertParamExists("createPdfExport", "exportVisualExportRequest", exportVisualExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xGdcDebug !== undefined && xGdcDebug !== null) {
                localVarHeaderParameter["X-Gdc-Debug"] = String(JSON.stringify(xGdcDebug));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportVisualExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportVisualExportRequest !== undefined ? exportVisualExportRequest : {})
                : exportVisualExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {string} workspaceId
         * @param {ExportRawExportRequest} exportRawExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawExport: async (
            workspaceId: string,
            exportRawExportRequest: ExportRawExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createRawExport", "workspaceId", workspaceId);
            // verify required parameter 'exportRawExportRequest' is not null or undefined
            assertParamExists("createRawExport", "exportRawExportRequest", exportRawExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportRawExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportRawExportRequest !== undefined ? exportRawExportRequest : {})
                : exportRawExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {string} workspaceId
         * @param {ExportSlidesExportRequest} exportSlidesExportRequest
         * @param {boolean} [xGdcDebug]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSlidesExport: async (
            workspaceId: string,
            exportSlidesExportRequest: ExportSlidesExportRequest,
            xGdcDebug?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createSlidesExport", "workspaceId", workspaceId);
            // verify required parameter 'exportSlidesExportRequest' is not null or undefined
            assertParamExists("createSlidesExport", "exportSlidesExportRequest", exportSlidesExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xGdcDebug !== undefined && xGdcDebug !== null) {
                localVarHeaderParameter["X-Gdc-Debug"] = String(JSON.stringify(xGdcDebug));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportSlidesExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportSlidesExportRequest !== undefined ? exportSlidesExportRequest : {})
                : exportSlidesExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {ExportTabularExportRequest} exportTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport: async (
            workspaceId: string,
            exportTabularExportRequest: ExportTabularExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'exportTabularExportRequest' is not null or undefined
            assertParamExists(
                "createTabularExport",
                "exportTabularExportRequest",
                exportTabularExportRequest,
            );
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportTabularExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportTabularExportRequest !== undefined ? exportTabularExportRequest : {})
                : exportTabularExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getExportedFile", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getExportedFile", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getImageExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getImageExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExportMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getImageExportMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getImageExportMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getRawExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getRawExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getSlidesExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getSlidesExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExportMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getSlidesExportMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getSlidesExportMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getTabularExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsExport - functional programming interface
 * @export
 */
export const ActionsExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsExportAxiosParamCreator(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {ExportDashboardTabularExportRequest} exportDashboardTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDashboardExportRequest(
            workspaceId: string,
            dashboardId: string,
            exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDashboardExportRequest(
                workspaceId,
                dashboardId,
                exportDashboardTabularExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {string} workspaceId
         * @param {ExportImageExportRequest} exportImageExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImageExport(
            workspaceId: string,
            exportImageExportRequest: ExportImageExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImageExport(
                workspaceId,
                exportImageExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {ExportVisualExportRequest} exportVisualExportRequest
         * @param {boolean} [xGdcDebug]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPdfExport(
            workspaceId: string,
            exportVisualExportRequest: ExportVisualExportRequest,
            xGdcDebug?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPdfExport(
                workspaceId,
                exportVisualExportRequest,
                xGdcDebug,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {string} workspaceId
         * @param {ExportRawExportRequest} exportRawExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawExport(
            workspaceId: string,
            exportRawExportRequest: ExportRawExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRawExport(
                workspaceId,
                exportRawExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {string} workspaceId
         * @param {ExportSlidesExportRequest} exportSlidesExportRequest
         * @param {boolean} [xGdcDebug]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSlidesExport(
            workspaceId: string,
            exportSlidesExportRequest: ExportSlidesExportRequest,
            xGdcDebug?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSlidesExport(
                workspaceId,
                exportSlidesExportRequest,
                xGdcDebug,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {ExportTabularExportRequest} exportTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTabularExport(
            workspaceId: string,
            exportTabularExportRequest: ExportTabularExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTabularExport(
                workspaceId,
                exportTabularExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExportedFile(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExportedFile(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageExportMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageExportMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRawExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlidesExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlidesExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlidesExportMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlidesExportMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTabularExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTabularExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsExport - factory interface
 * @export
 */
export const ActionsExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsExportFp(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {ActionsExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardExportRequest(
            requestParameters: ActionsExportCreateDashboardExportRequestRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createDashboardExportRequest(
                    requestParameters.workspaceId,
                    requestParameters.dashboardId,
                    requestParameters.exportDashboardTabularExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {ActionsExportCreateImageExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageExport(
            requestParameters: ActionsExportCreateImageExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createImageExport(
                    requestParameters.workspaceId,
                    requestParameters.exportImageExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {ActionsExportCreatePdfExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport(
            requestParameters: ActionsExportCreatePdfExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createPdfExport(
                    requestParameters.workspaceId,
                    requestParameters.exportVisualExportRequest,
                    requestParameters.xGdcDebug,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {ActionsExportCreateRawExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawExport(
            requestParameters: ActionsExportCreateRawExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createRawExport(
                    requestParameters.workspaceId,
                    requestParameters.exportRawExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {ActionsExportCreateSlidesExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSlidesExport(
            requestParameters: ActionsExportCreateSlidesExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createSlidesExport(
                    requestParameters.workspaceId,
                    requestParameters.exportSlidesExportRequest,
                    requestParameters.xGdcDebug,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {ActionsExportCreateTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport(
            requestParameters: ActionsExportCreateTabularExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createTabularExport(
                    requestParameters.workspaceId,
                    requestParameters.exportTabularExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {ActionsExportGetExportedFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile(
            requestParameters: ActionsExportGetExportedFileRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {ActionsExportGetImageExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExport(
            requestParameters: ActionsExportGetImageExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .getImageExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {ActionsExportGetImageExportMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExportMetadata(
            requestParameters: ActionsExportGetImageExportMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getImageExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {ActionsExportGetMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(
            requestParameters: ActionsExportGetMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {ActionsExportGetRawExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawExport(
            requestParameters: ActionsExportGetRawExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .getRawExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {ActionsExportGetSlidesExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExport(
            requestParameters: ActionsExportGetSlidesExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .getSlidesExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {ActionsExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExportMetadata(
            requestParameters: ActionsExportGetSlidesExportMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getSlidesExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {ActionsExportGetTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport(
            requestParameters: ActionsExportGetTabularExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsExport - interface
 * @export
 * @interface ActionsExport
 */
export interface ActionsExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {ActionsExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createDashboardExportRequest(
        requestParameters: ActionsExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ActionsExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createImageExport(
        requestParameters: ActionsExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {ActionsExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createPdfExport(
        requestParameters: ActionsExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {ActionsExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createRawExport(
        requestParameters: ActionsExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {ActionsExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createSlidesExport(
        requestParameters: ActionsExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {ActionsExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createTabularExport(
        requestParameters: ActionsExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {ActionsExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getExportedFile(
        requestParameters: ActionsExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getImageExport(
        requestParameters: ActionsExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getImageExportMetadata(
        requestParameters: ActionsExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {ActionsExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getMetadata(
        requestParameters: ActionsExportGetMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getRawExport(
        requestParameters: ActionsExportGetRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getSlidesExport(
        requestParameters: ActionsExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getSlidesExportMetadata(
        requestParameters: ActionsExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {ActionsExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getTabularExport(
        requestParameters: ActionsExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;
}

/**
 * Request parameters for createDashboardExportRequest operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateDashboardExportRequestRequest
 */
export interface ActionsExportCreateDashboardExportRequestRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateDashboardExportRequest
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateDashboardExportRequest
     */
    readonly dashboardId: string;

    /**
     *
     * @type {ExportDashboardTabularExportRequest}
     * @memberof ActionsExportCreateDashboardExportRequest
     */
    readonly exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest;
}

/**
 * Request parameters for createImageExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateImageExportRequest
 */
export interface ActionsExportCreateImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportImageExportRequest}
     * @memberof ActionsExportCreateImageExport
     */
    readonly exportImageExportRequest: ExportImageExportRequest;
}

/**
 * Request parameters for createPdfExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreatePdfExportRequest
 */
export interface ActionsExportCreatePdfExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreatePdfExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportVisualExportRequest}
     * @memberof ActionsExportCreatePdfExport
     */
    readonly exportVisualExportRequest: ExportVisualExportRequest;

    /**
     *
     * @type {boolean}
     * @memberof ActionsExportCreatePdfExport
     */
    readonly xGdcDebug?: boolean;
}

/**
 * Request parameters for createRawExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateRawExportRequest
 */
export interface ActionsExportCreateRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportRawExportRequest}
     * @memberof ActionsExportCreateRawExport
     */
    readonly exportRawExportRequest: ExportRawExportRequest;
}

/**
 * Request parameters for createSlidesExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateSlidesExportRequest
 */
export interface ActionsExportCreateSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportSlidesExportRequest}
     * @memberof ActionsExportCreateSlidesExport
     */
    readonly exportSlidesExportRequest: ExportSlidesExportRequest;

    /**
     *
     * @type {boolean}
     * @memberof ActionsExportCreateSlidesExport
     */
    readonly xGdcDebug?: boolean;
}

/**
 * Request parameters for createTabularExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateTabularExportRequest
 */
export interface ActionsExportCreateTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportTabularExportRequest}
     * @memberof ActionsExportCreateTabularExport
     */
    readonly exportTabularExportRequest: ExportTabularExportRequest;
}

/**
 * Request parameters for getExportedFile operation in ActionsExport.
 * @export
 * @interface ActionsExportGetExportedFileRequest
 */
export interface ActionsExportGetExportedFileRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetExportedFile
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetExportedFile
     */
    readonly exportId: string;
}

/**
 * Request parameters for getImageExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetImageExportRequest
 */
export interface ActionsExportGetImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getImageExportMetadata operation in ActionsExport.
 * @export
 * @interface ActionsExportGetImageExportMetadataRequest
 */
export interface ActionsExportGetImageExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExportMetadata
     */
    readonly exportId: string;
}

/**
 * Request parameters for getMetadata operation in ActionsExport.
 * @export
 * @interface ActionsExportGetMetadataRequest
 */
export interface ActionsExportGetMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetMetadata
     */
    readonly exportId: string;
}

/**
 * Request parameters for getRawExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetRawExportRequest
 */
export interface ActionsExportGetRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetRawExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getSlidesExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetSlidesExportRequest
 */
export interface ActionsExportGetSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getSlidesExportMetadata operation in ActionsExport.
 * @export
 * @interface ActionsExportGetSlidesExportMetadataRequest
 */
export interface ActionsExportGetSlidesExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExportMetadata
     */
    readonly exportId: string;
}

/**
 * Request parameters for getTabularExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetTabularExportRequest
 */
export interface ActionsExportGetTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetTabularExport
     */
    readonly exportId: string;
}

/**
 * ActionsExport - object-oriented interface
 * @export
 * @class ActionsExport
 * @extends {BaseAPI}
 */
export class ActionsExport extends BaseAPI implements ActionsExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {ActionsExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createDashboardExportRequest(
        requestParameters: ActionsExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createDashboardExportRequest(
                requestParameters.workspaceId,
                requestParameters.dashboardId,
                requestParameters.exportDashboardTabularExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ActionsExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createImageExport(
        requestParameters: ActionsExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createImageExport(
                requestParameters.workspaceId,
                requestParameters.exportImageExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {ActionsExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createPdfExport(
        requestParameters: ActionsExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createPdfExport(
                requestParameters.workspaceId,
                requestParameters.exportVisualExportRequest,
                requestParameters.xGdcDebug,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {ActionsExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createRawExport(
        requestParameters: ActionsExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createRawExport(requestParameters.workspaceId, requestParameters.exportRawExportRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {ActionsExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createSlidesExport(
        requestParameters: ActionsExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createSlidesExport(
                requestParameters.workspaceId,
                requestParameters.exportSlidesExportRequest,
                requestParameters.xGdcDebug,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {ActionsExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createTabularExport(
        requestParameters: ActionsExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createTabularExport(
                requestParameters.workspaceId,
                requestParameters.exportTabularExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {ActionsExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getExportedFile(
        requestParameters: ActionsExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getImageExport(
        requestParameters: ActionsExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getImageExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getImageExportMetadata(
        requestParameters: ActionsExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getImageExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {ActionsExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getMetadata(requestParameters: ActionsExportGetMetadataRequest, options?: AxiosRequestConfig) {
        return ActionsExportFp(this.configuration)
            .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getRawExport(requestParameters: ActionsExportGetRawExportRequest, options?: AxiosRequestConfig) {
        return ActionsExportFp(this.configuration)
            .getRawExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getSlidesExport(
        requestParameters: ActionsExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getSlidesExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getSlidesExportMetadata(
        requestParameters: ActionsExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getSlidesExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {ActionsExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getTabularExport(
        requestParameters: ActionsExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ImageExportExport - axios parameter creator
 * @export
 */
export const ImageExportExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {string} workspaceId
         * @param {ExportImageExportRequest} exportImageExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageExport: async (
            workspaceId: string,
            exportImageExportRequest: ExportImageExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createImageExport", "workspaceId", workspaceId);
            // verify required parameter 'exportImageExportRequest' is not null or undefined
            assertParamExists("createImageExport", "exportImageExportRequest", exportImageExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportImageExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportImageExportRequest !== undefined ? exportImageExportRequest : {})
                : exportImageExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getImageExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getImageExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExportMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getImageExportMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getImageExportMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ImageExportExport - functional programming interface
 * @export
 */
export const ImageExportExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageExportExportAxiosParamCreator(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {string} workspaceId
         * @param {ExportImageExportRequest} exportImageExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImageExport(
            workspaceId: string,
            exportImageExportRequest: ExportImageExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImageExport(
                workspaceId,
                exportImageExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageExportMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageExportMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ImageExportExport - factory interface
 * @export
 */
export const ImageExportExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ImageExportExportFp(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {ImageExportExportCreateImageExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageExport(
            requestParameters: ImageExportExportCreateImageExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createImageExport(
                    requestParameters.workspaceId,
                    requestParameters.exportImageExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {ImageExportExportGetImageExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExport(
            requestParameters: ImageExportExportGetImageExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .getImageExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {ImageExportExportGetImageExportMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExportMetadata(
            requestParameters: ImageExportExportGetImageExportMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getImageExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageExportExport - interface
 * @export
 * @interface ImageExportExport
 */
export interface ImageExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ImageExportExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExportInterface
     */
    createImageExport(
        requestParameters: ImageExportExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ImageExportExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExportInterface
     */
    getImageExport(
        requestParameters: ImageExportExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ImageExportExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExportInterface
     */
    getImageExportMetadata(
        requestParameters: ImageExportExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createImageExport operation in ImageExportExport.
 * @export
 * @interface ImageExportExportCreateImageExportRequest
 */
export interface ImageExportExportCreateImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ImageExportExportCreateImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportImageExportRequest}
     * @memberof ImageExportExportCreateImageExport
     */
    readonly exportImageExportRequest: ExportImageExportRequest;
}

/**
 * Request parameters for getImageExport operation in ImageExportExport.
 * @export
 * @interface ImageExportExportGetImageExportRequest
 */
export interface ImageExportExportGetImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getImageExportMetadata operation in ImageExportExport.
 * @export
 * @interface ImageExportExportGetImageExportMetadataRequest
 */
export interface ImageExportExportGetImageExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExportMetadata
     */
    readonly exportId: string;
}

/**
 * ImageExportExport - object-oriented interface
 * @export
 * @class ImageExportExport
 * @extends {BaseAPI}
 */
export class ImageExportExport extends BaseAPI implements ImageExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ImageExportExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExport
     */
    public createImageExport(
        requestParameters: ImageExportExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ImageExportExportFp(this.configuration)
            .createImageExport(
                requestParameters.workspaceId,
                requestParameters.exportImageExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ImageExportExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExport
     */
    public getImageExport(
        requestParameters: ImageExportExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ImageExportExportFp(this.configuration)
            .getImageExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ImageExportExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExport
     */
    public getImageExportMetadata(
        requestParameters: ImageExportExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ImageExportExportFp(this.configuration)
            .getImageExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * RawExportExport - axios parameter creator
 * @export
 */
export const RawExportExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {string} workspaceId
         * @param {ExportRawExportRequest} exportRawExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawExport: async (
            workspaceId: string,
            exportRawExportRequest: ExportRawExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createRawExport", "workspaceId", workspaceId);
            // verify required parameter 'exportRawExportRequest' is not null or undefined
            assertParamExists("createRawExport", "exportRawExportRequest", exportRawExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportRawExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportRawExportRequest !== undefined ? exportRawExportRequest : {})
                : exportRawExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getRawExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getRawExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * RawExportExport - functional programming interface
 * @export
 */
export const RawExportExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RawExportExportAxiosParamCreator(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {string} workspaceId
         * @param {ExportRawExportRequest} exportRawExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawExport(
            workspaceId: string,
            exportRawExportRequest: ExportRawExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRawExport(
                workspaceId,
                exportRawExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRawExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * RawExportExport - factory interface
 * @export
 */
export const RawExportExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = RawExportExportFp(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {RawExportExportCreateRawExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawExport(
            requestParameters: RawExportExportCreateRawExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createRawExport(
                    requestParameters.workspaceId,
                    requestParameters.exportRawExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {RawExportExportGetRawExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawExport(
            requestParameters: RawExportExportGetRawExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .getRawExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * RawExportExport - interface
 * @export
 * @interface RawExportExport
 */
export interface RawExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {RawExportExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExportInterface
     */
    createRawExport(
        requestParameters: RawExportExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {RawExportExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExportInterface
     */
    getRawExport(
        requestParameters: RawExportExportGetRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;
}

/**
 * Request parameters for createRawExport operation in RawExportExport.
 * @export
 * @interface RawExportExportCreateRawExportRequest
 */
export interface RawExportExportCreateRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof RawExportExportCreateRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportRawExportRequest}
     * @memberof RawExportExportCreateRawExport
     */
    readonly exportRawExportRequest: ExportRawExportRequest;
}

/**
 * Request parameters for getRawExport operation in RawExportExport.
 * @export
 * @interface RawExportExportGetRawExportRequest
 */
export interface RawExportExportGetRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof RawExportExportGetRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof RawExportExportGetRawExport
     */
    readonly exportId: string;
}

/**
 * RawExportExport - object-oriented interface
 * @export
 * @class RawExportExport
 * @extends {BaseAPI}
 */
export class RawExportExport extends BaseAPI implements RawExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {RawExportExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExport
     */
    public createRawExport(
        requestParameters: RawExportExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return RawExportExportFp(this.configuration)
            .createRawExport(requestParameters.workspaceId, requestParameters.exportRawExportRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {RawExportExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExport
     */
    public getRawExport(requestParameters: RawExportExportGetRawExportRequest, options?: AxiosRequestConfig) {
        return RawExportExportFp(this.configuration)
            .getRawExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * SlidesExportExport - axios parameter creator
 * @export
 */
export const SlidesExportExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {string} workspaceId
         * @param {ExportSlidesExportRequest} exportSlidesExportRequest
         * @param {boolean} [xGdcDebug]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSlidesExport: async (
            workspaceId: string,
            exportSlidesExportRequest: ExportSlidesExportRequest,
            xGdcDebug?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createSlidesExport", "workspaceId", workspaceId);
            // verify required parameter 'exportSlidesExportRequest' is not null or undefined
            assertParamExists("createSlidesExport", "exportSlidesExportRequest", exportSlidesExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xGdcDebug !== undefined && xGdcDebug !== null) {
                localVarHeaderParameter["X-Gdc-Debug"] = String(JSON.stringify(xGdcDebug));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportSlidesExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportSlidesExportRequest !== undefined ? exportSlidesExportRequest : {})
                : exportSlidesExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getSlidesExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getSlidesExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExportMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getSlidesExportMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getSlidesExportMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * SlidesExportExport - functional programming interface
 * @export
 */
export const SlidesExportExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SlidesExportExportAxiosParamCreator(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {string} workspaceId
         * @param {ExportSlidesExportRequest} exportSlidesExportRequest
         * @param {boolean} [xGdcDebug]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSlidesExport(
            workspaceId: string,
            exportSlidesExportRequest: ExportSlidesExportRequest,
            xGdcDebug?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSlidesExport(
                workspaceId,
                exportSlidesExportRequest,
                xGdcDebug,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlidesExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlidesExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlidesExportMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlidesExportMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * SlidesExportExport - factory interface
 * @export
 */
export const SlidesExportExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = SlidesExportExportFp(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {SlidesExportExportCreateSlidesExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSlidesExport(
            requestParameters: SlidesExportExportCreateSlidesExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createSlidesExport(
                    requestParameters.workspaceId,
                    requestParameters.exportSlidesExportRequest,
                    requestParameters.xGdcDebug,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {SlidesExportExportGetSlidesExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExport(
            requestParameters: SlidesExportExportGetSlidesExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .getSlidesExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {SlidesExportExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExportMetadata(
            requestParameters: SlidesExportExportGetSlidesExportMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getSlidesExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * SlidesExportExport - interface
 * @export
 * @interface SlidesExportExport
 */
export interface SlidesExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {SlidesExportExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExportInterface
     */
    createSlidesExport(
        requestParameters: SlidesExportExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {SlidesExportExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExportInterface
     */
    getSlidesExport(
        requestParameters: SlidesExportExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {SlidesExportExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExportInterface
     */
    getSlidesExportMetadata(
        requestParameters: SlidesExportExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createSlidesExport operation in SlidesExportExport.
 * @export
 * @interface SlidesExportExportCreateSlidesExportRequest
 */
export interface SlidesExportExportCreateSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof SlidesExportExportCreateSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportSlidesExportRequest}
     * @memberof SlidesExportExportCreateSlidesExport
     */
    readonly exportSlidesExportRequest: ExportSlidesExportRequest;

    /**
     *
     * @type {boolean}
     * @memberof SlidesExportExportCreateSlidesExport
     */
    readonly xGdcDebug?: boolean;
}

/**
 * Request parameters for getSlidesExport operation in SlidesExportExport.
 * @export
 * @interface SlidesExportExportGetSlidesExportRequest
 */
export interface SlidesExportExportGetSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getSlidesExportMetadata operation in SlidesExportExport.
 * @export
 * @interface SlidesExportExportGetSlidesExportMetadataRequest
 */
export interface SlidesExportExportGetSlidesExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExportMetadata
     */
    readonly exportId: string;
}

/**
 * SlidesExportExport - object-oriented interface
 * @export
 * @class SlidesExportExport
 * @extends {BaseAPI}
 */
export class SlidesExportExport extends BaseAPI implements SlidesExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {SlidesExportExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExport
     */
    public createSlidesExport(
        requestParameters: SlidesExportExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return SlidesExportExportFp(this.configuration)
            .createSlidesExport(
                requestParameters.workspaceId,
                requestParameters.exportSlidesExportRequest,
                requestParameters.xGdcDebug,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {SlidesExportExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExport
     */
    public getSlidesExport(
        requestParameters: SlidesExportExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return SlidesExportExportFp(this.configuration)
            .getSlidesExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {SlidesExportExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExport
     */
    public getSlidesExportMetadata(
        requestParameters: SlidesExportExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return SlidesExportExportFp(this.configuration)
            .getSlidesExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * TabularExportExport - axios parameter creator
 * @export
 */
export const TabularExportExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {ExportDashboardTabularExportRequest} exportDashboardTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardExportRequest: async (
            workspaceId: string,
            dashboardId: string,
            exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createDashboardExportRequest", "workspaceId", workspaceId);
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists("createDashboardExportRequest", "dashboardId", dashboardId);
            // verify required parameter 'exportDashboardTabularExportRequest' is not null or undefined
            assertParamExists(
                "createDashboardExportRequest",
                "exportDashboardTabularExportRequest",
                exportDashboardTabularExportRequest,
            );
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/export/tabular`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportDashboardTabularExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      exportDashboardTabularExportRequest !== undefined
                          ? exportDashboardTabularExportRequest
                          : {},
                  )
                : exportDashboardTabularExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {ExportTabularExportRequest} exportTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport: async (
            workspaceId: string,
            exportTabularExportRequest: ExportTabularExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'exportTabularExportRequest' is not null or undefined
            assertParamExists(
                "createTabularExport",
                "exportTabularExportRequest",
                exportTabularExportRequest,
            );
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportTabularExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportTabularExportRequest !== undefined ? exportTabularExportRequest : {})
                : exportTabularExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getTabularExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * TabularExportExport - functional programming interface
 * @export
 */
export const TabularExportExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TabularExportExportAxiosParamCreator(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {ExportDashboardTabularExportRequest} exportDashboardTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDashboardExportRequest(
            workspaceId: string,
            dashboardId: string,
            exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDashboardExportRequest(
                workspaceId,
                dashboardId,
                exportDashboardTabularExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {ExportTabularExportRequest} exportTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTabularExport(
            workspaceId: string,
            exportTabularExportRequest: ExportTabularExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTabularExport(
                workspaceId,
                exportTabularExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTabularExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTabularExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * TabularExportExport - factory interface
 * @export
 */
export const TabularExportExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = TabularExportExportFp(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {TabularExportExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardExportRequest(
            requestParameters: TabularExportExportCreateDashboardExportRequestRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createDashboardExportRequest(
                    requestParameters.workspaceId,
                    requestParameters.dashboardId,
                    requestParameters.exportDashboardTabularExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {TabularExportExportCreateTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport(
            requestParameters: TabularExportExportCreateTabularExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createTabularExport(
                    requestParameters.workspaceId,
                    requestParameters.exportTabularExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {TabularExportExportGetTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport(
            requestParameters: TabularExportExportGetTabularExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * TabularExportExport - interface
 * @export
 * @interface TabularExportExport
 */
export interface TabularExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {TabularExportExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExportInterface
     */
    createDashboardExportRequest(
        requestParameters: TabularExportExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {TabularExportExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExportInterface
     */
    createTabularExport(
        requestParameters: TabularExportExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {TabularExportExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExportInterface
     */
    getTabularExport(
        requestParameters: TabularExportExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;
}

/**
 * Request parameters for createDashboardExportRequest operation in TabularExportExport.
 * @export
 * @interface TabularExportExportCreateDashboardExportRequestRequest
 */
export interface TabularExportExportCreateDashboardExportRequestRequest {
    /**
     *
     * @type {string}
     * @memberof TabularExportExportCreateDashboardExportRequest
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof TabularExportExportCreateDashboardExportRequest
     */
    readonly dashboardId: string;

    /**
     *
     * @type {ExportDashboardTabularExportRequest}
     * @memberof TabularExportExportCreateDashboardExportRequest
     */
    readonly exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest;
}

/**
 * Request parameters for createTabularExport operation in TabularExportExport.
 * @export
 * @interface TabularExportExportCreateTabularExportRequest
 */
export interface TabularExportExportCreateTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof TabularExportExportCreateTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportTabularExportRequest}
     * @memberof TabularExportExportCreateTabularExport
     */
    readonly exportTabularExportRequest: ExportTabularExportRequest;
}

/**
 * Request parameters for getTabularExport operation in TabularExportExport.
 * @export
 * @interface TabularExportExportGetTabularExportRequest
 */
export interface TabularExportExportGetTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof TabularExportExportGetTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof TabularExportExportGetTabularExport
     */
    readonly exportId: string;
}

/**
 * TabularExportExport - object-oriented interface
 * @export
 * @class TabularExportExport
 * @extends {BaseAPI}
 */
export class TabularExportExport extends BaseAPI implements TabularExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {TabularExportExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExport
     */
    public createDashboardExportRequest(
        requestParameters: TabularExportExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ) {
        return TabularExportExportFp(this.configuration)
            .createDashboardExportRequest(
                requestParameters.workspaceId,
                requestParameters.dashboardId,
                requestParameters.exportDashboardTabularExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {TabularExportExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExport
     */
    public createTabularExport(
        requestParameters: TabularExportExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return TabularExportExportFp(this.configuration)
            .createTabularExport(
                requestParameters.workspaceId,
                requestParameters.exportTabularExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {TabularExportExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExport
     */
    public getTabularExport(
        requestParameters: TabularExportExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return TabularExportExportFp(this.configuration)
            .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * VisualExportExport - axios parameter creator
 * @export
 */
export const VisualExportExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {ExportVisualExportRequest} exportVisualExportRequest
         * @param {boolean} [xGdcDebug]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport: async (
            workspaceId: string,
            exportVisualExportRequest: ExportVisualExportRequest,
            xGdcDebug?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createPdfExport", "workspaceId", workspaceId);
            // verify required parameter 'exportVisualExportRequest' is not null or undefined
            assertParamExists("createPdfExport", "exportVisualExportRequest", exportVisualExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xGdcDebug !== undefined && xGdcDebug !== null) {
                localVarHeaderParameter["X-Gdc-Debug"] = String(JSON.stringify(xGdcDebug));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportVisualExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportVisualExportRequest !== undefined ? exportVisualExportRequest : {})
                : exportVisualExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getExportedFile", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getExportedFile", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * VisualExportExport - functional programming interface
 * @export
 */
export const VisualExportExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = VisualExportExportAxiosParamCreator(configuration);
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {ExportVisualExportRequest} exportVisualExportRequest
         * @param {boolean} [xGdcDebug]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPdfExport(
            workspaceId: string,
            exportVisualExportRequest: ExportVisualExportRequest,
            xGdcDebug?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPdfExport(
                workspaceId,
                exportVisualExportRequest,
                xGdcDebug,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExportedFile(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExportedFile(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * VisualExportExport - factory interface
 * @export
 */
export const VisualExportExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = VisualExportExportFp(configuration);
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {VisualExportExportCreatePdfExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport(
            requestParameters: VisualExportExportCreatePdfExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createPdfExport(
                    requestParameters.workspaceId,
                    requestParameters.exportVisualExportRequest,
                    requestParameters.xGdcDebug,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {VisualExportExportGetExportedFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile(
            requestParameters: VisualExportExportGetExportedFileRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {VisualExportExportGetMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(
            requestParameters: VisualExportExportGetMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * VisualExportExport - interface
 * @export
 * @interface VisualExportExport
 */
export interface VisualExportExportInterface {
    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {VisualExportExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExportInterface
     */
    createPdfExport(
        requestParameters: VisualExportExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {VisualExportExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExportInterface
     */
    getExportedFile(
        requestParameters: VisualExportExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {VisualExportExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExportInterface
     */
    getMetadata(
        requestParameters: VisualExportExportGetMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createPdfExport operation in VisualExportExport.
 * @export
 * @interface VisualExportExportCreatePdfExportRequest
 */
export interface VisualExportExportCreatePdfExportRequest {
    /**
     *
     * @type {string}
     * @memberof VisualExportExportCreatePdfExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportVisualExportRequest}
     * @memberof VisualExportExportCreatePdfExport
     */
    readonly exportVisualExportRequest: ExportVisualExportRequest;

    /**
     *
     * @type {boolean}
     * @memberof VisualExportExportCreatePdfExport
     */
    readonly xGdcDebug?: boolean;
}

/**
 * Request parameters for getExportedFile operation in VisualExportExport.
 * @export
 * @interface VisualExportExportGetExportedFileRequest
 */
export interface VisualExportExportGetExportedFileRequest {
    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetExportedFile
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetExportedFile
     */
    readonly exportId: string;
}

/**
 * Request parameters for getMetadata operation in VisualExportExport.
 * @export
 * @interface VisualExportExportGetMetadataRequest
 */
export interface VisualExportExportGetMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetMetadata
     */
    readonly exportId: string;
}

/**
 * VisualExportExport - object-oriented interface
 * @export
 * @class VisualExportExport
 * @extends {BaseAPI}
 */
export class VisualExportExport extends BaseAPI implements VisualExportExportInterface {
    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {VisualExportExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExport
     */
    public createPdfExport(
        requestParameters: VisualExportExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return VisualExportExportFp(this.configuration)
            .createPdfExport(
                requestParameters.workspaceId,
                requestParameters.exportVisualExportRequest,
                requestParameters.xGdcDebug,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {VisualExportExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExport
     */
    public getExportedFile(
        requestParameters: VisualExportExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ) {
        return VisualExportExportFp(this.configuration)
            .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {VisualExportExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExport
     */
    public getMetadata(
        requestParameters: VisualExportExportGetMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return VisualExportExportFp(this.configuration)
            .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
