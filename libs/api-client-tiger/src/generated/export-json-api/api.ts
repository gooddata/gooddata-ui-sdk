// (C) 2025 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 * @export
 * @interface ExportAFM
 */
export interface ExportAFM {
    /**
     * Attributes to be used in the computation.
     * @type {Array<ExportAttributeItem>}
     * @memberof ExportAFM
     */
    attributes: Array<ExportAttributeItem>;
    /**
     * Various filter types to filter the execution result.
     * @type {Array<ExportFilterDefinition>}
     * @memberof ExportAFM
     */
    filters: Array<ExportFilterDefinition>;
    /**
     * Metrics to be computed.
     * @type {Array<ExportMeasureItem>}
     * @memberof ExportAFM
     */
    measures: Array<ExportMeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     * @type {Array<ExportMeasureItem>}
     * @memberof ExportAFM
     */
    auxMeasures?: Array<ExportMeasureItem>;
}
/**
 * A datetime filter specifying exact from and to values.
 * @export
 * @interface ExportAbsoluteDateFilter
 */
export interface ExportAbsoluteDateFilter {
    /**
     *
     * @type {ExportAbsoluteDateFilterAbsoluteDateFilter}
     * @memberof ExportAbsoluteDateFilter
     */
    absoluteDateFilter: ExportAbsoluteDateFilterAbsoluteDateFilter;
}
/**
 *
 * @export
 * @interface ExportAbsoluteDateFilterAbsoluteDateFilter
 */
export interface ExportAbsoluteDateFilterAbsoluteDateFilter {
    /**
     *
     * @type {string}
     * @memberof ExportAbsoluteDateFilterAbsoluteDateFilter
     */
    from: string;
    /**
     *
     * @type {string}
     * @memberof ExportAbsoluteDateFilterAbsoluteDateFilter
     */
    to: string;
    /**
     *
     * @type {string}
     * @memberof ExportAbsoluteDateFilterAbsoluteDateFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof ExportAbsoluteDateFilterAbsoluteDateFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {ExportAfmObjectIdentifierDataset}
     * @memberof ExportAbsoluteDateFilterAbsoluteDateFilter
     */
    dataset: ExportAfmObjectIdentifierDataset;
}
/**
 * @type ExportAbstractMeasureValueFilter
 * @export
 */
export type ExportAbstractMeasureValueFilter =
    | ExportComparisonMeasureValueFilter
    | ExportRangeMeasureValueFilter
    | ExportRankingFilter;

/**
 * @type ExportAfmIdentifier
 * Reference to the attribute label to which the filter should be applied.
 * @export
 */
export type ExportAfmIdentifier = ExportAfmLocalIdentifier | ExportAfmObjectIdentifier;

/**
 *
 * @export
 * @interface ExportAfmLocalIdentifier
 */
export interface ExportAfmLocalIdentifier {
    /**
     *
     * @type {string}
     * @memberof ExportAfmLocalIdentifier
     */
    localIdentifier: string;
}
/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 * @export
 * @interface ExportAfmObjectIdentifier
 */
export interface ExportAfmObjectIdentifier {
    /**
     *
     * @type {ExportAfmObjectIdentifierIdentifier}
     * @memberof ExportAfmObjectIdentifier
     */
    identifier: ExportAfmObjectIdentifierIdentifier;
}
/**
 * Reference to the date attribute to use.
 * @export
 * @interface ExportAfmObjectIdentifierAttribute
 */
export interface ExportAfmObjectIdentifierAttribute {
    /**
     *
     * @type {ExportAfmObjectIdentifierAttributeIdentifier}
     * @memberof ExportAfmObjectIdentifierAttribute
     */
    identifier: ExportAfmObjectIdentifierAttributeIdentifier;
}
/**
 *
 * @export
 * @interface ExportAfmObjectIdentifierAttributeIdentifier
 */
export interface ExportAfmObjectIdentifierAttributeIdentifier {
    /**
     *
     * @type {string}
     * @memberof ExportAfmObjectIdentifierAttributeIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ExportAfmObjectIdentifierAttributeIdentifier
     */
    type: ExportAfmObjectIdentifierAttributeIdentifierTypeEnum;
}

export const ExportAfmObjectIdentifierAttributeIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
} as const;

export type ExportAfmObjectIdentifierAttributeIdentifierTypeEnum =
    typeof ExportAfmObjectIdentifierAttributeIdentifierTypeEnum[keyof typeof ExportAfmObjectIdentifierAttributeIdentifierTypeEnum];

/**
 * Reference to the metric, fact or attribute object to use for the metric.
 * @export
 * @interface ExportAfmObjectIdentifierCore
 */
export interface ExportAfmObjectIdentifierCore {
    /**
     *
     * @type {ExportAfmObjectIdentifierCoreIdentifier}
     * @memberof ExportAfmObjectIdentifierCore
     */
    identifier: ExportAfmObjectIdentifierCoreIdentifier;
}
/**
 *
 * @export
 * @interface ExportAfmObjectIdentifierCoreIdentifier
 */
export interface ExportAfmObjectIdentifierCoreIdentifier {
    /**
     *
     * @type {string}
     * @memberof ExportAfmObjectIdentifierCoreIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ExportAfmObjectIdentifierCoreIdentifier
     */
    type: ExportAfmObjectIdentifierCoreIdentifierTypeEnum;
}

export const ExportAfmObjectIdentifierCoreIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
    LABEL: "label",
    FACT: "fact",
    METRIC: "metric",
} as const;

export type ExportAfmObjectIdentifierCoreIdentifierTypeEnum =
    typeof ExportAfmObjectIdentifierCoreIdentifierTypeEnum[keyof typeof ExportAfmObjectIdentifierCoreIdentifierTypeEnum];

/**
 * Reference to the date dataset to which the filter should be applied.
 * @export
 * @interface ExportAfmObjectIdentifierDataset
 */
export interface ExportAfmObjectIdentifierDataset {
    /**
     *
     * @type {ExportAfmObjectIdentifierDatasetIdentifier}
     * @memberof ExportAfmObjectIdentifierDataset
     */
    identifier: ExportAfmObjectIdentifierDatasetIdentifier;
}
/**
 *
 * @export
 * @interface ExportAfmObjectIdentifierDatasetIdentifier
 */
export interface ExportAfmObjectIdentifierDatasetIdentifier {
    /**
     *
     * @type {string}
     * @memberof ExportAfmObjectIdentifierDatasetIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ExportAfmObjectIdentifierDatasetIdentifier
     */
    type: ExportAfmObjectIdentifierDatasetIdentifierTypeEnum;
}

export const ExportAfmObjectIdentifierDatasetIdentifierTypeEnum = {
    DATASET: "dataset",
} as const;

export type ExportAfmObjectIdentifierDatasetIdentifierTypeEnum =
    typeof ExportAfmObjectIdentifierDatasetIdentifierTypeEnum[keyof typeof ExportAfmObjectIdentifierDatasetIdentifierTypeEnum];

/**
 *
 * @export
 * @interface ExportAfmObjectIdentifierIdentifier
 */
export interface ExportAfmObjectIdentifierIdentifier {
    /**
     *
     * @type {string}
     * @memberof ExportAfmObjectIdentifierIdentifier
     */
    type: ExportAfmObjectIdentifierIdentifierTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ExportAfmObjectIdentifierIdentifier
     */
    id: string;
}

export const ExportAfmObjectIdentifierIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
} as const;

export type ExportAfmObjectIdentifierIdentifierTypeEnum =
    typeof ExportAfmObjectIdentifierIdentifierTypeEnum[keyof typeof ExportAfmObjectIdentifierIdentifierTypeEnum];

/**
 *
 * @export
 * @interface ExportAfmObjectIdentifierLabel
 */
export interface ExportAfmObjectIdentifierLabel {
    /**
     *
     * @type {ExportAfmObjectIdentifierLabelIdentifier}
     * @memberof ExportAfmObjectIdentifierLabel
     */
    identifier: ExportAfmObjectIdentifierLabelIdentifier;
}
/**
 *
 * @export
 * @interface ExportAfmObjectIdentifierLabelIdentifier
 */
export interface ExportAfmObjectIdentifierLabelIdentifier {
    /**
     *
     * @type {string}
     * @memberof ExportAfmObjectIdentifierLabelIdentifier
     */
    type: ExportAfmObjectIdentifierLabelIdentifierTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ExportAfmObjectIdentifierLabelIdentifier
     */
    id: string;
}

export const ExportAfmObjectIdentifierLabelIdentifierTypeEnum = {
    LABEL: "label",
} as const;

export type ExportAfmObjectIdentifierLabelIdentifierTypeEnum =
    typeof ExportAfmObjectIdentifierLabelIdentifierTypeEnum[keyof typeof ExportAfmObjectIdentifierLabelIdentifierTypeEnum];

/**
 * Metric representing arithmetics between other metrics.
 * @export
 * @interface ExportArithmeticMeasureDefinition
 */
export interface ExportArithmeticMeasureDefinition {
    /**
     *
     * @type {ExportArithmeticMeasureDefinitionArithmeticMeasure}
     * @memberof ExportArithmeticMeasureDefinition
     */
    arithmeticMeasure: ExportArithmeticMeasureDefinitionArithmeticMeasure;
}
/**
 *
 * @export
 * @interface ExportArithmeticMeasureDefinitionArithmeticMeasure
 */
export interface ExportArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of metrics to apply arithmetic operation by chosen operator.
     * @type {Array<ExportAfmLocalIdentifier>}
     * @memberof ExportArithmeticMeasureDefinitionArithmeticMeasure
     */
    measureIdentifiers: Array<ExportAfmLocalIdentifier>;
    /**
     * Arithmetic operator describing operation between metrics.
     * @type {string}
     * @memberof ExportArithmeticMeasureDefinitionArithmeticMeasure
     */
    operator: ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

export const ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum = {
    SUM: "SUM",
    DIFFERENCE: "DIFFERENCE",
    MULTIPLICATION: "MULTIPLICATION",
    RATIO: "RATIO",
    CHANGE: "CHANGE",
} as const;

export type ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum =
    typeof ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum[keyof typeof ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum];

/**
 * @type ExportAttributeElements
 * @export
 */
export type ExportAttributeElements = ExportAttributeElementsByRef | ExportAttributeElementsByValue;

/**
 *
 * @export
 * @interface ExportAttributeElementsByRef
 */
export interface ExportAttributeElementsByRef {
    /**
     * List of attribute elements by reference
     * @type {Array<string>}
     * @memberof ExportAttributeElementsByRef
     */
    uris: Array<string>;
}
/**
 *
 * @export
 * @interface ExportAttributeElementsByValue
 */
export interface ExportAttributeElementsByValue {
    /**
     * List of attribute elements by value
     * @type {Array<string>}
     * @memberof ExportAttributeElementsByValue
     */
    values: Array<string>;
}
/**
 * @type ExportAttributeFilter
 * Abstract filter definition type attributes
 * @export
 */
export type ExportAttributeFilter = ExportNegativeAttributeFilter | ExportPositiveAttributeFilter;

/**
 *
 * @export
 * @interface ExportAttributeFilterByDate
 */
export interface ExportAttributeFilterByDate {
    /**
     *
     * @type {string}
     * @memberof ExportAttributeFilterByDate
     */
    filterLocalIdentifier: string;
    /**
     *
     * @type {boolean}
     * @memberof ExportAttributeFilterByDate
     */
    isCommonDate: boolean;
}
/**
 * Filter on specific set of label values.
 * @export
 * @interface ExportAttributeFilterElements
 */
export interface ExportAttributeFilterElements {
    /**
     * Set of label values.
     * @type {Array<string>}
     * @memberof ExportAttributeFilterElements
     */
    values: Array<string>;
}
/**
 *
 * @export
 * @interface ExportAttributeFilterParent
 */
export interface ExportAttributeFilterParent {
    /**
     *
     * @type {string}
     * @memberof ExportAttributeFilterParent
     */
    filterLocalIdentifier: string;
    /**
     *
     * @type {ExportOver}
     * @memberof ExportAttributeFilterParent
     */
    over: ExportOver;
}
/**
 *
 * @export
 * @interface ExportAttributeItem
 */
export interface ExportAttributeItem {
    /**
     * Local identifier of the attribute. This can be used to reference the attribute in other parts of the execution definition.
     * @type {string}
     * @memberof ExportAttributeItem
     */
    localIdentifier: string;
    /**
     *
     * @type {ExportAfmObjectIdentifierLabel}
     * @memberof ExportAttributeItem
     */
    label: ExportAfmObjectIdentifierLabel;
    /**
     * Indicates whether to show all values of given attribute even if the data bound to those values is not available.
     * @type {boolean}
     * @memberof ExportAttributeItem
     */
    showAllValues?: boolean;
}
/**
 * Filter the result by comparing specified metric to given constant value, using given comparison operator.
 * @export
 * @interface ExportComparisonMeasureValueFilter
 */
export interface ExportComparisonMeasureValueFilter {
    /**
     *
     * @type {ExportComparisonMeasureValueFilterComparisonMeasureValueFilter}
     * @memberof ExportComparisonMeasureValueFilter
     */
    comparisonMeasureValueFilter: ExportComparisonMeasureValueFilterComparisonMeasureValueFilter;
}
/**
 *
 * @export
 * @interface ExportComparisonMeasureValueFilterComparisonMeasureValueFilter
 */
export interface ExportComparisonMeasureValueFilterComparisonMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     * @type {Array<ExportAfmIdentifier>}
     * @memberof ExportComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    dimensionality?: Array<ExportAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     * @type {number}
     * @memberof ExportComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof ExportComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    operator: ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof ExportComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    value: number;
    /**
     *
     * @type {string}
     * @memberof ExportComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof ExportComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {ExportAfmIdentifier}
     * @memberof ExportComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    measure: ExportAfmIdentifier;
}

export const ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum = {
    GREATER_THAN: "GREATER_THAN",
    GREATER_THAN_OR_EQUAL_TO: "GREATER_THAN_OR_EQUAL_TO",
    LESS_THAN: "LESS_THAN",
    LESS_THAN_OR_EQUAL_TO: "LESS_THAN_OR_EQUAL_TO",
    EQUAL_TO: "EQUAL_TO",
    NOT_EQUAL_TO: "NOT_EQUAL_TO",
} as const;

export type ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum =
    typeof ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum[keyof typeof ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum];

/**
 * Custom label object override.
 * @export
 * @interface ExportCustomLabel
 */
export interface ExportCustomLabel {
    /**
     * Override value.
     * @type {string}
     * @memberof ExportCustomLabel
     */
    title: string;
}
/**
 * Custom metric object override.
 * @export
 * @interface ExportCustomMetric
 */
export interface ExportCustomMetric {
    /**
     * Metric title override.
     * @type {string}
     * @memberof ExportCustomMetric
     */
    title: string;
    /**
     * Format override.
     * @type {string}
     * @memberof ExportCustomMetric
     */
    format: string;
}
/**
 * Custom cell value overrides (IDs will be replaced with specified values).
 * @export
 * @interface ExportCustomOverride
 */
export interface ExportCustomOverride {
    /**
     * Map of CustomLabels with keys used as placeholders in document.
     * @type {{ [key: string]: ExportCustomLabel; }}
     * @memberof ExportCustomOverride
     */
    labels?: { [key: string]: ExportCustomLabel };
    /**
     * Map of CustomMetrics with keys used as placeholders in document.
     * @type {{ [key: string]: ExportCustomMetric; }}
     * @memberof ExportCustomOverride
     */
    metrics?: { [key: string]: ExportCustomMetric };
}
/**
 *
 * @export
 * @interface ExportDashboardAttributeFilter
 */
export interface ExportDashboardAttributeFilter {
    /**
     *
     * @type {ExportDashboardAttributeFilterAttributeFilter}
     * @memberof ExportDashboardAttributeFilter
     */
    attributeFilter: ExportDashboardAttributeFilterAttributeFilter;
}
/**
 *
 * @export
 * @interface ExportDashboardAttributeFilterAttributeFilter
 */
export interface ExportDashboardAttributeFilterAttributeFilter {
    /**
     *
     * @type {ExportIdentifierRef}
     * @memberof ExportDashboardAttributeFilterAttributeFilter
     */
    displayForm: ExportIdentifierRef;
    /**
     *
     * @type {boolean}
     * @memberof ExportDashboardAttributeFilterAttributeFilter
     */
    negativeSelection: boolean;
    /**
     *
     * @type {ExportAttributeElements}
     * @memberof ExportDashboardAttributeFilterAttributeFilter
     */
    attributeElements: ExportAttributeElements;
    /**
     *
     * @type {Array<ExportAttributeFilterParent>}
     * @memberof ExportDashboardAttributeFilterAttributeFilter
     */
    filterElementsBy?: Array<ExportAttributeFilterParent>;
    /**
     *
     * @type {Array<ExportAttributeFilterByDate>}
     * @memberof ExportDashboardAttributeFilterAttributeFilter
     */
    filterElementsByDate?: Array<ExportAttributeFilterByDate>;
    /**
     *
     * @type {Array<ExportIdentifierRef>}
     * @memberof ExportDashboardAttributeFilterAttributeFilter
     */
    validateElementsBy?: Array<ExportIdentifierRef>;
    /**
     *
     * @type {string}
     * @memberof ExportDashboardAttributeFilterAttributeFilter
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof ExportDashboardAttributeFilterAttributeFilter
     */
    selectionMode?: ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum;
    /**
     *
     * @type {string}
     * @memberof ExportDashboardAttributeFilterAttributeFilter
     */
    localIdentifier?: string;
}

export const ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum = {
    SINGLE: "single",
    MULTI: "multi",
} as const;

export type ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum =
    typeof ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum[keyof typeof ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum];

/**
 *
 * @export
 * @interface ExportDashboardDateFilter
 */
export interface ExportDashboardDateFilter {
    /**
     *
     * @type {ExportDashboardDateFilterDateFilter}
     * @memberof ExportDashboardDateFilter
     */
    dateFilter: ExportDashboardDateFilterDateFilter;
}
/**
 *
 * @export
 * @interface ExportDashboardDateFilterDateFilter
 */
export interface ExportDashboardDateFilterDateFilter {
    /**
     *
     * @type {string}
     * @memberof ExportDashboardDateFilterDateFilter
     */
    type: ExportDashboardDateFilterDateFilterTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ExportDashboardDateFilterDateFilter
     */
    granularity: ExportDashboardDateFilterDateFilterGranularityEnum;
    /**
     *
     * @type {string | number}
     * @memberof ExportDashboardDateFilterDateFilter
     */
    from?: string | number;
    /**
     *
     * @type {string | number}
     * @memberof ExportDashboardDateFilterDateFilter
     */
    to?: string | number;
    /**
     *
     * @type {ExportIdentifierRef}
     * @memberof ExportDashboardDateFilterDateFilter
     */
    dataSet?: ExportIdentifierRef;
    /**
     *
     * @type {ExportIdentifierRef}
     * @memberof ExportDashboardDateFilterDateFilter
     */
    attribute?: ExportIdentifierRef;
    /**
     *
     * @type {string}
     * @memberof ExportDashboardDateFilterDateFilter
     */
    localIdentifier?: string;
}

export const ExportDashboardDateFilterDateFilterTypeEnum = {
    RELATIVE: "relative",
    ABSOLUTE: "absolute",
} as const;

export type ExportDashboardDateFilterDateFilterTypeEnum =
    typeof ExportDashboardDateFilterDateFilterTypeEnum[keyof typeof ExportDashboardDateFilterDateFilterTypeEnum];
export const ExportDashboardDateFilterDateFilterGranularityEnum = {
    ALL_TIME_GRANULARITY: "ALL_TIME_GRANULARITY",
    GDC_TIME_YEAR: "GDC.time.year",
    GDC_TIME_WEEK_US: "GDC.time.week_us",
    GDC_TIME_WEEK_IN_YEAR: "GDC.time.week_in_year",
    GDC_TIME_WEEK_IN_QUARTER: "GDC.time.week_in_quarter",
    GDC_TIME_WEEK: "GDC.time.week",
    GDC_TIME_EUWEEK_IN_YEAR: "GDC.time.euweek_in_year",
    GDC_TIME_EUWEEK_IN_QUARTER: "GDC.time.euweek_in_quarter",
    GDC_TIME_QUARTER: "GDC.time.quarter",
    GDC_TIME_QUARTER_IN_YEAR: "GDC.time.quarter_in_year",
    GDC_TIME_MONTH: "GDC.time.month",
    GDC_TIME_MONTH_IN_QUARTER: "GDC.time.month_in_quarter",
    GDC_TIME_MONTH_IN_YEAR: "GDC.time.month_in_year",
    GDC_TIME_DAY_IN_YEAR: "GDC.time.day_in_year",
    GDC_TIME_DAY_IN_QUARTER: "GDC.time.day_in_quarter",
    GDC_TIME_DAY_IN_MONTH: "GDC.time.day_in_month",
    GDC_TIME_DAY_IN_WEEK: "GDC.time.day_in_week",
    GDC_TIME_DAY_IN_EUWEEK: "GDC.time.day_in_euweek",
    GDC_TIME_DATE: "GDC.time.date",
    GDC_TIME_HOUR: "GDC.time.hour",
    GDC_TIME_HOUR_IN_DAY: "GDC.time.hour_in_day",
    GDC_TIME_MINUTE: "GDC.time.minute",
    GDC_TIME_MINUTE_IN_HOUR: "GDC.time.minute_in_hour",
} as const;

export type ExportDashboardDateFilterDateFilterGranularityEnum =
    typeof ExportDashboardDateFilterDateFilterGranularityEnum[keyof typeof ExportDashboardDateFilterDateFilterGranularityEnum];

/**
 * Additional settings.
 * @export
 * @interface ExportDashboardExportSettings
 */
export interface ExportDashboardExportSettings {
    /**
     * If true, the export will contain the information about the exported date and dashboard filters.
     * @type {boolean}
     * @memberof ExportDashboardExportSettings
     */
    exportInfo?: boolean;
    /**
     * Merge equal headers in neighbouring cells. Used for [XLSX] format only.
     * @type {boolean}
     * @memberof ExportDashboardExportSettings
     */
    mergeHeaders?: boolean;
}
/**
 * @type ExportDashboardFilter
 * @export
 */
export type ExportDashboardFilter = ExportDashboardAttributeFilter | ExportDashboardDateFilter;

/**
 * Export request object describing the export properties for dashboard tabular exports.
 * @export
 * @interface ExportDashboardTabularExportRequest
 */
export interface ExportDashboardTabularExportRequest {
    /**
     * Requested tabular export type.
     * @type {string}
     * @memberof ExportDashboardTabularExportRequest
     */
    format: ExportDashboardTabularExportRequestFormatEnum;
    /**
     * Filename of downloaded file without extension.
     * @type {string}
     * @memberof ExportDashboardTabularExportRequest
     */
    fileName: string;
    /**
     * List of filters that will be used instead of the default dashboard filters.
     * @type {Array<ExportDashboardFilter>}
     * @memberof ExportDashboardTabularExportRequest
     */
    dashboardFiltersOverride?: Array<ExportDashboardFilter>;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     * @type {Array<string>}
     * @memberof ExportDashboardTabularExportRequest
     */
    widgetIds?: Array<string>;
    /**
     *
     * @type {ExportDashboardExportSettings}
     * @memberof ExportDashboardTabularExportRequest
     */
    settings?: ExportDashboardExportSettings;
}

export const ExportDashboardTabularExportRequestFormatEnum = {
    XLSX: "XLSX",
} as const;

export type ExportDashboardTabularExportRequestFormatEnum =
    typeof ExportDashboardTabularExportRequestFormatEnum[keyof typeof ExportDashboardTabularExportRequestFormatEnum];

/**
 * @type ExportDateFilter
 * Abstract filter definition type for dates.
 * @export
 */
export type ExportDateFilter = ExportAbsoluteDateFilter | ExportRelativeDateFilter;

/**
 *
 * @export
 * @interface ExportDateValue
 */
export interface ExportDateValue {
    /**
     *
     * @type {string}
     * @memberof ExportDateValue
     */
    value: string;
}
/**
 * Various settings affecting the process of AFM execution or its result
 * @export
 * @interface ExportExecutionSettings
 */
export interface ExportExecutionSettings {
    /**
     * Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     * @type {number}
     * @memberof ExportExecutionSettings
     */
    dataSamplingPercentage?: number;
    /**
     * Specifies the timestamp of the execution from which relative filters are resolved. If not set, the current time is used.
     * @type {string}
     * @memberof ExportExecutionSettings
     */
    timestamp?: string;
}
/**
 *
 * @export
 * @interface ExportExportResponse
 */
export interface ExportExportResponse {
    /**
     *
     * @type {string}
     * @memberof ExportExportResponse
     */
    exportResult: string;
}
/**
 * @type ExportFilterDefinition
 * Abstract filter definition type
 * @export
 */
export type ExportFilterDefinition =
    | ExportAbsoluteDateFilter
    | ExportComparisonMeasureValueFilter
    | ExportInlineFilterDefinition
    | ExportNegativeAttributeFilter
    | ExportPositiveAttributeFilter
    | ExportRangeMeasureValueFilter
    | ExportRankingFilter
    | ExportRelativeDateFilter;

/**
 * @type ExportFilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple metric.
 * @export
 */
export type ExportFilterDefinitionForSimpleMeasure = ExportAttributeFilter | ExportDateFilter;

/**
 *
 * @export
 * @interface ExportIdentifierRef
 */
export interface ExportIdentifierRef {
    /**
     *
     * @type {ExportIdentifierRefIdentifier}
     * @memberof ExportIdentifierRef
     */
    identifier?: ExportIdentifierRefIdentifier;
}
/**
 *
 * @export
 * @interface ExportIdentifierRefIdentifier
 */
export interface ExportIdentifierRefIdentifier {
    /**
     *
     * @type {string}
     * @memberof ExportIdentifierRefIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ExportIdentifierRefIdentifier
     */
    type: ExportIdentifierRefIdentifierTypeEnum;
}

export const ExportIdentifierRefIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    ATTRIBUTE_HIERARCHY: "attributeHierarchy",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    USER_DATA_FILTER: "userDataFilter",
    EXPORT_DEFINITION: "exportDefinition",
    AUTOMATION: "automation",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
    WORKSPACE_SETTINGS: "workspaceSettings",
    CUSTOM_APPLICATION_SETTING: "customApplicationSetting",
    WORKSPACE_DATA_FILTER: "workspaceDataFilter",
    WORKSPACE_DATA_FILTER_SETTING: "workspaceDataFilterSetting",
    FILTER_VIEW: "filterView",
} as const;

export type ExportIdentifierRefIdentifierTypeEnum =
    typeof ExportIdentifierRefIdentifierTypeEnum[keyof typeof ExportIdentifierRefIdentifierTypeEnum];

/**
 * Export request object describing the export properties and metadata for image exports.
 * @export
 * @interface ExportImageExportRequest
 */
export interface ExportImageExportRequest {
    /**
     * Requested resulting file type.
     * @type {string}
     * @memberof ExportImageExportRequest
     */
    format: ExportImageExportRequestFormatEnum;
    /**
     * File name to be used for retrieving the image document.
     * @type {string}
     * @memberof ExportImageExportRequest
     */
    fileName: string;
    /**
     * Dashboard identifier
     * @type {string}
     * @memberof ExportImageExportRequest
     */
    dashboardId: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     * @type {Array<string>}
     * @memberof ExportImageExportRequest
     */
    widgetIds: Array<string>;
    /**
     * Metadata definition in free-form JSON format.
     * @type {object}
     * @memberof ExportImageExportRequest
     */
    metadata?: object | null;
}

export const ExportImageExportRequestFormatEnum = {
    PNG: "PNG",
} as const;

export type ExportImageExportRequestFormatEnum =
    typeof ExportImageExportRequestFormatEnum[keyof typeof ExportImageExportRequestFormatEnum];

/**
 * Filter in form of direct MAQL query.
 * @export
 * @interface ExportInlineFilterDefinition
 */
export interface ExportInlineFilterDefinition {
    /**
     *
     * @type {ExportInlineFilterDefinitionInline}
     * @memberof ExportInlineFilterDefinition
     */
    inline: ExportInlineFilterDefinitionInline;
}
/**
 *
 * @export
 * @interface ExportInlineFilterDefinitionInline
 */
export interface ExportInlineFilterDefinitionInline {
    /**
     * MAQL query representing the filter.
     * @type {string}
     * @memberof ExportInlineFilterDefinitionInline
     */
    filter: string;
    /**
     *
     * @type {string}
     * @memberof ExportInlineFilterDefinitionInline
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof ExportInlineFilterDefinitionInline
     */
    applyOnResult?: boolean;
}
/**
 * Metric defined by the raw MAQL query.
 * @export
 * @interface ExportInlineMeasureDefinition
 */
export interface ExportInlineMeasureDefinition {
    /**
     *
     * @type {ExportInlineMeasureDefinitionInline}
     * @memberof ExportInlineMeasureDefinition
     */
    inline: ExportInlineMeasureDefinitionInline;
}
/**
 *
 * @export
 * @interface ExportInlineMeasureDefinitionInline
 */
export interface ExportInlineMeasureDefinitionInline {
    /**
     * MAQL query defining the metric.
     * @type {string}
     * @memberof ExportInlineMeasureDefinitionInline
     */
    maql: string;
}
/**
 *
 * @export
 * @interface ExportInlineResponse202
 */
export interface ExportInlineResponse202 {
    /**
     *
     * @type {number}
     * @memberof ExportInlineResponse202
     */
    short?: number;
    /**
     *
     * @type {string}
     * @memberof ExportInlineResponse202
     */
    char?: string;
    /**
     *
     * @type {number}
     * @memberof ExportInlineResponse202
     */
    int?: number;
    /**
     *
     * @type {number}
     * @memberof ExportInlineResponse202
     */
    long?: number;
    /**
     *
     * @type {number}
     * @memberof ExportInlineResponse202
     */
    float?: number;
    /**
     *
     * @type {number}
     * @memberof ExportInlineResponse202
     */
    double?: number;
    /**
     *
     * @type {boolean}
     * @memberof ExportInlineResponse202
     */
    direct?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof ExportInlineResponse202
     */
    readOnly?: boolean;
}
/**
 * @type ExportMeasureDefinition
 * Abstract metric definition type
 * @export
 */
export type ExportMeasureDefinition =
    | ExportArithmeticMeasureDefinition
    | ExportInlineMeasureDefinition
    | ExportPopMeasureDefinition
    | ExportSimpleMeasureDefinition;

/**
 * Metric is a quantity that is calculated from the data.
 * @export
 * @interface ExportMeasureItem
 */
export interface ExportMeasureItem {
    /**
     * Local identifier of the metric. This can be used to reference the metric in other parts of the execution definition.
     * @type {string}
     * @memberof ExportMeasureItem
     */
    localIdentifier: string;
    /**
     *
     * @type {ExportMeasureDefinition}
     * @memberof ExportMeasureItem
     */
    definition: ExportMeasureDefinition;
}
/**
 * @type ExportMeasureValueFilter
 * Abstract filter definition type filtering by the value of the metric.
 * @export
 */
export type ExportMeasureValueFilter = ExportComparisonMeasureValueFilter | ExportRangeMeasureValueFilter;

/**
 * Filter able to limit element values by label and related selected negated elements.
 * @export
 * @interface ExportNegativeAttributeFilter
 */
export interface ExportNegativeAttributeFilter {
    /**
     *
     * @type {ExportNegativeAttributeFilterNegativeAttributeFilter}
     * @memberof ExportNegativeAttributeFilter
     */
    negativeAttributeFilter: ExportNegativeAttributeFilterNegativeAttributeFilter;
}
/**
 *
 * @export
 * @interface ExportNegativeAttributeFilterNegativeAttributeFilter
 */
export interface ExportNegativeAttributeFilterNegativeAttributeFilter {
    /**
     *
     * @type {ExportAttributeFilterElements}
     * @memberof ExportNegativeAttributeFilterNegativeAttributeFilter
     */
    notIn: ExportAttributeFilterElements;
    /**
     *
     * @type {string}
     * @memberof ExportNegativeAttributeFilterNegativeAttributeFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof ExportNegativeAttributeFilterNegativeAttributeFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {ExportAfmIdentifier}
     * @memberof ExportNegativeAttributeFilterNegativeAttributeFilter
     */
    label: ExportAfmIdentifier;
}
/**
 *
 * @export
 * @interface ExportOver
 */
export interface ExportOver {
    /**
     *
     * @type {Array<ExportIdentifierRef>}
     * @memberof ExportOver
     */
    attributes: Array<ExportIdentifierRef>;
}
/**
 * Custom CSS styles for the table. (PDF, HTML)
 * @export
 * @interface ExportPdfTableStyle
 */
export interface ExportPdfTableStyle {
    /**
     * CSS selector where to apply given properties.
     * @type {string}
     * @memberof ExportPdfTableStyle
     */
    selector: string;
    /**
     * List of CSS properties.
     * @type {Array<ExportPdfTableStyleProperty>}
     * @memberof ExportPdfTableStyle
     */
    properties?: Array<ExportPdfTableStyleProperty>;
}
/**
 * CSS property.
 * @export
 * @interface ExportPdfTableStyleProperty
 */
export interface ExportPdfTableStyleProperty {
    /**
     * CSS property key.
     * @type {string}
     * @memberof ExportPdfTableStyleProperty
     */
    key: string;
    /**
     * CSS property value.
     * @type {string}
     * @memberof ExportPdfTableStyleProperty
     */
    value: string;
}
/**
 * Combination of the date data set to use and how many periods ago to calculate the previous period for.
 * @export
 * @interface ExportPopDataset
 */
export interface ExportPopDataset {
    /**
     *
     * @type {ExportAfmObjectIdentifierDataset}
     * @memberof ExportPopDataset
     */
    dataset: ExportAfmObjectIdentifierDataset;
    /**
     * Number of periods ago to calculate the previous period for.
     * @type {number}
     * @memberof ExportPopDataset
     */
    periodsAgo: number;
}
/**
 * Previous period type of metric.
 * @export
 * @interface ExportPopDatasetMeasureDefinition
 */
export interface ExportPopDatasetMeasureDefinition {
    /**
     *
     * @type {ExportPopDatasetMeasureDefinitionPreviousPeriodMeasure}
     * @memberof ExportPopDatasetMeasureDefinition
     */
    previousPeriodMeasure: ExportPopDatasetMeasureDefinitionPreviousPeriodMeasure;
}
/**
 *
 * @export
 * @interface ExportPopDatasetMeasureDefinitionPreviousPeriodMeasure
 */
export interface ExportPopDatasetMeasureDefinitionPreviousPeriodMeasure {
    /**
     *
     * @type {ExportAfmLocalIdentifier}
     * @memberof ExportPopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    measureIdentifier: ExportAfmLocalIdentifier;
    /**
     * Specification of which date data sets to use for determining the period to calculate the previous period for.
     * @type {Array<ExportPopDataset>}
     * @memberof ExportPopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    dateDatasets: Array<ExportPopDataset>;
}
/**
 * Combination of the date attribute to use and how many periods ago to calculate the PoP for.
 * @export
 * @interface ExportPopDate
 */
export interface ExportPopDate {
    /**
     *
     * @type {ExportAfmObjectIdentifierAttribute}
     * @memberof ExportPopDate
     */
    attribute: ExportAfmObjectIdentifierAttribute;
    /**
     * Number of periods ago to calculate the previous period for.
     * @type {number}
     * @memberof ExportPopDate
     */
    periodsAgo: number;
}
/**
 * Period over period type of metric.
 * @export
 * @interface ExportPopDateMeasureDefinition
 */
export interface ExportPopDateMeasureDefinition {
    /**
     *
     * @type {ExportPopDateMeasureDefinitionOverPeriodMeasure}
     * @memberof ExportPopDateMeasureDefinition
     */
    overPeriodMeasure: ExportPopDateMeasureDefinitionOverPeriodMeasure;
}
/**
 *
 * @export
 * @interface ExportPopDateMeasureDefinitionOverPeriodMeasure
 */
export interface ExportPopDateMeasureDefinitionOverPeriodMeasure {
    /**
     *
     * @type {ExportAfmLocalIdentifier}
     * @memberof ExportPopDateMeasureDefinitionOverPeriodMeasure
     */
    measureIdentifier: ExportAfmLocalIdentifier;
    /**
     * Attributes to use for determining the period to calculate the PoP for.
     * @type {Array<ExportPopDate>}
     * @memberof ExportPopDateMeasureDefinitionOverPeriodMeasure
     */
    dateAttributes: Array<ExportPopDate>;
}
/**
 * @type ExportPopMeasureDefinition
 * @export
 */
export type ExportPopMeasureDefinition = ExportPopDatasetMeasureDefinition | ExportPopDateMeasureDefinition;

/**
 * Filter able to limit element values by label and related selected elements.
 * @export
 * @interface ExportPositiveAttributeFilter
 */
export interface ExportPositiveAttributeFilter {
    /**
     *
     * @type {ExportPositiveAttributeFilterPositiveAttributeFilter}
     * @memberof ExportPositiveAttributeFilter
     */
    positiveAttributeFilter: ExportPositiveAttributeFilterPositiveAttributeFilter;
}
/**
 *
 * @export
 * @interface ExportPositiveAttributeFilterPositiveAttributeFilter
 */
export interface ExportPositiveAttributeFilterPositiveAttributeFilter {
    /**
     *
     * @type {ExportAttributeFilterElements}
     * @memberof ExportPositiveAttributeFilterPositiveAttributeFilter
     */
    in: ExportAttributeFilterElements;
    /**
     *
     * @type {string}
     * @memberof ExportPositiveAttributeFilterPositiveAttributeFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof ExportPositiveAttributeFilterPositiveAttributeFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {ExportAfmIdentifier}
     * @memberof ExportPositiveAttributeFilterPositiveAttributeFilter
     */
    label: ExportAfmIdentifier;
}
/**
 * Filter the result by comparing specified metric to given range of values.
 * @export
 * @interface ExportRangeMeasureValueFilter
 */
export interface ExportRangeMeasureValueFilter {
    /**
     *
     * @type {ExportRangeMeasureValueFilterRangeMeasureValueFilter}
     * @memberof ExportRangeMeasureValueFilter
     */
    rangeMeasureValueFilter: ExportRangeMeasureValueFilterRangeMeasureValueFilter;
}
/**
 *
 * @export
 * @interface ExportRangeMeasureValueFilterRangeMeasureValueFilter
 */
export interface ExportRangeMeasureValueFilterRangeMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     * @type {Array<ExportAfmIdentifier>}
     * @memberof ExportRangeMeasureValueFilterRangeMeasureValueFilter
     */
    dimensionality?: Array<ExportAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     * @type {number}
     * @memberof ExportRangeMeasureValueFilterRangeMeasureValueFilter
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof ExportRangeMeasureValueFilterRangeMeasureValueFilter
     */
    operator: ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof ExportRangeMeasureValueFilterRangeMeasureValueFilter
     */
    from: number;
    /**
     *
     * @type {number}
     * @memberof ExportRangeMeasureValueFilterRangeMeasureValueFilter
     */
    to: number;
    /**
     *
     * @type {string}
     * @memberof ExportRangeMeasureValueFilterRangeMeasureValueFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof ExportRangeMeasureValueFilterRangeMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {ExportAfmIdentifier}
     * @memberof ExportRangeMeasureValueFilterRangeMeasureValueFilter
     */
    measure: ExportAfmIdentifier;
}

export const ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum = {
    BETWEEN: "BETWEEN",
    NOT_BETWEEN: "NOT_BETWEEN",
} as const;

export type ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum =
    typeof ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum[keyof typeof ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum];

/**
 * Filter the result on top/bottom N values according to given metric(s).
 * @export
 * @interface ExportRankingFilter
 */
export interface ExportRankingFilter {
    /**
     *
     * @type {ExportRankingFilterRankingFilter}
     * @memberof ExportRankingFilter
     */
    rankingFilter: ExportRankingFilterRankingFilter;
}
/**
 *
 * @export
 * @interface ExportRankingFilterRankingFilter
 */
export interface ExportRankingFilterRankingFilter {
    /**
     * References to the attributes to be used when filtering.
     * @type {Array<ExportAfmIdentifier>}
     * @memberof ExportRankingFilterRankingFilter
     */
    dimensionality?: Array<ExportAfmIdentifier>;
    /**
     * References to the metrics to be used when filtering.
     * @type {Array<ExportAfmIdentifier>}
     * @memberof ExportRankingFilterRankingFilter
     */
    measures: Array<ExportAfmIdentifier>;
    /**
     * The type of ranking to use, TOP or BOTTOM.
     * @type {string}
     * @memberof ExportRankingFilterRankingFilter
     */
    operator: ExportRankingFilterRankingFilterOperatorEnum;
    /**
     * Number of top/bottom values to filter.
     * @type {number}
     * @memberof ExportRankingFilterRankingFilter
     */
    value: number;
    /**
     *
     * @type {string}
     * @memberof ExportRankingFilterRankingFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof ExportRankingFilterRankingFilter
     */
    applyOnResult?: boolean;
}

export const ExportRankingFilterRankingFilterOperatorEnum = {
    TOP: "TOP",
    BOTTOM: "BOTTOM",
} as const;

export type ExportRankingFilterRankingFilterOperatorEnum =
    typeof ExportRankingFilterRankingFilterOperatorEnum[keyof typeof ExportRankingFilterRankingFilterOperatorEnum];

/**
 * Custom label object override.
 * @export
 * @interface ExportRawCustomLabel
 */
export interface ExportRawCustomLabel {
    /**
     * Override value.
     * @type {string}
     * @memberof ExportRawCustomLabel
     */
    title: string;
}
/**
 * Custom metric object override.
 * @export
 * @interface ExportRawCustomMetric
 */
export interface ExportRawCustomMetric {
    /**
     * Metric title override.
     * @type {string}
     * @memberof ExportRawCustomMetric
     */
    title: string;
}
/**
 * Custom cell value overrides (IDs will be replaced with specified values).
 * @export
 * @interface ExportRawCustomOverride
 */
export interface ExportRawCustomOverride {
    /**
     * Map of CustomLabels with keys used as placeholders in export result.
     * @type {{ [key: string]: ExportRawCustomLabel; }}
     * @memberof ExportRawCustomOverride
     */
    labels?: { [key: string]: ExportRawCustomLabel };
    /**
     * Map of CustomMetrics with keys used as placeholders in export result.
     * @type {{ [key: string]: ExportRawCustomMetric; }}
     * @memberof ExportRawCustomOverride
     */
    metrics?: { [key: string]: ExportRawCustomMetric };
}
/**
 * Export request object describing the export properties and overrides for raw exports.
 * @export
 * @interface ExportRawExportRequest
 */
export interface ExportRawExportRequest {
    /**
     * Requested resulting file type.
     * @type {string}
     * @memberof ExportRawExportRequest
     */
    format: ExportRawExportRequestFormatEnum;
    /**
     *
     * @type {ExportAFM}
     * @memberof ExportRawExportRequest
     */
    execution: ExportAFM;
    /**
     * Filename of downloaded file without extension.
     * @type {string}
     * @memberof ExportRawExportRequest
     */
    fileName: string;
    /**
     *
     * @type {ExportRawCustomOverride}
     * @memberof ExportRawExportRequest
     */
    customOverride?: ExportRawCustomOverride;
    /**
     *
     * @type {ExportExecutionSettings}
     * @memberof ExportRawExportRequest
     */
    executionSettings?: ExportExecutionSettings;
}

export const ExportRawExportRequestFormatEnum = {
    ARROW_FILE: "ARROW_FILE",
    ARROW_STREAM: "ARROW_STREAM",
    CSV: "CSV",
} as const;

export type ExportRawExportRequestFormatEnum =
    typeof ExportRawExportRequestFormatEnum[keyof typeof ExportRawExportRequestFormatEnum];

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension. The \'from\' and \'to\' properties mark the boundaries of the interval. If \'from\' is omitted, all values earlier than \'to\' are included. If \'to\' is omitted, all values later than \'from\' are included. It is not allowed to omit both.
 * @export
 * @interface ExportRelativeDateFilter
 */
export interface ExportRelativeDateFilter {
    /**
     *
     * @type {ExportRelativeDateFilterRelativeDateFilter}
     * @memberof ExportRelativeDateFilter
     */
    relativeDateFilter: ExportRelativeDateFilterRelativeDateFilter;
}
/**
 *
 * @export
 * @interface ExportRelativeDateFilterRelativeDateFilter
 */
export interface ExportRelativeDateFilterRelativeDateFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     * @type {string}
     * @memberof ExportRelativeDateFilterRelativeDateFilter
     */
    granularity: ExportRelativeDateFilterRelativeDateFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\'). If null, then start of the range is unbounded.
     * @type {number}
     * @memberof ExportRelativeDateFilterRelativeDateFilter
     */
    from?: number | null;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...). If null, then end of the range is unbounded.
     * @type {number}
     * @memberof ExportRelativeDateFilterRelativeDateFilter
     */
    to?: number | null;
    /**
     *
     * @type {string}
     * @memberof ExportRelativeDateFilterRelativeDateFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof ExportRelativeDateFilterRelativeDateFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {ExportAfmObjectIdentifierDataset}
     * @memberof ExportRelativeDateFilterRelativeDateFilter
     */
    dataset: ExportAfmObjectIdentifierDataset;
}

export const ExportRelativeDateFilterRelativeDateFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type ExportRelativeDateFilterRelativeDateFilterGranularityEnum =
    typeof ExportRelativeDateFilterRelativeDateFilterGranularityEnum[keyof typeof ExportRelativeDateFilterRelativeDateFilterGranularityEnum];

/**
 * Additional settings.
 * @export
 * @interface ExportSettings
 */
export interface ExportSettings {
    /**
     * Include export info sheet in the exported file. Works only with `visualizationObject`. (XLSX)
     * @type {boolean}
     * @memberof ExportSettings
     */
    exportInfo?: boolean;
    /**
     * Merge equal headers in neighbouring cells. (XLSX)
     * @type {boolean}
     * @memberof ExportSettings
     */
    mergeHeaders?: boolean;
    /**
     * Print applied filters on top of the document. (PDF/HTML when visualizationObject is given)
     * @type {boolean}
     * @memberof ExportSettings
     */
    showFilters?: boolean;
    /**
     * Page size and orientation. (PDF)
     * @type {string}
     * @memberof ExportSettings
     */
    pdfPageSize?: string;
    /**
     * Custom CSS styles for the table. (PDF, HTML)
     * @type {Array<ExportPdfTableStyle>}
     * @memberof ExportSettings
     */
    pdfTableStyle?: Array<ExportPdfTableStyle>;
    /**
     * Top left header content. (PDF)
     * @type {string}
     * @memberof ExportSettings
     */
    pdfTopLeftContent?: string;
    /**
     * Top right header content. (PDF)
     * @type {string}
     * @memberof ExportSettings
     */
    pdfTopRightContent?: string;
}
/**
 * Metric defined by referencing a MAQL metric or an LDM fact object with aggregation.
 * @export
 * @interface ExportSimpleMeasureDefinition
 */
export interface ExportSimpleMeasureDefinition {
    /**
     *
     * @type {ExportSimpleMeasureDefinitionMeasure}
     * @memberof ExportSimpleMeasureDefinition
     */
    measure: ExportSimpleMeasureDefinitionMeasure;
}
/**
 *
 * @export
 * @interface ExportSimpleMeasureDefinitionMeasure
 */
export interface ExportSimpleMeasureDefinitionMeasure {
    /**
     *
     * @type {ExportAfmObjectIdentifierCore}
     * @memberof ExportSimpleMeasureDefinitionMeasure
     */
    item: ExportAfmObjectIdentifierCore;
    /**
     * Definition of aggregation type of the metric.
     * @type {string}
     * @memberof ExportSimpleMeasureDefinitionMeasure
     */
    aggregation?: ExportSimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true, compute the percentage of given metric values (broken down by AFM attributes) to the total (not broken down).
     * @type {boolean}
     * @memberof ExportSimpleMeasureDefinitionMeasure
     */
    computeRatio?: boolean;
    /**
     * Metrics can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     * @type {Array<ExportFilterDefinitionForSimpleMeasure>}
     * @memberof ExportSimpleMeasureDefinitionMeasure
     */
    filters?: Array<ExportFilterDefinitionForSimpleMeasure>;
}

export const ExportSimpleMeasureDefinitionMeasureAggregationEnum = {
    SUM: "SUM",
    COUNT: "COUNT",
    AVG: "AVG",
    MIN: "MIN",
    MAX: "MAX",
    MEDIAN: "MEDIAN",
    RUNSUM: "RUNSUM",
    APPROXIMATE_COUNT: "APPROXIMATE_COUNT",
} as const;

export type ExportSimpleMeasureDefinitionMeasureAggregationEnum =
    typeof ExportSimpleMeasureDefinitionMeasureAggregationEnum[keyof typeof ExportSimpleMeasureDefinitionMeasureAggregationEnum];

/**
 * Export request object describing the export properties and metadata for slides exports.
 * @export
 * @interface ExportSlidesExportRequest
 */
export interface ExportSlidesExportRequest {
    /**
     * Requested resulting file type.
     * @type {string}
     * @memberof ExportSlidesExportRequest
     */
    format: ExportSlidesExportRequestFormatEnum;
    /**
     * File name to be used for retrieving the pdf document.
     * @type {string}
     * @memberof ExportSlidesExportRequest
     */
    fileName: string;
    /**
     * Dashboard identifier
     * @type {string}
     * @memberof ExportSlidesExportRequest
     */
    dashboardId?: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     * @type {Array<string>}
     * @memberof ExportSlidesExportRequest
     */
    widgetIds?: Array<string>;
    /**
     * List of visualization ids to be exported. Note that only one visualization is currently supported.
     * @type {Array<string>}
     * @memberof ExportSlidesExportRequest
     */
    visualizationIds?: Array<string>;
    /**
     * Metadata definition in free-form JSON format.
     * @type {object}
     * @memberof ExportSlidesExportRequest
     */
    metadata?: object | null;
    /**
     * Export template identifier.
     * @type {string}
     * @memberof ExportSlidesExportRequest
     */
    templateId?: string | null;
}

export const ExportSlidesExportRequestFormatEnum = {
    PDF: "PDF",
    PPTX: "PPTX",
} as const;

export type ExportSlidesExportRequestFormatEnum =
    typeof ExportSlidesExportRequestFormatEnum[keyof typeof ExportSlidesExportRequestFormatEnum];

/**
 * Export request object describing the export properties and overrides for tabular exports.
 * @export
 * @interface ExportTabularExportRequest
 */
export interface ExportTabularExportRequest {
    /**
     * Expected file format.
     * @type {string}
     * @memberof ExportTabularExportRequest
     */
    format: ExportTabularExportRequestFormatEnum;
    /**
     * Execution result identifier.
     * @type {string}
     * @memberof ExportTabularExportRequest
     */
    executionResult?: string;
    /**
     * Filename of downloaded file without extension.
     * @type {string}
     * @memberof ExportTabularExportRequest
     */
    fileName: string;
    /**
     *
     * @type {ExportSettings}
     * @memberof ExportTabularExportRequest
     */
    settings?: ExportSettings;
    /**
     *
     * @type {ExportCustomOverride}
     * @memberof ExportTabularExportRequest
     */
    customOverride?: ExportCustomOverride;
    /**
     * Visualization object identifier. Alternative to executionResult property.
     * @type {string}
     * @memberof ExportTabularExportRequest
     */
    visualizationObject?: string;
    /**
     * Optional custom filters (as array of IFilter objects defined in UI SDK) to be applied when visualizationObject is given.
     * @type {Array<object>}
     * @memberof ExportTabularExportRequest
     */
    visualizationObjectCustomFilters?: Array<object>;
    /**
     * Analytical dashboard identifier. Optional identifier, which informs the system that the export is related to a specific dashboard.
     * @type {string}
     * @memberof ExportTabularExportRequest
     */
    relatedDashboardId?: string;
    /**
     * Metadata definition in free-form JSON format.
     * @type {object}
     * @memberof ExportTabularExportRequest
     */
    metadata?: object | null;
}

export const ExportTabularExportRequestFormatEnum = {
    CSV: "CSV",
    XLSX: "XLSX",
    HTML: "HTML",
    PDF: "PDF",
} as const;

export type ExportTabularExportRequestFormatEnum =
    typeof ExportTabularExportRequestFormatEnum[keyof typeof ExportTabularExportRequestFormatEnum];

/**
 * Export request object describing the export properties and metadata for dashboard PDF exports.
 * @export
 * @interface ExportVisualExportRequest
 */
export interface ExportVisualExportRequest {
    /**
     * File name to be used for retrieving the pdf document.
     * @type {string}
     * @memberof ExportVisualExportRequest
     */
    fileName: string;
    /**
     * Dashboard identifier
     * @type {string}
     * @memberof ExportVisualExportRequest
     */
    dashboardId: string;
    /**
     * Metadata definition in free-form JSON format.
     * @type {object}
     * @memberof ExportVisualExportRequest
     */
    metadata?: object;
}

/**
 * ActionsExport - axios parameter creator
 * @export
 */
export const ActionsExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {ExportDashboardTabularExportRequest} exportDashboardTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardExportRequest: async (
            workspaceId: string,
            dashboardId: string,
            exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createDashboardExportRequest", "workspaceId", workspaceId);
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists("createDashboardExportRequest", "dashboardId", dashboardId);
            // verify required parameter 'exportDashboardTabularExportRequest' is not null or undefined
            assertParamExists(
                "createDashboardExportRequest",
                "exportDashboardTabularExportRequest",
                exportDashboardTabularExportRequest,
            );
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/export/tabular`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportDashboardTabularExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      exportDashboardTabularExportRequest !== undefined
                          ? exportDashboardTabularExportRequest
                          : {},
                  )
                : exportDashboardTabularExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {string} workspaceId
         * @param {ExportImageExportRequest} exportImageExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageExport: async (
            workspaceId: string,
            exportImageExportRequest: ExportImageExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createImageExport", "workspaceId", workspaceId);
            // verify required parameter 'exportImageExportRequest' is not null or undefined
            assertParamExists("createImageExport", "exportImageExportRequest", exportImageExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportImageExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportImageExportRequest !== undefined ? exportImageExportRequest : {})
                : exportImageExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {ExportVisualExportRequest} exportVisualExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport: async (
            workspaceId: string,
            exportVisualExportRequest: ExportVisualExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createPdfExport", "workspaceId", workspaceId);
            // verify required parameter 'exportVisualExportRequest' is not null or undefined
            assertParamExists("createPdfExport", "exportVisualExportRequest", exportVisualExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportVisualExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportVisualExportRequest !== undefined ? exportVisualExportRequest : {})
                : exportVisualExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {string} workspaceId
         * @param {ExportRawExportRequest} exportRawExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawExport: async (
            workspaceId: string,
            exportRawExportRequest: ExportRawExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createRawExport", "workspaceId", workspaceId);
            // verify required parameter 'exportRawExportRequest' is not null or undefined
            assertParamExists("createRawExport", "exportRawExportRequest", exportRawExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportRawExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportRawExportRequest !== undefined ? exportRawExportRequest : {})
                : exportRawExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {string} workspaceId
         * @param {ExportSlidesExportRequest} exportSlidesExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSlidesExport: async (
            workspaceId: string,
            exportSlidesExportRequest: ExportSlidesExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createSlidesExport", "workspaceId", workspaceId);
            // verify required parameter 'exportSlidesExportRequest' is not null or undefined
            assertParamExists("createSlidesExport", "exportSlidesExportRequest", exportSlidesExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportSlidesExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportSlidesExportRequest !== undefined ? exportSlidesExportRequest : {})
                : exportSlidesExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {ExportTabularExportRequest} exportTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport: async (
            workspaceId: string,
            exportTabularExportRequest: ExportTabularExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'exportTabularExportRequest' is not null or undefined
            assertParamExists(
                "createTabularExport",
                "exportTabularExportRequest",
                exportTabularExportRequest,
            );
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportTabularExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportTabularExportRequest !== undefined ? exportTabularExportRequest : {})
                : exportTabularExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getExportedFile", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getExportedFile", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getImageExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getImageExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExportMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getImageExportMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getImageExportMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getRawExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getRawExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getSlidesExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getSlidesExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExportMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getSlidesExportMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getSlidesExportMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getTabularExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsExport - functional programming interface
 * @export
 */
export const ActionsExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsExportAxiosParamCreator(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {ExportDashboardTabularExportRequest} exportDashboardTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDashboardExportRequest(
            workspaceId: string,
            dashboardId: string,
            exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDashboardExportRequest(
                workspaceId,
                dashboardId,
                exportDashboardTabularExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {string} workspaceId
         * @param {ExportImageExportRequest} exportImageExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImageExport(
            workspaceId: string,
            exportImageExportRequest: ExportImageExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImageExport(
                workspaceId,
                exportImageExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {ExportVisualExportRequest} exportVisualExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPdfExport(
            workspaceId: string,
            exportVisualExportRequest: ExportVisualExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPdfExport(
                workspaceId,
                exportVisualExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {string} workspaceId
         * @param {ExportRawExportRequest} exportRawExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawExport(
            workspaceId: string,
            exportRawExportRequest: ExportRawExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRawExport(
                workspaceId,
                exportRawExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {string} workspaceId
         * @param {ExportSlidesExportRequest} exportSlidesExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSlidesExport(
            workspaceId: string,
            exportSlidesExportRequest: ExportSlidesExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSlidesExport(
                workspaceId,
                exportSlidesExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {ExportTabularExportRequest} exportTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTabularExport(
            workspaceId: string,
            exportTabularExportRequest: ExportTabularExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTabularExport(
                workspaceId,
                exportTabularExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExportedFile(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExportedFile(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageExportMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageExportMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRawExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlidesExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlidesExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlidesExportMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlidesExportMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTabularExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTabularExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsExport - factory interface
 * @export
 */
export const ActionsExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsExportFp(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {ActionsExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardExportRequest(
            requestParameters: ActionsExportCreateDashboardExportRequestRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createDashboardExportRequest(
                    requestParameters.workspaceId,
                    requestParameters.dashboardId,
                    requestParameters.exportDashboardTabularExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {ActionsExportCreateImageExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageExport(
            requestParameters: ActionsExportCreateImageExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createImageExport(
                    requestParameters.workspaceId,
                    requestParameters.exportImageExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {ActionsExportCreatePdfExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport(
            requestParameters: ActionsExportCreatePdfExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createPdfExport(
                    requestParameters.workspaceId,
                    requestParameters.exportVisualExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {ActionsExportCreateRawExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawExport(
            requestParameters: ActionsExportCreateRawExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createRawExport(
                    requestParameters.workspaceId,
                    requestParameters.exportRawExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {ActionsExportCreateSlidesExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSlidesExport(
            requestParameters: ActionsExportCreateSlidesExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createSlidesExport(
                    requestParameters.workspaceId,
                    requestParameters.exportSlidesExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {ActionsExportCreateTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport(
            requestParameters: ActionsExportCreateTabularExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createTabularExport(
                    requestParameters.workspaceId,
                    requestParameters.exportTabularExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {ActionsExportGetExportedFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile(
            requestParameters: ActionsExportGetExportedFileRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {ActionsExportGetImageExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExport(
            requestParameters: ActionsExportGetImageExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getImageExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {ActionsExportGetImageExportMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExportMetadata(
            requestParameters: ActionsExportGetImageExportMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getImageExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {ActionsExportGetMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(
            requestParameters: ActionsExportGetMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {ActionsExportGetRawExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawExport(
            requestParameters: ActionsExportGetRawExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getRawExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {ActionsExportGetSlidesExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExport(
            requestParameters: ActionsExportGetSlidesExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getSlidesExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {ActionsExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExportMetadata(
            requestParameters: ActionsExportGetSlidesExportMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getSlidesExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {ActionsExportGetTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport(
            requestParameters: ActionsExportGetTabularExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsExport - interface
 * @export
 * @interface ActionsExport
 */
export interface ActionsExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {ActionsExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createDashboardExportRequest(
        requestParameters: ActionsExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ActionsExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createImageExport(
        requestParameters: ActionsExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {ActionsExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createPdfExport(
        requestParameters: ActionsExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {ActionsExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createRawExport(
        requestParameters: ActionsExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {ActionsExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createSlidesExport(
        requestParameters: ActionsExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {ActionsExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createTabularExport(
        requestParameters: ActionsExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {ActionsExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getExportedFile(
        requestParameters: ActionsExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getImageExport(
        requestParameters: ActionsExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getImageExportMetadata(
        requestParameters: ActionsExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {ActionsExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getMetadata(
        requestParameters: ActionsExportGetMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getRawExport(
        requestParameters: ActionsExportGetRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getSlidesExport(
        requestParameters: ActionsExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getSlidesExportMetadata(
        requestParameters: ActionsExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {ActionsExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getTabularExport(
        requestParameters: ActionsExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createDashboardExportRequest operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateDashboardExportRequestRequest
 */
export interface ActionsExportCreateDashboardExportRequestRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateDashboardExportRequest
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateDashboardExportRequest
     */
    readonly dashboardId: string;

    /**
     *
     * @type {ExportDashboardTabularExportRequest}
     * @memberof ActionsExportCreateDashboardExportRequest
     */
    readonly exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest;
}

/**
 * Request parameters for createImageExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateImageExportRequest
 */
export interface ActionsExportCreateImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportImageExportRequest}
     * @memberof ActionsExportCreateImageExport
     */
    readonly exportImageExportRequest: ExportImageExportRequest;
}

/**
 * Request parameters for createPdfExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreatePdfExportRequest
 */
export interface ActionsExportCreatePdfExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreatePdfExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportVisualExportRequest}
     * @memberof ActionsExportCreatePdfExport
     */
    readonly exportVisualExportRequest: ExportVisualExportRequest;
}

/**
 * Request parameters for createRawExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateRawExportRequest
 */
export interface ActionsExportCreateRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportRawExportRequest}
     * @memberof ActionsExportCreateRawExport
     */
    readonly exportRawExportRequest: ExportRawExportRequest;
}

/**
 * Request parameters for createSlidesExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateSlidesExportRequest
 */
export interface ActionsExportCreateSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportSlidesExportRequest}
     * @memberof ActionsExportCreateSlidesExport
     */
    readonly exportSlidesExportRequest: ExportSlidesExportRequest;
}

/**
 * Request parameters for createTabularExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateTabularExportRequest
 */
export interface ActionsExportCreateTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportTabularExportRequest}
     * @memberof ActionsExportCreateTabularExport
     */
    readonly exportTabularExportRequest: ExportTabularExportRequest;
}

/**
 * Request parameters for getExportedFile operation in ActionsExport.
 * @export
 * @interface ActionsExportGetExportedFileRequest
 */
export interface ActionsExportGetExportedFileRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetExportedFile
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetExportedFile
     */
    readonly exportId: string;
}

/**
 * Request parameters for getImageExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetImageExportRequest
 */
export interface ActionsExportGetImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getImageExportMetadata operation in ActionsExport.
 * @export
 * @interface ActionsExportGetImageExportMetadataRequest
 */
export interface ActionsExportGetImageExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExportMetadata
     */
    readonly exportId: string;
}

/**
 * Request parameters for getMetadata operation in ActionsExport.
 * @export
 * @interface ActionsExportGetMetadataRequest
 */
export interface ActionsExportGetMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetMetadata
     */
    readonly exportId: string;
}

/**
 * Request parameters for getRawExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetRawExportRequest
 */
export interface ActionsExportGetRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetRawExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getSlidesExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetSlidesExportRequest
 */
export interface ActionsExportGetSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getSlidesExportMetadata operation in ActionsExport.
 * @export
 * @interface ActionsExportGetSlidesExportMetadataRequest
 */
export interface ActionsExportGetSlidesExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExportMetadata
     */
    readonly exportId: string;
}

/**
 * Request parameters for getTabularExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetTabularExportRequest
 */
export interface ActionsExportGetTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetTabularExport
     */
    readonly exportId: string;
}

/**
 * ActionsExport - object-oriented interface
 * @export
 * @class ActionsExport
 * @extends {BaseAPI}
 */
export class ActionsExport extends BaseAPI implements ActionsExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {ActionsExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createDashboardExportRequest(
        requestParameters: ActionsExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createDashboardExportRequest(
                requestParameters.workspaceId,
                requestParameters.dashboardId,
                requestParameters.exportDashboardTabularExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ActionsExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createImageExport(
        requestParameters: ActionsExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createImageExport(
                requestParameters.workspaceId,
                requestParameters.exportImageExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {ActionsExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createPdfExport(
        requestParameters: ActionsExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createPdfExport(
                requestParameters.workspaceId,
                requestParameters.exportVisualExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {ActionsExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createRawExport(
        requestParameters: ActionsExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createRawExport(requestParameters.workspaceId, requestParameters.exportRawExportRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {ActionsExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createSlidesExport(
        requestParameters: ActionsExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createSlidesExport(
                requestParameters.workspaceId,
                requestParameters.exportSlidesExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {ActionsExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createTabularExport(
        requestParameters: ActionsExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .createTabularExport(
                requestParameters.workspaceId,
                requestParameters.exportTabularExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {ActionsExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getExportedFile(
        requestParameters: ActionsExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getImageExport(
        requestParameters: ActionsExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getImageExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getImageExportMetadata(
        requestParameters: ActionsExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getImageExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {ActionsExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getMetadata(requestParameters: ActionsExportGetMetadataRequest, options?: AxiosRequestConfig) {
        return ActionsExportFp(this.configuration)
            .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getRawExport(requestParameters: ActionsExportGetRawExportRequest, options?: AxiosRequestConfig) {
        return ActionsExportFp(this.configuration)
            .getRawExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getSlidesExport(
        requestParameters: ActionsExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getSlidesExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getSlidesExportMetadata(
        requestParameters: ActionsExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getSlidesExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {ActionsExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getTabularExport(
        requestParameters: ActionsExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExportFp(this.configuration)
            .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ImageExportExport - axios parameter creator
 * @export
 */
export const ImageExportExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {string} workspaceId
         * @param {ExportImageExportRequest} exportImageExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageExport: async (
            workspaceId: string,
            exportImageExportRequest: ExportImageExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createImageExport", "workspaceId", workspaceId);
            // verify required parameter 'exportImageExportRequest' is not null or undefined
            assertParamExists("createImageExport", "exportImageExportRequest", exportImageExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportImageExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportImageExportRequest !== undefined ? exportImageExportRequest : {})
                : exportImageExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getImageExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getImageExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExportMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getImageExportMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getImageExportMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ImageExportExport - functional programming interface
 * @export
 */
export const ImageExportExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageExportExportAxiosParamCreator(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {string} workspaceId
         * @param {ExportImageExportRequest} exportImageExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImageExport(
            workspaceId: string,
            exportImageExportRequest: ExportImageExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImageExport(
                workspaceId,
                exportImageExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageExportMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageExportMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ImageExportExport - factory interface
 * @export
 */
export const ImageExportExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ImageExportExportFp(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create image export request
         * @param {ImageExportExportCreateImageExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImageExport(
            requestParameters: ImageExportExportCreateImageExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createImageExport(
                    requestParameters.workspaceId,
                    requestParameters.exportImageExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {ImageExportExportGetImageExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExport(
            requestParameters: ImageExportExportGetImageExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getImageExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {ImageExportExportGetImageExportMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageExportMetadata(
            requestParameters: ImageExportExportGetImageExportMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getImageExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageExportExport - interface
 * @export
 * @interface ImageExportExport
 */
export interface ImageExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ImageExportExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExportInterface
     */
    createImageExport(
        requestParameters: ImageExportExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ImageExportExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExportInterface
     */
    getImageExport(
        requestParameters: ImageExportExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ImageExportExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExportInterface
     */
    getImageExportMetadata(
        requestParameters: ImageExportExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createImageExport operation in ImageExportExport.
 * @export
 * @interface ImageExportExportCreateImageExportRequest
 */
export interface ImageExportExportCreateImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ImageExportExportCreateImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportImageExportRequest}
     * @memberof ImageExportExportCreateImageExport
     */
    readonly exportImageExportRequest: ExportImageExportRequest;
}

/**
 * Request parameters for getImageExport operation in ImageExportExport.
 * @export
 * @interface ImageExportExportGetImageExportRequest
 */
export interface ImageExportExportGetImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getImageExportMetadata operation in ImageExportExport.
 * @export
 * @interface ImageExportExportGetImageExportMetadataRequest
 */
export interface ImageExportExportGetImageExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExportMetadata
     */
    readonly exportId: string;
}

/**
 * ImageExportExport - object-oriented interface
 * @export
 * @class ImageExportExport
 * @extends {BaseAPI}
 */
export class ImageExportExport extends BaseAPI implements ImageExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ImageExportExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExport
     */
    public createImageExport(
        requestParameters: ImageExportExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ImageExportExportFp(this.configuration)
            .createImageExport(
                requestParameters.workspaceId,
                requestParameters.exportImageExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ImageExportExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExport
     */
    public getImageExport(
        requestParameters: ImageExportExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ImageExportExportFp(this.configuration)
            .getImageExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ImageExportExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExport
     */
    public getImageExportMetadata(
        requestParameters: ImageExportExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ImageExportExportFp(this.configuration)
            .getImageExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * RawExportExport - axios parameter creator
 * @export
 */
export const RawExportExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {string} workspaceId
         * @param {ExportRawExportRequest} exportRawExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawExport: async (
            workspaceId: string,
            exportRawExportRequest: ExportRawExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createRawExport", "workspaceId", workspaceId);
            // verify required parameter 'exportRawExportRequest' is not null or undefined
            assertParamExists("createRawExport", "exportRawExportRequest", exportRawExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportRawExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportRawExportRequest !== undefined ? exportRawExportRequest : {})
                : exportRawExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getRawExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getRawExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * RawExportExport - functional programming interface
 * @export
 */
export const RawExportExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RawExportExportAxiosParamCreator(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {string} workspaceId
         * @param {ExportRawExportRequest} exportRawExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRawExport(
            workspaceId: string,
            exportRawExportRequest: ExportRawExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRawExport(
                workspaceId,
                exportRawExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRawExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * RawExportExport - factory interface
 * @export
 */
export const RawExportExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = RawExportExportFp(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create raw export request
         * @param {RawExportExportCreateRawExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRawExport(
            requestParameters: RawExportExportCreateRawExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createRawExport(
                    requestParameters.workspaceId,
                    requestParameters.exportRawExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {RawExportExportGetRawExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawExport(
            requestParameters: RawExportExportGetRawExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getRawExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * RawExportExport - interface
 * @export
 * @interface RawExportExport
 */
export interface RawExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {RawExportExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExportInterface
     */
    createRawExport(
        requestParameters: RawExportExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {RawExportExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExportInterface
     */
    getRawExport(
        requestParameters: RawExportExportGetRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createRawExport operation in RawExportExport.
 * @export
 * @interface RawExportExportCreateRawExportRequest
 */
export interface RawExportExportCreateRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof RawExportExportCreateRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportRawExportRequest}
     * @memberof RawExportExportCreateRawExport
     */
    readonly exportRawExportRequest: ExportRawExportRequest;
}

/**
 * Request parameters for getRawExport operation in RawExportExport.
 * @export
 * @interface RawExportExportGetRawExportRequest
 */
export interface RawExportExportGetRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof RawExportExportGetRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof RawExportExportGetRawExport
     */
    readonly exportId: string;
}

/**
 * RawExportExport - object-oriented interface
 * @export
 * @class RawExportExport
 * @extends {BaseAPI}
 */
export class RawExportExport extends BaseAPI implements RawExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {RawExportExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExport
     */
    public createRawExport(
        requestParameters: RawExportExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return RawExportExportFp(this.configuration)
            .createRawExport(requestParameters.workspaceId, requestParameters.exportRawExportRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {RawExportExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExport
     */
    public getRawExport(requestParameters: RawExportExportGetRawExportRequest, options?: AxiosRequestConfig) {
        return RawExportExportFp(this.configuration)
            .getRawExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * SlidesExportExport - axios parameter creator
 * @export
 */
export const SlidesExportExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {string} workspaceId
         * @param {ExportSlidesExportRequest} exportSlidesExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSlidesExport: async (
            workspaceId: string,
            exportSlidesExportRequest: ExportSlidesExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createSlidesExport", "workspaceId", workspaceId);
            // verify required parameter 'exportSlidesExportRequest' is not null or undefined
            assertParamExists("createSlidesExport", "exportSlidesExportRequest", exportSlidesExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportSlidesExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportSlidesExportRequest !== undefined ? exportSlidesExportRequest : {})
                : exportSlidesExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getSlidesExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getSlidesExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExportMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getSlidesExportMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getSlidesExportMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * SlidesExportExport - functional programming interface
 * @export
 */
export const SlidesExportExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SlidesExportExportAxiosParamCreator(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {string} workspaceId
         * @param {ExportSlidesExportRequest} exportSlidesExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSlidesExport(
            workspaceId: string,
            exportSlidesExportRequest: ExportSlidesExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSlidesExport(
                workspaceId,
                exportSlidesExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlidesExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlidesExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlidesExportMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlidesExportMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * SlidesExportExport - factory interface
 * @export
 */
export const SlidesExportExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = SlidesExportExportFp(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create slides export request
         * @param {SlidesExportExportCreateSlidesExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSlidesExport(
            requestParameters: SlidesExportExportCreateSlidesExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createSlidesExport(
                    requestParameters.workspaceId,
                    requestParameters.exportSlidesExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary (EXPERIMENTAL) Retrieve exported files
         * @param {SlidesExportExportGetSlidesExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExport(
            requestParameters: SlidesExportExportGetSlidesExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getSlidesExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
         * @summary (EXPERIMENTAL) Retrieve metadata context
         * @param {SlidesExportExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlidesExportMetadata(
            requestParameters: SlidesExportExportGetSlidesExportMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getSlidesExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * SlidesExportExport - interface
 * @export
 * @interface SlidesExportExport
 */
export interface SlidesExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {SlidesExportExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExportInterface
     */
    createSlidesExport(
        requestParameters: SlidesExportExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {SlidesExportExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExportInterface
     */
    getSlidesExport(
        requestParameters: SlidesExportExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {SlidesExportExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExportInterface
     */
    getSlidesExportMetadata(
        requestParameters: SlidesExportExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createSlidesExport operation in SlidesExportExport.
 * @export
 * @interface SlidesExportExportCreateSlidesExportRequest
 */
export interface SlidesExportExportCreateSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof SlidesExportExportCreateSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportSlidesExportRequest}
     * @memberof SlidesExportExportCreateSlidesExport
     */
    readonly exportSlidesExportRequest: ExportSlidesExportRequest;
}

/**
 * Request parameters for getSlidesExport operation in SlidesExportExport.
 * @export
 * @interface SlidesExportExportGetSlidesExportRequest
 */
export interface SlidesExportExportGetSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getSlidesExportMetadata operation in SlidesExportExport.
 * @export
 * @interface SlidesExportExportGetSlidesExportMetadataRequest
 */
export interface SlidesExportExportGetSlidesExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExportMetadata
     */
    readonly exportId: string;
}

/**
 * SlidesExportExport - object-oriented interface
 * @export
 * @class SlidesExportExport
 * @extends {BaseAPI}
 */
export class SlidesExportExport extends BaseAPI implements SlidesExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {SlidesExportExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExport
     */
    public createSlidesExport(
        requestParameters: SlidesExportExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return SlidesExportExportFp(this.configuration)
            .createSlidesExport(
                requestParameters.workspaceId,
                requestParameters.exportSlidesExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {SlidesExportExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExport
     */
    public getSlidesExport(
        requestParameters: SlidesExportExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return SlidesExportExportFp(this.configuration)
            .getSlidesExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {SlidesExportExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExport
     */
    public getSlidesExportMetadata(
        requestParameters: SlidesExportExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return SlidesExportExportFp(this.configuration)
            .getSlidesExportMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * TabularExportExport - axios parameter creator
 * @export
 */
export const TabularExportExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {ExportDashboardTabularExportRequest} exportDashboardTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardExportRequest: async (
            workspaceId: string,
            dashboardId: string,
            exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createDashboardExportRequest", "workspaceId", workspaceId);
            // verify required parameter 'dashboardId' is not null or undefined
            assertParamExists("createDashboardExportRequest", "dashboardId", dashboardId);
            // verify required parameter 'exportDashboardTabularExportRequest' is not null or undefined
            assertParamExists(
                "createDashboardExportRequest",
                "exportDashboardTabularExportRequest",
                exportDashboardTabularExportRequest,
            );
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/export/tabular`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportDashboardTabularExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      exportDashboardTabularExportRequest !== undefined
                          ? exportDashboardTabularExportRequest
                          : {},
                  )
                : exportDashboardTabularExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {ExportTabularExportRequest} exportTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport: async (
            workspaceId: string,
            exportTabularExportRequest: ExportTabularExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'exportTabularExportRequest' is not null or undefined
            assertParamExists(
                "createTabularExport",
                "exportTabularExportRequest",
                exportTabularExportRequest,
            );
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportTabularExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportTabularExportRequest !== undefined ? exportTabularExportRequest : {})
                : exportTabularExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getTabularExport", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getTabularExport", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * TabularExportExport - functional programming interface
 * @export
 */
export const TabularExportExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TabularExportExportAxiosParamCreator(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {string} workspaceId
         * @param {string} dashboardId
         * @param {ExportDashboardTabularExportRequest} exportDashboardTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDashboardExportRequest(
            workspaceId: string,
            dashboardId: string,
            exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDashboardExportRequest(
                workspaceId,
                dashboardId,
                exportDashboardTabularExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {string} workspaceId
         * @param {ExportTabularExportRequest} exportTabularExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTabularExport(
            workspaceId: string,
            exportTabularExportRequest: ExportTabularExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTabularExport(
                workspaceId,
                exportTabularExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTabularExport(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTabularExport(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * TabularExportExport - factory interface
 * @export
 */
export const TabularExportExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = TabularExportExportFp(configuration);
    return {
        /**
         * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary (EXPERIMENTAL) Create dashboard tabular export request
         * @param {TabularExportExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDashboardExportRequest(
            requestParameters: TabularExportExportCreateDashboardExportRequestRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createDashboardExportRequest(
                    requestParameters.workspaceId,
                    requestParameters.dashboardId,
                    requestParameters.exportDashboardTabularExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create tabular export request
         * @param {TabularExportExportCreateTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTabularExport(
            requestParameters: TabularExportExportCreateTabularExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createTabularExport(
                    requestParameters.workspaceId,
                    requestParameters.exportTabularExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
         * @summary Retrieve exported files
         * @param {TabularExportExportGetTabularExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTabularExport(
            requestParameters: TabularExportExportGetTabularExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * TabularExportExport - interface
 * @export
 * @interface TabularExportExport
 */
export interface TabularExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {TabularExportExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExportInterface
     */
    createDashboardExportRequest(
        requestParameters: TabularExportExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {TabularExportExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExportInterface
     */
    createTabularExport(
        requestParameters: TabularExportExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {TabularExportExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExportInterface
     */
    getTabularExport(
        requestParameters: TabularExportExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createDashboardExportRequest operation in TabularExportExport.
 * @export
 * @interface TabularExportExportCreateDashboardExportRequestRequest
 */
export interface TabularExportExportCreateDashboardExportRequestRequest {
    /**
     *
     * @type {string}
     * @memberof TabularExportExportCreateDashboardExportRequest
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof TabularExportExportCreateDashboardExportRequest
     */
    readonly dashboardId: string;

    /**
     *
     * @type {ExportDashboardTabularExportRequest}
     * @memberof TabularExportExportCreateDashboardExportRequest
     */
    readonly exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest;
}

/**
 * Request parameters for createTabularExport operation in TabularExportExport.
 * @export
 * @interface TabularExportExportCreateTabularExportRequest
 */
export interface TabularExportExportCreateTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof TabularExportExportCreateTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportTabularExportRequest}
     * @memberof TabularExportExportCreateTabularExport
     */
    readonly exportTabularExportRequest: ExportTabularExportRequest;
}

/**
 * Request parameters for getTabularExport operation in TabularExportExport.
 * @export
 * @interface TabularExportExportGetTabularExportRequest
 */
export interface TabularExportExportGetTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof TabularExportExportGetTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof TabularExportExportGetTabularExport
     */
    readonly exportId: string;
}

/**
 * TabularExportExport - object-oriented interface
 * @export
 * @class TabularExportExport
 * @extends {BaseAPI}
 */
export class TabularExportExport extends BaseAPI implements TabularExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {TabularExportExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExport
     */
    public createDashboardExportRequest(
        requestParameters: TabularExportExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ) {
        return TabularExportExportFp(this.configuration)
            .createDashboardExportRequest(
                requestParameters.workspaceId,
                requestParameters.dashboardId,
                requestParameters.exportDashboardTabularExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {TabularExportExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExport
     */
    public createTabularExport(
        requestParameters: TabularExportExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return TabularExportExportFp(this.configuration)
            .createTabularExport(
                requestParameters.workspaceId,
                requestParameters.exportTabularExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {TabularExportExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExport
     */
    public getTabularExport(
        requestParameters: TabularExportExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return TabularExportExportFp(this.configuration)
            .getTabularExport(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * VisualExportExport - axios parameter creator
 * @export
 */
export const VisualExportExportAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {ExportVisualExportRequest} exportVisualExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport: async (
            workspaceId: string,
            exportVisualExportRequest: ExportVisualExportRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createPdfExport", "workspaceId", workspaceId);
            // verify required parameter 'exportVisualExportRequest' is not null or undefined
            assertParamExists("createPdfExport", "exportVisualExportRequest", exportVisualExportRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof exportVisualExportRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(exportVisualExportRequest !== undefined ? exportVisualExportRequest : {})
                : exportVisualExportRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getExportedFile", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getExportedFile", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (
            workspaceId: string,
            exportId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getMetadata", "workspaceId", workspaceId);
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists("getMetadata", "exportId", exportId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}/metadata`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * VisualExportExport - functional programming interface
 * @export
 */
export const VisualExportExportFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = VisualExportExportAxiosParamCreator(configuration);
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {string} workspaceId
         * @param {ExportVisualExportRequest} exportVisualExportRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPdfExport(
            workspaceId: string,
            exportVisualExportRequest: ExportVisualExportRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportExportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPdfExport(
                workspaceId,
                exportVisualExportRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExportedFile(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExportedFile(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {string} workspaceId
         * @param {string} exportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(
            workspaceId: string,
            exportId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(
                workspaceId,
                exportId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * VisualExportExport - factory interface
 * @export
 */
export const VisualExportExportFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = VisualExportExportFp(configuration);
    return {
        /**
         * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
         * @summary Create visual - pdf export request
         * @param {VisualExportExportCreatePdfExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPdfExport(
            requestParameters: VisualExportExportCreatePdfExportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExportExportResponse> {
            return localVarFp
                .createPdfExport(
                    requestParameters.workspaceId,
                    requestParameters.exportVisualExportRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
         * @summary Retrieve exported files
         * @param {VisualExportExportGetExportedFileRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportedFile(
            requestParameters: VisualExportExportGetExportedFileRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
         * @summary Retrieve metadata context
         * @param {VisualExportExportGetMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(
            requestParameters: VisualExportExportGetMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * VisualExportExport - interface
 * @export
 * @interface VisualExportExport
 */
export interface VisualExportExportInterface {
    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {VisualExportExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExportInterface
     */
    createPdfExport(
        requestParameters: VisualExportExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {VisualExportExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExportInterface
     */
    getExportedFile(
        requestParameters: VisualExportExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {VisualExportExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExportInterface
     */
    getMetadata(
        requestParameters: VisualExportExportGetMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createPdfExport operation in VisualExportExport.
 * @export
 * @interface VisualExportExportCreatePdfExportRequest
 */
export interface VisualExportExportCreatePdfExportRequest {
    /**
     *
     * @type {string}
     * @memberof VisualExportExportCreatePdfExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportVisualExportRequest}
     * @memberof VisualExportExportCreatePdfExport
     */
    readonly exportVisualExportRequest: ExportVisualExportRequest;
}

/**
 * Request parameters for getExportedFile operation in VisualExportExport.
 * @export
 * @interface VisualExportExportGetExportedFileRequest
 */
export interface VisualExportExportGetExportedFileRequest {
    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetExportedFile
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetExportedFile
     */
    readonly exportId: string;
}

/**
 * Request parameters for getMetadata operation in VisualExportExport.
 * @export
 * @interface VisualExportExportGetMetadataRequest
 */
export interface VisualExportExportGetMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetMetadata
     */
    readonly exportId: string;
}

/**
 * VisualExportExport - object-oriented interface
 * @export
 * @class VisualExportExport
 * @extends {BaseAPI}
 */
export class VisualExportExport extends BaseAPI implements VisualExportExportInterface {
    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {VisualExportExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExport
     */
    public createPdfExport(
        requestParameters: VisualExportExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return VisualExportExportFp(this.configuration)
            .createPdfExport(
                requestParameters.workspaceId,
                requestParameters.exportVisualExportRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {VisualExportExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExport
     */
    public getExportedFile(
        requestParameters: VisualExportExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ) {
        return VisualExportExportFp(this.configuration)
            .getExportedFile(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {VisualExportExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExport
     */
    public getMetadata(
        requestParameters: VisualExportExportGetMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return VisualExportExportFp(this.configuration)
            .getMetadata(requestParameters.workspaceId, requestParameters.exportId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
