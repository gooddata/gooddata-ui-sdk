// (C) 2026 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 */
export interface ExportAFM {
    /**
     * Attributes to be used in the computation.
     */
    attributes: Array<ExportAttributeItem>;
    /**
     * Various filter types to filter the execution result.
     */
    filters: Array<ExportFilterDefinition>;
    /**
     * Metrics to be computed.
     */
    measures: Array<ExportMeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     */
    auxMeasures?: Array<ExportMeasureItem>;
}

/**
 * A datetime filter specifying exact from and to values.
 */
export interface ExportAbsoluteDateFilter {
    absoluteDateFilter: ExportAbsoluteDateFilterAbsoluteDateFilter;
}

export interface ExportAbsoluteDateFilterAbsoluteDateFilter {
    from: string;
    to: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
    /**
     * If true, rows with undefined (NULL) date values will be included in the result. The filter becomes: (date_condition) OR (date IS NULL). If false or not set, standard behavior applies (NULLs excluded by the date condition).
     */
    includeEmptyValues?: boolean;
    dataset: ExportAfmObjectIdentifierDataset;
}

/**
 * @type ExportAbstractMeasureValueFilter
 */
export type ExportAbstractMeasureValueFilter =
    | ExportComparisonMeasureValueFilter
    | ExportCompoundMeasureValueFilter
    | ExportRangeMeasureValueFilter
    | ExportRankingFilter;

/**
 * @type ExportAfmIdentifier
 * Reference to the attribute label to which the filter should be applied.
 */
export type ExportAfmIdentifier = ExportAfmLocalIdentifier | ExportAfmObjectIdentifier;

export interface ExportAfmLocalIdentifier {
    localIdentifier: string;
}

/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 */
export interface ExportAfmObjectIdentifier {
    identifier: ExportAfmObjectIdentifierIdentifier;
}

/**
 * Reference to the date attribute to use.
 */
export interface ExportAfmObjectIdentifierAttribute {
    identifier: ExportAfmObjectIdentifierAttributeIdentifier;
}

export interface ExportAfmObjectIdentifierAttributeIdentifier {
    id: string;
    type: ExportAfmObjectIdentifierAttributeIdentifierTypeEnum;
}

export type ExportAfmObjectIdentifierAttributeIdentifierTypeEnum = "attribute";

/**
 * Reference to the metric, fact or attribute object to use for the metric.
 */
export interface ExportAfmObjectIdentifierCore {
    identifier: ExportAfmObjectIdentifierCoreIdentifier;
}

export interface ExportAfmObjectIdentifierCoreIdentifier {
    id: string;
    type: ExportAfmObjectIdentifierCoreIdentifierTypeEnum;
}

export type ExportAfmObjectIdentifierCoreIdentifierTypeEnum = "attribute" | "label" | "fact" | "metric";

/**
 * Reference to the date dataset to which the filter should be applied.
 */
export interface ExportAfmObjectIdentifierDataset {
    identifier: ExportAfmObjectIdentifierDatasetIdentifier;
}

export interface ExportAfmObjectIdentifierDatasetIdentifier {
    id: string;
    type: ExportAfmObjectIdentifierDatasetIdentifierTypeEnum;
}

export type ExportAfmObjectIdentifierDatasetIdentifierTypeEnum = "dataset";

export interface ExportAfmObjectIdentifierIdentifier {
    type: ExportAfmObjectIdentifierIdentifierTypeEnum;
    id: string;
}

export type ExportAfmObjectIdentifierIdentifierTypeEnum =
    | "analyticalDashboard"
    | "attribute"
    | "dashboardPlugin"
    | "dataset"
    | "fact"
    | "label"
    | "metric"
    | "prompt"
    | "visualizationObject"
    | "filterContext";

export interface ExportAfmObjectIdentifierLabel {
    identifier: ExportAfmObjectIdentifierLabelIdentifier;
}

export interface ExportAfmObjectIdentifierLabelIdentifier {
    type: ExportAfmObjectIdentifierLabelIdentifierTypeEnum;
    id: string;
}

export type ExportAfmObjectIdentifierLabelIdentifierTypeEnum = "label";

/**
 * Metric representing arithmetics between other metrics.
 */
export interface ExportArithmeticMeasureDefinition {
    arithmeticMeasure: ExportArithmeticMeasureDefinitionArithmeticMeasure;
}

export interface ExportArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of metrics to apply arithmetic operation by chosen operator.
     */
    measureIdentifiers: Array<ExportAfmLocalIdentifier>;
    /**
     * Arithmetic operator describing operation between metrics.
     */
    operator: ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

export type ExportArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum =
    | "SUM"
    | "DIFFERENCE"
    | "MULTIPLICATION"
    | "RATIO"
    | "CHANGE";

/**
 * @type ExportAttributeElements
 */
export type ExportAttributeElements = ExportAttributeElementsByRef | ExportAttributeElementsByValue;

export interface ExportAttributeElementsByRef {
    /**
     * List of attribute elements by reference
     */
    uris: Array<string | null>;
}

export interface ExportAttributeElementsByValue {
    /**
     * List of attribute elements by value
     */
    values: Array<string | null>;
}

/**
 * @type ExportAttributeFilter
 * Abstract filter definition type attributes
 */
export type ExportAttributeFilter = ExportNegativeAttributeFilter | ExportPositiveAttributeFilter;

export interface ExportAttributeFilterByDate {
    filterLocalIdentifier: string;
    isCommonDate: boolean;
}

/**
 * Filter on specific set of label values.
 */
export interface ExportAttributeFilterElements {
    /**
     * Set of label values.
     */
    values: Array<string | null>;
}

export interface ExportAttributeFilterParent {
    filterLocalIdentifier: string;
    over: ExportOver;
}

export interface ExportAttributeItem {
    /**
     * Local identifier of the attribute. This can be used to reference the attribute in other parts of the execution definition.
     */
    localIdentifier: string;
    label: ExportAfmObjectIdentifierLabel;
    /**
     * Indicates whether to show all values of given attribute even if the data bound to those values is not available.
     */
    showAllValues?: boolean;
}

/**
 * Bounding filter for this relative date filter. This can be used to limit the range of the relative date filter to a specific date range.
 */
export interface ExportBoundedFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: ExportBoundedFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\'). If null, then start of the range is unbounded.
     */
    from?: number | null;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...). If null, then end of the range is unbounded.
     */
    to?: number | null;
}

export type ExportBoundedFilterGranularityEnum =
    | "MINUTE"
    | "HOUR"
    | "DAY"
    | "WEEK"
    | "MONTH"
    | "QUARTER"
    | "YEAR"
    | "MINUTE_OF_HOUR"
    | "HOUR_OF_DAY"
    | "DAY_OF_WEEK"
    | "DAY_OF_MONTH"
    | "DAY_OF_QUARTER"
    | "DAY_OF_YEAR"
    | "WEEK_OF_YEAR"
    | "MONTH_OF_YEAR"
    | "QUARTER_OF_YEAR"
    | "FISCAL_MONTH"
    | "FISCAL_QUARTER"
    | "FISCAL_YEAR";

/**
 * Condition that compares the metric value to a given constant value using a comparison operator.
 */
export interface ExportComparisonCondition {
    comparison: ExportComparisonConditionComparison;
}

export interface ExportComparisonConditionComparison {
    operator: ExportComparisonConditionComparisonOperatorEnum;
    value: number;
}

export type ExportComparisonConditionComparisonOperatorEnum =
    | "GREATER_THAN"
    | "GREATER_THAN_OR_EQUAL_TO"
    | "LESS_THAN"
    | "LESS_THAN_OR_EQUAL_TO"
    | "EQUAL_TO"
    | "NOT_EQUAL_TO";

/**
 * Filter the result by comparing specified metric to given constant value, using given comparison operator.
 */
export interface ExportComparisonMeasureValueFilter {
    comparisonMeasureValueFilter: ExportComparisonMeasureValueFilterComparisonMeasureValueFilter;
}

export interface ExportComparisonMeasureValueFilterComparisonMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<ExportAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum;
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: ExportAfmIdentifier;
}

export type ExportComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum =
    | "GREATER_THAN"
    | "GREATER_THAN_OR_EQUAL_TO"
    | "LESS_THAN"
    | "LESS_THAN_OR_EQUAL_TO"
    | "EQUAL_TO"
    | "NOT_EQUAL_TO";

/**
 * Filter the result by applying multiple comparison and/or range conditions combined with OR logic. If conditions list is empty, no filtering is applied (all rows are returned).
 */
export interface ExportCompoundMeasureValueFilter {
    compoundMeasureValueFilter: ExportCompoundMeasureValueFilterCompoundMeasureValueFilter;
}

export interface ExportCompoundMeasureValueFilterCompoundMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<ExportAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    /**
     * List of conditions to apply. Conditions are combined with OR logic. Each condition can be either a comparison (e.g., > 100) or a range (e.g., BETWEEN 10 AND 50). If empty, no filtering is applied and all rows are returned.
     */
    conditions: Array<ExportMeasureValueCondition>;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: ExportAfmIdentifier;
}

/**
 * Custom label object override.
 */
export interface ExportCustomLabel {
    /**
     * Override value.
     */
    title: string;
}

/**
 * Custom metric object override.
 */
export interface ExportCustomMetric {
    /**
     * Metric title override.
     */
    title: string;
    /**
     * Format override.
     */
    format: string;
}

/**
 * Custom cell value overrides (IDs will be replaced with specified values).
 */
export interface ExportCustomOverride {
    /**
     * Map of CustomLabels with keys used as placeholders in document.
     */
    labels?: { [key: string]: ExportCustomLabel };
    /**
     * Map of CustomMetrics with keys used as placeholders in document.
     */
    metrics?: { [key: string]: ExportCustomMetric };
}

export interface ExportDashboardAttributeFilter {
    attributeFilter: ExportDashboardAttributeFilterAttributeFilter;
}

export interface ExportDashboardAttributeFilterAttributeFilter {
    displayForm: ExportIdentifierRef;
    negativeSelection: boolean;
    attributeElements: ExportAttributeElements;
    filterElementsBy?: Array<ExportAttributeFilterParent>;
    filterElementsByDate?: Array<ExportAttributeFilterByDate>;
    validateElementsBy?: Array<ExportIdentifierRef>;
    title?: string;
    selectionMode?: ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum;
    localIdentifier?: string;
}

export type ExportDashboardAttributeFilterAttributeFilterSelectionModeEnum = "single" | "multi";

export interface ExportDashboardDateFilter {
    dateFilter: ExportDashboardDateFilterDateFilter;
}

export interface ExportDashboardDateFilterDateFilter {
    type: ExportDashboardDateFilterDateFilterTypeEnum;
    granularity: ExportDashboardDateFilterDateFilterGranularityEnum;
    from?: ExportDashboardDateFilterDateFilterFrom;
    to?: ExportDashboardDateFilterDateFilterFrom;
    dataSet?: ExportIdentifierRef;
    attribute?: ExportIdentifierRef;
    boundedFilter?: ExportRelativeBoundedDateFilter;
    includeEmptyValues?: boolean;
    localIdentifier?: string;
}

export type ExportDashboardDateFilterDateFilterTypeEnum = "relative" | "absolute";
export type ExportDashboardDateFilterDateFilterGranularityEnum =
    | "ALL_TIME_GRANULARITY"
    | "GDC.time.year"
    | "GDC.time.week_us"
    | "GDC.time.week_in_year"
    | "GDC.time.week_in_quarter"
    | "GDC.time.week"
    | "GDC.time.euweek_in_year"
    | "GDC.time.euweek_in_quarter"
    | "GDC.time.quarter"
    | "GDC.time.quarter_in_year"
    | "GDC.time.month"
    | "GDC.time.month_in_quarter"
    | "GDC.time.month_in_year"
    | "GDC.time.day_in_year"
    | "GDC.time.day_in_quarter"
    | "GDC.time.day_in_month"
    | "GDC.time.day_in_week"
    | "GDC.time.day_in_euweek"
    | "GDC.time.date"
    | "GDC.time.hour"
    | "GDC.time.hour_in_day"
    | "GDC.time.minute"
    | "GDC.time.minute_in_hour"
    | "GDC.time.fiscal_month"
    | "GDC.time.fiscal_quarter"
    | "GDC.time.fiscal_year";

/**
 * @type ExportDashboardDateFilterDateFilterFrom
 */
export type ExportDashboardDateFilterDateFilterFrom = number | string;

/**
 * Additional settings.
 */
export interface ExportDashboardExportSettings {
    /**
     * If true, the export will contain the information about the export – exported date, dashboard filters, etc.
     */
    exportInfo?: boolean;
    /**
     * Merge equal headers in neighbouring cells. Used for [XLSX] format only.
     */
    mergeHeaders?: boolean;
    /**
     * Set page size. (PDF)
     */
    pageSize?: ExportDashboardExportSettingsPageSizeEnum;
    /**
     * Set page orientation. (PDF)
     */
    pageOrientation?: ExportDashboardExportSettingsPageOrientationEnum;
}

export type ExportDashboardExportSettingsPageSizeEnum = "A3" | "A4" | "LETTER";
export type ExportDashboardExportSettingsPageOrientationEnum = "PORTRAIT" | "LANDSCAPE";

/**
 * @type ExportDashboardFilter
 */
export type ExportDashboardFilter = ExportDashboardAttributeFilter | ExportDashboardDateFilter;

/**
 * Export request object describing the export properties for dashboard tabular exports.
 */
export interface ExportDashboardTabularExportRequest {
    /**
     * Requested tabular export type.
     */
    format: ExportDashboardTabularExportRequestFormatEnum;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    /**
     * List of filters that will be used instead of the default dashboard filters.
     */
    dashboardFiltersOverride?: Array<ExportDashboardFilter>;
    /**
     * Map of tab-specific filter overrides. Key is tabId, value is list of filters for that tab.
     */
    dashboardTabsFiltersOverrides?: { [key: string]: Array<ExportDashboardFilter> };
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds?: Array<string>;
    settings?: ExportDashboardExportSettings;
}

export type ExportDashboardTabularExportRequestFormatEnum = "XLSX" | "PDF";

/**
 * @type ExportDateFilter
 * Abstract filter definition type for dates.
 */
export type ExportDateFilter = ExportAbsoluteDateFilter | ExportRelativeDateFilter;

export interface ExportDateValue {
    value: string;
}

/**
 * Various settings affecting the process of AFM execution or its result
 */
export interface ExportExecutionSettings {
    /**
     * Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     */
    dataSamplingPercentage?: number;
    /**
     * Specifies the timestamp of the execution from which relative filters are resolved. If not set, the current time is used.
     */
    timestamp?: string;
}

export interface ExportExportResponse {
    exportResult: string;
}

/**
 * @type ExportFilterDefinition
 * Abstract filter definition type
 */
export type ExportFilterDefinition =
    | ExportAbsoluteDateFilter
    | ExportComparisonMeasureValueFilter
    | ExportCompoundMeasureValueFilter
    | ExportInlineFilterDefinition
    | ExportNegativeAttributeFilter
    | ExportPositiveAttributeFilter
    | ExportRangeMeasureValueFilter
    | ExportRankingFilter
    | ExportRelativeDateFilter;

/**
 * @type ExportFilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple metric.
 */
export type ExportFilterDefinitionForSimpleMeasure = ExportAttributeFilter | ExportDateFilter;

export interface ExportGetSlidesExport202ResponseInner {
    short?: number;
    char?: string;
    int?: number;
    long?: number;
    float?: number;
    double?: number;
    direct?: boolean;
    readOnly?: boolean;
}

export interface ExportIdentifierRef {
    identifier?: ExportIdentifierRefIdentifier;
}

export interface ExportIdentifierRefIdentifier {
    id: string;
    type: ExportIdentifierRefIdentifierTypeEnum;
}

export type ExportIdentifierRefIdentifierTypeEnum =
    | "analyticalDashboard"
    | "attribute"
    | "attributeHierarchy"
    | "dashboardPlugin"
    | "dataset"
    | "fact"
    | "aggregatedFact"
    | "label"
    | "metric"
    | "userDataFilter"
    | "exportDefinition"
    | "automation"
    | "automationResult"
    | "memoryItem"
    | "knowledgeRecommendation"
    | "prompt"
    | "visualizationObject"
    | "filterContext"
    | "workspaceSettings"
    | "customApplicationSetting"
    | "workspaceDataFilter"
    | "workspaceDataFilterSetting"
    | "filterView";

/**
 * Export request object describing the export properties and metadata for image exports.
 */
export interface ExportImageExportRequest {
    /**
     * Requested resulting file type.
     */
    format: ExportImageExportRequestFormatEnum;
    /**
     * File name to be used for retrieving the image document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds: Array<string>;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
}

export type ExportImageExportRequestFormatEnum = "PNG";

/**
 * Filter in form of direct MAQL query.
 */
export interface ExportInlineFilterDefinition {
    inline: ExportInlineFilterDefinitionInline;
}

export interface ExportInlineFilterDefinitionInline {
    /**
     * MAQL query representing the filter.
     */
    filter: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
}

/**
 * Metric defined by the raw MAQL query.
 */
export interface ExportInlineMeasureDefinition {
    inline: ExportInlineMeasureDefinitionInline;
}

export interface ExportInlineMeasureDefinitionInline {
    /**
     * MAQL query defining the metric.
     */
    maql: string;
}

/**
 * @type ExportMeasureDefinition
 * Abstract metric definition type
 */
export type ExportMeasureDefinition =
    | ExportArithmeticMeasureDefinition
    | ExportInlineMeasureDefinition
    | ExportPopMeasureDefinition
    | ExportSimpleMeasureDefinition;

/**
 * Metric is a quantity that is calculated from the data.
 */
export interface ExportMeasureItem {
    /**
     * Local identifier of the metric. This can be used to reference the metric in other parts of the execution definition.
     */
    localIdentifier: string;
    definition: ExportMeasureDefinition;
}

/**
 * @type ExportMeasureValueCondition
 * A condition for filtering by measure value. Can be either a comparison or a range condition.
 */
export type ExportMeasureValueCondition = ExportComparisonCondition | ExportRangeCondition;

/**
 * @type ExportMeasureValueFilter
 * Abstract filter definition type filtering by the value of the metric.
 */
export type ExportMeasureValueFilter =
    | ExportComparisonMeasureValueFilter
    | ExportCompoundMeasureValueFilter
    | ExportRangeMeasureValueFilter;

/**
 * Filter able to limit element values by label and related selected negated elements.
 */
export interface ExportNegativeAttributeFilter {
    negativeAttributeFilter: ExportNegativeAttributeFilterNegativeAttributeFilter;
}

export interface ExportNegativeAttributeFilterNegativeAttributeFilter {
    notIn: ExportAttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: ExportAfmIdentifier;
}

export interface ExportOver {
    attributes: Array<ExportIdentifierRef>;
}

/**
 * Custom CSS styles for the table. (PDF, HTML)
 */
export interface ExportPdfTableStyle {
    /**
     * CSS selector where to apply given properties.
     */
    selector: string;
    /**
     * List of CSS properties.
     */
    properties?: Array<ExportPdfTableStyleProperty>;
}

/**
 * CSS property.
 */
export interface ExportPdfTableStyleProperty {
    /**
     * CSS property key.
     */
    key: string;
    /**
     * CSS property value.
     */
    value: string;
}

/**
 * Combination of the date data set to use and how many periods ago to calculate the previous period for.
 */
export interface ExportPopDataset {
    dataset: ExportAfmObjectIdentifierDataset;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}

/**
 * Previous period type of metric.
 */
export interface ExportPopDatasetMeasureDefinition {
    previousPeriodMeasure: ExportPopDatasetMeasureDefinitionPreviousPeriodMeasure;
}

export interface ExportPopDatasetMeasureDefinitionPreviousPeriodMeasure {
    measureIdentifier: ExportAfmLocalIdentifier;
    /**
     * Specification of which date data sets to use for determining the period to calculate the previous period for.
     */
    dateDatasets: Array<ExportPopDataset>;
}

/**
 * Combination of the date attribute to use and how many periods ago to calculate the PoP for.
 */
export interface ExportPopDate {
    attribute: ExportAfmObjectIdentifierAttribute;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}

/**
 * Period over period type of metric.
 */
export interface ExportPopDateMeasureDefinition {
    overPeriodMeasure: ExportPopDateMeasureDefinitionOverPeriodMeasure;
}

export interface ExportPopDateMeasureDefinitionOverPeriodMeasure {
    measureIdentifier: ExportAfmLocalIdentifier;
    /**
     * Attributes to use for determining the period to calculate the PoP for.
     */
    dateAttributes: Array<ExportPopDate>;
}

/**
 * @type ExportPopMeasureDefinition
 */
export type ExportPopMeasureDefinition = ExportPopDatasetMeasureDefinition | ExportPopDateMeasureDefinition;

/**
 * Filter able to limit element values by label and related selected elements.
 */
export interface ExportPositiveAttributeFilter {
    positiveAttributeFilter: ExportPositiveAttributeFilterPositiveAttributeFilter;
}

export interface ExportPositiveAttributeFilterPositiveAttributeFilter {
    in: ExportAttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: ExportAfmIdentifier;
}

/**
 * Condition that checks if the metric value is within a given range.
 */
export interface ExportRangeCondition {
    range: ExportRangeConditionRange;
}

export interface ExportRangeConditionRange {
    operator: ExportRangeConditionRangeOperatorEnum;
    from: number;
    to: number;
}

export type ExportRangeConditionRangeOperatorEnum = "BETWEEN" | "NOT_BETWEEN";

/**
 * Filter the result by comparing specified metric to given range of values.
 */
export interface ExportRangeMeasureValueFilter {
    rangeMeasureValueFilter: ExportRangeMeasureValueFilterRangeMeasureValueFilter;
}

export interface ExportRangeMeasureValueFilterRangeMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<ExportAfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum;
    from: number;
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: ExportAfmIdentifier;
}

export type ExportRangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum = "BETWEEN" | "NOT_BETWEEN";

/**
 * Filter the result on top/bottom N values according to given metric(s).
 */
export interface ExportRankingFilter {
    rankingFilter: ExportRankingFilterRankingFilter;
}

export interface ExportRankingFilterRankingFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<ExportAfmIdentifier>;
    /**
     * References to the metrics to be used when filtering.
     */
    measures: Array<ExportAfmIdentifier>;
    /**
     * The type of ranking to use, TOP or BOTTOM.
     */
    operator: ExportRankingFilterRankingFilterOperatorEnum;
    /**
     * Number of top/bottom values to filter.
     */
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
}

export type ExportRankingFilterRankingFilterOperatorEnum = "TOP" | "BOTTOM";

/**
 * Custom label object override.
 */
export interface ExportRawCustomLabel {
    /**
     * Override value.
     */
    title: string;
}

/**
 * Custom metric object override.
 */
export interface ExportRawCustomMetric {
    /**
     * Metric title override.
     */
    title: string;
}

/**
 * Custom cell value overrides (IDs will be replaced with specified values).
 */
export interface ExportRawCustomOverride {
    /**
     * Map of CustomLabels with keys used as placeholders in export result.
     */
    labels?: { [key: string]: ExportRawCustomLabel };
    /**
     * Map of CustomMetrics with keys used as placeholders in export result.
     */
    metrics?: { [key: string]: ExportRawCustomMetric };
}

/**
 * Export request object describing the export properties and overrides for raw exports.
 */
export interface ExportRawExportRequest {
    /**
     * Requested resulting file type.
     */
    format: ExportRawExportRequestFormatEnum;
    execution: ExportAFM;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    customOverride?: ExportRawCustomOverride;
    executionSettings?: ExportExecutionSettings;
    /**
     * Set column delimiter. (CSV)
     */
    delimiter?: string;
}

export type ExportRawExportRequestFormatEnum = "ARROW_FILE" | "ARROW_STREAM" | "CSV";

export interface ExportRelativeBoundedDateFilter {
    granularity: ExportRelativeBoundedDateFilterGranularityEnum;
    from?: number;
    to?: number;
}

export type ExportRelativeBoundedDateFilterGranularityEnum =
    | "ALL_TIME_GRANULARITY"
    | "GDC.time.year"
    | "GDC.time.week_us"
    | "GDC.time.week_in_year"
    | "GDC.time.week_in_quarter"
    | "GDC.time.week"
    | "GDC.time.euweek_in_year"
    | "GDC.time.euweek_in_quarter"
    | "GDC.time.quarter"
    | "GDC.time.quarter_in_year"
    | "GDC.time.month"
    | "GDC.time.month_in_quarter"
    | "GDC.time.month_in_year"
    | "GDC.time.day_in_year"
    | "GDC.time.day_in_quarter"
    | "GDC.time.day_in_month"
    | "GDC.time.day_in_week"
    | "GDC.time.day_in_euweek"
    | "GDC.time.date"
    | "GDC.time.hour"
    | "GDC.time.hour_in_day"
    | "GDC.time.minute"
    | "GDC.time.minute_in_hour"
    | "GDC.time.fiscal_month"
    | "GDC.time.fiscal_quarter"
    | "GDC.time.fiscal_year";

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension. The \'from\' and \'to\' properties mark the boundaries of the interval. If \'from\' is omitted, all values earlier than \'to\' are included. If \'to\' is omitted, all values later than \'from\' are included. It is not allowed to omit both.
 */
export interface ExportRelativeDateFilter {
    relativeDateFilter: ExportRelativeDateFilterRelativeDateFilter;
}

export interface ExportRelativeDateFilterRelativeDateFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: ExportRelativeDateFilterRelativeDateFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     */
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    boundedFilter?: ExportBoundedFilter;
    /**
     * If true, rows with undefined (NULL) date values will be included in the result. The filter becomes: (date_condition) OR (date IS NULL). If false or not set, standard behavior applies (NULLs excluded by the date condition).
     */
    includeEmptyValues?: boolean;
    dataset: ExportAfmObjectIdentifierDataset;
}

export type ExportRelativeDateFilterRelativeDateFilterGranularityEnum =
    | "MINUTE"
    | "HOUR"
    | "DAY"
    | "WEEK"
    | "MONTH"
    | "QUARTER"
    | "YEAR"
    | "MINUTE_OF_HOUR"
    | "HOUR_OF_DAY"
    | "DAY_OF_WEEK"
    | "DAY_OF_MONTH"
    | "DAY_OF_QUARTER"
    | "DAY_OF_YEAR"
    | "WEEK_OF_YEAR"
    | "MONTH_OF_YEAR"
    | "QUARTER_OF_YEAR"
    | "FISCAL_MONTH"
    | "FISCAL_QUARTER"
    | "FISCAL_YEAR";

/**
 * Additional settings.
 */
export interface ExportSettings {
    /**
     * If true, the export will contain the information about the export – exported date, filters, etc. Works only with `visualizationObject`. (XLSX, PDF)
     */
    exportInfo?: boolean;
    /**
     * Merge equal headers in neighbouring cells. (XLSX)
     */
    mergeHeaders?: boolean;
    /**
     * Print applied filters on top of the document. (PDF/HTML when visualizationObject is given)
     * @deprecated
     */
    showFilters?: boolean;
    /**
     * Page size and orientation. (PDF)
     * @deprecated
     */
    pdfPageSize?: string;
    /**
     * Custom CSS styles for the table. (PDF, HTML)
     * @deprecated
     */
    pdfTableStyle?: Array<ExportPdfTableStyle>;
    /**
     * Top left header content. (PDF)
     * @deprecated
     */
    pdfTopLeftContent?: string;
    /**
     * Top right header content. (PDF)
     * @deprecated
     */
    pdfTopRightContent?: string;
    /**
     * Set page size. (PDF)
     */
    pageSize?: ExportSettingsPageSizeEnum;
    /**
     * Set page orientation. (PDF)
     */
    pageOrientation?: ExportSettingsPageOrientationEnum;
    /**
     * Set column delimiter. (CSV)
     */
    delimiter?: string;
}

export type ExportSettingsPageSizeEnum = "A3" | "A4" | "LETTER";
export type ExportSettingsPageOrientationEnum = "PORTRAIT" | "LANDSCAPE";

/**
 * Metric defined by referencing a MAQL metric or an LDM fact object with aggregation.
 */
export interface ExportSimpleMeasureDefinition {
    measure: ExportSimpleMeasureDefinitionMeasure;
}

export interface ExportSimpleMeasureDefinitionMeasure {
    item: ExportAfmObjectIdentifierCore;
    /**
     * Definition of aggregation type of the metric.
     */
    aggregation?: ExportSimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true, compute the percentage of given metric values (broken down by AFM attributes) to the total (not broken down).
     */
    computeRatio?: boolean;
    /**
     * Metrics can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     */
    filters?: Array<ExportFilterDefinitionForSimpleMeasure>;
}

export type ExportSimpleMeasureDefinitionMeasureAggregationEnum =
    | "SUM"
    | "COUNT"
    | "AVG"
    | "MIN"
    | "MAX"
    | "MEDIAN"
    | "RUNSUM"
    | "APPROXIMATE_COUNT";

/**
 * Export request object describing the export properties and metadata for slides exports.
 */
export interface ExportSlidesExportRequest {
    /**
     * Requested resulting file type.
     */
    format: ExportSlidesExportRequestFormatEnum;
    /**
     * File name to be used for retrieving the pdf document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId?: string;
    /**
     * List of widget identifiers to be exported. Note that only one widget is currently supported.
     */
    widgetIds?: Array<string>;
    /**
     * List of visualization ids to be exported. Note that only one visualization is currently supported.
     */
    visualizationIds?: Array<string>;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
    /**
     * Export template identifier.
     */
    templateId?: string | null;
}

export type ExportSlidesExportRequestFormatEnum = "PDF" | "PPTX";

/**
 * Export request object describing the export properties and overrides for tabular exports.
 */
export interface ExportTabularExportRequest {
    /**
     * Expected file format.
     */
    format: ExportTabularExportRequestFormatEnum;
    /**
     * Execution result identifier.
     */
    executionResult?: string;
    /**
     * Filename of downloaded file without extension.
     */
    fileName: string;
    settings?: ExportSettings;
    customOverride?: ExportCustomOverride;
    /**
     * Visualization object identifier. Alternative to executionResult property.
     */
    visualizationObject?: string;
    /**
     * Optional custom filters (as array of IFilter objects defined in UI SDK) to be applied when visualizationObject is given. Those filters override the original filters defined in the visualization.
     */
    visualizationObjectCustomFilters?: Array<object>;
    /**
     * Analytical dashboard identifier. Optional identifier, which informs the system that the export is related to a specific dashboard.
     */
    relatedDashboardId?: string;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object | null;
}

export type ExportTabularExportRequestFormatEnum = "CSV" | "XLSX" | "HTML" | "PDF";

/**
 * Export request object describing the export properties and metadata for dashboard PDF exports.
 */
export interface ExportVisualExportRequest {
    /**
     * File name to be used for retrieving the pdf document.
     */
    fileName: string;
    /**
     * Dashboard identifier
     */
    dashboardId: string;
    /**
     * Metadata definition in free-form JSON format.
     */
    metadata?: object;
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create dashboard tabular export request
 * @param {string} workspaceId
 * @param {string} dashboardId
 * @param {ExportDashboardTabularExportRequest} exportDashboardTabularExportRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_CreateDashboardExportRequest(
    workspaceId: string,
    dashboardId: string,
    exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createDashboardExportRequest", "workspaceId", workspaceId);
    // verify required parameter 'dashboardId' is not null or undefined
    assertParamExists("createDashboardExportRequest", "dashboardId", dashboardId);
    // verify required parameter 'exportDashboardTabularExportRequest' is not null or undefined
    assertParamExists(
        "createDashboardExportRequest",
        "exportDashboardTabularExportRequest",
        exportDashboardTabularExportRequest,
    );
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/export/tabular`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportDashboardTabularExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
              exportDashboardTabularExportRequest !== undefined ? exportDashboardTabularExportRequest : {},
          )
        : exportDashboardTabularExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create image export request
 * @param {string} workspaceId
 * @param {ExportImageExportRequest} exportImageExportRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_CreateImageExport(
    workspaceId: string,
    exportImageExportRequest: ExportImageExportRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createImageExport", "workspaceId", workspaceId);
    // verify required parameter 'exportImageExportRequest' is not null or undefined
    assertParamExists("createImageExport", "exportImageExportRequest", exportImageExportRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportImageExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(exportImageExportRequest !== undefined ? exportImageExportRequest : {})
        : exportImageExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary Create visual - pdf export request
 * @param {string} workspaceId
 * @param {ExportVisualExportRequest} exportVisualExportRequest
 * @param {boolean} [xGdcDebug]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_CreatePdfExport(
    workspaceId: string,
    exportVisualExportRequest: ExportVisualExportRequest,
    xGdcDebug?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createPdfExport", "workspaceId", workspaceId);
    // verify required parameter 'exportVisualExportRequest' is not null or undefined
    assertParamExists("createPdfExport", "exportVisualExportRequest", exportVisualExportRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (xGdcDebug !== undefined && xGdcDebug !== null) {
        localVarHeaderParameter["X-Gdc-Debug"] = String(JSON.stringify(xGdcDebug));
    }

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportVisualExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(exportVisualExportRequest !== undefined ? exportVisualExportRequest : {})
        : exportVisualExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create raw export request
 * @param {string} workspaceId
 * @param {ExportRawExportRequest} exportRawExportRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_CreateRawExport(
    workspaceId: string,
    exportRawExportRequest: ExportRawExportRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createRawExport", "workspaceId", workspaceId);
    // verify required parameter 'exportRawExportRequest' is not null or undefined
    assertParamExists("createRawExport", "exportRawExportRequest", exportRawExportRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportRawExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(exportRawExportRequest !== undefined ? exportRawExportRequest : {})
        : exportRawExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create slides export request
 * @param {string} workspaceId
 * @param {ExportSlidesExportRequest} exportSlidesExportRequest
 * @param {boolean} [xGdcDebug]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_CreateSlidesExport(
    workspaceId: string,
    exportSlidesExportRequest: ExportSlidesExportRequest,
    xGdcDebug?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createSlidesExport", "workspaceId", workspaceId);
    // verify required parameter 'exportSlidesExportRequest' is not null or undefined
    assertParamExists("createSlidesExport", "exportSlidesExportRequest", exportSlidesExportRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (xGdcDebug !== undefined && xGdcDebug !== null) {
        localVarHeaderParameter["X-Gdc-Debug"] = String(JSON.stringify(xGdcDebug));
    }

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportSlidesExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(exportSlidesExportRequest !== undefined ? exportSlidesExportRequest : {})
        : exportSlidesExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary Create tabular export request
 * @param {string} workspaceId
 * @param {ExportTabularExportRequest} exportTabularExportRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_CreateTabularExport(
    workspaceId: string,
    exportTabularExportRequest: ExportTabularExportRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createTabularExport", "workspaceId", workspaceId);
    // verify required parameter 'exportTabularExportRequest' is not null or undefined
    assertParamExists("createTabularExport", "exportTabularExportRequest", exportTabularExportRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportTabularExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(exportTabularExportRequest !== undefined ? exportTabularExportRequest : {})
        : exportTabularExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
 * @summary Retrieve exported files
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_GetExportedFile(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getExportedFile", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getExportedFile", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_GetImageExport(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getImageExport", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getImageExport", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
 * @summary (EXPERIMENTAL) Retrieve metadata context
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_GetImageExportMetadata(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getImageExportMetadata", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getImageExportMetadata", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}/metadata`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
 * @summary Retrieve metadata context
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_GetMetadata(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getMetadata", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getMetadata", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}/metadata`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_GetRawExport(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getRawExport", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getRawExport", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw/{exportId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_GetSlidesExport(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getSlidesExport", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getSlidesExport", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
 * @summary (EXPERIMENTAL) Retrieve metadata context
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_GetSlidesExportMetadata(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getSlidesExportMetadata", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getSlidesExportMetadata", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}/metadata`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport FP - ActionsExportAxiosParamCreator
/**
 * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary Retrieve exported files
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExportAxiosParamCreator_GetTabularExport(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getTabularExport", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getTabularExport", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular/{exportId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create dashboard tabular export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_CreateDashboardExportRequest(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportCreateDashboardExportRequestRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_CreateDashboardExportRequest(
        requestParameters.workspaceId,
        requestParameters.dashboardId,
        requestParameters.exportDashboardTabularExportRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create image export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportCreateImageExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_CreateImageExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportCreateImageExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_CreateImageExport(
        requestParameters.workspaceId,
        requestParameters.exportImageExportRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary Create visual - pdf export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportCreatePdfExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_CreatePdfExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportCreatePdfExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_CreatePdfExport(
        requestParameters.workspaceId,
        requestParameters.exportVisualExportRequest,
        requestParameters.xGdcDebug,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create raw export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportCreateRawExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_CreateRawExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportCreateRawExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_CreateRawExport(
        requestParameters.workspaceId,
        requestParameters.exportRawExportRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create slides export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportCreateSlidesExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_CreateSlidesExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportCreateSlidesExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_CreateSlidesExport(
        requestParameters.workspaceId,
        requestParameters.exportSlidesExportRequest,
        requestParameters.xGdcDebug,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary Create tabular export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportCreateTabularExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_CreateTabularExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportCreateTabularExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_CreateTabularExport(
        requestParameters.workspaceId,
        requestParameters.exportTabularExportRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
 * @summary Retrieve exported files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportGetExportedFileRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_GetExportedFile(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportGetExportedFileRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_GetExportedFile(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportGetImageExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_GetImageExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportGetImageExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_GetImageExport(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
 * @summary (EXPERIMENTAL) Retrieve metadata context
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportGetImageExportMetadataRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_GetImageExportMetadata(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportGetImageExportMetadataRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_GetImageExportMetadata(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
 * @summary Retrieve metadata context
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportGetMetadataRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_GetMetadata(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportGetMetadataRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_GetMetadata(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportGetRawExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_GetRawExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportGetRawExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_GetRawExport(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportGetSlidesExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_GetSlidesExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportGetSlidesExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_GetSlidesExport(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
 * @summary (EXPERIMENTAL) Retrieve metadata context
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_GetSlidesExportMetadata(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportGetSlidesExportMetadataRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_GetSlidesExportMetadata(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsExport Api FP
/**
 * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary Retrieve exported files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsExportGetTabularExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsExport_GetTabularExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsExportGetTabularExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await ActionsExportAxiosParamCreator_GetTabularExport(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * ActionsExport - interface
 * @export
 * @interface ActionsExport
 */
export interface ActionsExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {ActionsExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createDashboardExportRequest(
        requestParameters: ActionsExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ActionsExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createImageExport(
        requestParameters: ActionsExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {ActionsExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createPdfExport(
        requestParameters: ActionsExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {ActionsExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createRawExport(
        requestParameters: ActionsExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {ActionsExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createSlidesExport(
        requestParameters: ActionsExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {ActionsExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    createTabularExport(
        requestParameters: ActionsExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {ActionsExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getExportedFile(
        requestParameters: ActionsExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getImageExport(
        requestParameters: ActionsExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getImageExportMetadata(
        requestParameters: ActionsExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {ActionsExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getMetadata(
        requestParameters: ActionsExportGetMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getRawExport(
        requestParameters: ActionsExportGetRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getSlidesExport(
        requestParameters: ActionsExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getSlidesExportMetadata(
        requestParameters: ActionsExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {ActionsExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExportInterface
     */
    getTabularExport(
        requestParameters: ActionsExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;
}

/**
 * Request parameters for createDashboardExportRequest operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateDashboardExportRequestRequest
 */
export interface ActionsExportCreateDashboardExportRequestRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateDashboardExportRequest
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateDashboardExportRequest
     */
    readonly dashboardId: string;

    /**
     *
     * @type {ExportDashboardTabularExportRequest}
     * @memberof ActionsExportCreateDashboardExportRequest
     */
    readonly exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest;
}

/**
 * Request parameters for createImageExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateImageExportRequest
 */
export interface ActionsExportCreateImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportImageExportRequest}
     * @memberof ActionsExportCreateImageExport
     */
    readonly exportImageExportRequest: ExportImageExportRequest;
}

/**
 * Request parameters for createPdfExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreatePdfExportRequest
 */
export interface ActionsExportCreatePdfExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreatePdfExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportVisualExportRequest}
     * @memberof ActionsExportCreatePdfExport
     */
    readonly exportVisualExportRequest: ExportVisualExportRequest;

    /**
     *
     * @type {boolean}
     * @memberof ActionsExportCreatePdfExport
     */
    readonly xGdcDebug?: boolean;
}

/**
 * Request parameters for createRawExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateRawExportRequest
 */
export interface ActionsExportCreateRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportRawExportRequest}
     * @memberof ActionsExportCreateRawExport
     */
    readonly exportRawExportRequest: ExportRawExportRequest;
}

/**
 * Request parameters for createSlidesExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateSlidesExportRequest
 */
export interface ActionsExportCreateSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportSlidesExportRequest}
     * @memberof ActionsExportCreateSlidesExport
     */
    readonly exportSlidesExportRequest: ExportSlidesExportRequest;

    /**
     *
     * @type {boolean}
     * @memberof ActionsExportCreateSlidesExport
     */
    readonly xGdcDebug?: boolean;
}

/**
 * Request parameters for createTabularExport operation in ActionsExport.
 * @export
 * @interface ActionsExportCreateTabularExportRequest
 */
export interface ActionsExportCreateTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportCreateTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportTabularExportRequest}
     * @memberof ActionsExportCreateTabularExport
     */
    readonly exportTabularExportRequest: ExportTabularExportRequest;
}

/**
 * Request parameters for getExportedFile operation in ActionsExport.
 * @export
 * @interface ActionsExportGetExportedFileRequest
 */
export interface ActionsExportGetExportedFileRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetExportedFile
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetExportedFile
     */
    readonly exportId: string;
}

/**
 * Request parameters for getImageExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetImageExportRequest
 */
export interface ActionsExportGetImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getImageExportMetadata operation in ActionsExport.
 * @export
 * @interface ActionsExportGetImageExportMetadataRequest
 */
export interface ActionsExportGetImageExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetImageExportMetadata
     */
    readonly exportId: string;
}

/**
 * Request parameters for getMetadata operation in ActionsExport.
 * @export
 * @interface ActionsExportGetMetadataRequest
 */
export interface ActionsExportGetMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetMetadata
     */
    readonly exportId: string;
}

/**
 * Request parameters for getRawExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetRawExportRequest
 */
export interface ActionsExportGetRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetRawExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getSlidesExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetSlidesExportRequest
 */
export interface ActionsExportGetSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getSlidesExportMetadata operation in ActionsExport.
 * @export
 * @interface ActionsExportGetSlidesExportMetadataRequest
 */
export interface ActionsExportGetSlidesExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetSlidesExportMetadata
     */
    readonly exportId: string;
}

/**
 * Request parameters for getTabularExport operation in ActionsExport.
 * @export
 * @interface ActionsExportGetTabularExportRequest
 */
export interface ActionsExportGetTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsExportGetTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsExportGetTabularExport
     */
    readonly exportId: string;
}

/**
 * ActionsExport - object-oriented interface
 * @export
 * @class ActionsExport
 * @extends {BaseAPI}
 */
export class ActionsExport extends BaseAPI implements ActionsExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {ActionsExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createDashboardExportRequest(
        requestParameters: ActionsExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_CreateDashboardExportRequest(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ActionsExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createImageExport(
        requestParameters: ActionsExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_CreateImageExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {ActionsExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createPdfExport(
        requestParameters: ActionsExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_CreatePdfExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {ActionsExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createRawExport(
        requestParameters: ActionsExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_CreateRawExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {ActionsExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createSlidesExport(
        requestParameters: ActionsExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_CreateSlidesExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {ActionsExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public createTabularExport(
        requestParameters: ActionsExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_CreateTabularExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {ActionsExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getExportedFile(
        requestParameters: ActionsExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_GetExportedFile(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getImageExport(
        requestParameters: ActionsExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_GetImageExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getImageExportMetadata(
        requestParameters: ActionsExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_GetImageExportMetadata(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {ActionsExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getMetadata(requestParameters: ActionsExportGetMetadataRequest, options?: AxiosRequestConfig) {
        return ActionsExport_GetMetadata(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getRawExport(requestParameters: ActionsExportGetRawExportRequest, options?: AxiosRequestConfig) {
        return ActionsExport_GetRawExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ActionsExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getSlidesExport(
        requestParameters: ActionsExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_GetSlidesExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ActionsExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getSlidesExportMetadata(
        requestParameters: ActionsExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_GetSlidesExportMetadata(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {ActionsExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsExport
     */
    public getTabularExport(
        requestParameters: ActionsExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsExport_GetTabularExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}

// ImageExportExport FP - ImageExportExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create image export request
 * @param {string} workspaceId
 * @param {ExportImageExportRequest} exportImageExportRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ImageExportExportAxiosParamCreator_CreateImageExport(
    workspaceId: string,
    exportImageExportRequest: ExportImageExportRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createImageExport", "workspaceId", workspaceId);
    // verify required parameter 'exportImageExportRequest' is not null or undefined
    assertParamExists("createImageExport", "exportImageExportRequest", exportImageExportRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportImageExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(exportImageExportRequest !== undefined ? exportImageExportRequest : {})
        : exportImageExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ImageExportExport FP - ImageExportExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ImageExportExportAxiosParamCreator_GetImageExport(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getImageExport", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getImageExport", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ImageExportExport FP - ImageExportExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
 * @summary (EXPERIMENTAL) Retrieve metadata context
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ImageExportExportAxiosParamCreator_GetImageExportMetadata(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getImageExportMetadata", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getImageExportMetadata", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/image/{exportId}/metadata`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ImageExportExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create image export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ImageExportExportCreateImageExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ImageExportExport_CreateImageExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ImageExportExportCreateImageExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await ImageExportExportAxiosParamCreator_CreateImageExport(
        requestParameters.workspaceId,
        requestParameters.exportImageExportRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ImageExportExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ImageExportExportGetImageExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ImageExportExport_GetImageExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ImageExportExportGetImageExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await ImageExportExportAxiosParamCreator_GetImageExport(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ImageExportExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
 * @summary (EXPERIMENTAL) Retrieve metadata context
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ImageExportExportGetImageExportMetadataRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ImageExportExport_GetImageExportMetadata(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ImageExportExportGetImageExportMetadataRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await ImageExportExportAxiosParamCreator_GetImageExportMetadata(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * ImageExportExport - interface
 * @export
 * @interface ImageExportExport
 */
export interface ImageExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ImageExportExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExportInterface
     */
    createImageExport(
        requestParameters: ImageExportExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ImageExportExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExportInterface
     */
    getImageExport(
        requestParameters: ImageExportExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ImageExportExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExportInterface
     */
    getImageExportMetadata(
        requestParameters: ImageExportExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createImageExport operation in ImageExportExport.
 * @export
 * @interface ImageExportExportCreateImageExportRequest
 */
export interface ImageExportExportCreateImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ImageExportExportCreateImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportImageExportRequest}
     * @memberof ImageExportExportCreateImageExport
     */
    readonly exportImageExportRequest: ExportImageExportRequest;
}

/**
 * Request parameters for getImageExport operation in ImageExportExport.
 * @export
 * @interface ImageExportExportGetImageExportRequest
 */
export interface ImageExportExportGetImageExportRequest {
    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getImageExportMetadata operation in ImageExportExport.
 * @export
 * @interface ImageExportExportGetImageExportMetadataRequest
 */
export interface ImageExportExportGetImageExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ImageExportExportGetImageExportMetadata
     */
    readonly exportId: string;
}

/**
 * ImageExportExport - object-oriented interface
 * @export
 * @class ImageExportExport
 * @extends {BaseAPI}
 */
export class ImageExportExport extends BaseAPI implements ImageExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. An image export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create image export request
     * @param {ImageExportExportCreateImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExport
     */
    public createImageExport(
        requestParameters: ImageExportExportCreateImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ImageExportExport_CreateImageExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {ImageExportExportGetImageExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExport
     */
    public getImageExport(
        requestParameters: ImageExportExportGetImageExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ImageExportExport_GetImageExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/image endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {ImageExportExportGetImageExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageExportExport
     */
    public getImageExportMetadata(
        requestParameters: ImageExportExportGetImageExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ImageExportExport_GetImageExportMetadata(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}

// RawExportExport FP - RawExportExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create raw export request
 * @param {string} workspaceId
 * @param {ExportRawExportRequest} exportRawExportRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function RawExportExportAxiosParamCreator_CreateRawExport(
    workspaceId: string,
    exportRawExportRequest: ExportRawExportRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createRawExport", "workspaceId", workspaceId);
    // verify required parameter 'exportRawExportRequest' is not null or undefined
    assertParamExists("createRawExport", "exportRawExportRequest", exportRawExportRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportRawExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(exportRawExportRequest !== undefined ? exportRawExportRequest : {})
        : exportRawExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// RawExportExport FP - RawExportExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function RawExportExportAxiosParamCreator_GetRawExport(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getRawExport", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getRawExport", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/raw/{exportId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// RawExportExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create raw export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {RawExportExportCreateRawExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function RawExportExport_CreateRawExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: RawExportExportCreateRawExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await RawExportExportAxiosParamCreator_CreateRawExport(
        requestParameters.workspaceId,
        requestParameters.exportRawExportRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// RawExportExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {RawExportExportGetRawExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function RawExportExport_GetRawExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: RawExportExportGetRawExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await RawExportExportAxiosParamCreator_GetRawExport(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * RawExportExport - interface
 * @export
 * @interface RawExportExport
 */
export interface RawExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {RawExportExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExportInterface
     */
    createRawExport(
        requestParameters: RawExportExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {RawExportExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExportInterface
     */
    getRawExport(
        requestParameters: RawExportExportGetRawExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;
}

/**
 * Request parameters for createRawExport operation in RawExportExport.
 * @export
 * @interface RawExportExportCreateRawExportRequest
 */
export interface RawExportExportCreateRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof RawExportExportCreateRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportRawExportRequest}
     * @memberof RawExportExportCreateRawExport
     */
    readonly exportRawExportRequest: ExportRawExportRequest;
}

/**
 * Request parameters for getRawExport operation in RawExportExport.
 * @export
 * @interface RawExportExportGetRawExportRequest
 */
export interface RawExportExportGetRawExportRequest {
    /**
     *
     * @type {string}
     * @memberof RawExportExportGetRawExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof RawExportExportGetRawExport
     */
    readonly exportId: string;
}

/**
 * RawExportExport - object-oriented interface
 * @export
 * @class RawExportExport
 * @extends {BaseAPI}
 */
export class RawExportExport extends BaseAPI implements RawExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An raw export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create raw export request
     * @param {RawExportExportCreateRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExport
     */
    public createRawExport(
        requestParameters: RawExportExportCreateRawExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return RawExportExport_CreateRawExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {RawExportExportGetRawExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RawExportExport
     */
    public getRawExport(requestParameters: RawExportExportGetRawExportRequest, options?: AxiosRequestConfig) {
        return RawExportExport_GetRawExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}

// SlidesExportExport FP - SlidesExportExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create slides export request
 * @param {string} workspaceId
 * @param {ExportSlidesExportRequest} exportSlidesExportRequest
 * @param {boolean} [xGdcDebug]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SlidesExportExportAxiosParamCreator_CreateSlidesExport(
    workspaceId: string,
    exportSlidesExportRequest: ExportSlidesExportRequest,
    xGdcDebug?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createSlidesExport", "workspaceId", workspaceId);
    // verify required parameter 'exportSlidesExportRequest' is not null or undefined
    assertParamExists("createSlidesExport", "exportSlidesExportRequest", exportSlidesExportRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (xGdcDebug !== undefined && xGdcDebug !== null) {
        localVarHeaderParameter["X-Gdc-Debug"] = String(JSON.stringify(xGdcDebug));
    }

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportSlidesExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(exportSlidesExportRequest !== undefined ? exportSlidesExportRequest : {})
        : exportSlidesExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SlidesExportExport FP - SlidesExportExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SlidesExportExportAxiosParamCreator_GetSlidesExport(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getSlidesExport", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getSlidesExport", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SlidesExportExport FP - SlidesExportExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
 * @summary (EXPERIMENTAL) Retrieve metadata context
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SlidesExportExportAxiosParamCreator_GetSlidesExportMetadata(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getSlidesExportMetadata", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getSlidesExportMetadata", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/slides/{exportId}/metadata`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SlidesExportExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create slides export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SlidesExportExportCreateSlidesExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SlidesExportExport_CreateSlidesExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SlidesExportExportCreateSlidesExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await SlidesExportExportAxiosParamCreator_CreateSlidesExport(
        requestParameters.workspaceId,
        requestParameters.exportSlidesExportRequest,
        requestParameters.xGdcDebug,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SlidesExportExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary (EXPERIMENTAL) Retrieve exported files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SlidesExportExportGetSlidesExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SlidesExportExport_GetSlidesExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SlidesExportExportGetSlidesExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await SlidesExportExportAxiosParamCreator_GetSlidesExport(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SlidesExportExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
 * @summary (EXPERIMENTAL) Retrieve metadata context
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SlidesExportExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SlidesExportExport_GetSlidesExportMetadata(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SlidesExportExportGetSlidesExportMetadataRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await SlidesExportExportAxiosParamCreator_GetSlidesExportMetadata(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * SlidesExportExport - interface
 * @export
 * @interface SlidesExportExport
 */
export interface SlidesExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {SlidesExportExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExportInterface
     */
    createSlidesExport(
        requestParameters: SlidesExportExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {SlidesExportExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExportInterface
     */
    getSlidesExport(
        requestParameters: SlidesExportExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {SlidesExportExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExportInterface
     */
    getSlidesExportMetadata(
        requestParameters: SlidesExportExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createSlidesExport operation in SlidesExportExport.
 * @export
 * @interface SlidesExportExportCreateSlidesExportRequest
 */
export interface SlidesExportExportCreateSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof SlidesExportExportCreateSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportSlidesExportRequest}
     * @memberof SlidesExportExportCreateSlidesExport
     */
    readonly exportSlidesExportRequest: ExportSlidesExportRequest;

    /**
     *
     * @type {boolean}
     * @memberof SlidesExportExportCreateSlidesExport
     */
    readonly xGdcDebug?: boolean;
}

/**
 * Request parameters for getSlidesExport operation in SlidesExportExport.
 * @export
 * @interface SlidesExportExportGetSlidesExportRequest
 */
export interface SlidesExportExportGetSlidesExportRequest {
    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExport
     */
    readonly exportId: string;
}

/**
 * Request parameters for getSlidesExportMetadata operation in SlidesExportExport.
 * @export
 * @interface SlidesExportExportGetSlidesExportMetadataRequest
 */
export interface SlidesExportExportGetSlidesExportMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExportMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof SlidesExportExportGetSlidesExportMetadata
     */
    readonly exportId: string;
}

/**
 * SlidesExportExport - object-oriented interface
 * @export
 * @class SlidesExportExport
 * @extends {BaseAPI}
 */
export class SlidesExportExport extends BaseAPI implements SlidesExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. A slides export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create slides export request
     * @param {SlidesExportExportCreateSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExport
     */
    public createSlidesExport(
        requestParameters: SlidesExportExportCreateSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return SlidesExportExport_CreateSlidesExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary (EXPERIMENTAL) Retrieve exported files
     * @param {SlidesExportExportGetSlidesExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExport
     */
    public getSlidesExport(
        requestParameters: SlidesExportExportGetSlidesExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return SlidesExportExport_GetSlidesExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly. This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/slides endpoint. The metadata structure is not verified.
     * @summary (EXPERIMENTAL) Retrieve metadata context
     * @param {SlidesExportExportGetSlidesExportMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SlidesExportExport
     */
    public getSlidesExportMetadata(
        requestParameters: SlidesExportExportGetSlidesExportMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return SlidesExportExport_GetSlidesExportMetadata(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}

// TabularExportExport FP - TabularExportExportAxiosParamCreator
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create dashboard tabular export request
 * @param {string} workspaceId
 * @param {string} dashboardId
 * @param {ExportDashboardTabularExportRequest} exportDashboardTabularExportRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function TabularExportExportAxiosParamCreator_CreateDashboardExportRequest(
    workspaceId: string,
    dashboardId: string,
    exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createDashboardExportRequest", "workspaceId", workspaceId);
    // verify required parameter 'dashboardId' is not null or undefined
    assertParamExists("createDashboardExportRequest", "dashboardId", dashboardId);
    // verify required parameter 'exportDashboardTabularExportRequest' is not null or undefined
    assertParamExists(
        "createDashboardExportRequest",
        "exportDashboardTabularExportRequest",
        exportDashboardTabularExportRequest,
    );
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/analyticalDashboards/{dashboardId}/export/tabular`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"dashboardId"}}`, encodeURIComponent(String(dashboardId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportDashboardTabularExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(
              exportDashboardTabularExportRequest !== undefined ? exportDashboardTabularExportRequest : {},
          )
        : exportDashboardTabularExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// TabularExportExport FP - TabularExportExportAxiosParamCreator
/**
 * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary Create tabular export request
 * @param {string} workspaceId
 * @param {ExportTabularExportRequest} exportTabularExportRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function TabularExportExportAxiosParamCreator_CreateTabularExport(
    workspaceId: string,
    exportTabularExportRequest: ExportTabularExportRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createTabularExport", "workspaceId", workspaceId);
    // verify required parameter 'exportTabularExportRequest' is not null or undefined
    assertParamExists("createTabularExport", "exportTabularExportRequest", exportTabularExportRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportTabularExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(exportTabularExportRequest !== undefined ? exportTabularExportRequest : {})
        : exportTabularExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// TabularExportExport FP - TabularExportExportAxiosParamCreator
/**
 * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary Retrieve exported files
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function TabularExportExportAxiosParamCreator_GetTabularExport(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getTabularExport", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getTabularExport", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/tabular/{exportId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// TabularExportExport Api FP
/**
 * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary (EXPERIMENTAL) Create dashboard tabular export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {TabularExportExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function TabularExportExport_CreateDashboardExportRequest(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: TabularExportExportCreateDashboardExportRequestRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await TabularExportExportAxiosParamCreator_CreateDashboardExportRequest(
        requestParameters.workspaceId,
        requestParameters.dashboardId,
        requestParameters.exportDashboardTabularExportRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// TabularExportExport Api FP
/**
 * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary Create tabular export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {TabularExportExportCreateTabularExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function TabularExportExport_CreateTabularExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: TabularExportExportCreateTabularExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await TabularExportExportAxiosParamCreator_CreateTabularExport(
        requestParameters.workspaceId,
        requestParameters.exportTabularExportRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// TabularExportExport Api FP
/**
 * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
 * @summary Retrieve exported files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {TabularExportExportGetTabularExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function TabularExportExport_GetTabularExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: TabularExportExportGetTabularExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await TabularExportExportAxiosParamCreator_GetTabularExport(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * TabularExportExport - interface
 * @export
 * @interface TabularExportExport
 */
export interface TabularExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {TabularExportExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExportInterface
     */
    createDashboardExportRequest(
        requestParameters: TabularExportExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {TabularExportExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExportInterface
     */
    createTabularExport(
        requestParameters: TabularExportExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {TabularExportExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExportInterface
     */
    getTabularExport(
        requestParameters: TabularExportExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;
}

/**
 * Request parameters for createDashboardExportRequest operation in TabularExportExport.
 * @export
 * @interface TabularExportExportCreateDashboardExportRequestRequest
 */
export interface TabularExportExportCreateDashboardExportRequestRequest {
    /**
     *
     * @type {string}
     * @memberof TabularExportExportCreateDashboardExportRequest
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof TabularExportExportCreateDashboardExportRequest
     */
    readonly dashboardId: string;

    /**
     *
     * @type {ExportDashboardTabularExportRequest}
     * @memberof TabularExportExportCreateDashboardExportRequest
     */
    readonly exportDashboardTabularExportRequest: ExportDashboardTabularExportRequest;
}

/**
 * Request parameters for createTabularExport operation in TabularExportExport.
 * @export
 * @interface TabularExportExportCreateTabularExportRequest
 */
export interface TabularExportExportCreateTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof TabularExportExportCreateTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportTabularExportRequest}
     * @memberof TabularExportExportCreateTabularExport
     */
    readonly exportTabularExportRequest: ExportTabularExportRequest;
}

/**
 * Request parameters for getTabularExport operation in TabularExportExport.
 * @export
 * @interface TabularExportExportGetTabularExportRequest
 */
export interface TabularExportExportGetTabularExportRequest {
    /**
     *
     * @type {string}
     * @memberof TabularExportExportGetTabularExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof TabularExportExportGetTabularExport
     */
    readonly exportId: string;
}

/**
 * TabularExportExport - object-oriented interface
 * @export
 * @class TabularExportExport
 * @extends {BaseAPI}
 */
export class TabularExportExport extends BaseAPI implements TabularExportExportInterface {
    /**
     * Note: This API is an experimental and is going to change. Please, use it accordingly.An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary (EXPERIMENTAL) Create dashboard tabular export request
     * @param {TabularExportExportCreateDashboardExportRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExport
     */
    public createDashboardExportRequest(
        requestParameters: TabularExportExportCreateDashboardExportRequestRequest,
        options?: AxiosRequestConfig,
    ) {
        return TabularExportExport_CreateDashboardExportRequest(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * An tabular export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create tabular export request
     * @param {TabularExportExportCreateTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExport
     */
    public createTabularExport(
        requestParameters: TabularExportExportCreateTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return TabularExportExport_CreateTabularExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * After clients creates a POST export request, the processing of it will start shortly asynchronously. To retrieve the result, client has to check periodically for the result on this endpoint. In case the result isn\'t ready yet, the service returns 202. If the result is ready, it returns 200 and octet stream of the result file with provided filename.
     * @summary Retrieve exported files
     * @param {TabularExportExportGetTabularExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TabularExportExport
     */
    public getTabularExport(
        requestParameters: TabularExportExportGetTabularExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return TabularExportExport_GetTabularExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}

// VisualExportExport FP - VisualExportExportAxiosParamCreator
/**
 * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary Create visual - pdf export request
 * @param {string} workspaceId
 * @param {ExportVisualExportRequest} exportVisualExportRequest
 * @param {boolean} [xGdcDebug]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function VisualExportExportAxiosParamCreator_CreatePdfExport(
    workspaceId: string,
    exportVisualExportRequest: ExportVisualExportRequest,
    xGdcDebug?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createPdfExport", "workspaceId", workspaceId);
    // verify required parameter 'exportVisualExportRequest' is not null or undefined
    assertParamExists("createPdfExport", "exportVisualExportRequest", exportVisualExportRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (xGdcDebug !== undefined && xGdcDebug !== null) {
        localVarHeaderParameter["X-Gdc-Debug"] = String(JSON.stringify(xGdcDebug));
    }

    const consumes = ["application/json"];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter["Content-Type"] = consumes.includes("application/json")
        ? "application/json"
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof exportVisualExportRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(exportVisualExportRequest !== undefined ? exportVisualExportRequest : {})
        : exportVisualExportRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// VisualExportExport FP - VisualExportExportAxiosParamCreator
/**
 * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
 * @summary Retrieve exported files
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function VisualExportExportAxiosParamCreator_GetExportedFile(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getExportedFile", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getExportedFile", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// VisualExportExport FP - VisualExportExportAxiosParamCreator
/**
 * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
 * @summary Retrieve metadata context
 * @param {string} workspaceId
 * @param {string} exportId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function VisualExportExportAxiosParamCreator_GetMetadata(
    workspaceId: string,
    exportId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getMetadata", "workspaceId", workspaceId);
    // verify required parameter 'exportId' is not null or undefined
    assertParamExists("getMetadata", "exportId", exportId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/export/visual/{exportId}/metadata`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"exportId"}}`, encodeURIComponent(String(exportId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// VisualExportExport Api FP
/**
 * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
 * @summary Create visual - pdf export request
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {VisualExportExportCreatePdfExportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function VisualExportExport_CreatePdfExport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: VisualExportExportCreatePdfExportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExportExportResponse> {
    const localVarAxiosArgs = await VisualExportExportAxiosParamCreator_CreatePdfExport(
        requestParameters.workspaceId,
        requestParameters.exportVisualExportRequest,
        requestParameters.xGdcDebug,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// VisualExportExport Api FP
/**
 * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
 * @summary Retrieve exported files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {VisualExportExportGetExportedFileRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function VisualExportExport_GetExportedFile(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: VisualExportExportGetExportedFileRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await VisualExportExportAxiosParamCreator_GetExportedFile(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// VisualExportExport Api FP
/**
 * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
 * @summary Retrieve metadata context
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {VisualExportExportGetMetadataRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function VisualExportExport_GetMetadata(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: VisualExportExportGetMetadataRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await VisualExportExportAxiosParamCreator_GetMetadata(
        requestParameters.workspaceId,
        requestParameters.exportId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * VisualExportExport - interface
 * @export
 * @interface VisualExportExport
 */
export interface VisualExportExportInterface {
    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {VisualExportExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExportInterface
     */
    createPdfExport(
        requestParameters: VisualExportExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExportExportResponse>;

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {VisualExportExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExportInterface
     */
    getExportedFile(
        requestParameters: VisualExportExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {VisualExportExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExportInterface
     */
    getMetadata(
        requestParameters: VisualExportExportGetMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for createPdfExport operation in VisualExportExport.
 * @export
 * @interface VisualExportExportCreatePdfExportRequest
 */
export interface VisualExportExportCreatePdfExportRequest {
    /**
     *
     * @type {string}
     * @memberof VisualExportExportCreatePdfExport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ExportVisualExportRequest}
     * @memberof VisualExportExportCreatePdfExport
     */
    readonly exportVisualExportRequest: ExportVisualExportRequest;

    /**
     *
     * @type {boolean}
     * @memberof VisualExportExportCreatePdfExport
     */
    readonly xGdcDebug?: boolean;
}

/**
 * Request parameters for getExportedFile operation in VisualExportExport.
 * @export
 * @interface VisualExportExportGetExportedFileRequest
 */
export interface VisualExportExportGetExportedFileRequest {
    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetExportedFile
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetExportedFile
     */
    readonly exportId: string;
}

/**
 * Request parameters for getMetadata operation in VisualExportExport.
 * @export
 * @interface VisualExportExportGetMetadataRequest
 */
export interface VisualExportExportGetMetadataRequest {
    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetMetadata
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof VisualExportExportGetMetadata
     */
    readonly exportId: string;
}

/**
 * VisualExportExport - object-oriented interface
 * @export
 * @class VisualExportExport
 * @extends {BaseAPI}
 */
export class VisualExportExport extends BaseAPI implements VisualExportExportInterface {
    /**
     * An visual export job will be created based on the export request and put to queue to be executed. The result of the operation will be an exportResult identifier that will be assembled by the client into a url that can be polled.
     * @summary Create visual - pdf export request
     * @param {VisualExportExportCreatePdfExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExport
     */
    public createPdfExport(
        requestParameters: VisualExportExportCreatePdfExportRequest,
        options?: AxiosRequestConfig,
    ) {
        return VisualExportExport_CreatePdfExport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns 202 until original POST export request is not processed.Returns 200 with exported data once the export is done.
     * @summary Retrieve exported files
     * @param {VisualExportExportGetExportedFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExport
     */
    public getExportedFile(
        requestParameters: VisualExportExportGetExportedFileRequest,
        options?: AxiosRequestConfig,
    ) {
        return VisualExportExport_GetExportedFile(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * This endpoint serves as a cache for user-defined metadata of the export for the front end UI to retrieve it, if one was created using the POST ../export/visual endpoint. The metadata structure is not verified.
     * @summary Retrieve metadata context
     * @param {VisualExportExportGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VisualExportExport
     */
    public getMetadata(
        requestParameters: VisualExportExportGetMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return VisualExportExport_GetMetadata(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}
