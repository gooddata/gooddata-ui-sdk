// (C) 2024 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Bulk CSV analysis request.
 * @export
 * @interface AnalyzeCsvRequest
 */
export interface AnalyzeCsvRequest {
    /**
     * List of individual CSV analysis requests.
     * @type {Array<AnalyzeCsvRequestItem>}
     * @memberof AnalyzeCsvRequest
     */
    analyzeRequests: Array<AnalyzeCsvRequestItem>;
}
/**
 * CSV analysis request.
 * @export
 * @interface AnalyzeCsvRequestItem
 */
export interface AnalyzeCsvRequestItem {
    /**
     * Location of the CSV file to analyze.
     * @type {string}
     * @memberof AnalyzeCsvRequestItem
     */
    location: string;
    /**
     *
     * @type {AnalyzeCsvRequestItemConfig}
     * @memberof AnalyzeCsvRequestItem
     */
    config?: AnalyzeCsvRequestItemConfig;
}
/**
 * CSV analysis request config.
 * @export
 * @interface AnalyzeCsvRequestItemConfig
 */
export interface AnalyzeCsvRequestItemConfig {
    /**
     * Number of rows to return in the flight that represents analysis result. If 0, no rows are returned, if less than 0, all rows that were in the sample are returned.
     * @type {number}
     * @memberof AnalyzeCsvRequestItemConfig
     */
    resultRows?: number;
    /**
     * Maximum number of rows to work with during header detection.
     * @type {number}
     * @memberof AnalyzeCsvRequestItemConfig
     */
    headerDetectMaxRows?: number;
    /**
     * Number of rows to consider as header, if null, header will be detected.
     * @type {number}
     * @memberof AnalyzeCsvRequestItemConfig
     */
    headerRowCount?: number;
    /**
     * Possible column delimiters.
     * @type {Array<string>}
     * @memberof AnalyzeCsvRequestItemConfig
     */
    delimiters?: Array<string>;
}
/**
 * Describes the results of a CSV analysis of a single file.
 * @export
 * @interface AnalyzeCsvResponse
 */
export interface AnalyzeCsvResponse {
    /**
     * Location of the analyzed file in the source data source.
     * @type {string}
     * @memberof AnalyzeCsvResponse
     */
    location: string;
    /**
     * List of column metadata.
     * @type {Array<AnalyzeCsvResponseColumn>}
     * @memberof AnalyzeCsvResponse
     */
    columns: Array<AnalyzeCsvResponseColumn>;
    /**
     * Preview of the first N rows of the file.
     * @type {Array<Array<object>>}
     * @memberof AnalyzeCsvResponse
     */
    previewData: Array<Array<object>>;
    /**
     *
     * @type {AnalyzeCsvResponseConfig}
     * @memberof AnalyzeCsvResponse
     */
    config?: AnalyzeCsvResponseConfig;
}
/**
 * Describes the result column.
 * @export
 * @interface AnalyzeCsvResponseColumn
 */
export interface AnalyzeCsvResponseColumn {
    /**
     * Name of the column as specified in the file (or autogenerated one if the file has no header).
     * @type {string}
     * @memberof AnalyzeCsvResponseColumn
     */
    name: string;
    /**
     * Type of the column (e.g. string, bool, etc.).
     * @type {string}
     * @memberof AnalyzeCsvResponseColumn
     */
    type: string;
    /**
     * List of date formats that can be used to parse this column as date. Null if there are none.
     * @type {Array<string>}
     * @memberof AnalyzeCsvResponseColumn
     */
    detectedDateFormats?: Array<string>;
}
/**
 * Config used to process the CSV file.
 * @export
 * @interface AnalyzeCsvResponseConfig
 */
export interface AnalyzeCsvResponseConfig {
    /**
     *
     * @type {CsvReadOptions}
     * @memberof AnalyzeCsvResponseConfig
     */
    readOptions?: CsvReadOptions;
    /**
     *
     * @type {CsvParseOptions}
     * @memberof AnalyzeCsvResponseConfig
     */
    parseOptions?: CsvParseOptions;
    /**
     *
     * @type {CsvConvertOptions}
     * @memberof AnalyzeCsvResponseConfig
     */
    convertOptions?: CsvConvertOptions;
}
/**
 * Information about a period in time and how much cached data was removed.
 * @export
 * @interface CacheRemovalInterval
 */
export interface CacheRemovalInterval {
    /**
     * Start timestamp of the removal interval.
     * @type {string}
     * @memberof CacheRemovalInterval
     */
    from: string;
    /**
     * End timestamp of the removal interval.
     * @type {string}
     * @memberof CacheRemovalInterval
     */
    to: string;
    /**
     * Bytes removed during this interval.
     * @type {number}
     * @memberof CacheRemovalInterval
     */
    removed: number;
}
/**
 * Result of scan of data source physical model.
 * @export
 * @interface CacheUsageData
 */
export interface CacheUsageData {
    /**
     *
     * @type {OrganizationCacheUsage}
     * @memberof CacheUsageData
     */
    organizationCacheUsage: OrganizationCacheUsage;
    /**
     * Map of data about the cache usage of the individual workspaces.
     * @type {{ [key: string]: WorkspaceCacheUsage; }}
     * @memberof CacheUsageData
     */
    workspaceCacheUsages: { [key: string]: WorkspaceCacheUsage };
}
/**
 * Options for converting CSV files when reading.
 * @export
 * @interface CsvConvertOptions
 */
export interface CsvConvertOptions {
    /**
     * Whether to check UTF8 validity of string columns.
     * @type {boolean}
     * @memberof CsvConvertOptions
     */
    checkUtf8?: boolean;
    /**
     * Information about the column types in the table.
     * @type {Array<CsvConvertOptionsColumnType>}
     * @memberof CsvConvertOptions
     */
    columnTypes?: Array<CsvConvertOptionsColumnType>;
    /**
     * Sequence of strings that denote nulls in the data.
     * @type {Array<string>}
     * @memberof CsvConvertOptions
     */
    nullValues?: Array<string>;
    /**
     * Sequence of strings that denote true Booleans in the data.
     * @type {Array<string>}
     * @memberof CsvConvertOptions
     */
    trueValues?: Array<string>;
    /**
     * Sequence of strings that denote false Booleans in the data.
     * @type {Array<string>}
     * @memberof CsvConvertOptions
     */
    falseValues?: Array<string>;
    /**
     * The character used as decimal point in floating-point and decimal data.
     * @type {string}
     * @memberof CsvConvertOptions
     */
    decimalPoint?: string;
    /**
     * Whether string / binary columns can have null values.
     * @type {boolean}
     * @memberof CsvConvertOptions
     */
    stringsCanBeNull?: boolean;
    /**
     * Whether quoted values can be null.
     * @type {boolean}
     * @memberof CsvConvertOptions
     */
    quotedStringsCanBeNull?: boolean;
    /**
     * The names of columns to include in the Table. If empty, the Table will include all columns from the CSV file. If not empty, only these columns will be included, in this order.
     * @type {Array<string>}
     * @memberof CsvConvertOptions
     */
    includeColumns?: Array<string>;
    /**
     * If false, columns in includeColumns but not in the CSV file will error out.
     * @type {boolean}
     * @memberof CsvConvertOptions
     */
    includeMissingColumns?: boolean;
    /**
     * Whether to try to automatically dict-encode string / binary data.
     * @type {boolean}
     * @memberof CsvConvertOptions
     */
    autoDictEncode?: boolean;
    /**
     * The maximum dictionary cardinality for autoDictEncode.
     * @type {number}
     * @memberof CsvConvertOptions
     */
    autoDictMaxCardinality?: number;
    /**
     * Sequence of strptime()-compatible format strings, tried in order when attempting to infer or convert timestamp values.
     * @type {Array<string>}
     * @memberof CsvConvertOptions
     */
    timestampParsers?: Array<string>;
}
/**
 * Information about a certain column in the table.
 * @export
 * @interface CsvConvertOptionsColumnType
 */
export interface CsvConvertOptionsColumnType {
    /**
     * The column name.
     * @type {string}
     * @memberof CsvConvertOptionsColumnType
     */
    name?: string;
    /**
     * The column type.
     * @type {string}
     * @memberof CsvConvertOptionsColumnType
     */
    type?: string;
    /**
     * Whether the data in the given column can be null.
     * @type {boolean}
     * @memberof CsvConvertOptionsColumnType
     */
    nullable?: boolean;
}
/**
 * Body of the CSV manifest.
 * @export
 * @interface CsvManifestBody
 */
export interface CsvManifestBody {
    /**
     *
     * @type {CsvReadOptions}
     * @memberof CsvManifestBody
     */
    read?: CsvReadOptions;
    /**
     *
     * @type {CsvParseOptions}
     * @memberof CsvManifestBody
     */
    parse?: CsvParseOptions;
    /**
     *
     * @type {CsvConvertOptions}
     * @memberof CsvManifestBody
     */
    convert?: CsvConvertOptions;
    /**
     * Map of column names to date formats to use when parsing them as dates.
     * @type {{ [key: string]: string; }}
     * @memberof CsvManifestBody
     */
    column_date_formats?: { [key: string]: string };
    /**
     * Method used to read the CSV file.
     * @type {string}
     * @memberof CsvManifestBody
     */
    read_method?: string;
}
/**
 * Options for parsing CSV files.
 * @export
 * @interface CsvParseOptions
 */
export interface CsvParseOptions {
    /**
     * The character delimiting individual cells in the CSV data.
     * @type {string}
     * @memberof CsvParseOptions
     */
    delimiter?: string;
    /**
     * The character used optionally for quoting CSV values or false to disable quoting.
     * @type {object}
     * @memberof CsvParseOptions
     */
    quoteChar?: object;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     * @type {boolean}
     * @memberof CsvParseOptions
     */
    doubleQuote?: boolean;
    /**
     * The character used optionally for escaping special characters or false to disable escaping.
     * @type {object}
     * @memberof CsvParseOptions
     */
    escapeChar?: object;
    /**
     * Whether newline characters are allowed in CSV values.
     * @type {boolean}
     * @memberof CsvParseOptions
     */
    newlinesInValues?: boolean;
    /**
     * Whether empty lines are ignored in CSV input.
     * @type {boolean}
     * @memberof CsvParseOptions
     */
    ignoreEmptyLines?: boolean;
}
/**
 * Options for reading CSV files.
 * @export
 * @interface CsvReadOptions
 */
export interface CsvReadOptions {
    /**
     * Whether to use multiple threads to accelerate reading.
     * @type {boolean}
     * @memberof CsvReadOptions
     */
    useThreads?: boolean;
    /**
     * How many bytes to process at a time from the input stream.
     * @type {number}
     * @memberof CsvReadOptions
     */
    blockSize?: number;
    /**
     * The number of rows to skip before the column names (if any) and the CSV data.
     * @type {number}
     * @memberof CsvReadOptions
     */
    skipRows?: number;
    /**
     * The number of rows to skip after the column names.
     * @type {number}
     * @memberof CsvReadOptions
     */
    skipRowsAfterNames?: number;
    /**
     * The column names of the target table.
     * @type {Array<string>}
     * @memberof CsvReadOptions
     */
    columnNames?: Array<string>;
    /**
     * Whether to autogenerate column names if columnNames is empty.
     * @type {boolean}
     * @memberof CsvReadOptions
     */
    autoGenerateColumnNames?: boolean;
    /**
     * The character encoding of the CSV data.
     * @type {string}
     * @memberof CsvReadOptions
     */
    encoding?: string;
}
/**
 * Request to delete files from the storage.
 * @export
 * @interface DeleteFilesRequest
 */
export interface DeleteFilesRequest {
    /**
     * Names of the files to delete.
     * @type {Array<string>}
     * @memberof DeleteFilesRequest
     */
    fileNames: Array<string>;
}
/**
 * File stored in GD Storage.
 * @export
 * @interface GdStorageFile
 */
export interface GdStorageFile {
    /**
     * Name of the file.
     * @type {string}
     * @memberof GdStorageFile
     */
    name: string;
    /**
     * Version of the file.
     * @type {number}
     * @memberof GdStorageFile
     */
    version: number;
    /**
     * Size of the file in bytes.
     * @type {number}
     * @memberof GdStorageFile
     */
    size: number;
    /**
     * Last modification timestamp of the file.
     * @type {string}
     * @memberof GdStorageFile
     */
    modifiedAt: string;
    /**
     * Type of file stored in GD Storage.
     * @type {string}
     * @memberof GdStorageFile
     */
    type: GdStorageFileTypeEnum;
}

export const GdStorageFileTypeEnum = {
    CSV: "CSV",
} as const;

export type GdStorageFileTypeEnum = typeof GdStorageFileTypeEnum[keyof typeof GdStorageFileTypeEnum];

/**
 * Request containing the information necessary to import one or more CSV files from the staging area.
 * @export
 * @interface ImportCsvRequest
 */
export interface ImportCsvRequest {
    /**
     * Information about the individual tables.
     * @type {Array<ImportCsvRequestTable>}
     * @memberof ImportCsvRequest
     */
    tables: Array<ImportCsvRequestTable>;
}
/**
 * Information about a particular table.
 * @export
 * @interface ImportCsvRequestTable
 */
export interface ImportCsvRequestTable {
    /**
     * Name of the table.
     * @type {string}
     * @memberof ImportCsvRequestTable
     */
    name: string;
    /**
     *
     * @type {ImportCsvRequestTableSource}
     * @memberof ImportCsvRequestTable
     */
    source: ImportCsvRequestTableSource;
}
/**
 * Information about source data for a particular table.
 * @export
 * @interface ImportCsvRequestTableSource
 */
export interface ImportCsvRequestTableSource {
    /**
     * Location of the data in the staging area.
     * @type {string}
     * @memberof ImportCsvRequestTableSource
     */
    location: string;
    /**
     *
     * @type {ImportCsvRequestTableSourceConfig}
     * @memberof ImportCsvRequestTableSource
     */
    config: ImportCsvRequestTableSourceConfig;
}
/**
 * Config to use when accessing the data for executions, etc.
 * @export
 * @interface ImportCsvRequestTableSourceConfig
 */
export interface ImportCsvRequestTableSourceConfig {
    /**
     *
     * @type {CsvReadOptions}
     * @memberof ImportCsvRequestTableSourceConfig
     */
    readOptions?: CsvReadOptions;
    /**
     *
     * @type {CsvParseOptions}
     * @memberof ImportCsvRequestTableSourceConfig
     */
    parseOptions?: CsvParseOptions;
    /**
     *
     * @type {CsvConvertOptions}
     * @memberof ImportCsvRequestTableSourceConfig
     */
    convertOptions?: CsvConvertOptions;
    /**
     * Date formats to use to use to read the given columns.
     * @type {{ [key: string]: string; }}
     * @memberof ImportCsvRequestTableSourceConfig
     */
    columnDateFormats?: { [key: string]: string };
}
/**
 * Response containing the information about the imported CSV file.
 * @export
 * @interface ImportCsvResponse
 */
export interface ImportCsvResponse {
    /**
     * Name of the table the file was imported to.
     * @type {string}
     * @memberof ImportCsvResponse
     */
    name: string;
    /**
     * Version the file was imported as.
     * @type {number}
     * @memberof ImportCsvResponse
     */
    version: number;
}
/**
 * Settings for organization cache.
 * @export
 * @interface OrganizationCacheSettings
 */
export interface OrganizationCacheSettings {
    /**
     * Extra cache budget the organization can allocate among its workspaces, in bytes.
     * @type {number}
     * @memberof OrganizationCacheSettings
     */
    extraCacheBudget: number;
}
/**
 * Data about the whole organization\'s cache usage.
 * @export
 * @interface OrganizationCacheUsage
 */
export interface OrganizationCacheUsage {
    /**
     *
     * @type {OrganizationCacheSettings}
     * @memberof OrganizationCacheUsage
     */
    settings: OrganizationCacheSettings;
    /**
     *
     * @type {OrganizationCurrentCacheUsage}
     * @memberof OrganizationCacheUsage
     */
    current: OrganizationCurrentCacheUsage;
    /**
     * List of cache removal intervals.
     * @type {Array<CacheRemovalInterval>}
     * @memberof OrganizationCacheUsage
     */
    removalIntervals: Array<CacheRemovalInterval>;
}
/**
 * Current cache usage of the organization.
 * @export
 * @interface OrganizationCurrentCacheUsage
 */
export interface OrganizationCurrentCacheUsage {
    /**
     * Cache currently used by the organization, in bytes.
     * @type {number}
     * @memberof OrganizationCurrentCacheUsage
     */
    cacheUsed: number;
    /**
     * Start timestamp of removal period.
     * @type {string}
     * @memberof OrganizationCurrentCacheUsage
     */
    removalPeriodStart?: string;
    /**
     * Bytes removed since start due to insufficient cache.
     * @type {number}
     * @memberof OrganizationCurrentCacheUsage
     */
    removedSinceStart: number;
}
/**
 * Request to read the manifests of the specified files.
 * @export
 * @interface ReadFileManifestsRequest
 */
export interface ReadFileManifestsRequest {
    /**
     * Files to read the schemata for.
     * @type {Array<ReadFileManifestsRequestItem>}
     * @memberof ReadFileManifestsRequest
     */
    manifestRequests: Array<ReadFileManifestsRequestItem>;
}
/**
 * Request to read the manifest of a single file.
 * @export
 * @interface ReadFileManifestsRequestItem
 */
export interface ReadFileManifestsRequestItem {
    /**
     * Name of the file to read the manifest for.
     * @type {string}
     * @memberof ReadFileManifestsRequestItem
     */
    fileName: string;
    /**
     * Optional version of the file to read the manifest for. If null or not specified, the latest version is read.
     * @type {number}
     * @memberof ReadFileManifestsRequestItem
     */
    version?: number;
}
/**
 * Describes the results of a CSV manifest read of a single file.
 * @export
 * @interface ReadFileManifestsResponse
 */
export interface ReadFileManifestsResponse {
    /**
     * Name of the file in the source data source.
     * @type {string}
     * @memberof ReadFileManifestsResponse
     */
    name: string;
    /**
     * Version of the file in the source data source.
     * @type {number}
     * @memberof ReadFileManifestsResponse
     */
    version: number;
    /**
     *
     * @type {CsvManifestBody}
     * @memberof ReadFileManifestsResponse
     */
    manifest: CsvManifestBody;
}
/**
 * Information related to uploading a file to the staging area.
 * @export
 * @interface StagingUploadLocation
 */
export interface StagingUploadLocation {
    /**
     * Location relative to the root of the storage.
     * @type {string}
     * @memberof StagingUploadLocation
     */
    location: string;
    /**
     * Pre-signed upload URL to PUT the file to.
     * @type {string}
     * @memberof StagingUploadLocation
     */
    uploadUrl: string;
}
/**
 * Information related to the file uploaded to the staging area.
 * @export
 * @interface UploadFileResponse
 */
export interface UploadFileResponse {
    /**
     * Location to use when referencing the uploaded file in subsequent requests.
     * @type {string}
     * @memberof UploadFileResponse
     */
    location: string;
}
/**
 * Cache settings for the workspace.
 * @export
 * @interface WorkspaceCacheSettings
 */
export interface WorkspaceCacheSettings {
    /**
     * Extra cache for the workspace, in bytes.
     * @type {number}
     * @memberof WorkspaceCacheSettings
     */
    extraCache: number;
}
/**
 * Data about a particular workspace cache usage.
 * @export
 * @interface WorkspaceCacheUsage
 */
export interface WorkspaceCacheUsage {
    /**
     *
     * @type {WorkspaceCacheSettings}
     * @memberof WorkspaceCacheUsage
     */
    settings: WorkspaceCacheSettings;
    /**
     *
     * @type {WorkspaceCurrentCacheUsage}
     * @memberof WorkspaceCacheUsage
     */
    current: WorkspaceCurrentCacheUsage;
    /**
     * List of cache removal intervals for workspace.
     * @type {Array<CacheRemovalInterval>}
     * @memberof WorkspaceCacheUsage
     */
    removalIntervals: Array<CacheRemovalInterval>;
}
/**
 * Current cache usage of the workspace.
 * @export
 * @interface WorkspaceCurrentCacheUsage
 */
export interface WorkspaceCurrentCacheUsage {
    /**
     * Cache used by the workspace.
     * @type {number}
     * @memberof WorkspaceCurrentCacheUsage
     */
    cacheUsed: number;
    /**
     * Cache available for the workspace.
     * @type {number}
     * @memberof WorkspaceCurrentCacheUsage
     */
    cacheAvailable: number;
    /**
     * Start timestamp of removal period for the workspace.
     * @type {string}
     * @memberof WorkspaceCurrentCacheUsage
     */
    removalPeriodStart: string;
    /**
     * Bytes removed since start due to insufficient cache for the workspace.
     * @type {number}
     * @memberof WorkspaceCurrentCacheUsage
     */
    removedSinceStart: number;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {string} dataSourceId
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv: async (
            dataSourceId: string,
            analyzeCsvRequest: AnalyzeCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("analyzeCsv", "dataSourceId", dataSourceId);
            // verify required parameter 'analyzeCsvRequest' is not null or undefined
            assertParamExists("analyzeCsv", "analyzeCsvRequest", analyzeCsvRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/analyze`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof analyzeCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(analyzeCsvRequest !== undefined ? analyzeCsvRequest : {})
                : analyzeCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/collectCacheUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {string} dataSourceId
         * @param {DeleteFilesRequest} deleteFilesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles: async (
            dataSourceId: string,
            deleteFilesRequest: DeleteFilesRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("deleteFiles", "dataSourceId", dataSourceId);
            // verify required parameter 'deleteFilesRequest' is not null or undefined
            assertParamExists("deleteFiles", "deleteFilesRequest", deleteFilesRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/deleteFiles`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof deleteFilesRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(deleteFilesRequest !== undefined ? deleteFilesRequest : {})
                : deleteFilesRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStagingUploadLocation: async (
            dataSourceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getStagingUploadLocation", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/staging/upload`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv: async (
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("importCsv", "dataSourceId", dataSourceId);
            // verify required parameter 'importCsvRequest' is not null or undefined
            assertParamExists("importCsv", "importCsvRequest", importCsvRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/import`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof importCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(importCsvRequest !== undefined ? importCsvRequest : {})
                : importCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: async (dataSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("listFiles", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/listFiles`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the manifests of the files in the given data source.
         * @summary Read datasource file manifests
         * @param {string} dataSourceId
         * @param {ReadFileManifestsRequest} readFileManifestsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFileManifests: async (
            dataSourceId: string,
            readFileManifestsRequest: ReadFileManifestsRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("readFileManifests", "dataSourceId", dataSourceId);
            // verify required parameter 'readFileManifestsRequest' is not null or undefined
            assertParamExists("readFileManifests", "readFileManifestsRequest", readFileManifestsRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/readFileManifests`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof readFileManifestsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(readFileManifestsRequest !== undefined ? readFileManifestsRequest : {})
                : readFileManifestsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {string} dataSourceId
         * @param {any} file The file to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stagingUpload: async (
            dataSourceId: string,
            file: any,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("stagingUpload", "dataSourceId", dataSourceId);
            // verify required parameter 'file' is not null or undefined
            assertParamExists("stagingUpload", "file", file);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/staging/uploadFile`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (file !== undefined) {
                localVarFormParams.append("file", file as any);
            }

            localVarHeaderParameter["Content-Type"] = "multipart/form-data";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {string} dataSourceId
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzeCsv(
            dataSourceId: string,
            analyzeCsvRequest: AnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnalyzeCsvResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeCsv(
                dataSourceId,
                analyzeCsvRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectCacheUsage(
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacheUsageData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectCacheUsage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {string} dataSourceId
         * @param {DeleteFilesRequest} deleteFilesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFiles(
            dataSourceId: string,
            deleteFilesRequest: DeleteFilesRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFiles(
                dataSourceId,
                deleteFilesRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStagingUploadLocation(
            dataSourceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StagingUploadLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStagingUploadLocation(
                dataSourceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCsv(
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImportCsvResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCsv(
                dataSourceId,
                importCsvRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFiles(
            dataSourceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GdStorageFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Read the manifests of the files in the given data source.
         * @summary Read datasource file manifests
         * @param {string} dataSourceId
         * @param {ReadFileManifestsRequest} readFileManifestsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readFileManifests(
            dataSourceId: string,
            readFileManifestsRequest: ReadFileManifestsRequest,
            options?: AxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReadFileManifestsResponse>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readFileManifests(
                dataSourceId,
                readFileManifestsRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {string} dataSourceId
         * @param {any} file The file to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stagingUpload(
            dataSourceId: string,
            file: any,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stagingUpload(
                dataSourceId,
                file,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv(
            requestParameters: ActionsApiAnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<AnalyzeCsvResponse>> {
            return localVarFp
                .analyzeCsv(requestParameters.dataSourceId, requestParameters.analyzeCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData> {
            return localVarFp.collectCacheUsage(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {ActionsApiDeleteFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles(
            requestParameters: ActionsApiDeleteFilesRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteFiles(requestParameters.dataSourceId, requestParameters.deleteFilesRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {ActionsApiGetStagingUploadLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStagingUploadLocation(
            requestParameters: ActionsApiGetStagingUploadLocationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<StagingUploadLocation> {
            return localVarFp
                .getStagingUploadLocation(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv(
            requestParameters: ActionsApiImportCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<ImportCsvResponse>> {
            return localVarFp
                .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {ActionsApiListFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(
            requestParameters: ActionsApiListFilesRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<GdStorageFile>> {
            return localVarFp
                .listFiles(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Read the manifests of the files in the given data source.
         * @summary Read datasource file manifests
         * @param {ActionsApiReadFileManifestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFileManifests(
            requestParameters: ActionsApiReadFileManifestsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<ReadFileManifestsResponse>> {
            return localVarFp
                .readFileManifests(
                    requestParameters.dataSourceId,
                    requestParameters.readFileManifestsRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {ActionsApiStagingUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stagingUpload(
            requestParameters: ActionsApiStagingUploadRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<UploadFileResponse> {
            return localVarFp
                .stagingUpload(requestParameters.dataSourceId, requestParameters.file, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    analyzeCsv(
        requestParameters: ActionsApiAnalyzeCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<AnalyzeCsvResponse>>;

    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData>;

    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {ActionsApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    deleteFiles(
        requestParameters: ActionsApiDeleteFilesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Provides a location for uploading staging files.
     * @summary Get a staging upload location
     * @param {ActionsApiGetStagingUploadLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getStagingUploadLocation(
        requestParameters: ActionsApiGetStagingUploadLocationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<StagingUploadLocation>;

    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    importCsv(
        requestParameters: ActionsApiImportCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ImportCsvResponse>>;

    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {ActionsApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    listFiles(
        requestParameters: ActionsApiListFilesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<GdStorageFile>>;

    /**
     * Read the manifests of the files in the given data source.
     * @summary Read datasource file manifests
     * @param {ActionsApiReadFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    readFileManifests(
        requestParameters: ActionsApiReadFileManifestsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ReadFileManifestsResponse>>;

    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {ActionsApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    stagingUpload(
        requestParameters: ActionsApiStagingUploadRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<UploadFileResponse>;
}

/**
 * Request parameters for analyzeCsv operation in ActionsApi.
 * @export
 * @interface ActionsApiAnalyzeCsvRequest
 */
export interface ActionsApiAnalyzeCsvRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiAnalyzeCsv
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {AnalyzeCsvRequest}
     * @memberof ActionsApiAnalyzeCsv
     */
    readonly analyzeCsvRequest: AnalyzeCsvRequest;
}

/**
 * Request parameters for deleteFiles operation in ActionsApi.
 * @export
 * @interface ActionsApiDeleteFilesRequest
 */
export interface ActionsApiDeleteFilesRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiDeleteFiles
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {DeleteFilesRequest}
     * @memberof ActionsApiDeleteFiles
     */
    readonly deleteFilesRequest: DeleteFilesRequest;
}

/**
 * Request parameters for getStagingUploadLocation operation in ActionsApi.
 * @export
 * @interface ActionsApiGetStagingUploadLocationRequest
 */
export interface ActionsApiGetStagingUploadLocationRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiGetStagingUploadLocation
     */
    readonly dataSourceId: string;
}

/**
 * Request parameters for importCsv operation in ActionsApi.
 * @export
 * @interface ActionsApiImportCsvRequest
 */
export interface ActionsApiImportCsvRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiImportCsv
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ImportCsvRequest}
     * @memberof ActionsApiImportCsv
     */
    readonly importCsvRequest: ImportCsvRequest;
}

/**
 * Request parameters for listFiles operation in ActionsApi.
 * @export
 * @interface ActionsApiListFilesRequest
 */
export interface ActionsApiListFilesRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiListFiles
     */
    readonly dataSourceId: string;
}

/**
 * Request parameters for readFileManifests operation in ActionsApi.
 * @export
 * @interface ActionsApiReadFileManifestsRequest
 */
export interface ActionsApiReadFileManifestsRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiReadFileManifests
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ReadFileManifestsRequest}
     * @memberof ActionsApiReadFileManifests
     */
    readonly readFileManifestsRequest: ReadFileManifestsRequest;
}

/**
 * Request parameters for stagingUpload operation in ActionsApi.
 * @export
 * @interface ActionsApiStagingUploadRequest
 */
export interface ActionsApiStagingUploadRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiStagingUpload
     */
    readonly dataSourceId: string;

    /**
     * The file to upload.
     * @type {any}
     * @memberof ActionsApiStagingUpload
     */
    readonly file: any;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public analyzeCsv(requestParameters: ActionsApiAnalyzeCsvRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .analyzeCsv(requestParameters.dataSourceId, requestParameters.analyzeCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public collectCacheUsage(options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .collectCacheUsage(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {ActionsApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public deleteFiles(requestParameters: ActionsApiDeleteFilesRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .deleteFiles(requestParameters.dataSourceId, requestParameters.deleteFilesRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides a location for uploading staging files.
     * @summary Get a staging upload location
     * @param {ActionsApiGetStagingUploadLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getStagingUploadLocation(
        requestParameters: ActionsApiGetStagingUploadLocationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .getStagingUploadLocation(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public importCsv(requestParameters: ActionsApiImportCsvRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {ActionsApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public listFiles(requestParameters: ActionsApiListFilesRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .listFiles(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the manifests of the files in the given data source.
     * @summary Read datasource file manifests
     * @param {ActionsApiReadFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public readFileManifests(
        requestParameters: ActionsApiReadFileManifestsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .readFileManifests(
                requestParameters.dataSourceId,
                requestParameters.readFileManifestsRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {ActionsApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public stagingUpload(requestParameters: ActionsApiStagingUploadRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .stagingUpload(requestParameters.dataSourceId, requestParameters.file, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * CacheUsageApi - axios parameter creator
 * @export
 */
export const CacheUsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/collectCacheUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * CacheUsageApi - functional programming interface
 * @export
 */
export const CacheUsageApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CacheUsageApiAxiosParamCreator(configuration);
    return {
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectCacheUsage(
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacheUsageData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectCacheUsage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * CacheUsageApi - factory interface
 * @export
 */
export const CacheUsageApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = CacheUsageApiFp(configuration);
    return {
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData> {
            return localVarFp.collectCacheUsage(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CacheUsageApi - interface
 * @export
 * @interface CacheUsageApi
 */
export interface CacheUsageApiInterface {
    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CacheUsageApiInterface
     */
    collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData>;
}

/**
 * CacheUsageApi - object-oriented interface
 * @export
 * @class CacheUsageApi
 * @extends {BaseAPI}
 */
export class CacheUsageApi extends BaseAPI implements CacheUsageApiInterface {
    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CacheUsageApi
     */
    public collectCacheUsage(options?: AxiosRequestConfig) {
        return CacheUsageApiFp(this.configuration)
            .collectCacheUsage(options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesAnalysisApi - axios parameter creator
 * @export
 */
export const DataSourceFilesAnalysisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {string} dataSourceId
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv: async (
            dataSourceId: string,
            analyzeCsvRequest: AnalyzeCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("analyzeCsv", "dataSourceId", dataSourceId);
            // verify required parameter 'analyzeCsvRequest' is not null or undefined
            assertParamExists("analyzeCsv", "analyzeCsvRequest", analyzeCsvRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/analyze`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof analyzeCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(analyzeCsvRequest !== undefined ? analyzeCsvRequest : {})
                : analyzeCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesAnalysisApi - functional programming interface
 * @export
 */
export const DataSourceFilesAnalysisApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesAnalysisApiAxiosParamCreator(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {string} dataSourceId
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzeCsv(
            dataSourceId: string,
            analyzeCsvRequest: AnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnalyzeCsvResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeCsv(
                dataSourceId,
                analyzeCsvRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesAnalysisApi - factory interface
 * @export
 */
export const DataSourceFilesAnalysisApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesAnalysisApiFp(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv(
            requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<AnalyzeCsvResponse>> {
            return localVarFp
                .analyzeCsv(requestParameters.dataSourceId, requestParameters.analyzeCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesAnalysisApi - interface
 * @export
 * @interface DataSourceFilesAnalysisApi
 */
export interface DataSourceFilesAnalysisApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesAnalysisApiInterface
     */
    analyzeCsv(
        requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<AnalyzeCsvResponse>>;
}

/**
 * Request parameters for analyzeCsv operation in DataSourceFilesAnalysisApi.
 * @export
 * @interface DataSourceFilesAnalysisApiAnalyzeCsvRequest
 */
export interface DataSourceFilesAnalysisApiAnalyzeCsvRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceFilesAnalysisApiAnalyzeCsv
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {AnalyzeCsvRequest}
     * @memberof DataSourceFilesAnalysisApiAnalyzeCsv
     */
    readonly analyzeCsvRequest: AnalyzeCsvRequest;
}

/**
 * DataSourceFilesAnalysisApi - object-oriented interface
 * @export
 * @class DataSourceFilesAnalysisApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesAnalysisApi extends BaseAPI implements DataSourceFilesAnalysisApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesAnalysisApi
     */
    public analyzeCsv(
        requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesAnalysisApiFp(this.configuration)
            .analyzeCsv(requestParameters.dataSourceId, requestParameters.analyzeCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesDeletionApi - axios parameter creator
 * @export
 */
export const DataSourceFilesDeletionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {string} dataSourceId
         * @param {DeleteFilesRequest} deleteFilesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles: async (
            dataSourceId: string,
            deleteFilesRequest: DeleteFilesRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("deleteFiles", "dataSourceId", dataSourceId);
            // verify required parameter 'deleteFilesRequest' is not null or undefined
            assertParamExists("deleteFiles", "deleteFilesRequest", deleteFilesRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/deleteFiles`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof deleteFilesRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(deleteFilesRequest !== undefined ? deleteFilesRequest : {})
                : deleteFilesRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesDeletionApi - functional programming interface
 * @export
 */
export const DataSourceFilesDeletionApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesDeletionApiAxiosParamCreator(configuration);
    return {
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {string} dataSourceId
         * @param {DeleteFilesRequest} deleteFilesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFiles(
            dataSourceId: string,
            deleteFilesRequest: DeleteFilesRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFiles(
                dataSourceId,
                deleteFilesRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesDeletionApi - factory interface
 * @export
 */
export const DataSourceFilesDeletionApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesDeletionApiFp(configuration);
    return {
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {DataSourceFilesDeletionApiDeleteFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles(
            requestParameters: DataSourceFilesDeletionApiDeleteFilesRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteFiles(requestParameters.dataSourceId, requestParameters.deleteFilesRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesDeletionApi - interface
 * @export
 * @interface DataSourceFilesDeletionApi
 */
export interface DataSourceFilesDeletionApiInterface {
    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {DataSourceFilesDeletionApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesDeletionApiInterface
     */
    deleteFiles(
        requestParameters: DataSourceFilesDeletionApiDeleteFilesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for deleteFiles operation in DataSourceFilesDeletionApi.
 * @export
 * @interface DataSourceFilesDeletionApiDeleteFilesRequest
 */
export interface DataSourceFilesDeletionApiDeleteFilesRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceFilesDeletionApiDeleteFiles
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {DeleteFilesRequest}
     * @memberof DataSourceFilesDeletionApiDeleteFiles
     */
    readonly deleteFilesRequest: DeleteFilesRequest;
}

/**
 * DataSourceFilesDeletionApi - object-oriented interface
 * @export
 * @class DataSourceFilesDeletionApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesDeletionApi extends BaseAPI implements DataSourceFilesDeletionApiInterface {
    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {DataSourceFilesDeletionApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesDeletionApi
     */
    public deleteFiles(
        requestParameters: DataSourceFilesDeletionApiDeleteFilesRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesDeletionApiFp(this.configuration)
            .deleteFiles(requestParameters.dataSourceId, requestParameters.deleteFilesRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesImportApi - axios parameter creator
 * @export
 */
export const DataSourceFilesImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv: async (
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("importCsv", "dataSourceId", dataSourceId);
            // verify required parameter 'importCsvRequest' is not null or undefined
            assertParamExists("importCsv", "importCsvRequest", importCsvRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/import`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof importCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(importCsvRequest !== undefined ? importCsvRequest : {})
                : importCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesImportApi - functional programming interface
 * @export
 */
export const DataSourceFilesImportApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesImportApiAxiosParamCreator(configuration);
    return {
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCsv(
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImportCsvResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCsv(
                dataSourceId,
                importCsvRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesImportApi - factory interface
 * @export
 */
export const DataSourceFilesImportApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesImportApiFp(configuration);
    return {
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv(
            requestParameters: DataSourceFilesImportApiImportCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<ImportCsvResponse>> {
            return localVarFp
                .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesImportApi - interface
 * @export
 * @interface DataSourceFilesImportApi
 */
export interface DataSourceFilesImportApiInterface {
    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesImportApiInterface
     */
    importCsv(
        requestParameters: DataSourceFilesImportApiImportCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ImportCsvResponse>>;
}

/**
 * Request parameters for importCsv operation in DataSourceFilesImportApi.
 * @export
 * @interface DataSourceFilesImportApiImportCsvRequest
 */
export interface DataSourceFilesImportApiImportCsvRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceFilesImportApiImportCsv
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ImportCsvRequest}
     * @memberof DataSourceFilesImportApiImportCsv
     */
    readonly importCsvRequest: ImportCsvRequest;
}

/**
 * DataSourceFilesImportApi - object-oriented interface
 * @export
 * @class DataSourceFilesImportApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesImportApi extends BaseAPI implements DataSourceFilesImportApiInterface {
    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesImportApi
     */
    public importCsv(
        requestParameters: DataSourceFilesImportApiImportCsvRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesImportApiFp(this.configuration)
            .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesListingApi - axios parameter creator
 * @export
 */
export const DataSourceFilesListingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: async (dataSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("listFiles", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/listFiles`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesListingApi - functional programming interface
 * @export
 */
export const DataSourceFilesListingApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesListingApiAxiosParamCreator(configuration);
    return {
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFiles(
            dataSourceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GdStorageFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesListingApi - factory interface
 * @export
 */
export const DataSourceFilesListingApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesListingApiFp(configuration);
    return {
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {DataSourceFilesListingApiListFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(
            requestParameters: DataSourceFilesListingApiListFilesRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<GdStorageFile>> {
            return localVarFp
                .listFiles(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesListingApi - interface
 * @export
 * @interface DataSourceFilesListingApi
 */
export interface DataSourceFilesListingApiInterface {
    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {DataSourceFilesListingApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesListingApiInterface
     */
    listFiles(
        requestParameters: DataSourceFilesListingApiListFilesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<GdStorageFile>>;
}

/**
 * Request parameters for listFiles operation in DataSourceFilesListingApi.
 * @export
 * @interface DataSourceFilesListingApiListFilesRequest
 */
export interface DataSourceFilesListingApiListFilesRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceFilesListingApiListFiles
     */
    readonly dataSourceId: string;
}

/**
 * DataSourceFilesListingApi - object-oriented interface
 * @export
 * @class DataSourceFilesListingApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesListingApi extends BaseAPI implements DataSourceFilesListingApiInterface {
    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {DataSourceFilesListingApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesListingApi
     */
    public listFiles(
        requestParameters: DataSourceFilesListingApiListFilesRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesListingApiFp(this.configuration)
            .listFiles(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesManifestReadApi - axios parameter creator
 * @export
 */
export const DataSourceFilesManifestReadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Read the manifests of the files in the given data source.
         * @summary Read datasource file manifests
         * @param {string} dataSourceId
         * @param {ReadFileManifestsRequest} readFileManifestsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFileManifests: async (
            dataSourceId: string,
            readFileManifestsRequest: ReadFileManifestsRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("readFileManifests", "dataSourceId", dataSourceId);
            // verify required parameter 'readFileManifestsRequest' is not null or undefined
            assertParamExists("readFileManifests", "readFileManifestsRequest", readFileManifestsRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/readFileManifests`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof readFileManifestsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(readFileManifestsRequest !== undefined ? readFileManifestsRequest : {})
                : readFileManifestsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesManifestReadApi - functional programming interface
 * @export
 */
export const DataSourceFilesManifestReadApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesManifestReadApiAxiosParamCreator(configuration);
    return {
        /**
         * Read the manifests of the files in the given data source.
         * @summary Read datasource file manifests
         * @param {string} dataSourceId
         * @param {ReadFileManifestsRequest} readFileManifestsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readFileManifests(
            dataSourceId: string,
            readFileManifestsRequest: ReadFileManifestsRequest,
            options?: AxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReadFileManifestsResponse>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readFileManifests(
                dataSourceId,
                readFileManifestsRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesManifestReadApi - factory interface
 * @export
 */
export const DataSourceFilesManifestReadApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesManifestReadApiFp(configuration);
    return {
        /**
         * Read the manifests of the files in the given data source.
         * @summary Read datasource file manifests
         * @param {DataSourceFilesManifestReadApiReadFileManifestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFileManifests(
            requestParameters: DataSourceFilesManifestReadApiReadFileManifestsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<ReadFileManifestsResponse>> {
            return localVarFp
                .readFileManifests(
                    requestParameters.dataSourceId,
                    requestParameters.readFileManifestsRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesManifestReadApi - interface
 * @export
 * @interface DataSourceFilesManifestReadApi
 */
export interface DataSourceFilesManifestReadApiInterface {
    /**
     * Read the manifests of the files in the given data source.
     * @summary Read datasource file manifests
     * @param {DataSourceFilesManifestReadApiReadFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesManifestReadApiInterface
     */
    readFileManifests(
        requestParameters: DataSourceFilesManifestReadApiReadFileManifestsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ReadFileManifestsResponse>>;
}

/**
 * Request parameters for readFileManifests operation in DataSourceFilesManifestReadApi.
 * @export
 * @interface DataSourceFilesManifestReadApiReadFileManifestsRequest
 */
export interface DataSourceFilesManifestReadApiReadFileManifestsRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceFilesManifestReadApiReadFileManifests
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ReadFileManifestsRequest}
     * @memberof DataSourceFilesManifestReadApiReadFileManifests
     */
    readonly readFileManifestsRequest: ReadFileManifestsRequest;
}

/**
 * DataSourceFilesManifestReadApi - object-oriented interface
 * @export
 * @class DataSourceFilesManifestReadApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesManifestReadApi
    extends BaseAPI
    implements DataSourceFilesManifestReadApiInterface
{
    /**
     * Read the manifests of the files in the given data source.
     * @summary Read datasource file manifests
     * @param {DataSourceFilesManifestReadApiReadFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesManifestReadApi
     */
    public readFileManifests(
        requestParameters: DataSourceFilesManifestReadApiReadFileManifestsRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesManifestReadApiFp(this.configuration)
            .readFileManifests(
                requestParameters.dataSourceId,
                requestParameters.readFileManifestsRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceStagingLocationApi - axios parameter creator
 * @export
 */
export const DataSourceStagingLocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStagingUploadLocation: async (
            dataSourceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getStagingUploadLocation", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/staging/upload`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {string} dataSourceId
         * @param {any} file The file to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stagingUpload: async (
            dataSourceId: string,
            file: any,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("stagingUpload", "dataSourceId", dataSourceId);
            // verify required parameter 'file' is not null or undefined
            assertParamExists("stagingUpload", "file", file);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/staging/uploadFile`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (file !== undefined) {
                localVarFormParams.append("file", file as any);
            }

            localVarHeaderParameter["Content-Type"] = "multipart/form-data";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceStagingLocationApi - functional programming interface
 * @export
 */
export const DataSourceStagingLocationApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceStagingLocationApiAxiosParamCreator(configuration);
    return {
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStagingUploadLocation(
            dataSourceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StagingUploadLocation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStagingUploadLocation(
                dataSourceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {string} dataSourceId
         * @param {any} file The file to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stagingUpload(
            dataSourceId: string,
            file: any,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stagingUpload(
                dataSourceId,
                file,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceStagingLocationApi - factory interface
 * @export
 */
export const DataSourceStagingLocationApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceStagingLocationApiFp(configuration);
    return {
        /**
         * Provides a location for uploading staging files.
         * @summary Get a staging upload location
         * @param {DataSourceStagingLocationApiGetStagingUploadLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStagingUploadLocation(
            requestParameters: DataSourceStagingLocationApiGetStagingUploadLocationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<StagingUploadLocation> {
            return localVarFp
                .getStagingUploadLocation(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {DataSourceStagingLocationApiStagingUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stagingUpload(
            requestParameters: DataSourceStagingLocationApiStagingUploadRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<UploadFileResponse> {
            return localVarFp
                .stagingUpload(requestParameters.dataSourceId, requestParameters.file, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceStagingLocationApi - interface
 * @export
 * @interface DataSourceStagingLocationApi
 */
export interface DataSourceStagingLocationApiInterface {
    /**
     * Provides a location for uploading staging files.
     * @summary Get a staging upload location
     * @param {DataSourceStagingLocationApiGetStagingUploadLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceStagingLocationApiInterface
     */
    getStagingUploadLocation(
        requestParameters: DataSourceStagingLocationApiGetStagingUploadLocationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<StagingUploadLocation>;

    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {DataSourceStagingLocationApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceStagingLocationApiInterface
     */
    stagingUpload(
        requestParameters: DataSourceStagingLocationApiStagingUploadRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<UploadFileResponse>;
}

/**
 * Request parameters for getStagingUploadLocation operation in DataSourceStagingLocationApi.
 * @export
 * @interface DataSourceStagingLocationApiGetStagingUploadLocationRequest
 */
export interface DataSourceStagingLocationApiGetStagingUploadLocationRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceStagingLocationApiGetStagingUploadLocation
     */
    readonly dataSourceId: string;
}

/**
 * Request parameters for stagingUpload operation in DataSourceStagingLocationApi.
 * @export
 * @interface DataSourceStagingLocationApiStagingUploadRequest
 */
export interface DataSourceStagingLocationApiStagingUploadRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceStagingLocationApiStagingUpload
     */
    readonly dataSourceId: string;

    /**
     * The file to upload.
     * @type {any}
     * @memberof DataSourceStagingLocationApiStagingUpload
     */
    readonly file: any;
}

/**
 * DataSourceStagingLocationApi - object-oriented interface
 * @export
 * @class DataSourceStagingLocationApi
 * @extends {BaseAPI}
 */
export class DataSourceStagingLocationApi extends BaseAPI implements DataSourceStagingLocationApiInterface {
    /**
     * Provides a location for uploading staging files.
     * @summary Get a staging upload location
     * @param {DataSourceStagingLocationApiGetStagingUploadLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceStagingLocationApi
     */
    public getStagingUploadLocation(
        requestParameters: DataSourceStagingLocationApiGetStagingUploadLocationRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceStagingLocationApiFp(this.configuration)
            .getStagingUploadLocation(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {DataSourceStagingLocationApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceStagingLocationApi
     */
    public stagingUpload(
        requestParameters: DataSourceStagingLocationApiStagingUploadRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceStagingLocationApiFp(this.configuration)
            .stagingUpload(requestParameters.dataSourceId, requestParameters.file, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
