// (C) 2024-2026 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration.js';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Bulk CSV analysis request.
 */
export interface AnalyzeCsvRequest {
    /**
     * List of individual CSV analysis requests.
     */
    'analyzeRequests': Array<AnalyzeCsvRequestItem>;
}

/**
 * CSV analysis request.
 */
export interface AnalyzeCsvRequestItem {
    /**
     * Location of the CSV file to analyze.
     */
    'location': string;
    'config'?: AnalyzeCsvRequestItemConfig;
}

/**
 * CSV analysis request config.
 */
export interface AnalyzeCsvRequestItemConfig {
    /**
     * Number of rows to return in the flight that represents analysis result. If 0, no rows are returned, if less than 0, all rows that were in the sample are returned.
     */
    'resultRows'?: number;
    /**
     * Maximum number of rows to work with during header detection.
     */
    'headerDetectMaxRows'?: number;
    /**
     * Number of rows to consider as header, if null, header will be detected.
     */
    'headerRowCount'?: number;
    /**
     * Possible column delimiters.
     */
    'delimiters'?: Array<string>;
}

/**
 * Describes the results of a CSV analysis of a single file.
 */
export interface AnalyzeCsvResponse {
    /**
     * Location of the analyzed file in the source data source.
     */
    'location': string;
    /**
     * List of column metadata.
     */
    'columns': Array<AnalyzeCsvResponseColumn>;
    /**
     * Preview of the first N rows of the file.
     */
    'previewData': Array<Array<object>>;
    'config'?: AnalyzeCsvResponseConfig;
}

/**
 * Describes the result column.
 */
export interface AnalyzeCsvResponseColumn {
    /**
     * Name of the column as specified in the file (or autogenerated one if the file has no header).
     */
    'name': string;
    /**
     * Type of the column (e.g. string, bool, etc.).
     */
    'type': string;
    /**
     * List of date formats that can be used to parse this column as date. Null if there are none.
     */
    'detectedDateFormats'?: Array<string>;
}

/**
 * Config used to process the CSV file.
 */
export interface AnalyzeCsvResponseConfig {
    'readOptions'?: CsvReadOptions;
    'parseOptions'?: CsvParseOptions;
    'convertOptions'?: CsvConvertOptions;
}

/**
 * Information about a period in time and how much cached data was removed.
 */
export interface CacheRemovalInterval {
    /**
     * Start timestamp of the removal interval.
     */
    'from': string;
    /**
     * End timestamp of the removal interval.
     */
    'to': string;
    /**
     * Bytes removed during this interval.
     */
    'removed': number;
}

/**
 * Result of scan of data source physical model.
 */
export interface CacheUsageData {
    'organizationCacheUsage': OrganizationCacheUsage;
    /**
     * Map of data about the cache usage of the individual workspaces.
     */
    'workspaceCacheUsages': { [key: string]: WorkspaceCacheUsage; };
}

/**
 * Request to convert a geo file to GeoParquet format.
 */
export interface ConvertGeoFileRequest {
    /**
     * Location of the file in the staging area to convert.
     */
    'location': string;
}

/**
 * Response after successfully converting a geo file.
 */
export interface ConvertGeoFileResponse {
    /**
     * Location of the converted GeoParquet file in the staging area.
     */
    'location': string;
}

/**
 * Options for converting CSV files when reading.
 */
export interface CsvConvertOptions {
    /**
     * Whether to check UTF8 validity of string columns.
     */
    'checkUtf8'?: boolean;
    /**
     * Information about the column types in the table.
     */
    'columnTypes'?: Array<CsvConvertOptionsColumnType>;
    /**
     * Sequence of strings that denote nulls in the data.
     */
    'nullValues'?: Array<string>;
    /**
     * Sequence of strings that denote true Booleans in the data.
     */
    'trueValues'?: Array<string>;
    /**
     * Sequence of strings that denote false Booleans in the data.
     */
    'falseValues'?: Array<string>;
    /**
     * The character used as decimal point in floating-point and decimal data.
     */
    'decimalPoint'?: string;
    /**
     * Whether string / binary columns can have null values.
     */
    'stringsCanBeNull'?: boolean;
    /**
     * Whether quoted values can be null.
     */
    'quotedStringsCanBeNull'?: boolean;
    /**
     * The names of columns to include in the Table. If empty, the Table will include all columns from the CSV file. If not empty, only these columns will be included, in this order.
     */
    'includeColumns'?: Array<string>;
    /**
     * If false, columns in includeColumns but not in the CSV file will error out.
     */
    'includeMissingColumns'?: boolean;
    /**
     * Whether to try to automatically dict-encode string / binary data.
     */
    'autoDictEncode'?: boolean;
    /**
     * The maximum dictionary cardinality for autoDictEncode.
     */
    'autoDictMaxCardinality'?: number;
    /**
     * Sequence of strptime()-compatible format strings, tried in order when attempting to infer or convert timestamp values.
     */
    'timestampParsers'?: Array<string>;
}

/**
 * Information about a certain column in the table.
 */
export interface CsvConvertOptionsColumnType {
    /**
     * The column name.
     */
    'name'?: string;
    /**
     * The column type.
     */
    'type'?: string;
    /**
     * Whether the data in the given column can be null.
     */
    'nullable'?: boolean;
}

/**
 * Body of the CSV manifest.
 */
export interface CsvManifestBody {
    'read'?: CsvReadOptions;
    'parse'?: CsvParseOptions;
    'convert'?: CsvConvertOptions;
    /**
     * Map of column names to date formats to use when parsing them as dates.
     */
    'column_date_formats'?: { [key: string]: string; };
    /**
     * Method used to read the CSV file.
     */
    'read_method'?: string;
}

/**
 * Options for parsing CSV files.
 */
export interface CsvParseOptions {
    /**
     * The character delimiting individual cells in the CSV data.
     */
    'delimiter'?: string;
    /**
     * The character used optionally for quoting CSV values or false to disable quoting.
     */
    'quoteChar'?: object;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    'doubleQuote'?: boolean;
    /**
     * The character used optionally for escaping special characters or false to disable escaping.
     */
    'escapeChar'?: object;
    /**
     * Whether newline characters are allowed in CSV values.
     */
    'newlinesInValues'?: boolean;
    /**
     * Whether empty lines are ignored in CSV input.
     */
    'ignoreEmptyLines'?: boolean;
}

/**
 * Options for reading CSV files.
 */
export interface CsvReadOptions {
    /**
     * Whether to use multiple threads to accelerate reading.
     */
    'useThreads'?: boolean;
    /**
     * How many bytes to process at a time from the input stream.
     */
    'blockSize'?: number;
    /**
     * The number of rows to skip before the column names (if any) and the CSV data.
     */
    'skipRows'?: number;
    /**
     * The number of rows to skip after the column names.
     */
    'skipRowsAfterNames'?: number;
    /**
     * The column names of the target table.
     */
    'columnNames'?: Array<string>;
    /**
     * Whether to autogenerate column names if columnNames is empty.
     */
    'autoGenerateColumnNames'?: boolean;
    /**
     * The character encoding of the CSV data.
     */
    'encoding'?: string;
}

/**
 * Request to delete files from the storage.
 */
export interface DeleteFilesRequest {
    /**
     * Names of the files to delete.
     */
    'fileNames': Array<string>;
}

/**
 * File stored in GD Storage.
 */
export interface GdStorageFile {
    /**
     * Name of the file.
     */
    'name': string;
    /**
     * Size of the file in bytes.
     */
    'size': number;
    /**
     * Last modification timestamp of the file.
     */
    'modifiedAt': string;
    /**
     * Type of the file.
     */
    'type': GdStorageFileTypeEnum;
}

export type GdStorageFileTypeEnum = 'CSV';

/**
 * GeoJSON Feature
 */
export interface GeoJsonFeature {
    'type': string;
    'id'?: object;
    'geometry'?: GeoJsonGeometry;
    'properties': { [key: string]: object; };
}

/**
 * GeoJSON FeatureCollection
 */
export interface GeoJsonFeatureCollection {
    'type': string;
    'features': Array<GeoJsonFeature>;
    'bbox'?: Array<number>;
}

/**
 * GeoJSON Geometry
 */
export interface GeoJsonGeometry {
    'type': string;
    'coordinates': object;
}

/**
 * Request containing the information necessary to import one or more CSV files from the staging area.
 */
export interface ImportCsvRequest {
    /**
     * Information about the individual tables.
     */
    'tables': Array<ImportCsvRequestTable>;
}

/**
 * Information about a particular table.
 */
export interface ImportCsvRequestTable {
    /**
     * Name of the table.
     */
    'name': string;
    'source': ImportCsvRequestTableSource;
}

/**
 * Information about source data for a particular table.
 */
export interface ImportCsvRequestTableSource {
    /**
     * Location of the data in the staging area.
     */
    'location': string;
    'config': ImportCsvRequestTableSourceConfig;
}

/**
 * Config to use when accessing the data for executions, etc.
 */
export interface ImportCsvRequestTableSourceConfig {
    'readOptions'?: CsvReadOptions;
    'parseOptions'?: CsvParseOptions;
    'convertOptions'?: CsvConvertOptions;
    /**
     * Date formats to use to use to read the given columns.
     */
    'columnDateFormats'?: { [key: string]: string; };
}

/**
 * Response containing the information about the imported CSV file.
 */
export interface ImportCsvResponse {
    /**
     * Name of the table the file was imported to.
     */
    'name': string;
    /**
     * Version the file was imported as.
     */
    'version': number;
}

/**
 * Request to import a geo collection file from the staging area.
 */
export interface ImportGeoCollectionRequest {
    /**
     * Location of the file in the staging area.
     */
    'location': string;
}

/**
 * Response after successfully importing a geo collection.
 */
export interface ImportGeoCollectionResponse {
    /**
     * The version of the imported geo collection.
     */
    'version': number;
}

/**
 * Settings for organization cache.
 */
export interface OrganizationCacheSettings {
    /**
     * Extra cache budget the organization can allocate among its workspaces, in bytes.
     */
    'extraCacheBudget': number;
}

/**
 * Data about the whole organization\'s cache usage.
 */
export interface OrganizationCacheUsage {
    'settings': OrganizationCacheSettings;
    'current': OrganizationCurrentCacheUsage;
    /**
     * List of cache removal intervals.
     */
    'removalIntervals': Array<CacheRemovalInterval>;
}

/**
 * Current cache usage of the organization.
 */
export interface OrganizationCurrentCacheUsage {
    /**
     * Cache currently used by the organization, in bytes.
     */
    'cacheUsed': number;
    /**
     * Start timestamp of removal period.
     */
    'removalPeriodStart'?: string;
    /**
     * Bytes removed since start due to insufficient cache.
     */
    'removedSinceStart': number;
}

/**
 * Request to read the manifests of the specified CSV files.
 */
export interface ReadCsvFileManifestsRequest {
    /**
     * Files to read the manifests for.
     */
    'manifestRequests': Array<ReadCsvFileManifestsRequestItem>;
}

/**
 * Request to read the manifest of a single CSV file.
 */
export interface ReadCsvFileManifestsRequestItem {
    /**
     * Name of the CSV file to read the manifest for.
     */
    'fileName': string;
    /**
     * Optional version of the file to read the manifest for. If null or not specified, the latest version is read.
     */
    'version'?: number;
}

/**
 * Describes the results of a CSV manifest read of a single file.
 */
export interface ReadCsvFileManifestsResponse {
    /**
     * Name of the file in the source data source.
     */
    'name': string;
    /**
     * Version of the file in the source data source.
     */
    'version': number;
    'manifest': CsvManifestBody;
}

/**
 * Information related to the file uploaded to the staging area.
 */
export interface UploadFileResponse {
    /**
     * Location to use when referencing the uploaded file in subsequent requests.
     */
    'location': string;
}

/**
 * Information related to the geo collection file uploaded to the staging area.
 */
export interface UploadGeoCollectionFileResponse {
    /**
     * Location to use when referencing the uploaded file in subsequent requests.
     */
    'location': string;
}

/**
 * Cache settings for the workspace.
 */
export interface WorkspaceCacheSettings {
    /**
     * Extra cache for the workspace, in bytes.
     */
    'extraCache': number;
}

/**
 * Data about a particular workspace cache usage.
 */
export interface WorkspaceCacheUsage {
    'settings': WorkspaceCacheSettings;
    'current': WorkspaceCurrentCacheUsage;
    /**
     * List of cache removal intervals for workspace.
     */
    'removalIntervals': Array<CacheRemovalInterval>;
}

/**
 * Current cache usage of the workspace.
 */
export interface WorkspaceCurrentCacheUsage {
    /**
     * Cache used by the workspace.
     */
    'cacheUsed': number;
    /**
     * Cache available for the workspace.
     */
    'cacheAvailable': number;
    /**
     * Start timestamp of removal period for the workspace.
     */
    'removalPeriodStart': string;
    /**
     * Bytes removed since start due to insufficient cache for the workspace.
     */
    'removedSinceStart': number;
}



// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Analyzes CSV files at the given locations
 * @summary Analyze CSV
 * @param {AnalyzeCsvRequest} analyzeCsvRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_AnalyzeCsv(
    analyzeCsvRequest: AnalyzeCsvRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'analyzeCsvRequest' is not null or undefined
    assertParamExists('analyzeCsv', 'analyzeCsvRequest', analyzeCsvRequest)
    const localVarPath = `/api/v1/actions/fileStorage/staging/analyzeCsv`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof analyzeCsvRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(analyzeCsvRequest !== undefined ? analyzeCsvRequest : {})
        : analyzeCsvRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
 * @summary Collect data about the current cache usage
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_CollectCacheUsage(
    
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    const localVarPath = `/api/v1/actions/collectCacheUsage`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Converts a geo file from the staging area to GeoParquet format. Supported source formats: GeoJSON (.geojson, .json). If the source file is already in GeoParquet format, the same location is returned without conversion.
 * @summary Convert a geo file to GeoParquet format
 * @param {ConvertGeoFileRequest} convertGeoFileRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ConvertGeoFile(
    convertGeoFileRequest: ConvertGeoFileRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'convertGeoFileRequest' is not null or undefined
    assertParamExists('convertGeoFile', 'convertGeoFileRequest', convertGeoFileRequest)
    const localVarPath = `/api/v1/actions/customGeoCollection/convert`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof convertGeoFileRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(convertGeoFileRequest !== undefined ? convertGeoFileRequest : {})
        : convertGeoFileRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Provides a location for uploading staging files for custom geo collections. Supported file types: GeoParquet (.parquet), GeoJSON (.geojson, .json).
 * @summary Upload a geo collection file to the staging area
 * @param {File} file The geo collection file to upload. Supported formats: GeoParquet (.parquet), GeoJSON (.geojson, .json).
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_CustomGeoCollectionStagingUpload(
    file: File, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'file' is not null or undefined
    assertParamExists('customGeoCollectionStagingUpload', 'file', file)
    const localVarPath = `/api/v1/actions/customGeoCollection/staging/upload`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;
    const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


    if (file !== undefined) { 
        localVarFormParams.append('file', file as any);
    }
    
    
    localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    localVarRequestOptions.data = localVarFormParams;

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Delete the files in the given data source.
 * @summary Delete datasource files
 * @param {string} dataSourceId 
 * @param {DeleteFilesRequest} deleteFilesRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_DeleteFiles(
    dataSourceId: string, deleteFilesRequest: DeleteFilesRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('deleteFiles', 'dataSourceId', dataSourceId)
    // verify required parameter 'deleteFilesRequest' is not null or undefined
    assertParamExists('deleteFiles', 'deleteFilesRequest', deleteFilesRequest)
    const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/deleteFiles`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof deleteFilesRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(deleteFilesRequest !== undefined ? deleteFilesRequest : {})
        : deleteFilesRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Import the CSV files at the given locations in the staging area to the final location.
 * @summary Import CSV
 * @param {string} dataSourceId 
 * @param {ImportCsvRequest} importCsvRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ImportCsv(
    dataSourceId: string, importCsvRequest: ImportCsvRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('importCsv', 'dataSourceId', dataSourceId)
    // verify required parameter 'importCsvRequest' is not null or undefined
    assertParamExists('importCsv', 'importCsvRequest', importCsvRequest)
    const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/importCsv`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof importCsvRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(importCsvRequest !== undefined ? importCsvRequest : {})
        : importCsvRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Import a geo collection file from the staging area to be available for use.
 * @summary Import custom geo collection
 * @param {string} collectionId 
 * @param {ImportGeoCollectionRequest} importGeoCollectionRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ImportCustomGeoCollection(
    collectionId: string, importGeoCollectionRequest: ImportGeoCollectionRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'collectionId' is not null or undefined
    assertParamExists('importCustomGeoCollection', 'collectionId', collectionId)
    // verify required parameter 'importGeoCollectionRequest' is not null or undefined
    assertParamExists('importCustomGeoCollection', 'importGeoCollectionRequest', importGeoCollectionRequest)
    const localVarPath = `/api/v1/actions/customGeoCollection/{collectionId}/import`
        .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof importGeoCollectionRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(importGeoCollectionRequest !== undefined ? importGeoCollectionRequest : {})
        : importGeoCollectionRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * List all the files in the given data source.
 * @summary List datasource files
 * @param {string} dataSourceId 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ListFiles(
    dataSourceId: string, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('listFiles', 'dataSourceId', dataSourceId)
    const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/listFiles`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Read the manifests of the CSV files in the given data source.
 * @summary Read CSV file manifests
 * @param {string} dataSourceId 
 * @param {ReadCsvFileManifestsRequest} readCsvFileManifestsRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ReadCsvFileManifests(
    dataSourceId: string, readCsvFileManifestsRequest: ReadCsvFileManifestsRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('readCsvFileManifests', 'dataSourceId', dataSourceId)
    // verify required parameter 'readCsvFileManifestsRequest' is not null or undefined
    assertParamExists('readCsvFileManifests', 'readCsvFileManifestsRequest', readCsvFileManifestsRequest)
    const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/readCsvFileManifests`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof readCsvFileManifestsRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(readCsvFileManifestsRequest !== undefined ? readCsvFileManifestsRequest : {})
        : readCsvFileManifestsRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Provides a location for uploading staging files.
 * @summary Upload a file to the staging area
 * @param {File} file The file to upload.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_StagingUpload(
    file: File, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'file' is not null or undefined
    assertParamExists('stagingUpload', 'file', file)
    const localVarPath = `/api/v1/actions/fileStorage/staging/upload`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;
    const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


    if (file !== undefined) { 
        localVarFormParams.append('file', file as any);
    }
    
    
    localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    localVarRequestOptions.data = localVarFormParams;

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// ActionsApi Api FP
/**
 * Analyzes CSV files at the given locations
 * @summary Analyze CSV
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_AnalyzeCsv(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiAnalyzeCsvRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<Array<AnalyzeCsvResponse>> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_AnalyzeCsv(
        requestParameters.analyzeCsvRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
 * @summary Collect data about the current cache usage
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_CollectCacheUsage(
    axios: AxiosInstance, basePath: string,
    
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<CacheUsageData> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_CollectCacheUsage(
        
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * Converts a geo file from the staging area to GeoParquet format. Supported source formats: GeoJSON (.geojson, .json). If the source file is already in GeoParquet format, the same location is returned without conversion.
 * @summary Convert a geo file to GeoParquet format
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiConvertGeoFileRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ConvertGeoFile(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiConvertGeoFileRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ConvertGeoFileResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ConvertGeoFile(
        requestParameters.convertGeoFileRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * Provides a location for uploading staging files for custom geo collections. Supported file types: GeoParquet (.parquet), GeoJSON (.geojson, .json).
 * @summary Upload a geo collection file to the staging area
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiCustomGeoCollectionStagingUploadRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_CustomGeoCollectionStagingUpload(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiCustomGeoCollectionStagingUploadRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<UploadGeoCollectionFileResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_CustomGeoCollectionStagingUpload(
        requestParameters.file, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * Delete the files in the given data source.
 * @summary Delete datasource files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiDeleteFilesRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_DeleteFiles(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiDeleteFilesRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_DeleteFiles(
        requestParameters.dataSourceId, requestParameters.deleteFilesRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * Import the CSV files at the given locations in the staging area to the final location.
 * @summary Import CSV
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ImportCsv(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiImportCsvRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<Array<ImportCsvResponse>> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ImportCsv(
        requestParameters.dataSourceId, requestParameters.importCsvRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * Import a geo collection file from the staging area to be available for use.
 * @summary Import custom geo collection
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiImportCustomGeoCollectionRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ImportCustomGeoCollection(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiImportCustomGeoCollectionRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ImportGeoCollectionResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ImportCustomGeoCollection(
        requestParameters.collectionId, requestParameters.importGeoCollectionRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * List all the files in the given data source.
 * @summary List datasource files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiListFilesRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ListFiles(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiListFilesRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<Array<GdStorageFile>> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ListFiles(
        requestParameters.dataSourceId, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * Read the manifests of the CSV files in the given data source.
 * @summary Read CSV file manifests
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiReadCsvFileManifestsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ReadCsvFileManifests(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiReadCsvFileManifestsRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<Array<ReadCsvFileManifestsResponse>> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ReadCsvFileManifests(
        requestParameters.dataSourceId, requestParameters.readCsvFileManifestsRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * Provides a location for uploading staging files.
 * @summary Upload a file to the staging area
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiStagingUploadRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_StagingUpload(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiStagingUploadRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<UploadFileResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_StagingUpload(
        requestParameters.file, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    analyzeCsv(requestParameters: ActionsApiAnalyzeCsvRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AnalyzeCsvResponse>>;

    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData>;

    /**
     * Converts a geo file from the staging area to GeoParquet format. Supported source formats: GeoJSON (.geojson, .json). If the source file is already in GeoParquet format, the same location is returned without conversion.
     * @summary Convert a geo file to GeoParquet format
     * @param {ActionsApiConvertGeoFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    convertGeoFile(requestParameters: ActionsApiConvertGeoFileRequest, options?: AxiosRequestConfig): AxiosPromise<ConvertGeoFileResponse>;

    /**
     * Provides a location for uploading staging files for custom geo collections. Supported file types: GeoParquet (.parquet), GeoJSON (.geojson, .json).
     * @summary Upload a geo collection file to the staging area
     * @param {ActionsApiCustomGeoCollectionStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    customGeoCollectionStagingUpload(requestParameters: ActionsApiCustomGeoCollectionStagingUploadRequest, options?: AxiosRequestConfig): AxiosPromise<UploadGeoCollectionFileResponse>;

    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {ActionsApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    deleteFiles(requestParameters: ActionsApiDeleteFilesRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    importCsv(requestParameters: ActionsApiImportCsvRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ImportCsvResponse>>;

    /**
     * Import a geo collection file from the staging area to be available for use.
     * @summary Import custom geo collection
     * @param {ActionsApiImportCustomGeoCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    importCustomGeoCollection(requestParameters: ActionsApiImportCustomGeoCollectionRequest, options?: AxiosRequestConfig): AxiosPromise<ImportGeoCollectionResponse>;

    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {ActionsApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    listFiles(requestParameters: ActionsApiListFilesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<GdStorageFile>>;

    /**
     * Read the manifests of the CSV files in the given data source.
     * @summary Read CSV file manifests
     * @param {ActionsApiReadCsvFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    readCsvFileManifests(requestParameters: ActionsApiReadCsvFileManifestsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ReadCsvFileManifestsResponse>>;

    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {ActionsApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    stagingUpload(requestParameters: ActionsApiStagingUploadRequest, options?: AxiosRequestConfig): AxiosPromise<UploadFileResponse>;

}

/**
 * Request parameters for analyzeCsv operation in ActionsApi.
 * @export
 * @interface ActionsApiAnalyzeCsvRequest
 */
export interface ActionsApiAnalyzeCsvRequest {
    /**
     * 
     * @type {AnalyzeCsvRequest}
     * @memberof ActionsApiAnalyzeCsv
     */
    readonly analyzeCsvRequest: AnalyzeCsvRequest
}

/**
 * Request parameters for convertGeoFile operation in ActionsApi.
 * @export
 * @interface ActionsApiConvertGeoFileRequest
 */
export interface ActionsApiConvertGeoFileRequest {
    /**
     * 
     * @type {ConvertGeoFileRequest}
     * @memberof ActionsApiConvertGeoFile
     */
    readonly convertGeoFileRequest: ConvertGeoFileRequest
}

/**
 * Request parameters for customGeoCollectionStagingUpload operation in ActionsApi.
 * @export
 * @interface ActionsApiCustomGeoCollectionStagingUploadRequest
 */
export interface ActionsApiCustomGeoCollectionStagingUploadRequest {
    /**
     * The geo collection file to upload. Supported formats: GeoParquet (.parquet), GeoJSON (.geojson, .json).
     * @type {File}
     * @memberof ActionsApiCustomGeoCollectionStagingUpload
     */
    readonly file: File
}

/**
 * Request parameters for deleteFiles operation in ActionsApi.
 * @export
 * @interface ActionsApiDeleteFilesRequest
 */
export interface ActionsApiDeleteFilesRequest {
    /**
     * 
     * @type {string}
     * @memberof ActionsApiDeleteFiles
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {DeleteFilesRequest}
     * @memberof ActionsApiDeleteFiles
     */
    readonly deleteFilesRequest: DeleteFilesRequest
}

/**
 * Request parameters for importCsv operation in ActionsApi.
 * @export
 * @interface ActionsApiImportCsvRequest
 */
export interface ActionsApiImportCsvRequest {
    /**
     * 
     * @type {string}
     * @memberof ActionsApiImportCsv
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {ImportCsvRequest}
     * @memberof ActionsApiImportCsv
     */
    readonly importCsvRequest: ImportCsvRequest
}

/**
 * Request parameters for importCustomGeoCollection operation in ActionsApi.
 * @export
 * @interface ActionsApiImportCustomGeoCollectionRequest
 */
export interface ActionsApiImportCustomGeoCollectionRequest {
    /**
     * 
     * @type {string}
     * @memberof ActionsApiImportCustomGeoCollection
     */
    readonly collectionId: string

    /**
     * 
     * @type {ImportGeoCollectionRequest}
     * @memberof ActionsApiImportCustomGeoCollection
     */
    readonly importGeoCollectionRequest: ImportGeoCollectionRequest
}

/**
 * Request parameters for listFiles operation in ActionsApi.
 * @export
 * @interface ActionsApiListFilesRequest
 */
export interface ActionsApiListFilesRequest {
    /**
     * 
     * @type {string}
     * @memberof ActionsApiListFiles
     */
    readonly dataSourceId: string
}

/**
 * Request parameters for readCsvFileManifests operation in ActionsApi.
 * @export
 * @interface ActionsApiReadCsvFileManifestsRequest
 */
export interface ActionsApiReadCsvFileManifestsRequest {
    /**
     * 
     * @type {string}
     * @memberof ActionsApiReadCsvFileManifests
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {ReadCsvFileManifestsRequest}
     * @memberof ActionsApiReadCsvFileManifests
     */
    readonly readCsvFileManifestsRequest: ReadCsvFileManifestsRequest
}

/**
 * Request parameters for stagingUpload operation in ActionsApi.
 * @export
 * @interface ActionsApiStagingUploadRequest
 */
export interface ActionsApiStagingUploadRequest {
    /**
     * The file to upload.
     * @type {File}
     * @memberof ActionsApiStagingUpload
     */
    readonly file: File
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public analyzeCsv(requestParameters: ActionsApiAnalyzeCsvRequest, options?: AxiosRequestConfig) {
        return ActionsApi_AnalyzeCsv(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public collectCacheUsage(options?: AxiosRequestConfig) {
        return ActionsApi_CollectCacheUsage(this.axios, this.basePath, options, this.configuration);
    }

    /**
     * Converts a geo file from the staging area to GeoParquet format. Supported source formats: GeoJSON (.geojson, .json). If the source file is already in GeoParquet format, the same location is returned without conversion.
     * @summary Convert a geo file to GeoParquet format
     * @param {ActionsApiConvertGeoFileRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public convertGeoFile(requestParameters: ActionsApiConvertGeoFileRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ConvertGeoFile(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Provides a location for uploading staging files for custom geo collections. Supported file types: GeoParquet (.parquet), GeoJSON (.geojson, .json).
     * @summary Upload a geo collection file to the staging area
     * @param {ActionsApiCustomGeoCollectionStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public customGeoCollectionStagingUpload(requestParameters: ActionsApiCustomGeoCollectionStagingUploadRequest, options?: AxiosRequestConfig) {
        return ActionsApi_CustomGeoCollectionStagingUpload(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {ActionsApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public deleteFiles(requestParameters: ActionsApiDeleteFilesRequest, options?: AxiosRequestConfig) {
        return ActionsApi_DeleteFiles(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public importCsv(requestParameters: ActionsApiImportCsvRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ImportCsv(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Import a geo collection file from the staging area to be available for use.
     * @summary Import custom geo collection
     * @param {ActionsApiImportCustomGeoCollectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public importCustomGeoCollection(requestParameters: ActionsApiImportCustomGeoCollectionRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ImportCustomGeoCollection(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {ActionsApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public listFiles(requestParameters: ActionsApiListFilesRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ListFiles(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Read the manifests of the CSV files in the given data source.
     * @summary Read CSV file manifests
     * @param {ActionsApiReadCsvFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public readCsvFileManifests(requestParameters: ActionsApiReadCsvFileManifestsRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ReadCsvFileManifests(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {ActionsApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public stagingUpload(requestParameters: ActionsApiStagingUploadRequest, options?: AxiosRequestConfig) {
        return ActionsApi_StagingUpload(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}


// CacheUsageApi FP - CacheUsageApiAxiosParamCreator
/**
 * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
 * @summary Collect data about the current cache usage
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function CacheUsageApiAxiosParamCreator_CollectCacheUsage(
    
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    const localVarPath = `/api/v1/actions/collectCacheUsage`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// CacheUsageApi Api FP
/**
 * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
 * @summary Collect data about the current cache usage
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function CacheUsageApi_CollectCacheUsage(
    axios: AxiosInstance, basePath: string,
    
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<CacheUsageData> {
    const localVarAxiosArgs = await CacheUsageApiAxiosParamCreator_CollectCacheUsage(
        
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * CacheUsageApi - interface
 * @export
 * @interface CacheUsageApi
 */
export interface CacheUsageApiInterface {
    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CacheUsageApiInterface
     */
    collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData>;

}

/**
 * CacheUsageApi - object-oriented interface
 * @export
 * @class CacheUsageApi
 * @extends {BaseAPI}
 */
export class CacheUsageApi extends BaseAPI implements CacheUsageApiInterface {
    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CacheUsageApi
     */
    public collectCacheUsage(options?: AxiosRequestConfig) {
        return CacheUsageApi_CollectCacheUsage(this.axios, this.basePath, options, this.configuration);
    }
}


// DataSourceFilesAnalysisApi FP - DataSourceFilesAnalysisApiAxiosParamCreator
/**
 * Analyzes CSV files at the given locations
 * @summary Analyze CSV
 * @param {AnalyzeCsvRequest} analyzeCsvRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceFilesAnalysisApiAxiosParamCreator_AnalyzeCsv(
    analyzeCsvRequest: AnalyzeCsvRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'analyzeCsvRequest' is not null or undefined
    assertParamExists('analyzeCsv', 'analyzeCsvRequest', analyzeCsvRequest)
    const localVarPath = `/api/v1/actions/fileStorage/staging/analyzeCsv`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof analyzeCsvRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(analyzeCsvRequest !== undefined ? analyzeCsvRequest : {})
        : analyzeCsvRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// DataSourceFilesAnalysisApi Api FP
/**
 * Analyzes CSV files at the given locations
 * @summary Analyze CSV
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceFilesAnalysisApi_AnalyzeCsv(
    axios: AxiosInstance, basePath: string,
    requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<Array<AnalyzeCsvResponse>> {
    const localVarAxiosArgs = await DataSourceFilesAnalysisApiAxiosParamCreator_AnalyzeCsv(
        requestParameters.analyzeCsvRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * DataSourceFilesAnalysisApi - interface
 * @export
 * @interface DataSourceFilesAnalysisApi
 */
export interface DataSourceFilesAnalysisApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesAnalysisApiInterface
     */
    analyzeCsv(requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AnalyzeCsvResponse>>;

}

/**
 * Request parameters for analyzeCsv operation in DataSourceFilesAnalysisApi.
 * @export
 * @interface DataSourceFilesAnalysisApiAnalyzeCsvRequest
 */
export interface DataSourceFilesAnalysisApiAnalyzeCsvRequest {
    /**
     * 
     * @type {AnalyzeCsvRequest}
     * @memberof DataSourceFilesAnalysisApiAnalyzeCsv
     */
    readonly analyzeCsvRequest: AnalyzeCsvRequest
}

/**
 * DataSourceFilesAnalysisApi - object-oriented interface
 * @export
 * @class DataSourceFilesAnalysisApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesAnalysisApi extends BaseAPI implements DataSourceFilesAnalysisApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesAnalysisApi
     */
    public analyzeCsv(requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest, options?: AxiosRequestConfig) {
        return DataSourceFilesAnalysisApi_AnalyzeCsv(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}


// DataSourceFilesDeletionApi FP - DataSourceFilesDeletionApiAxiosParamCreator
/**
 * Delete the files in the given data source.
 * @summary Delete datasource files
 * @param {string} dataSourceId 
 * @param {DeleteFilesRequest} deleteFilesRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceFilesDeletionApiAxiosParamCreator_DeleteFiles(
    dataSourceId: string, deleteFilesRequest: DeleteFilesRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('deleteFiles', 'dataSourceId', dataSourceId)
    // verify required parameter 'deleteFilesRequest' is not null or undefined
    assertParamExists('deleteFiles', 'deleteFilesRequest', deleteFilesRequest)
    const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/deleteFiles`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof deleteFilesRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(deleteFilesRequest !== undefined ? deleteFilesRequest : {})
        : deleteFilesRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// DataSourceFilesDeletionApi Api FP
/**
 * Delete the files in the given data source.
 * @summary Delete datasource files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {DataSourceFilesDeletionApiDeleteFilesRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceFilesDeletionApi_DeleteFiles(
    axios: AxiosInstance, basePath: string,
    requestParameters: DataSourceFilesDeletionApiDeleteFilesRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<void> {
    const localVarAxiosArgs = await DataSourceFilesDeletionApiAxiosParamCreator_DeleteFiles(
        requestParameters.dataSourceId, requestParameters.deleteFilesRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * DataSourceFilesDeletionApi - interface
 * @export
 * @interface DataSourceFilesDeletionApi
 */
export interface DataSourceFilesDeletionApiInterface {
    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {DataSourceFilesDeletionApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesDeletionApiInterface
     */
    deleteFiles(requestParameters: DataSourceFilesDeletionApiDeleteFilesRequest, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for deleteFiles operation in DataSourceFilesDeletionApi.
 * @export
 * @interface DataSourceFilesDeletionApiDeleteFilesRequest
 */
export interface DataSourceFilesDeletionApiDeleteFilesRequest {
    /**
     * 
     * @type {string}
     * @memberof DataSourceFilesDeletionApiDeleteFiles
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {DeleteFilesRequest}
     * @memberof DataSourceFilesDeletionApiDeleteFiles
     */
    readonly deleteFilesRequest: DeleteFilesRequest
}

/**
 * DataSourceFilesDeletionApi - object-oriented interface
 * @export
 * @class DataSourceFilesDeletionApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesDeletionApi extends BaseAPI implements DataSourceFilesDeletionApiInterface {
    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {DataSourceFilesDeletionApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesDeletionApi
     */
    public deleteFiles(requestParameters: DataSourceFilesDeletionApiDeleteFilesRequest, options?: AxiosRequestConfig) {
        return DataSourceFilesDeletionApi_DeleteFiles(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}


// DataSourceFilesImportApi FP - DataSourceFilesImportApiAxiosParamCreator
/**
 * Import the CSV files at the given locations in the staging area to the final location.
 * @summary Import CSV
 * @param {string} dataSourceId 
 * @param {ImportCsvRequest} importCsvRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceFilesImportApiAxiosParamCreator_ImportCsv(
    dataSourceId: string, importCsvRequest: ImportCsvRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('importCsv', 'dataSourceId', dataSourceId)
    // verify required parameter 'importCsvRequest' is not null or undefined
    assertParamExists('importCsv', 'importCsvRequest', importCsvRequest)
    const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/importCsv`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof importCsvRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(importCsvRequest !== undefined ? importCsvRequest : {})
        : importCsvRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// DataSourceFilesImportApi Api FP
/**
 * Import the CSV files at the given locations in the staging area to the final location.
 * @summary Import CSV
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceFilesImportApi_ImportCsv(
    axios: AxiosInstance, basePath: string,
    requestParameters: DataSourceFilesImportApiImportCsvRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<Array<ImportCsvResponse>> {
    const localVarAxiosArgs = await DataSourceFilesImportApiAxiosParamCreator_ImportCsv(
        requestParameters.dataSourceId, requestParameters.importCsvRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * DataSourceFilesImportApi - interface
 * @export
 * @interface DataSourceFilesImportApi
 */
export interface DataSourceFilesImportApiInterface {
    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesImportApiInterface
     */
    importCsv(requestParameters: DataSourceFilesImportApiImportCsvRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ImportCsvResponse>>;

}

/**
 * Request parameters for importCsv operation in DataSourceFilesImportApi.
 * @export
 * @interface DataSourceFilesImportApiImportCsvRequest
 */
export interface DataSourceFilesImportApiImportCsvRequest {
    /**
     * 
     * @type {string}
     * @memberof DataSourceFilesImportApiImportCsv
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {ImportCsvRequest}
     * @memberof DataSourceFilesImportApiImportCsv
     */
    readonly importCsvRequest: ImportCsvRequest
}

/**
 * DataSourceFilesImportApi - object-oriented interface
 * @export
 * @class DataSourceFilesImportApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesImportApi extends BaseAPI implements DataSourceFilesImportApiInterface {
    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesImportApi
     */
    public importCsv(requestParameters: DataSourceFilesImportApiImportCsvRequest, options?: AxiosRequestConfig) {
        return DataSourceFilesImportApi_ImportCsv(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}


// DataSourceFilesListingApi FP - DataSourceFilesListingApiAxiosParamCreator
/**
 * List all the files in the given data source.
 * @summary List datasource files
 * @param {string} dataSourceId 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceFilesListingApiAxiosParamCreator_ListFiles(
    dataSourceId: string, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('listFiles', 'dataSourceId', dataSourceId)
    const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/listFiles`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// DataSourceFilesListingApi Api FP
/**
 * List all the files in the given data source.
 * @summary List datasource files
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {DataSourceFilesListingApiListFilesRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceFilesListingApi_ListFiles(
    axios: AxiosInstance, basePath: string,
    requestParameters: DataSourceFilesListingApiListFilesRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<Array<GdStorageFile>> {
    const localVarAxiosArgs = await DataSourceFilesListingApiAxiosParamCreator_ListFiles(
        requestParameters.dataSourceId, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * DataSourceFilesListingApi - interface
 * @export
 * @interface DataSourceFilesListingApi
 */
export interface DataSourceFilesListingApiInterface {
    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {DataSourceFilesListingApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesListingApiInterface
     */
    listFiles(requestParameters: DataSourceFilesListingApiListFilesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<GdStorageFile>>;

}

/**
 * Request parameters for listFiles operation in DataSourceFilesListingApi.
 * @export
 * @interface DataSourceFilesListingApiListFilesRequest
 */
export interface DataSourceFilesListingApiListFilesRequest {
    /**
     * 
     * @type {string}
     * @memberof DataSourceFilesListingApiListFiles
     */
    readonly dataSourceId: string
}

/**
 * DataSourceFilesListingApi - object-oriented interface
 * @export
 * @class DataSourceFilesListingApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesListingApi extends BaseAPI implements DataSourceFilesListingApiInterface {
    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {DataSourceFilesListingApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesListingApi
     */
    public listFiles(requestParameters: DataSourceFilesListingApiListFilesRequest, options?: AxiosRequestConfig) {
        return DataSourceFilesListingApi_ListFiles(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}


// DataSourceFilesManifestReadApi FP - DataSourceFilesManifestReadApiAxiosParamCreator
/**
 * Read the manifests of the CSV files in the given data source.
 * @summary Read CSV file manifests
 * @param {string} dataSourceId 
 * @param {ReadCsvFileManifestsRequest} readCsvFileManifestsRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceFilesManifestReadApiAxiosParamCreator_ReadCsvFileManifests(
    dataSourceId: string, readCsvFileManifestsRequest: ReadCsvFileManifestsRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('readCsvFileManifests', 'dataSourceId', dataSourceId)
    // verify required parameter 'readCsvFileManifestsRequest' is not null or undefined
    assertParamExists('readCsvFileManifests', 'readCsvFileManifestsRequest', readCsvFileManifestsRequest)
    const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/readCsvFileManifests`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof readCsvFileManifestsRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(readCsvFileManifestsRequest !== undefined ? readCsvFileManifestsRequest : {})
        : readCsvFileManifestsRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// DataSourceFilesManifestReadApi Api FP
/**
 * Read the manifests of the CSV files in the given data source.
 * @summary Read CSV file manifests
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {DataSourceFilesManifestReadApiReadCsvFileManifestsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceFilesManifestReadApi_ReadCsvFileManifests(
    axios: AxiosInstance, basePath: string,
    requestParameters: DataSourceFilesManifestReadApiReadCsvFileManifestsRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<Array<ReadCsvFileManifestsResponse>> {
    const localVarAxiosArgs = await DataSourceFilesManifestReadApiAxiosParamCreator_ReadCsvFileManifests(
        requestParameters.dataSourceId, requestParameters.readCsvFileManifestsRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * DataSourceFilesManifestReadApi - interface
 * @export
 * @interface DataSourceFilesManifestReadApi
 */
export interface DataSourceFilesManifestReadApiInterface {
    /**
     * Read the manifests of the CSV files in the given data source.
     * @summary Read CSV file manifests
     * @param {DataSourceFilesManifestReadApiReadCsvFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesManifestReadApiInterface
     */
    readCsvFileManifests(requestParameters: DataSourceFilesManifestReadApiReadCsvFileManifestsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<ReadCsvFileManifestsResponse>>;

}

/**
 * Request parameters for readCsvFileManifests operation in DataSourceFilesManifestReadApi.
 * @export
 * @interface DataSourceFilesManifestReadApiReadCsvFileManifestsRequest
 */
export interface DataSourceFilesManifestReadApiReadCsvFileManifestsRequest {
    /**
     * 
     * @type {string}
     * @memberof DataSourceFilesManifestReadApiReadCsvFileManifests
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {ReadCsvFileManifestsRequest}
     * @memberof DataSourceFilesManifestReadApiReadCsvFileManifests
     */
    readonly readCsvFileManifestsRequest: ReadCsvFileManifestsRequest
}

/**
 * DataSourceFilesManifestReadApi - object-oriented interface
 * @export
 * @class DataSourceFilesManifestReadApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesManifestReadApi extends BaseAPI implements DataSourceFilesManifestReadApiInterface {
    /**
     * Read the manifests of the CSV files in the given data source.
     * @summary Read CSV file manifests
     * @param {DataSourceFilesManifestReadApiReadCsvFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesManifestReadApi
     */
    public readCsvFileManifests(requestParameters: DataSourceFilesManifestReadApiReadCsvFileManifestsRequest, options?: AxiosRequestConfig) {
        return DataSourceFilesManifestReadApi_ReadCsvFileManifests(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}


// DataSourceStagingLocationApi FP - DataSourceStagingLocationApiAxiosParamCreator
/**
 * Provides a location for uploading staging files.
 * @summary Upload a file to the staging area
 * @param {File} file The file to upload.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceStagingLocationApiAxiosParamCreator_StagingUpload(
    file: File, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'file' is not null or undefined
    assertParamExists('stagingUpload', 'file', file)
    const localVarPath = `/api/v1/actions/fileStorage/staging/upload`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;
    const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


    if (file !== undefined) { 
        localVarFormParams.append('file', file as any);
    }
    
    
    localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    localVarRequestOptions.data = localVarFormParams;

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// DataSourceStagingLocationApi Api FP
/**
 * Provides a location for uploading staging files.
 * @summary Upload a file to the staging area
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {DataSourceStagingLocationApiStagingUploadRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function DataSourceStagingLocationApi_StagingUpload(
    axios: AxiosInstance, basePath: string,
    requestParameters: DataSourceStagingLocationApiStagingUploadRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<UploadFileResponse> {
    const localVarAxiosArgs = await DataSourceStagingLocationApiAxiosParamCreator_StagingUpload(
        requestParameters.file, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * DataSourceStagingLocationApi - interface
 * @export
 * @interface DataSourceStagingLocationApi
 */
export interface DataSourceStagingLocationApiInterface {
    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {DataSourceStagingLocationApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceStagingLocationApiInterface
     */
    stagingUpload(requestParameters: DataSourceStagingLocationApiStagingUploadRequest, options?: AxiosRequestConfig): AxiosPromise<UploadFileResponse>;

}

/**
 * Request parameters for stagingUpload operation in DataSourceStagingLocationApi.
 * @export
 * @interface DataSourceStagingLocationApiStagingUploadRequest
 */
export interface DataSourceStagingLocationApiStagingUploadRequest {
    /**
     * The file to upload.
     * @type {File}
     * @memberof DataSourceStagingLocationApiStagingUpload
     */
    readonly file: File
}

/**
 * DataSourceStagingLocationApi - object-oriented interface
 * @export
 * @class DataSourceStagingLocationApi
 * @extends {BaseAPI}
 */
export class DataSourceStagingLocationApi extends BaseAPI implements DataSourceStagingLocationApiInterface {
    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {DataSourceStagingLocationApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceStagingLocationApi
     */
    public stagingUpload(requestParameters: DataSourceStagingLocationApiStagingUploadRequest, options?: AxiosRequestConfig) {
        return DataSourceStagingLocationApi_StagingUpload(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}


// OGCAPIFeaturesApi FP - OGCAPIFeaturesApiAxiosParamCreator
/**
 * Retrieve features from a GeoCollections collection as GeoJSON
 * @summary Get collection features
 * @param {string} collectionId Collection identifier
 * @param {number} [limit] Maximum number of features to return
 * @param {string} [bbox] Bounding box filter (minx,miny,maxx,maxy)
 * @param {Array<string>} [values] List of values to filter features by
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function OGCAPIFeaturesApiAxiosParamCreator_GetCollectionItems(
    collectionId: string, limit?: number, bbox?: string, values?: Array<string>, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'collectionId' is not null or undefined
    assertParamExists('getCollectionItems', 'collectionId', collectionId)
    const localVarPath = `/api/v1/location/collections/{collectionId}/items`
        .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
    }

    if (bbox !== undefined) {
        localVarQueryParameter['bbox'] = bbox;
    }

    if (values) {
        localVarQueryParameter['values'] = values;
    }


    
    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// OGCAPIFeaturesApi FP - OGCAPIFeaturesApiAxiosParamCreator
/**
 * Retrieve features from a custom (organization-scoped) GeoCollections collection as GeoJSON
 * @summary Get custom collection features
 * @param {string} collectionId Collection identifier
 * @param {number} [limit] Maximum number of features to return
 * @param {string} [bbox] Bounding box filter (minx,miny,maxx,maxy)
 * @param {Array<string>} [values] List of values to filter features by
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function OGCAPIFeaturesApiAxiosParamCreator_GetCustomCollectionItems(
    collectionId: string, limit?: number, bbox?: string, values?: Array<string>, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'collectionId' is not null or undefined
    assertParamExists('getCustomCollectionItems', 'collectionId', collectionId)
    const localVarPath = `/api/v1/location/custom/collections/{collectionId}/items`
        .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
    }

    if (bbox !== undefined) {
        localVarQueryParameter['bbox'] = bbox;
    }

    if (values) {
        localVarQueryParameter['values'] = values;
    }


    
    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// OGCAPIFeaturesApi Api FP
/**
 * Retrieve features from a GeoCollections collection as GeoJSON
 * @summary Get collection features
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {OGCAPIFeaturesApiGetCollectionItemsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function OGCAPIFeaturesApi_GetCollectionItems(
    axios: AxiosInstance, basePath: string,
    requestParameters: OGCAPIFeaturesApiGetCollectionItemsRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<GeoJsonFeatureCollection> {
    const localVarAxiosArgs = await OGCAPIFeaturesApiAxiosParamCreator_GetCollectionItems(
        requestParameters.collectionId, requestParameters.limit, requestParameters.bbox, requestParameters.values, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// OGCAPIFeaturesApi Api FP
/**
 * Retrieve features from a custom (organization-scoped) GeoCollections collection as GeoJSON
 * @summary Get custom collection features
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {OGCAPIFeaturesApiGetCustomCollectionItemsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function OGCAPIFeaturesApi_GetCustomCollectionItems(
    axios: AxiosInstance, basePath: string,
    requestParameters: OGCAPIFeaturesApiGetCustomCollectionItemsRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<GeoJsonFeatureCollection> {
    const localVarAxiosArgs = await OGCAPIFeaturesApiAxiosParamCreator_GetCustomCollectionItems(
        requestParameters.collectionId, requestParameters.limit, requestParameters.bbox, requestParameters.values, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * OGCAPIFeaturesApi - interface
 * @export
 * @interface OGCAPIFeaturesApi
 */
export interface OGCAPIFeaturesApiInterface {
    /**
     * Retrieve features from a GeoCollections collection as GeoJSON
     * @summary Get collection features
     * @param {OGCAPIFeaturesApiGetCollectionItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OGCAPIFeaturesApiInterface
     */
    getCollectionItems(requestParameters: OGCAPIFeaturesApiGetCollectionItemsRequest, options?: AxiosRequestConfig): AxiosPromise<GeoJsonFeatureCollection>;

    /**
     * Retrieve features from a custom (organization-scoped) GeoCollections collection as GeoJSON
     * @summary Get custom collection features
     * @param {OGCAPIFeaturesApiGetCustomCollectionItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OGCAPIFeaturesApiInterface
     */
    getCustomCollectionItems(requestParameters: OGCAPIFeaturesApiGetCustomCollectionItemsRequest, options?: AxiosRequestConfig): AxiosPromise<GeoJsonFeatureCollection>;

}

/**
 * Request parameters for getCollectionItems operation in OGCAPIFeaturesApi.
 * @export
 * @interface OGCAPIFeaturesApiGetCollectionItemsRequest
 */
export interface OGCAPIFeaturesApiGetCollectionItemsRequest {
    /**
     * Collection identifier
     * @type {string}
     * @memberof OGCAPIFeaturesApiGetCollectionItems
     */
    readonly collectionId: string

    /**
     * Maximum number of features to return
     * @type {number}
     * @memberof OGCAPIFeaturesApiGetCollectionItems
     */
    readonly limit?: number

    /**
     * Bounding box filter (minx,miny,maxx,maxy)
     * @type {string}
     * @memberof OGCAPIFeaturesApiGetCollectionItems
     */
    readonly bbox?: string

    /**
     * List of values to filter features by
     * @type {Array<string>}
     * @memberof OGCAPIFeaturesApiGetCollectionItems
     */
    readonly values?: Array<string>
}

/**
 * Request parameters for getCustomCollectionItems operation in OGCAPIFeaturesApi.
 * @export
 * @interface OGCAPIFeaturesApiGetCustomCollectionItemsRequest
 */
export interface OGCAPIFeaturesApiGetCustomCollectionItemsRequest {
    /**
     * Collection identifier
     * @type {string}
     * @memberof OGCAPIFeaturesApiGetCustomCollectionItems
     */
    readonly collectionId: string

    /**
     * Maximum number of features to return
     * @type {number}
     * @memberof OGCAPIFeaturesApiGetCustomCollectionItems
     */
    readonly limit?: number

    /**
     * Bounding box filter (minx,miny,maxx,maxy)
     * @type {string}
     * @memberof OGCAPIFeaturesApiGetCustomCollectionItems
     */
    readonly bbox?: string

    /**
     * List of values to filter features by
     * @type {Array<string>}
     * @memberof OGCAPIFeaturesApiGetCustomCollectionItems
     */
    readonly values?: Array<string>
}

/**
 * OGCAPIFeaturesApi - object-oriented interface
 * @export
 * @class OGCAPIFeaturesApi
 * @extends {BaseAPI}
 */
export class OGCAPIFeaturesApi extends BaseAPI implements OGCAPIFeaturesApiInterface {
    /**
     * Retrieve features from a GeoCollections collection as GeoJSON
     * @summary Get collection features
     * @param {OGCAPIFeaturesApiGetCollectionItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OGCAPIFeaturesApi
     */
    public getCollectionItems(requestParameters: OGCAPIFeaturesApiGetCollectionItemsRequest, options?: AxiosRequestConfig) {
        return OGCAPIFeaturesApi_GetCollectionItems(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Retrieve features from a custom (organization-scoped) GeoCollections collection as GeoJSON
     * @summary Get custom collection features
     * @param {OGCAPIFeaturesApiGetCustomCollectionItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OGCAPIFeaturesApi
     */
    public getCustomCollectionItems(requestParameters: OGCAPIFeaturesApiGetCustomCollectionItemsRequest, options?: AxiosRequestConfig) {
        return OGCAPIFeaturesApi_GetCustomCollectionItems(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}

