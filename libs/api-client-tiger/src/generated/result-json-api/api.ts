// (C) 2025 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Bulk CSV analysis request.
 */
export interface AnalyzeCsvRequest {
    /**
     * List of individual CSV analysis requests.
     */
    analyzeRequests: Array<AnalyzeCsvRequestItem>;
}
/**
 * CSV analysis request.
 */
export interface AnalyzeCsvRequestItem {
    /**
     * Location of the CSV file to analyze.
     */
    location: string;
    config?: AnalyzeCsvRequestItemConfig;
}
/**
 * CSV analysis request config.
 */
export interface AnalyzeCsvRequestItemConfig {
    /**
     * Number of rows to return in the flight that represents analysis result. If 0, no rows are returned, if less than 0, all rows that were in the sample are returned.
     */
    resultRows?: number;
    /**
     * Maximum number of rows to work with during header detection.
     */
    headerDetectMaxRows?: number;
    /**
     * Number of rows to consider as header, if null, header will be detected.
     */
    headerRowCount?: number;
    /**
     * Possible column delimiters.
     */
    delimiters?: Array<string>;
}
/**
 * Describes the results of a CSV analysis of a single file.
 */
export interface AnalyzeCsvResponse {
    /**
     * Location of the analyzed file in the source data source.
     */
    location: string;
    /**
     * List of column metadata.
     */
    columns: Array<AnalyzeCsvResponseColumn>;
    /**
     * Preview of the first N rows of the file.
     */
    previewData: Array<Array<object>>;
    config?: AnalyzeCsvResponseConfig;
}
/**
 * Describes the result column.
 */
export interface AnalyzeCsvResponseColumn {
    /**
     * Name of the column as specified in the file (or autogenerated one if the file has no header).
     */
    name: string;
    /**
     * Type of the column (e.g. string, bool, etc.).
     */
    type: string;
    /**
     * List of date formats that can be used to parse this column as date. Null if there are none.
     */
    detectedDateFormats?: Array<string>;
}
/**
 * Config used to process the CSV file.
 */
export interface AnalyzeCsvResponseConfig {
    readOptions?: CsvReadOptions;
    parseOptions?: CsvParseOptions;
    convertOptions?: CsvConvertOptions;
}
/**
 * Information about a period in time and how much cached data was removed.
 */
export interface CacheRemovalInterval {
    /**
     * Start timestamp of the removal interval.
     */
    from: string;
    /**
     * End timestamp of the removal interval.
     */
    to: string;
    /**
     * Bytes removed during this interval.
     */
    removed: number;
}
/**
 * Result of scan of data source physical model.
 */
export interface CacheUsageData {
    organizationCacheUsage: OrganizationCacheUsage;
    /**
     * Map of data about the cache usage of the individual workspaces.
     */
    workspaceCacheUsages: { [key: string]: WorkspaceCacheUsage };
}
/**
 * Options for converting CSV files when reading.
 */
export interface CsvConvertOptions {
    /**
     * Whether to check UTF8 validity of string columns.
     */
    checkUtf8?: boolean;
    /**
     * Information about the column types in the table.
     */
    columnTypes?: Array<CsvConvertOptionsColumnType>;
    /**
     * Sequence of strings that denote nulls in the data.
     */
    nullValues?: Array<string>;
    /**
     * Sequence of strings that denote true Booleans in the data.
     */
    trueValues?: Array<string>;
    /**
     * Sequence of strings that denote false Booleans in the data.
     */
    falseValues?: Array<string>;
    /**
     * The character used as decimal point in floating-point and decimal data.
     */
    decimalPoint?: string;
    /**
     * Whether string / binary columns can have null values.
     */
    stringsCanBeNull?: boolean;
    /**
     * Whether quoted values can be null.
     */
    quotedStringsCanBeNull?: boolean;
    /**
     * The names of columns to include in the Table. If empty, the Table will include all columns from the CSV file. If not empty, only these columns will be included, in this order.
     */
    includeColumns?: Array<string>;
    /**
     * If false, columns in includeColumns but not in the CSV file will error out.
     */
    includeMissingColumns?: boolean;
    /**
     * Whether to try to automatically dict-encode string / binary data.
     */
    autoDictEncode?: boolean;
    /**
     * The maximum dictionary cardinality for autoDictEncode.
     */
    autoDictMaxCardinality?: number;
    /**
     * Sequence of strptime()-compatible format strings, tried in order when attempting to infer or convert timestamp values.
     */
    timestampParsers?: Array<string>;
}
/**
 * Information about a certain column in the table.
 */
export interface CsvConvertOptionsColumnType {
    /**
     * The column name.
     */
    name?: string;
    /**
     * The column type.
     */
    type?: string;
    /**
     * Whether the data in the given column can be null.
     */
    nullable?: boolean;
}
/**
 * Body of the CSV manifest.
 */
export interface CsvManifestBody {
    read?: CsvReadOptions;
    parse?: CsvParseOptions;
    convert?: CsvConvertOptions;
    /**
     * Map of column names to date formats to use when parsing them as dates.
     */
    column_date_formats?: { [key: string]: string };
    /**
     * Method used to read the CSV file.
     */
    read_method?: string;
}
/**
 * Options for parsing CSV files.
 */
export interface CsvParseOptions {
    /**
     * The character delimiting individual cells in the CSV data.
     */
    delimiter?: string;
    /**
     * The character used optionally for quoting CSV values or false to disable quoting.
     */
    quoteChar?: object;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data.
     */
    doubleQuote?: boolean;
    /**
     * The character used optionally for escaping special characters or false to disable escaping.
     */
    escapeChar?: object;
    /**
     * Whether newline characters are allowed in CSV values.
     */
    newlinesInValues?: boolean;
    /**
     * Whether empty lines are ignored in CSV input.
     */
    ignoreEmptyLines?: boolean;
}
/**
 * Options for reading CSV files.
 */
export interface CsvReadOptions {
    /**
     * Whether to use multiple threads to accelerate reading.
     */
    useThreads?: boolean;
    /**
     * How many bytes to process at a time from the input stream.
     */
    blockSize?: number;
    /**
     * The number of rows to skip before the column names (if any) and the CSV data.
     */
    skipRows?: number;
    /**
     * The number of rows to skip after the column names.
     */
    skipRowsAfterNames?: number;
    /**
     * The column names of the target table.
     */
    columnNames?: Array<string>;
    /**
     * Whether to autogenerate column names if columnNames is empty.
     */
    autoGenerateColumnNames?: boolean;
    /**
     * The character encoding of the CSV data.
     */
    encoding?: string;
}
/**
 * Request to delete files from the storage.
 */
export interface DeleteFilesRequest {
    /**
     * Names of the files to delete.
     */
    fileNames: Array<string>;
}
/**
 * File stored in GD Storage.
 */
export interface GdStorageFile {
    /**
     * Name of the file.
     */
    name: string;
    /**
     * Size of the file in bytes.
     */
    size: number;
    /**
     * Last modification timestamp of the file.
     */
    modifiedAt: string;
    /**
     * Type of the file.
     */
    type: GdStorageFileTypeEnum;
}

export const GdStorageFileTypeEnum = {
    CSV: "CSV",
} as const;

export type GdStorageFileTypeEnum = (typeof GdStorageFileTypeEnum)[keyof typeof GdStorageFileTypeEnum];

/**
 * Request containing the information necessary to import one or more CSV files from the staging area.
 */
export interface ImportCsvRequest {
    /**
     * Information about the individual tables.
     */
    tables: Array<ImportCsvRequestTable>;
}
/**
 * Information about a particular table.
 */
export interface ImportCsvRequestTable {
    /**
     * Name of the table.
     */
    name: string;
    source: ImportCsvRequestTableSource;
}
/**
 * Information about source data for a particular table.
 */
export interface ImportCsvRequestTableSource {
    /**
     * Location of the data in the staging area.
     */
    location: string;
    config: ImportCsvRequestTableSourceConfig;
}
/**
 * Config to use when accessing the data for executions, etc.
 */
export interface ImportCsvRequestTableSourceConfig {
    readOptions?: CsvReadOptions;
    parseOptions?: CsvParseOptions;
    convertOptions?: CsvConvertOptions;
    /**
     * Date formats to use to use to read the given columns.
     */
    columnDateFormats?: { [key: string]: string };
}
/**
 * Response containing the information about the imported CSV file.
 */
export interface ImportCsvResponse {
    /**
     * Name of the table the file was imported to.
     */
    name: string;
    /**
     * Version the file was imported as.
     */
    version: number;
}
/**
 * Settings for organization cache.
 */
export interface OrganizationCacheSettings {
    /**
     * Extra cache budget the organization can allocate among its workspaces, in bytes.
     */
    extraCacheBudget: number;
}
/**
 * Data about the whole organization\'s cache usage.
 */
export interface OrganizationCacheUsage {
    settings: OrganizationCacheSettings;
    current: OrganizationCurrentCacheUsage;
    /**
     * List of cache removal intervals.
     */
    removalIntervals: Array<CacheRemovalInterval>;
}
/**
 * Current cache usage of the organization.
 */
export interface OrganizationCurrentCacheUsage {
    /**
     * Cache currently used by the organization, in bytes.
     */
    cacheUsed: number;
    /**
     * Start timestamp of removal period.
     */
    removalPeriodStart?: string;
    /**
     * Bytes removed since start due to insufficient cache.
     */
    removedSinceStart: number;
}
/**
 * Request to read the manifests of the specified CSV files.
 */
export interface ReadCsvFileManifestsRequest {
    /**
     * Files to read the manifests for.
     */
    manifestRequests: Array<ReadCsvFileManifestsRequestItem>;
}
/**
 * Request to read the manifest of a single CSV file.
 */
export interface ReadCsvFileManifestsRequestItem {
    /**
     * Name of the CSV file to read the manifest for.
     */
    fileName: string;
    /**
     * Optional version of the file to read the manifest for. If null or not specified, the latest version is read.
     */
    version?: number;
}
/**
 * Describes the results of a CSV manifest read of a single file.
 */
export interface ReadCsvFileManifestsResponse {
    /**
     * Name of the file in the source data source.
     */
    name: string;
    /**
     * Version of the file in the source data source.
     */
    version: number;
    manifest: CsvManifestBody;
}
/**
 * Information related to the file uploaded to the staging area.
 */
export interface UploadFileResponse {
    /**
     * Location to use when referencing the uploaded file in subsequent requests.
     */
    location: string;
}
/**
 * Cache settings for the workspace.
 */
export interface WorkspaceCacheSettings {
    /**
     * Extra cache for the workspace, in bytes.
     */
    extraCache: number;
}
/**
 * Data about a particular workspace cache usage.
 */
export interface WorkspaceCacheUsage {
    settings: WorkspaceCacheSettings;
    current: WorkspaceCurrentCacheUsage;
    /**
     * List of cache removal intervals for workspace.
     */
    removalIntervals: Array<CacheRemovalInterval>;
}
/**
 * Current cache usage of the workspace.
 */
export interface WorkspaceCurrentCacheUsage {
    /**
     * Cache used by the workspace.
     */
    cacheUsed: number;
    /**
     * Cache available for the workspace.
     */
    cacheAvailable: number;
    /**
     * Start timestamp of removal period for the workspace.
     */
    removalPeriodStart: string;
    /**
     * Bytes removed since start due to insufficient cache for the workspace.
     */
    removedSinceStart: number;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv: async (
            analyzeCsvRequest: AnalyzeCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'analyzeCsvRequest' is not null or undefined
            assertParamExists("analyzeCsv", "analyzeCsvRequest", analyzeCsvRequest);
            const localVarPath = `/api/v1/actions/fileStorage/staging/analyzeCsv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof analyzeCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(analyzeCsvRequest !== undefined ? analyzeCsvRequest : {})
                : analyzeCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/collectCacheUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {string} dataSourceId
         * @param {DeleteFilesRequest} deleteFilesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles: async (
            dataSourceId: string,
            deleteFilesRequest: DeleteFilesRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("deleteFiles", "dataSourceId", dataSourceId);
            // verify required parameter 'deleteFilesRequest' is not null or undefined
            assertParamExists("deleteFiles", "deleteFilesRequest", deleteFilesRequest);
            const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/deleteFiles`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof deleteFilesRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(deleteFilesRequest !== undefined ? deleteFilesRequest : {})
                : deleteFilesRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv: async (
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("importCsv", "dataSourceId", dataSourceId);
            // verify required parameter 'importCsvRequest' is not null or undefined
            assertParamExists("importCsv", "importCsvRequest", importCsvRequest);
            const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/importCsv`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof importCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(importCsvRequest !== undefined ? importCsvRequest : {})
                : importCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: async (dataSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("listFiles", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/listFiles`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read the manifests of the CSV files in the given data source.
         * @summary Read CSV file manifests
         * @param {string} dataSourceId
         * @param {ReadCsvFileManifestsRequest} readCsvFileManifestsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCsvFileManifests: async (
            dataSourceId: string,
            readCsvFileManifestsRequest: ReadCsvFileManifestsRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("readCsvFileManifests", "dataSourceId", dataSourceId);
            // verify required parameter 'readCsvFileManifestsRequest' is not null or undefined
            assertParamExists(
                "readCsvFileManifests",
                "readCsvFileManifestsRequest",
                readCsvFileManifestsRequest,
            );
            const localVarPath =
                `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/readCsvFileManifests`.replace(
                    `{${"dataSourceId"}}`,
                    encodeURIComponent(String(dataSourceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof readCsvFileManifestsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(readCsvFileManifestsRequest !== undefined ? readCsvFileManifestsRequest : {})
                : readCsvFileManifestsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {File} file The file to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stagingUpload: async (file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists("stagingUpload", "file", file);
            const localVarPath = `/api/v1/actions/fileStorage/staging/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (file !== undefined) {
                localVarFormParams.append("file", file as any);
            }

            localVarHeaderParameter["Content-Type"] = "multipart/form-data";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzeCsv(
            analyzeCsvRequest: AnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnalyzeCsvResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeCsv(analyzeCsvRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectCacheUsage(
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacheUsageData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectCacheUsage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {string} dataSourceId
         * @param {DeleteFilesRequest} deleteFilesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFiles(
            dataSourceId: string,
            deleteFilesRequest: DeleteFilesRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFiles(
                dataSourceId,
                deleteFilesRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCsv(
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImportCsvResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCsv(
                dataSourceId,
                importCsvRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFiles(
            dataSourceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GdStorageFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Read the manifests of the CSV files in the given data source.
         * @summary Read CSV file manifests
         * @param {string} dataSourceId
         * @param {ReadCsvFileManifestsRequest} readCsvFileManifestsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCsvFileManifests(
            dataSourceId: string,
            readCsvFileManifestsRequest: ReadCsvFileManifestsRequest,
            options?: AxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReadCsvFileManifestsResponse>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCsvFileManifests(
                dataSourceId,
                readCsvFileManifestsRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {File} file The file to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stagingUpload(
            file: File,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stagingUpload(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv(
            requestParameters: ActionsApiAnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<AnalyzeCsvResponse>> {
            return localVarFp
                .analyzeCsv(requestParameters.analyzeCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData> {
            return localVarFp.collectCacheUsage(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {ActionsApiDeleteFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles(
            requestParameters: ActionsApiDeleteFilesRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteFiles(requestParameters.dataSourceId, requestParameters.deleteFilesRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv(
            requestParameters: ActionsApiImportCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<ImportCsvResponse>> {
            return localVarFp
                .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {ActionsApiListFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(
            requestParameters: ActionsApiListFilesRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<GdStorageFile>> {
            return localVarFp
                .listFiles(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Read the manifests of the CSV files in the given data source.
         * @summary Read CSV file manifests
         * @param {ActionsApiReadCsvFileManifestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCsvFileManifests(
            requestParameters: ActionsApiReadCsvFileManifestsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<ReadCsvFileManifestsResponse>> {
            return localVarFp
                .readCsvFileManifests(
                    requestParameters.dataSourceId,
                    requestParameters.readCsvFileManifestsRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {ActionsApiStagingUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stagingUpload(
            requestParameters: ActionsApiStagingUploadRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<UploadFileResponse> {
            return localVarFp
                .stagingUpload(requestParameters.file, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    analyzeCsv(
        requestParameters: ActionsApiAnalyzeCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<AnalyzeCsvResponse>>;

    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData>;

    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {ActionsApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    deleteFiles(
        requestParameters: ActionsApiDeleteFilesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    importCsv(
        requestParameters: ActionsApiImportCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ImportCsvResponse>>;

    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {ActionsApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    listFiles(
        requestParameters: ActionsApiListFilesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<GdStorageFile>>;

    /**
     * Read the manifests of the CSV files in the given data source.
     * @summary Read CSV file manifests
     * @param {ActionsApiReadCsvFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    readCsvFileManifests(
        requestParameters: ActionsApiReadCsvFileManifestsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ReadCsvFileManifestsResponse>>;

    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {ActionsApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    stagingUpload(
        requestParameters: ActionsApiStagingUploadRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<UploadFileResponse>;
}

/**
 * Request parameters for analyzeCsv operation in ActionsApi.
 * @export
 * @interface ActionsApiAnalyzeCsvRequest
 */
export interface ActionsApiAnalyzeCsvRequest {
    /**
     *
     * @type {AnalyzeCsvRequest}
     * @memberof ActionsApiAnalyzeCsv
     */
    readonly analyzeCsvRequest: AnalyzeCsvRequest;
}

/**
 * Request parameters for deleteFiles operation in ActionsApi.
 * @export
 * @interface ActionsApiDeleteFilesRequest
 */
export interface ActionsApiDeleteFilesRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiDeleteFiles
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {DeleteFilesRequest}
     * @memberof ActionsApiDeleteFiles
     */
    readonly deleteFilesRequest: DeleteFilesRequest;
}

/**
 * Request parameters for importCsv operation in ActionsApi.
 * @export
 * @interface ActionsApiImportCsvRequest
 */
export interface ActionsApiImportCsvRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiImportCsv
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ImportCsvRequest}
     * @memberof ActionsApiImportCsv
     */
    readonly importCsvRequest: ImportCsvRequest;
}

/**
 * Request parameters for listFiles operation in ActionsApi.
 * @export
 * @interface ActionsApiListFilesRequest
 */
export interface ActionsApiListFilesRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiListFiles
     */
    readonly dataSourceId: string;
}

/**
 * Request parameters for readCsvFileManifests operation in ActionsApi.
 * @export
 * @interface ActionsApiReadCsvFileManifestsRequest
 */
export interface ActionsApiReadCsvFileManifestsRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiReadCsvFileManifests
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ReadCsvFileManifestsRequest}
     * @memberof ActionsApiReadCsvFileManifests
     */
    readonly readCsvFileManifestsRequest: ReadCsvFileManifestsRequest;
}

/**
 * Request parameters for stagingUpload operation in ActionsApi.
 * @export
 * @interface ActionsApiStagingUploadRequest
 */
export interface ActionsApiStagingUploadRequest {
    /**
     * The file to upload.
     * @type {File}
     * @memberof ActionsApiStagingUpload
     */
    readonly file: File;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {ActionsApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public analyzeCsv(requestParameters: ActionsApiAnalyzeCsvRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .analyzeCsv(requestParameters.analyzeCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public collectCacheUsage(options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .collectCacheUsage(options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {ActionsApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public deleteFiles(requestParameters: ActionsApiDeleteFilesRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .deleteFiles(requestParameters.dataSourceId, requestParameters.deleteFilesRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {ActionsApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public importCsv(requestParameters: ActionsApiImportCsvRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {ActionsApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public listFiles(requestParameters: ActionsApiListFilesRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .listFiles(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read the manifests of the CSV files in the given data source.
     * @summary Read CSV file manifests
     * @param {ActionsApiReadCsvFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public readCsvFileManifests(
        requestParameters: ActionsApiReadCsvFileManifestsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .readCsvFileManifests(
                requestParameters.dataSourceId,
                requestParameters.readCsvFileManifestsRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {ActionsApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public stagingUpload(requestParameters: ActionsApiStagingUploadRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .stagingUpload(requestParameters.file, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * CacheUsageApi - axios parameter creator
 * @export
 */
export const CacheUsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/collectCacheUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * CacheUsageApi - functional programming interface
 * @export
 */
export const CacheUsageApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CacheUsageApiAxiosParamCreator(configuration);
    return {
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async collectCacheUsage(
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CacheUsageData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.collectCacheUsage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * CacheUsageApi - factory interface
 * @export
 */
export const CacheUsageApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = CacheUsageApiFp(configuration);
    return {
        /**
         * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
         * @summary Collect data about the current cache usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData> {
            return localVarFp.collectCacheUsage(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CacheUsageApi - interface
 * @export
 * @interface CacheUsageApi
 */
export interface CacheUsageApiInterface {
    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CacheUsageApiInterface
     */
    collectCacheUsage(options?: AxiosRequestConfig): AxiosPromise<CacheUsageData>;
}

/**
 * CacheUsageApi - object-oriented interface
 * @export
 * @class CacheUsageApi
 * @extends {BaseAPI}
 */
export class CacheUsageApi extends BaseAPI implements CacheUsageApiInterface {
    /**
     * Get the detailed data about how much cache your organization is currently using, broken down by individual workspaces.
     * @summary Collect data about the current cache usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CacheUsageApi
     */
    public collectCacheUsage(options?: AxiosRequestConfig) {
        return CacheUsageApiFp(this.configuration)
            .collectCacheUsage(options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesAnalysisApi - axios parameter creator
 * @export
 */
export const DataSourceFilesAnalysisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv: async (
            analyzeCsvRequest: AnalyzeCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'analyzeCsvRequest' is not null or undefined
            assertParamExists("analyzeCsv", "analyzeCsvRequest", analyzeCsvRequest);
            const localVarPath = `/api/v1/actions/fileStorage/staging/analyzeCsv`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof analyzeCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(analyzeCsvRequest !== undefined ? analyzeCsvRequest : {})
                : analyzeCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesAnalysisApi - functional programming interface
 * @export
 */
export const DataSourceFilesAnalysisApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesAnalysisApiAxiosParamCreator(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {AnalyzeCsvRequest} analyzeCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyzeCsv(
            analyzeCsvRequest: AnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnalyzeCsvResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyzeCsv(analyzeCsvRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesAnalysisApi - factory interface
 * @export
 */
export const DataSourceFilesAnalysisApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesAnalysisApiFp(configuration);
    return {
        /**
         * Analyzes CSV files at the given locations
         * @summary Analyze CSV
         * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyzeCsv(
            requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<AnalyzeCsvResponse>> {
            return localVarFp
                .analyzeCsv(requestParameters.analyzeCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesAnalysisApi - interface
 * @export
 * @interface DataSourceFilesAnalysisApi
 */
export interface DataSourceFilesAnalysisApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesAnalysisApiInterface
     */
    analyzeCsv(
        requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<AnalyzeCsvResponse>>;
}

/**
 * Request parameters for analyzeCsv operation in DataSourceFilesAnalysisApi.
 * @export
 * @interface DataSourceFilesAnalysisApiAnalyzeCsvRequest
 */
export interface DataSourceFilesAnalysisApiAnalyzeCsvRequest {
    /**
     *
     * @type {AnalyzeCsvRequest}
     * @memberof DataSourceFilesAnalysisApiAnalyzeCsv
     */
    readonly analyzeCsvRequest: AnalyzeCsvRequest;
}

/**
 * DataSourceFilesAnalysisApi - object-oriented interface
 * @export
 * @class DataSourceFilesAnalysisApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesAnalysisApi extends BaseAPI implements DataSourceFilesAnalysisApiInterface {
    /**
     * Analyzes CSV files at the given locations
     * @summary Analyze CSV
     * @param {DataSourceFilesAnalysisApiAnalyzeCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesAnalysisApi
     */
    public analyzeCsv(
        requestParameters: DataSourceFilesAnalysisApiAnalyzeCsvRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesAnalysisApiFp(this.configuration)
            .analyzeCsv(requestParameters.analyzeCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesDeletionApi - axios parameter creator
 * @export
 */
export const DataSourceFilesDeletionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {string} dataSourceId
         * @param {DeleteFilesRequest} deleteFilesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles: async (
            dataSourceId: string,
            deleteFilesRequest: DeleteFilesRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("deleteFiles", "dataSourceId", dataSourceId);
            // verify required parameter 'deleteFilesRequest' is not null or undefined
            assertParamExists("deleteFiles", "deleteFilesRequest", deleteFilesRequest);
            const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/deleteFiles`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof deleteFilesRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(deleteFilesRequest !== undefined ? deleteFilesRequest : {})
                : deleteFilesRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesDeletionApi - functional programming interface
 * @export
 */
export const DataSourceFilesDeletionApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesDeletionApiAxiosParamCreator(configuration);
    return {
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {string} dataSourceId
         * @param {DeleteFilesRequest} deleteFilesRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFiles(
            dataSourceId: string,
            deleteFilesRequest: DeleteFilesRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFiles(
                dataSourceId,
                deleteFilesRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesDeletionApi - factory interface
 * @export
 */
export const DataSourceFilesDeletionApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesDeletionApiFp(configuration);
    return {
        /**
         * Delete the files in the given data source.
         * @summary Delete datasource files
         * @param {DataSourceFilesDeletionApiDeleteFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFiles(
            requestParameters: DataSourceFilesDeletionApiDeleteFilesRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .deleteFiles(requestParameters.dataSourceId, requestParameters.deleteFilesRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesDeletionApi - interface
 * @export
 * @interface DataSourceFilesDeletionApi
 */
export interface DataSourceFilesDeletionApiInterface {
    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {DataSourceFilesDeletionApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesDeletionApiInterface
     */
    deleteFiles(
        requestParameters: DataSourceFilesDeletionApiDeleteFilesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for deleteFiles operation in DataSourceFilesDeletionApi.
 * @export
 * @interface DataSourceFilesDeletionApiDeleteFilesRequest
 */
export interface DataSourceFilesDeletionApiDeleteFilesRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceFilesDeletionApiDeleteFiles
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {DeleteFilesRequest}
     * @memberof DataSourceFilesDeletionApiDeleteFiles
     */
    readonly deleteFilesRequest: DeleteFilesRequest;
}

/**
 * DataSourceFilesDeletionApi - object-oriented interface
 * @export
 * @class DataSourceFilesDeletionApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesDeletionApi extends BaseAPI implements DataSourceFilesDeletionApiInterface {
    /**
     * Delete the files in the given data source.
     * @summary Delete datasource files
     * @param {DataSourceFilesDeletionApiDeleteFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesDeletionApi
     */
    public deleteFiles(
        requestParameters: DataSourceFilesDeletionApiDeleteFilesRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesDeletionApiFp(this.configuration)
            .deleteFiles(requestParameters.dataSourceId, requestParameters.deleteFilesRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesImportApi - axios parameter creator
 * @export
 */
export const DataSourceFilesImportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv: async (
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("importCsv", "dataSourceId", dataSourceId);
            // verify required parameter 'importCsvRequest' is not null or undefined
            assertParamExists("importCsv", "importCsvRequest", importCsvRequest);
            const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/importCsv`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof importCsvRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(importCsvRequest !== undefined ? importCsvRequest : {})
                : importCsvRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesImportApi - functional programming interface
 * @export
 */
export const DataSourceFilesImportApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesImportApiAxiosParamCreator(configuration);
    return {
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {string} dataSourceId
         * @param {ImportCsvRequest} importCsvRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCsv(
            dataSourceId: string,
            importCsvRequest: ImportCsvRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImportCsvResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCsv(
                dataSourceId,
                importCsvRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesImportApi - factory interface
 * @export
 */
export const DataSourceFilesImportApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesImportApiFp(configuration);
    return {
        /**
         * Import the CSV files at the given locations in the staging area to the final location.
         * @summary Import CSV
         * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCsv(
            requestParameters: DataSourceFilesImportApiImportCsvRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<ImportCsvResponse>> {
            return localVarFp
                .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesImportApi - interface
 * @export
 * @interface DataSourceFilesImportApi
 */
export interface DataSourceFilesImportApiInterface {
    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesImportApiInterface
     */
    importCsv(
        requestParameters: DataSourceFilesImportApiImportCsvRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ImportCsvResponse>>;
}

/**
 * Request parameters for importCsv operation in DataSourceFilesImportApi.
 * @export
 * @interface DataSourceFilesImportApiImportCsvRequest
 */
export interface DataSourceFilesImportApiImportCsvRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceFilesImportApiImportCsv
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ImportCsvRequest}
     * @memberof DataSourceFilesImportApiImportCsv
     */
    readonly importCsvRequest: ImportCsvRequest;
}

/**
 * DataSourceFilesImportApi - object-oriented interface
 * @export
 * @class DataSourceFilesImportApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesImportApi extends BaseAPI implements DataSourceFilesImportApiInterface {
    /**
     * Import the CSV files at the given locations in the staging area to the final location.
     * @summary Import CSV
     * @param {DataSourceFilesImportApiImportCsvRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesImportApi
     */
    public importCsv(
        requestParameters: DataSourceFilesImportApiImportCsvRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesImportApiFp(this.configuration)
            .importCsv(requestParameters.dataSourceId, requestParameters.importCsvRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesListingApi - axios parameter creator
 * @export
 */
export const DataSourceFilesListingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles: async (dataSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("listFiles", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/listFiles`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesListingApi - functional programming interface
 * @export
 */
export const DataSourceFilesListingApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesListingApiAxiosParamCreator(configuration);
    return {
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {string} dataSourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFiles(
            dataSourceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GdStorageFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFiles(dataSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesListingApi - factory interface
 * @export
 */
export const DataSourceFilesListingApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesListingApiFp(configuration);
    return {
        /**
         * List all the files in the given data source.
         * @summary List datasource files
         * @param {DataSourceFilesListingApiListFilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFiles(
            requestParameters: DataSourceFilesListingApiListFilesRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<GdStorageFile>> {
            return localVarFp
                .listFiles(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesListingApi - interface
 * @export
 * @interface DataSourceFilesListingApi
 */
export interface DataSourceFilesListingApiInterface {
    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {DataSourceFilesListingApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesListingApiInterface
     */
    listFiles(
        requestParameters: DataSourceFilesListingApiListFilesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<GdStorageFile>>;
}

/**
 * Request parameters for listFiles operation in DataSourceFilesListingApi.
 * @export
 * @interface DataSourceFilesListingApiListFilesRequest
 */
export interface DataSourceFilesListingApiListFilesRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceFilesListingApiListFiles
     */
    readonly dataSourceId: string;
}

/**
 * DataSourceFilesListingApi - object-oriented interface
 * @export
 * @class DataSourceFilesListingApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesListingApi extends BaseAPI implements DataSourceFilesListingApiInterface {
    /**
     * List all the files in the given data source.
     * @summary List datasource files
     * @param {DataSourceFilesListingApiListFilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesListingApi
     */
    public listFiles(
        requestParameters: DataSourceFilesListingApiListFilesRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesListingApiFp(this.configuration)
            .listFiles(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceFilesManifestReadApi - axios parameter creator
 * @export
 */
export const DataSourceFilesManifestReadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Read the manifests of the CSV files in the given data source.
         * @summary Read CSV file manifests
         * @param {string} dataSourceId
         * @param {ReadCsvFileManifestsRequest} readCsvFileManifestsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCsvFileManifests: async (
            dataSourceId: string,
            readCsvFileManifestsRequest: ReadCsvFileManifestsRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("readCsvFileManifests", "dataSourceId", dataSourceId);
            // verify required parameter 'readCsvFileManifestsRequest' is not null or undefined
            assertParamExists(
                "readCsvFileManifests",
                "readCsvFileManifestsRequest",
                readCsvFileManifestsRequest,
            );
            const localVarPath =
                `/api/v1/actions/fileStorage/dataSources/{dataSourceId}/readCsvFileManifests`.replace(
                    `{${"dataSourceId"}}`,
                    encodeURIComponent(String(dataSourceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof readCsvFileManifestsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(readCsvFileManifestsRequest !== undefined ? readCsvFileManifestsRequest : {})
                : readCsvFileManifestsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceFilesManifestReadApi - functional programming interface
 * @export
 */
export const DataSourceFilesManifestReadApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceFilesManifestReadApiAxiosParamCreator(configuration);
    return {
        /**
         * Read the manifests of the CSV files in the given data source.
         * @summary Read CSV file manifests
         * @param {string} dataSourceId
         * @param {ReadCsvFileManifestsRequest} readCsvFileManifestsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readCsvFileManifests(
            dataSourceId: string,
            readCsvFileManifestsRequest: ReadCsvFileManifestsRequest,
            options?: AxiosRequestConfig,
        ): Promise<
            (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReadCsvFileManifestsResponse>>
        > {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readCsvFileManifests(
                dataSourceId,
                readCsvFileManifestsRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceFilesManifestReadApi - factory interface
 * @export
 */
export const DataSourceFilesManifestReadApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceFilesManifestReadApiFp(configuration);
    return {
        /**
         * Read the manifests of the CSV files in the given data source.
         * @summary Read CSV file manifests
         * @param {DataSourceFilesManifestReadApiReadCsvFileManifestsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readCsvFileManifests(
            requestParameters: DataSourceFilesManifestReadApiReadCsvFileManifestsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<ReadCsvFileManifestsResponse>> {
            return localVarFp
                .readCsvFileManifests(
                    requestParameters.dataSourceId,
                    requestParameters.readCsvFileManifestsRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceFilesManifestReadApi - interface
 * @export
 * @interface DataSourceFilesManifestReadApi
 */
export interface DataSourceFilesManifestReadApiInterface {
    /**
     * Read the manifests of the CSV files in the given data source.
     * @summary Read CSV file manifests
     * @param {DataSourceFilesManifestReadApiReadCsvFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesManifestReadApiInterface
     */
    readCsvFileManifests(
        requestParameters: DataSourceFilesManifestReadApiReadCsvFileManifestsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<ReadCsvFileManifestsResponse>>;
}

/**
 * Request parameters for readCsvFileManifests operation in DataSourceFilesManifestReadApi.
 * @export
 * @interface DataSourceFilesManifestReadApiReadCsvFileManifestsRequest
 */
export interface DataSourceFilesManifestReadApiReadCsvFileManifestsRequest {
    /**
     *
     * @type {string}
     * @memberof DataSourceFilesManifestReadApiReadCsvFileManifests
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ReadCsvFileManifestsRequest}
     * @memberof DataSourceFilesManifestReadApiReadCsvFileManifests
     */
    readonly readCsvFileManifestsRequest: ReadCsvFileManifestsRequest;
}

/**
 * DataSourceFilesManifestReadApi - object-oriented interface
 * @export
 * @class DataSourceFilesManifestReadApi
 * @extends {BaseAPI}
 */
export class DataSourceFilesManifestReadApi
    extends BaseAPI
    implements DataSourceFilesManifestReadApiInterface
{
    /**
     * Read the manifests of the CSV files in the given data source.
     * @summary Read CSV file manifests
     * @param {DataSourceFilesManifestReadApiReadCsvFileManifestsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceFilesManifestReadApi
     */
    public readCsvFileManifests(
        requestParameters: DataSourceFilesManifestReadApiReadCsvFileManifestsRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceFilesManifestReadApiFp(this.configuration)
            .readCsvFileManifests(
                requestParameters.dataSourceId,
                requestParameters.readCsvFileManifestsRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * DataSourceStagingLocationApi - axios parameter creator
 * @export
 */
export const DataSourceStagingLocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {File} file The file to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stagingUpload: async (file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists("stagingUpload", "file", file);
            const localVarPath = `/api/v1/actions/fileStorage/staging/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (file !== undefined) {
                localVarFormParams.append("file", file as any);
            }

            localVarHeaderParameter["Content-Type"] = "multipart/form-data";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DataSourceStagingLocationApi - functional programming interface
 * @export
 */
export const DataSourceStagingLocationApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSourceStagingLocationApiAxiosParamCreator(configuration);
    return {
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {File} file The file to upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stagingUpload(
            file: File,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stagingUpload(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * DataSourceStagingLocationApi - factory interface
 * @export
 */
export const DataSourceStagingLocationApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = DataSourceStagingLocationApiFp(configuration);
    return {
        /**
         * Provides a location for uploading staging files.
         * @summary Upload a file to the staging area
         * @param {DataSourceStagingLocationApiStagingUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stagingUpload(
            requestParameters: DataSourceStagingLocationApiStagingUploadRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<UploadFileResponse> {
            return localVarFp
                .stagingUpload(requestParameters.file, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourceStagingLocationApi - interface
 * @export
 * @interface DataSourceStagingLocationApi
 */
export interface DataSourceStagingLocationApiInterface {
    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {DataSourceStagingLocationApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceStagingLocationApiInterface
     */
    stagingUpload(
        requestParameters: DataSourceStagingLocationApiStagingUploadRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<UploadFileResponse>;
}

/**
 * Request parameters for stagingUpload operation in DataSourceStagingLocationApi.
 * @export
 * @interface DataSourceStagingLocationApiStagingUploadRequest
 */
export interface DataSourceStagingLocationApiStagingUploadRequest {
    /**
     * The file to upload.
     * @type {File}
     * @memberof DataSourceStagingLocationApiStagingUpload
     */
    readonly file: File;
}

/**
 * DataSourceStagingLocationApi - object-oriented interface
 * @export
 * @class DataSourceStagingLocationApi
 * @extends {BaseAPI}
 */
export class DataSourceStagingLocationApi extends BaseAPI implements DataSourceStagingLocationApiInterface {
    /**
     * Provides a location for uploading staging files.
     * @summary Upload a file to the staging area
     * @param {DataSourceStagingLocationApiStagingUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourceStagingLocationApi
     */
    public stagingUpload(
        requestParameters: DataSourceStagingLocationApiStagingUploadRequest,
        options?: AxiosRequestConfig,
    ) {
        return DataSourceStagingLocationApiFp(this.configuration)
            .stagingUpload(requestParameters.file, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
