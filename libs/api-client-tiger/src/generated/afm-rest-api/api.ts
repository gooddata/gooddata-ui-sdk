// (C) 2024 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 * @export
 * @interface AFM
 */
export interface AFM {
    /**
     * Attributes to be used in the computation.
     * @type {Array<AttributeItem>}
     * @memberof AFM
     */
    attributes: Array<AttributeItem>;
    /**
     * Various filter types to filter execution result.
     * @type {Array<FilterDefinition>}
     * @memberof AFM
     */
    filters: Array<FilterDefinition>;
    /**
     * Metrics to be computed.
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    measures: Array<MeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    auxMeasures?: Array<MeasureItem>;
}
/**
 * A datetime filter specifying exact from and to values.
 * @export
 * @interface AbsoluteDateFilter
 */
export interface AbsoluteDateFilter {
    /**
     *
     * @type {AbsoluteDateFilterAbsoluteDateFilter}
     * @memberof AbsoluteDateFilter
     */
    absoluteDateFilter: AbsoluteDateFilterAbsoluteDateFilter;
}
/**
 *
 * @export
 * @interface AbsoluteDateFilterAbsoluteDateFilter
 */
export interface AbsoluteDateFilterAbsoluteDateFilter {
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    from: string;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    to: string;
    /**
     *
     * @type {boolean}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifierDataset}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    dataset: AfmObjectIdentifierDataset;
}
/**
 * @type AbstractMeasureValueFilter
 * @export
 */
export type AbstractMeasureValueFilter =
    | ComparisonMeasureValueFilter
    | RangeMeasureValueFilter
    | RankingFilter;

/**
 *
 * @export
 * @interface AfmExecution
 */
export interface AfmExecution {
    /**
     *
     * @type {AFM}
     * @memberof AfmExecution
     */
    execution: AFM;
    /**
     *
     * @type {ResultSpec}
     * @memberof AfmExecution
     */
    resultSpec: ResultSpec;
    /**
     *
     * @type {ExecutionSettings}
     * @memberof AfmExecution
     */
    settings?: ExecutionSettings;
}
/**
 *
 * @export
 * @interface AfmExecutionResponse
 */
export interface AfmExecutionResponse {
    /**
     *
     * @type {ExecutionResponse}
     * @memberof AfmExecutionResponse
     */
    executionResponse: ExecutionResponse;
}
/**
 * @type AfmIdentifier
 * @export
 */
export type AfmIdentifier = AfmLocalIdentifier | AfmObjectIdentifier;

/**
 *
 * @export
 * @interface AfmLocalIdentifier
 */
export interface AfmLocalIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmLocalIdentifier
     */
    localIdentifier: string;
}
/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 * @export
 * @interface AfmObjectIdentifier
 */
export interface AfmObjectIdentifier {
    /**
     *
     * @type {AfmObjectIdentifierIdentifier}
     * @memberof AfmObjectIdentifier
     */
    identifier: AfmObjectIdentifierIdentifier;
}
/**
 *
 * @export
 * @interface AfmObjectIdentifierAttribute
 */
export interface AfmObjectIdentifierAttribute {
    /**
     *
     * @type {AfmObjectIdentifierAttributeIdentifier}
     * @memberof AfmObjectIdentifierAttribute
     */
    identifier: AfmObjectIdentifierAttributeIdentifier;
}
/**
 *
 * @export
 * @interface AfmObjectIdentifierAttributeIdentifier
 */
export interface AfmObjectIdentifierAttributeIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierAttributeIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierAttributeIdentifier
     */
    type: AfmObjectIdentifierAttributeIdentifierTypeEnum;
}

export const AfmObjectIdentifierAttributeIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
} as const;

export type AfmObjectIdentifierAttributeIdentifierTypeEnum =
    typeof AfmObjectIdentifierAttributeIdentifierTypeEnum[keyof typeof AfmObjectIdentifierAttributeIdentifierTypeEnum];

/**
 *
 * @export
 * @interface AfmObjectIdentifierCore
 */
export interface AfmObjectIdentifierCore {
    /**
     *
     * @type {AfmObjectIdentifierCoreIdentifier}
     * @memberof AfmObjectIdentifierCore
     */
    identifier: AfmObjectIdentifierCoreIdentifier;
}
/**
 *
 * @export
 * @interface AfmObjectIdentifierCoreIdentifier
 */
export interface AfmObjectIdentifierCoreIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierCoreIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierCoreIdentifier
     */
    type: AfmObjectIdentifierCoreIdentifierTypeEnum;
}

export const AfmObjectIdentifierCoreIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
    LABEL: "label",
    FACT: "fact",
    METRIC: "metric",
} as const;

export type AfmObjectIdentifierCoreIdentifierTypeEnum =
    typeof AfmObjectIdentifierCoreIdentifierTypeEnum[keyof typeof AfmObjectIdentifierCoreIdentifierTypeEnum];

/**
 *
 * @export
 * @interface AfmObjectIdentifierDataset
 */
export interface AfmObjectIdentifierDataset {
    /**
     *
     * @type {AfmObjectIdentifierDatasetIdentifier}
     * @memberof AfmObjectIdentifierDataset
     */
    identifier: AfmObjectIdentifierDatasetIdentifier;
}
/**
 *
 * @export
 * @interface AfmObjectIdentifierDatasetIdentifier
 */
export interface AfmObjectIdentifierDatasetIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierDatasetIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierDatasetIdentifier
     */
    type: AfmObjectIdentifierDatasetIdentifierTypeEnum;
}

export const AfmObjectIdentifierDatasetIdentifierTypeEnum = {
    DATASET: "dataset",
} as const;

export type AfmObjectIdentifierDatasetIdentifierTypeEnum =
    typeof AfmObjectIdentifierDatasetIdentifierTypeEnum[keyof typeof AfmObjectIdentifierDatasetIdentifierTypeEnum];

/**
 *
 * @export
 * @interface AfmObjectIdentifierIdentifier
 */
export interface AfmObjectIdentifierIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierIdentifier
     */
    type: AfmObjectIdentifierIdentifierTypeEnum;
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierIdentifier
     */
    id: string;
}

export const AfmObjectIdentifierIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
} as const;

export type AfmObjectIdentifierIdentifierTypeEnum =
    typeof AfmObjectIdentifierIdentifierTypeEnum[keyof typeof AfmObjectIdentifierIdentifierTypeEnum];

/**
 *
 * @export
 * @interface AfmObjectIdentifierLabel
 */
export interface AfmObjectIdentifierLabel {
    /**
     *
     * @type {AfmObjectIdentifierLabelIdentifier}
     * @memberof AfmObjectIdentifierLabel
     */
    identifier: AfmObjectIdentifierLabelIdentifier;
}
/**
 *
 * @export
 * @interface AfmObjectIdentifierLabelIdentifier
 */
export interface AfmObjectIdentifierLabelIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierLabelIdentifier
     */
    type: AfmObjectIdentifierLabelIdentifierTypeEnum;
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierLabelIdentifier
     */
    id: string;
}

export const AfmObjectIdentifierLabelIdentifierTypeEnum = {
    LABEL: "label",
} as const;

export type AfmObjectIdentifierLabelIdentifierTypeEnum =
    typeof AfmObjectIdentifierLabelIdentifierTypeEnum[keyof typeof AfmObjectIdentifierLabelIdentifierTypeEnum];

/**
 * Entity describing the valid descendants request.
 * @export
 * @interface AfmValidDescendantsQuery
 */
export interface AfmValidDescendantsQuery {
    /**
     * List of identifiers of the attributes to get the valid descendants for.
     * @type {Array<AfmObjectIdentifierAttribute>}
     * @memberof AfmValidDescendantsQuery
     */
    attributes: Array<AfmObjectIdentifierAttribute>;
}
/**
 * Entity describing the valid descendants response.
 * @export
 * @interface AfmValidDescendantsResponse
 */
export interface AfmValidDescendantsResponse {
    /**
     * Map of attribute identifiers to list of valid descendants identifiers.
     * @type {{ [key: string]: Array<AfmObjectIdentifierAttribute>; }}
     * @memberof AfmValidDescendantsResponse
     */
    validDescendants: { [key: string]: Array<AfmObjectIdentifierAttribute> };
}
/**
 * Entity holding AFM and list of object types whose validity should be computed.
 * @export
 * @interface AfmValidObjectsQuery
 */
export interface AfmValidObjectsQuery {
    /**
     *
     * @type {Array<string>}
     * @memberof AfmValidObjectsQuery
     */
    types: Array<AfmValidObjectsQueryTypesEnum>;
    /**
     *
     * @type {AFM}
     * @memberof AfmValidObjectsQuery
     */
    afm: AFM;
}

export const AfmValidObjectsQueryTypesEnum = {
    FACTS: "facts",
    ATTRIBUTES: "attributes",
    MEASURES: "measures",
} as const;

export type AfmValidObjectsQueryTypesEnum =
    typeof AfmValidObjectsQueryTypesEnum[keyof typeof AfmValidObjectsQueryTypesEnum];

/**
 * All objects of specified types valid with respect to given AFM.
 * @export
 * @interface AfmValidObjectsResponse
 */
export interface AfmValidObjectsResponse {
    /**
     *
     * @type {Array<RestApiIdentifier>}
     * @memberof AfmValidObjectsResponse
     */
    items: Array<RestApiIdentifier>;
}
/**
 * Metric representing arithmetics between metrics.
 * @export
 * @interface ArithmeticMeasureDefinition
 */
export interface ArithmeticMeasureDefinition {
    /**
     *
     * @type {ArithmeticMeasureDefinitionArithmeticMeasure}
     * @memberof ArithmeticMeasureDefinition
     */
    arithmeticMeasure: ArithmeticMeasureDefinitionArithmeticMeasure;
}
/**
 *
 * @export
 * @interface ArithmeticMeasureDefinitionArithmeticMeasure
 */
export interface ArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of metrics to apply arithmetic operation by chosen operator.
     * @type {Array<AfmLocalIdentifier>}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    measureIdentifiers: Array<AfmLocalIdentifier>;
    /**
     * Arithmetic operator describing operation between metrics.
     * @type {string}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    operator: ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

export const ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum = {
    SUM: "SUM",
    DIFFERENCE: "DIFFERENCE",
    MULTIPLICATION: "MULTIPLICATION",
    RATIO: "RATIO",
    CHANGE: "CHANGE",
} as const;

export type ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum =
    typeof ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum[keyof typeof ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum];

/**
 *
 * @export
 * @interface AttributeExecutionResultHeader
 */
export interface AttributeExecutionResultHeader {
    /**
     *
     * @type {AttributeResultHeader}
     * @memberof AttributeExecutionResultHeader
     */
    attributeHeader: AttributeResultHeader;
}
/**
 * @type AttributeFilter
 * Abstract filter definition type attributes
 * @export
 */
export type AttributeFilter = NegativeAttributeFilter | PositiveAttributeFilter;

/**
 * Filter on specific set of label values.
 * @export
 * @interface AttributeFilterElements
 */
export interface AttributeFilterElements {
    /**
     * Set of label values.
     * @type {Array<string>}
     * @memberof AttributeFilterElements
     */
    values: Array<string | null>;
}
/**
 *
 * @export
 * @interface AttributeFormat
 */
export interface AttributeFormat {
    /**
     * Format locale
     * @type {string}
     * @memberof AttributeFormat
     */
    locale: string;
    /**
     * Format pattern
     * @type {string}
     * @memberof AttributeFormat
     */
    pattern: string;
}
/**
 *
 * @export
 * @interface AttributeHeaderOut
 */
export interface AttributeHeaderOut {
    /**
     *
     * @type {AttributeHeaderOutAttributeHeader}
     * @memberof AttributeHeaderOut
     */
    attributeHeader: AttributeHeaderOutAttributeHeader;
}
/**
 *
 * @export
 * @interface AttributeHeaderOutAttributeHeader
 */
export interface AttributeHeaderOutAttributeHeader {
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderOutAttributeHeader
     */
    localIdentifier: string;
    /**
     *
     * @type {RestApiIdentifier}
     * @memberof AttributeHeaderOutAttributeHeader
     */
    label: RestApiIdentifier;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderOutAttributeHeader
     */
    labelName: string;
    /**
     *
     * @type {RestApiIdentifier}
     * @memberof AttributeHeaderOutAttributeHeader
     */
    attribute: RestApiIdentifier;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderOutAttributeHeader
     */
    attributeName: string;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderOutAttributeHeader
     */
    granularity?: AttributeHeaderOutAttributeHeaderGranularityEnum;
    /**
     *
     * @type {RestApiIdentifier}
     * @memberof AttributeHeaderOutAttributeHeader
     */
    primaryLabel: RestApiIdentifier;
    /**
     *
     * @type {AttributeFormat}
     * @memberof AttributeHeaderOutAttributeHeader
     */
    format?: AttributeFormat;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderOutAttributeHeader
     */
    valueType?: AttributeHeaderOutAttributeHeaderValueTypeEnum;
}

export const AttributeHeaderOutAttributeHeaderGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type AttributeHeaderOutAttributeHeaderGranularityEnum =
    typeof AttributeHeaderOutAttributeHeaderGranularityEnum[keyof typeof AttributeHeaderOutAttributeHeaderGranularityEnum];
export const AttributeHeaderOutAttributeHeaderValueTypeEnum = {
    TEXT: "TEXT",
    HYPERLINK: "HYPERLINK",
    GEO: "GEO",
    GEO_LONGITUDE: "GEO_LONGITUDE",
    GEO_LATITUDE: "GEO_LATITUDE",
    IMAGE: "IMAGE",
} as const;

export type AttributeHeaderOutAttributeHeaderValueTypeEnum =
    typeof AttributeHeaderOutAttributeHeaderValueTypeEnum[keyof typeof AttributeHeaderOutAttributeHeaderValueTypeEnum];

/**
 *
 * @export
 * @interface AttributeItem
 */
export interface AttributeItem {
    /**
     *
     * @type {string}
     * @memberof AttributeItem
     */
    localIdentifier: string;
    /**
     *
     * @type {AfmObjectIdentifierLabel}
     * @memberof AttributeItem
     */
    label: AfmObjectIdentifierLabel;
    /**
     * Specifies that the label should be outer-joined.
     * @type {boolean}
     * @memberof AttributeItem
     */
    showAllValues?: boolean;
}
/**
 * Header containing the information related to attributes.
 * @export
 * @interface AttributeResultHeader
 */
export interface AttributeResultHeader {
    /**
     * A value of the current attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    labelValue: string;
    /**
     * A value of the primary attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    primaryLabelValue: string;
}
/**
 * Filter the result by comparing specified metric to given constant value, using given comparison operator.
 * @export
 * @interface ComparisonMeasureValueFilter
 */
export interface ComparisonMeasureValueFilter {
    /**
     *
     * @type {ComparisonMeasureValueFilterComparisonMeasureValueFilter}
     * @memberof ComparisonMeasureValueFilter
     */
    comparisonMeasureValueFilter: ComparisonMeasureValueFilterComparisonMeasureValueFilter;
}
/**
 *
 * @export
 * @interface ComparisonMeasureValueFilterComparisonMeasureValueFilter
 */
export interface ComparisonMeasureValueFilterComparisonMeasureValueFilter {
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    operator: ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    value: number;
    /**
     *
     * @type {boolean}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmIdentifier}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    measure: AfmIdentifier;
}

export const ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum = {
    GREATER_THAN: "GREATER_THAN",
    GREATER_THAN_OR_EQUAL_TO: "GREATER_THAN_OR_EQUAL_TO",
    LESS_THAN: "LESS_THAN",
    LESS_THAN_OR_EQUAL_TO: "LESS_THAN_OR_EQUAL_TO",
    EQUAL_TO: "EQUAL_TO",
    NOT_EQUAL_TO: "NOT_EQUAL_TO",
} as const;

export type ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum =
    typeof ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum[keyof typeof ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum];

/**
 * Mapping from dimension items (either \'localIdentifier\' from \'AttributeItem\', or \"measureGroup\") to their respective values. This effectively specifies the path (location) of the data column used for sorting. Therefore values for all dimension items must be specified.
 * @export
 * @interface DataColumnLocator
 */
export interface DataColumnLocator {
    /**
     * Mapping from dimension items (either \'localIdentifier\' from \'AttributeItem\', or \"measureGroup\") to their respective values. This effectively specifies the path (location) of the data column used for sorting. Therefore values for all dimension items must be specified.
     * @type {{ [key: string]: string; }}
     * @memberof DataColumnLocator
     */
    properties: { [key: string]: string };
}
/**
 *
 * @export
 * @interface DataColumnLocators
 */
export interface DataColumnLocators {
    /**
     * Mapping from dimensions to data column locators.
     * @type {{ [key: string]: DataColumnLocator; }}
     * @memberof DataColumnLocators
     */
    properties?: { [key: string]: DataColumnLocator };
}
/**
 * @type DateFilter
 * Abstract filter definition type for dates.
 * @export
 */
export type DateFilter = AbsoluteDateFilter | RelativeDateFilter;

/**
 * Filter definition type specified by label and values.
 * @export
 * @interface DependsOn
 */
export interface DependsOn {
    /**
     * Specifies on which label the filter depends on.
     * @type {string}
     * @memberof DependsOn
     */
    label: string;
    /**
     * Specifies values of the label for element filtering.
     * @type {Array<string>}
     * @memberof DependsOn
     */
    values: Array<string | null>;
    /**
     * Inverse filtering mode.
     * @type {boolean}
     * @memberof DependsOn
     */
    complementFilter?: boolean;
}
/**
 *
 * @export
 * @interface DependsOnAllOf
 */
export interface DependsOnAllOf {
    /**
     * Specifies on which label the filter depends on.
     * @type {string}
     * @memberof DependsOnAllOf
     */
    label?: string;
    /**
     * Specifies values of the label for element filtering.
     * @type {Array<string>}
     * @memberof DependsOnAllOf
     */
    values?: Array<string>;
    /**
     * Inverse filtering mode.
     * @type {boolean}
     * @memberof DependsOnAllOf
     */
    complementFilter?: boolean;
}
/**
 * Filter definition type for dates.
 * @export
 * @interface DependsOnDateFilter
 */
export interface DependsOnDateFilter {
    /**
     *
     * @type {DateFilter}
     * @memberof DependsOnDateFilter
     */
    dateFilter: DateFilter;
}
/**
 *
 * @export
 * @interface DependsOnDateFilterAllOf
 */
export interface DependsOnDateFilterAllOf {
    /**
     *
     * @type {DateFilter}
     * @memberof DependsOnDateFilterAllOf
     */
    dateFilter?: DateFilter;
}
/**
 * Single dimension description.
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * Dimension identification within requests. Other entities can reference this dimension by this value.
     * @type {string}
     * @memberof Dimension
     */
    localIdentifier?: string;
    /**
     * List of items in current dimension. Can reference \'localIdentifier\' from \'AttributeItem\', or special pseudo attribute \"measureGroup\" representing list of metrics.
     * @type {Array<string>}
     * @memberof Dimension
     */
    itemIdentifiers: Array<string>;
    /**
     * List of sorting rules. From most relevant to least relevant (less relevant rule is applied, when more relevant rule compares items as equal).
     * @type {Array<SortKey>}
     * @memberof Dimension
     */
    sorting?: Array<SortKey>;
}
/**
 * Contains the dimension-specific header information.
 * @export
 * @interface DimensionHeader
 */
export interface DimensionHeader {
    /**
     * An array containing header groups.
     * @type {Array<HeaderGroup>}
     * @memberof DimensionHeader
     */
    headerGroups: Array<HeaderGroup>;
}
/**
 * List of returned elements.
 * @export
 * @interface Element
 */
export interface Element {
    /**
     * Title of requested label.
     * @type {string}
     * @memberof Element
     */
    title: string | null;
    /**
     * Title of primary label of attribute owning requested label, null if the title is null or the primary label is excluded
     * @type {string}
     * @memberof Element
     */
    primaryTitle: string | null;
}
/**
 *
 * @export
 * @interface ElementsRequest
 */
export interface ElementsRequest {
    /**
     * Requested label.
     * @type {string}
     * @memberof ElementsRequest
     */
    label: string;
    /**
     * Excludes items from the result that differ only by primary label * ```false``` - return items with distinct primary label * ```true``` - return items with distinct requested label
     * @type {boolean}
     * @memberof ElementsRequest
     */
    excludePrimaryLabel?: boolean;
    /**
     *
     * @type {FilterBy}
     * @memberof ElementsRequest
     */
    filterBy?: FilterBy;
    /**
     * Sort order of returned items. Items are sorted by ```label``` title. If no sort order is specified then attribute\'s ```sortDirection``` is used, which is ASC by default
     * @type {string}
     * @memberof ElementsRequest
     */
    sortOrder?: ElementsRequestSortOrderEnum;
    /**
     * Inverse filters: * ```false``` - return items matching ```patternFilter``` and ```exactFilter``` * ```true``` - return items not matching ```patternFilter``` and ```exactFilter```
     * @type {boolean}
     * @memberof ElementsRequest
     */
    complementFilter?: boolean;
    /**
     * Return only items, whose ```label``` title case insensitively contains ```filter``` as substring.
     * @type {string}
     * @memberof ElementsRequest
     */
    patternFilter?: string;
    /**
     * Return only items, whose ```label``` title exactly matches one of ```filter```.
     * @type {Array<string>}
     * @memberof ElementsRequest
     */
    exactFilter?: Array<string>;
    /**
     * Return only items, whose are not filtered out by the parent filters.
     * @type {Array<DependsOn | DependsOnDateFilter>}
     * @memberof ElementsRequest
     */
    dependsOn?: Array<DependsOn | DependsOnDateFilter>;
    /**
     * Return only items, what are computable on metric.
     * @type {Array<ValidateByItem>}
     * @memberof ElementsRequest
     */
    validateBy?: Array<ValidateByItem>;
    /**
     * Specifies percentage of source table data scanned during the computation. This field is deprecated and is no longer used during the elements computation.
     * @type {number}
     * @memberof ElementsRequest
     * @deprecated
     */
    dataSamplingPercentage?: number;
    /**
     * If specified, the element data will be taken from the result with the same cacheId if it is available.
     * @type {string}
     * @memberof ElementsRequest
     */
    cacheId?: string;
}

export const ElementsRequestSortOrderEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type ElementsRequestSortOrderEnum =
    typeof ElementsRequestSortOrderEnum[keyof typeof ElementsRequestSortOrderEnum];

/**
 * Entity holding list of sorted & filtered label elements, related primary label of attribute owning requested label and paging.
 * @export
 * @interface ElementsResponse
 */
export interface ElementsResponse {
    /**
     *
     * @type {RestApiIdentifier}
     * @memberof ElementsResponse
     */
    primaryLabel: RestApiIdentifier;
    /**
     * List of returned elements.
     * @type {Array<Element>}
     * @memberof ElementsResponse
     */
    elements: Array<Element>;
    /**
     *
     * @type {Paging}
     * @memberof ElementsResponse
     */
    paging: Paging;
    /**
     * Granularity of requested label in case of date attribute
     * @type {string}
     * @memberof ElementsResponse
     */
    granularity?: ElementsResponseGranularityEnum;
    /**
     *
     * @type {AttributeFormat}
     * @memberof ElementsResponse
     */
    format?: AttributeFormat;
    /**
     * The client can use this in subsequent requests (like paging or search) to get results from the same point in time as the previous request. This is useful when the underlying data source has caches disabled and the client wants to avoid seeing inconsistent results and to also avoid excessive queries to the database itself.
     * @type {string}
     * @memberof ElementsResponse
     */
    cacheId?: string;
}

export const ElementsResponseGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type ElementsResponseGranularityEnum =
    typeof ElementsResponseGranularityEnum[keyof typeof ElementsResponseGranularityEnum];

/**
 *
 * @export
 * @interface ExecutionLinks
 */
export interface ExecutionLinks {
    /**
     *
     * @type {string}
     * @memberof ExecutionLinks
     */
    executionResult: string;
}
/**
 *
 * @export
 * @interface ExecutionResponse
 */
export interface ExecutionResponse {
    /**
     *
     * @type {Array<ResultDimension>}
     * @memberof ExecutionResponse
     */
    dimensions: Array<ResultDimension>;
    /**
     *
     * @type {ExecutionLinks}
     * @memberof ExecutionResponse
     */
    links: ExecutionLinks;
}
/**
 * Contains the result of an AFM execution.
 * @export
 * @interface ExecutionResult
 */
export interface ExecutionResult {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     * @type {Array<object>}
     * @memberof ExecutionResult
     */
    data: Array<object>;
    /**
     * An array containing dimension headers. The size of the array corresponds to the number of dimensions. Their order corresponds to the dimension order in the execution result spec.
     * @type {Array<DimensionHeader>}
     * @memberof ExecutionResult
     */
    dimensionHeaders: Array<DimensionHeader>;
    /**
     *
     * @type {Array<ExecutionResultGrandTotal>}
     * @memberof ExecutionResult
     */
    grandTotals: Array<ExecutionResultGrandTotal>;
    /**
     *
     * @type {ExecutionResultPaging}
     * @memberof ExecutionResult
     */
    paging: ExecutionResultPaging;
}
/**
 * Contains the data of grand totals with the same dimensions.
 * @export
 * @interface ExecutionResultGrandTotal
 */
export interface ExecutionResultGrandTotal {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     * @type {Array<object>}
     * @memberof ExecutionResultGrandTotal
     */
    data: Array<object>;
    /**
     * Contains headers for a subset of `totalDimensions` in which the totals are grand totals.
     * @type {Array<DimensionHeader>}
     * @memberof ExecutionResultGrandTotal
     */
    dimensionHeaders: Array<DimensionHeader>;
    /**
     * Dimensions of the grand totals.
     * @type {Array<string>}
     * @memberof ExecutionResultGrandTotal
     */
    totalDimensions: Array<string>;
}
/**
 * @type ExecutionResultHeader
 * Abstract execution result header
 * @export
 */
export type ExecutionResultHeader =
    | AttributeExecutionResultHeader
    | MeasureExecutionResultHeader
    | TotalExecutionResultHeader;

/**
 * A paging information related to the data presented in the execution result. These paging information are multi-dimensional.
 * @export
 * @interface ExecutionResultPaging
 */
export interface ExecutionResultPaging {
    /**
     * A count of the returned results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    count: Array<number>;
    /**
     * The offset of the results returned in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    offset: Array<number>;
    /**
     * A total count of the results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    total: Array<number>;
}
/**
 * Various settings affecting the process of AFM execution or its result
 * @export
 * @interface ExecutionSettings
 */
export interface ExecutionSettings {
    /**
     * Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     * @type {number}
     * @memberof ExecutionSettings
     */
    dataSamplingPercentage?: number;
}
/**
 * Specifies what is used for filtering.
 * @export
 * @interface FilterBy
 */
export interface FilterBy {
    /**
     * Specifies which label is used for filtering - primary or requested.
     * @type {string}
     * @memberof FilterBy
     */
    labelType?: FilterByLabelTypeEnum;
}

export const FilterByLabelTypeEnum = {
    PRIMARY: "PRIMARY",
    REQUESTED: "REQUESTED",
} as const;

export type FilterByLabelTypeEnum = typeof FilterByLabelTypeEnum[keyof typeof FilterByLabelTypeEnum];

/**
 * @type FilterDefinition
 * Abstract filter definition type
 * @export
 */
export type FilterDefinition =
    | AbsoluteDateFilter
    | ComparisonMeasureValueFilter
    | InlineFilterDefinition
    | NegativeAttributeFilter
    | PositiveAttributeFilter
    | RangeMeasureValueFilter
    | RankingFilter
    | RelativeDateFilter;

/**
 * @type FilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple metric.
 * @export
 */
export type FilterDefinitionForSimpleMeasure = AttributeFilter | DateFilter;

/**
 *
 * @export
 * @interface ForecastRequest
 */
export interface ForecastRequest {
    /**
     * Number of future periods that should be forecasted
     * @type {number}
     * @memberof ForecastRequest
     */
    forecastPeriod: number;
    /**
     * Confidence interval boundary value.
     * @type {number}
     * @memberof ForecastRequest
     */
    confidenceLevel?: number;
    /**
     * Whether the input data is seasonal
     * @type {boolean}
     * @memberof ForecastRequest
     */
    seasonal?: boolean;
}
/**
 *
 * @export
 * @interface ForecastResult
 */
export interface ForecastResult {
    /**
     *
     * @type {Array<string>}
     * @memberof ForecastResult
     */
    attribute: Array<string>;
    /**
     *
     * @type {Array<number>}
     * @memberof ForecastResult
     */
    origin: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof ForecastResult
     */
    prediction: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof ForecastResult
     */
    lowerBound: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof ForecastResult
     */
    upperBound: Array<number>;
}
/**
 * Contains the information specific for a group of headers. These groups correlate to attributes and metric groups.
 * @export
 * @interface HeaderGroup
 */
export interface HeaderGroup {
    /**
     * An array containing headers.
     * @type {Array<ExecutionResultHeader>}
     * @memberof HeaderGroup
     */
    headers: Array<ExecutionResultHeader>;
}
/**
 * Filter in form of direct MAQL query.
 * @export
 * @interface InlineFilterDefinition
 */
export interface InlineFilterDefinition {
    /**
     *
     * @type {InlineFilterDefinitionInline}
     * @memberof InlineFilterDefinition
     */
    inline: InlineFilterDefinitionInline;
}
/**
 *
 * @export
 * @interface InlineFilterDefinitionInline
 */
export interface InlineFilterDefinitionInline {
    /**
     *
     * @type {string}
     * @memberof InlineFilterDefinitionInline
     */
    filter: string;
    /**
     *
     * @type {boolean}
     * @memberof InlineFilterDefinitionInline
     */
    applyOnResult?: boolean;
}
/**
 * Metric defined by the raw MAQL query.
 * @export
 * @interface InlineMeasureDefinition
 */
export interface InlineMeasureDefinition {
    /**
     *
     * @type {InlineMeasureDefinitionInline}
     * @memberof InlineMeasureDefinition
     */
    inline: InlineMeasureDefinitionInline;
}
/**
 *
 * @export
 * @interface InlineMeasureDefinitionInline
 */
export interface InlineMeasureDefinitionInline {
    /**
     *
     * @type {string}
     * @memberof InlineMeasureDefinitionInline
     */
    maql: string;
}
/**
 * @type MeasureDefinition
 * Abstract metric definition type
 * @export
 */
export type MeasureDefinition =
    | ArithmeticMeasureDefinition
    | InlineMeasureDefinition
    | PopMeasureDefinition
    | SimpleMeasureDefinition;

/**
 *
 * @export
 * @interface MeasureExecutionResultHeader
 */
export interface MeasureExecutionResultHeader {
    /**
     *
     * @type {MeasureResultHeader}
     * @memberof MeasureExecutionResultHeader
     */
    measureHeader: MeasureResultHeader;
}
/**
 *
 * @export
 * @interface MeasureGroupHeaders
 */
export interface MeasureGroupHeaders {
    /**
     *
     * @type {Array<MeasureHeaderOut>}
     * @memberof MeasureGroupHeaders
     */
    measureGroupHeaders?: Array<MeasureHeaderOut>;
}
/**
 *
 * @export
 * @interface MeasureHeaderOut
 */
export interface MeasureHeaderOut {
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    localIdentifier: string;
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    format?: string;
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    name?: string;
}
/**
 *
 * @export
 * @interface MeasureItem
 */
export interface MeasureItem {
    /**
     *
     * @type {string}
     * @memberof MeasureItem
     */
    localIdentifier: string;
    /**
     *
     * @type {MeasureDefinition}
     * @memberof MeasureItem
     */
    definition: MeasureDefinition;
}
/**
 * Header containing the information related to metrics.
 * @export
 * @interface MeasureResultHeader
 */
export interface MeasureResultHeader {
    /**
     * Metric index. Starts at 0.
     * @type {number}
     * @memberof MeasureResultHeader
     */
    measureIndex: number;
}
/**
 * @type MeasureValueFilter
 * Abstract filter definition type filtering by the value of the metric.
 * @export
 */
export type MeasureValueFilter = ComparisonMeasureValueFilter | RangeMeasureValueFilter;

/**
 * Filter able to limit element values by label and related selected negated elements.
 * @export
 * @interface NegativeAttributeFilter
 */
export interface NegativeAttributeFilter {
    /**
     *
     * @type {NegativeAttributeFilterNegativeAttributeFilter}
     * @memberof NegativeAttributeFilter
     */
    negativeAttributeFilter: NegativeAttributeFilterNegativeAttributeFilter;
}
/**
 *
 * @export
 * @interface NegativeAttributeFilterNegativeAttributeFilter
 */
export interface NegativeAttributeFilterNegativeAttributeFilter {
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof NegativeAttributeFilterNegativeAttributeFilter
     */
    notIn: AttributeFilterElements;
    /**
     *
     * @type {boolean}
     * @memberof NegativeAttributeFilterNegativeAttributeFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmIdentifier}
     * @memberof NegativeAttributeFilterNegativeAttributeFilter
     */
    label: AfmIdentifier;
}
/**
 * Current page description.
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * Count of returnable items ignoring paging.
     * @type {number}
     * @memberof Paging
     */
    total: number;
    /**
     * Count of items in this page.
     * @type {number}
     * @memberof Paging
     */
    count: number;
    /**
     * Offset of this page.
     * @type {number}
     * @memberof Paging
     */
    offset: number;
    /**
     * Link to next page, or null if this is last page.
     * @type {string}
     * @memberof Paging
     */
    next?: string;
}
/**
 *
 * @export
 * @interface PopDataset
 */
export interface PopDataset {
    /**
     *
     * @type {AfmObjectIdentifierDataset}
     * @memberof PopDataset
     */
    dataset: AfmObjectIdentifierDataset;
    /**
     *
     * @type {number}
     * @memberof PopDataset
     */
    periodsAgo: number;
}
/**
 * Previous period type of metric.
 * @export
 * @interface PopDatasetMeasureDefinition
 */
export interface PopDatasetMeasureDefinition {
    /**
     *
     * @type {PopDatasetMeasureDefinitionPreviousPeriodMeasure}
     * @memberof PopDatasetMeasureDefinition
     */
    previousPeriodMeasure: PopDatasetMeasureDefinitionPreviousPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDatasetMeasureDefinitionPreviousPeriodMeasure
 */
export interface PopDatasetMeasureDefinitionPreviousPeriodMeasure {
    /**
     *
     * @type {AfmLocalIdentifier}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    measureIdentifier: AfmLocalIdentifier;
    /**
     *
     * @type {Array<PopDataset>}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    dateDatasets: Array<PopDataset>;
}
/**
 *
 * @export
 * @interface PopDate
 */
export interface PopDate {
    /**
     *
     * @type {AfmObjectIdentifierAttribute}
     * @memberof PopDate
     */
    attribute: AfmObjectIdentifierAttribute;
    /**
     *
     * @type {number}
     * @memberof PopDate
     */
    periodsAgo: number;
}
/**
 * Period over period type of metric.
 * @export
 * @interface PopDateMeasureDefinition
 */
export interface PopDateMeasureDefinition {
    /**
     *
     * @type {PopDateMeasureDefinitionOverPeriodMeasure}
     * @memberof PopDateMeasureDefinition
     */
    overPeriodMeasure: PopDateMeasureDefinitionOverPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDateMeasureDefinitionOverPeriodMeasure
 */
export interface PopDateMeasureDefinitionOverPeriodMeasure {
    /**
     *
     * @type {AfmLocalIdentifier}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    measureIdentifier: AfmLocalIdentifier;
    /**
     *
     * @type {Array<PopDate>}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    dateAttributes: Array<PopDate>;
}
/**
 * @type PopMeasureDefinition
 * @export
 */
export type PopMeasureDefinition = PopDatasetMeasureDefinition | PopDateMeasureDefinition;

/**
 * Filter able to limit element values by label and related selected elements.
 * @export
 * @interface PositiveAttributeFilter
 */
export interface PositiveAttributeFilter {
    /**
     *
     * @type {PositiveAttributeFilterPositiveAttributeFilter}
     * @memberof PositiveAttributeFilter
     */
    positiveAttributeFilter: PositiveAttributeFilterPositiveAttributeFilter;
}
/**
 *
 * @export
 * @interface PositiveAttributeFilterPositiveAttributeFilter
 */
export interface PositiveAttributeFilterPositiveAttributeFilter {
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof PositiveAttributeFilterPositiveAttributeFilter
     */
    in: AttributeFilterElements;
    /**
     *
     * @type {boolean}
     * @memberof PositiveAttributeFilterPositiveAttributeFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmIdentifier}
     * @memberof PositiveAttributeFilterPositiveAttributeFilter
     */
    label: AfmIdentifier;
}
/**
 * Filter the result by comparing specified metric to given range of values.
 * @export
 * @interface RangeMeasureValueFilter
 */
export interface RangeMeasureValueFilter {
    /**
     *
     * @type {RangeMeasureValueFilterRangeMeasureValueFilter}
     * @memberof RangeMeasureValueFilter
     */
    rangeMeasureValueFilter: RangeMeasureValueFilterRangeMeasureValueFilter;
}
/**
 *
 * @export
 * @interface RangeMeasureValueFilterRangeMeasureValueFilter
 */
export interface RangeMeasureValueFilterRangeMeasureValueFilter {
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    operator: RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    from: number;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    to: number;
    /**
     *
     * @type {boolean}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmIdentifier}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    measure: AfmIdentifier;
}

export const RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum = {
    BETWEEN: "BETWEEN",
    NOT_BETWEEN: "NOT_BETWEEN",
} as const;

export type RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum =
    typeof RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum[keyof typeof RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum];

/**
 * Filter the result on top/bottom N values according to given metric(s).
 * @export
 * @interface RankingFilter
 */
export interface RankingFilter {
    /**
     *
     * @type {RankingFilterRankingFilter}
     * @memberof RankingFilter
     */
    rankingFilter: RankingFilterRankingFilter;
}
/**
 *
 * @export
 * @interface RankingFilterRankingFilter
 */
export interface RankingFilterRankingFilter {
    /**
     *
     * @type {Array<AfmIdentifier>}
     * @memberof RankingFilterRankingFilter
     */
    measures: Array<AfmIdentifier>;
    /**
     *
     * @type {string}
     * @memberof RankingFilterRankingFilter
     */
    operator: RankingFilterRankingFilterOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RankingFilterRankingFilter
     */
    value: number;
    /**
     *
     * @type {boolean}
     * @memberof RankingFilterRankingFilter
     */
    applyOnResult?: boolean;
}

export const RankingFilterRankingFilterOperatorEnum = {
    TOP: "TOP",
    BOTTOM: "BOTTOM",
} as const;

export type RankingFilterRankingFilterOperatorEnum =
    typeof RankingFilterRankingFilterOperatorEnum[keyof typeof RankingFilterRankingFilterOperatorEnum];

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension.
 * @export
 * @interface RelativeDateFilter
 */
export interface RelativeDateFilter {
    /**
     *
     * @type {RelativeDateFilterRelativeDateFilter}
     * @memberof RelativeDateFilter
     */
    relativeDateFilter: RelativeDateFilterRelativeDateFilter;
}
/**
 *
 * @export
 * @interface RelativeDateFilterRelativeDateFilter
 */
export interface RelativeDateFilterRelativeDateFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     * @type {string}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    granularity: RelativeDateFilterRelativeDateFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     * @type {number}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     * @type {number}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    to: number;
    /**
     *
     * @type {boolean}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifierDataset}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    dataset: AfmObjectIdentifierDataset;
}

export const RelativeDateFilterRelativeDateFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type RelativeDateFilterRelativeDateFilterGranularityEnum =
    typeof RelativeDateFilterRelativeDateFilterGranularityEnum[keyof typeof RelativeDateFilterRelativeDateFilterGranularityEnum];

/**
 * Object identifier.
 * @export
 * @interface RestApiIdentifier
 */
export interface RestApiIdentifier {
    /**
     *
     * @type {string}
     * @memberof RestApiIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RestApiIdentifier
     */
    type: string;
}
/**
 * All execution result\'s metadata used for calculation including ExecutionResponse
 * @export
 * @interface ResultCacheMetadata
 */
export interface ResultCacheMetadata {
    /**
     *
     * @type {AFM}
     * @memberof ResultCacheMetadata
     */
    afm: AFM;
    /**
     *
     * @type {ExecutionResponse}
     * @memberof ResultCacheMetadata
     */
    executionResponse: ExecutionResponse;
    /**
     *
     * @type {ResultSpec}
     * @memberof ResultCacheMetadata
     */
    resultSpec: ResultSpec;
    /**
     *
     * @type {number}
     * @memberof ResultCacheMetadata
     */
    resultSize: number;
}
/**
 *
 * @export
 * @interface ResultDimension
 */
export interface ResultDimension {
    /**
     *
     * @type {Array<ResultDimensionHeader>}
     * @memberof ResultDimension
     */
    headers: Array<ResultDimensionHeader>;
    /**
     *
     * @type {string}
     * @memberof ResultDimension
     */
    localIdentifier: string;
}
/**
 * @type ResultDimensionHeader
 * @export
 */
export type ResultDimensionHeader = AttributeHeaderOut | MeasureGroupHeaders;

/**
 * Specifies how the result data will be formatted (```dimensions```) and which additional data shall be computed (```totals```).
 * @export
 * @interface ResultSpec
 */
export interface ResultSpec {
    /**
     *
     * @type {Array<Dimension>}
     * @memberof ResultSpec
     */
    dimensions: Array<Dimension>;
    /**
     *
     * @type {Array<Total>}
     * @memberof ResultSpec
     */
    totals?: Array<Total>;
}
/**
 *
 * @export
 * @interface SimpleMeasureDefinition
 */
export interface SimpleMeasureDefinition {
    /**
     *
     * @type {SimpleMeasureDefinitionMeasure}
     * @memberof SimpleMeasureDefinition
     */
    measure: SimpleMeasureDefinitionMeasure;
}
/**
 *
 * @export
 * @interface SimpleMeasureDefinitionMeasure
 */
export interface SimpleMeasureDefinitionMeasure {
    /**
     *
     * @type {AfmObjectIdentifierCore}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    item: AfmObjectIdentifierCore;
    /**
     * Definition of aggregation type of the metric.
     * @type {string}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    aggregation?: SimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true compute the percentage of given metric values (broken down by AFM attributes) to the total (not broken down).
     * @type {boolean}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    computeRatio?: boolean;
    /**
     * Metrics can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     * @type {Array<FilterDefinitionForSimpleMeasure>}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    filters?: Array<FilterDefinitionForSimpleMeasure>;
}

export const SimpleMeasureDefinitionMeasureAggregationEnum = {
    SUM: "SUM",
    COUNT: "COUNT",
    AVG: "AVG",
    MIN: "MIN",
    MAX: "MAX",
    MEDIAN: "MEDIAN",
    RUNSUM: "RUNSUM",
    APPROXIMATE_COUNT: "APPROXIMATE_COUNT",
} as const;

export type SimpleMeasureDefinitionMeasureAggregationEnum =
    typeof SimpleMeasureDefinitionMeasureAggregationEnum[keyof typeof SimpleMeasureDefinitionMeasureAggregationEnum];

/**
 *
 * @export
 * @interface SmartFunctionResponse
 */
export interface SmartFunctionResponse {
    /**
     *
     * @type {ExecutionLinks}
     * @memberof SmartFunctionResponse
     */
    links: ExecutionLinks;
}
/**
 * @type SortKey
 * @export
 */
export type SortKey = SortKeyAttribute | SortKeyTotal | SortKeyValue;

/**
 * Sorting rule for sorting by attribute value in current dimension.
 * @export
 * @interface SortKeyAttribute
 */
export interface SortKeyAttribute {
    /**
     *
     * @type {SortKeyAttributeAttribute}
     * @memberof SortKeyAttribute
     */
    attribute: SortKeyAttributeAttribute;
}
/**
 *
 * @export
 * @interface SortKeyAttributeAttribute
 */
export interface SortKeyAttributeAttribute {
    /**
     * Item reference (to \'itemIdentifiers\') referencing, which item should be used for sorting. Only references to attributes are allowed.
     * @type {string}
     * @memberof SortKeyAttributeAttribute
     */
    attributeIdentifier: string;
    /**
     * Mechanism by which this attribute should be sorted. Available options are: - DEFAULT: sorting based on default rules (using sort column if defined, otherwise this label)  - LABEL: sorting by this label values  - ATTRIBUTE: sorting by values of this label\'s attribute (or rather the primary label)  - AREA: sorting by area (total or subtotal) corresponding to each attribute value. The area is computed by summing up all metric values in all other dimensions.
     * @type {string}
     * @memberof SortKeyAttributeAttribute
     */
    sortType?: SortKeyAttributeAttributeSortTypeEnum;
    /**
     * Sorting elements - ascending/descending order.
     * @type {string}
     * @memberof SortKeyAttributeAttribute
     */
    direction?: SortKeyAttributeAttributeDirectionEnum;
}

export const SortKeyAttributeAttributeSortTypeEnum = {
    DEFAULT: "DEFAULT",
    LABEL: "LABEL",
    ATTRIBUTE: "ATTRIBUTE",
    AREA: "AREA",
} as const;

export type SortKeyAttributeAttributeSortTypeEnum =
    typeof SortKeyAttributeAttributeSortTypeEnum[keyof typeof SortKeyAttributeAttributeSortTypeEnum];
export const SortKeyAttributeAttributeDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type SortKeyAttributeAttributeDirectionEnum =
    typeof SortKeyAttributeAttributeDirectionEnum[keyof typeof SortKeyAttributeAttributeDirectionEnum];

/**
 * Sorting rule for sorting by total value. DataColumnLocators are only required if there is ambiguity. Locator for measureGroup is taken from the metric of the total.
 * @export
 * @interface SortKeyTotal
 */
export interface SortKeyTotal {
    /**
     *
     * @type {SortKeyTotalTotal}
     * @memberof SortKeyTotal
     */
    total: SortKeyTotalTotal;
}
/**
 *
 * @export
 * @interface SortKeyTotalTotal
 */
export interface SortKeyTotalTotal {
    /**
     *
     * @type {string}
     * @memberof SortKeyTotalTotal
     */
    totalIdentifier: string;
    /**
     *
     * @type {DataColumnLocators}
     * @memberof SortKeyTotalTotal
     */
    dataColumnLocators?: DataColumnLocators;
    /**
     * Sorting elements - ascending/descending order.
     * @type {string}
     * @memberof SortKeyTotalTotal
     */
    direction?: SortKeyTotalTotalDirectionEnum;
}

export const SortKeyTotalTotalDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type SortKeyTotalTotalDirectionEnum =
    typeof SortKeyTotalTotalDirectionEnum[keyof typeof SortKeyTotalTotalDirectionEnum];

/**
 * Sorting rule for sorting by measure value. DataColumnLocators for each dimension opposite to the sorted one must be specified.
 * @export
 * @interface SortKeyValue
 */
export interface SortKeyValue {
    /**
     *
     * @type {SortKeyValueValue}
     * @memberof SortKeyValue
     */
    value: SortKeyValueValue;
}
/**
 *
 * @export
 * @interface SortKeyValueValue
 */
export interface SortKeyValueValue {
    /**
     *
     * @type {DataColumnLocators}
     * @memberof SortKeyValueValue
     */
    dataColumnLocators: DataColumnLocators;
    /**
     * Sorting elements - ascending/descending order.
     * @type {string}
     * @memberof SortKeyValueValue
     */
    direction?: SortKeyValueValueDirectionEnum;
}

export const SortKeyValueValueDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type SortKeyValueValueDirectionEnum =
    typeof SortKeyValueValueDirectionEnum[keyof typeof SortKeyValueValueDirectionEnum];

/**
 * Definition of a total. There are two types of totals: grand totals and subtotals. Grand total data will be returned in a separate section of the result structure while subtotals are fully integrated into the main result data. The mechanism for this distinction is automatic and it\'s described in `TotalDimension`
 * @export
 * @interface Total
 */
export interface Total {
    /**
     * Total identification within this request. Used e.g. in sorting by a total.
     * @type {string}
     * @memberof Total
     */
    localIdentifier: string;
    /**
     * Aggregation function to compute the total.
     * @type {string}
     * @memberof Total
     */
    function: TotalFunctionEnum;
    /**
     * The metric for which the total will be computed
     * @type {string}
     * @memberof Total
     */
    metric: string;
    /**
     *
     * @type {Array<TotalDimension>}
     * @memberof Total
     */
    totalDimensions: Array<TotalDimension>;
}

export const TotalFunctionEnum = {
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    AVG: "AVG",
    MED: "MED",
} as const;

export type TotalFunctionEnum = typeof TotalFunctionEnum[keyof typeof TotalFunctionEnum];

/**
 * A list of dimensions across which the total will be computed. Total headers for only these dimensions will be returned in the result.
 * @export
 * @interface TotalDimension
 */
export interface TotalDimension {
    /**
     * An identifier of a dimension for which the total will be computed.
     * @type {string}
     * @memberof TotalDimension
     */
    dimensionIdentifier: string;
    /**
     * List of dimension items which will be used for total computation. The total is a grand total in this dimension if the list is empty or it includes the first dimension item from the dimension definition, and its data and header will be returned in a separate `ExecutionResultGrandTotal` structure. Otherwise, it is a subtotal and the data will be integrated into the main result.
     * @type {Array<string>}
     * @memberof TotalDimension
     */
    totalDimensionItems: Array<string>;
}
/**
 *
 * @export
 * @interface TotalExecutionResultHeader
 */
export interface TotalExecutionResultHeader {
    /**
     *
     * @type {TotalResultHeader}
     * @memberof TotalExecutionResultHeader
     */
    totalHeader: TotalResultHeader;
}
/**
 * Header containing the information related to a subtotal.
 * @export
 * @interface TotalResultHeader
 */
export interface TotalResultHeader {
    /**
     *
     * @type {string}
     * @memberof TotalResultHeader
     */
    function: string;
}
/**
 *
 * @export
 * @interface ValidateByItem
 */
export interface ValidateByItem {
    /**
     * Specifies entity used for valid elements computation.
     * @type {string}
     * @memberof ValidateByItem
     */
    id: string;
    /**
     * Specifies entity type which could be label, attribute, fact, or metric.
     * @type {string}
     * @memberof ValidateByItem
     */
    type: string;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: async (
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeLabelElementsPost", "workspaceId", workspaceId);
            // verify required parameter 'elementsRequest' is not null or undefined
            assertParamExists("computeLabelElementsPost", "elementsRequest", elementsRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof elementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
                : elementsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeReport", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("computeReport", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants: async (
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidDescendants", "workspaceId", workspaceId);
            // verify required parameter 'afmValidDescendantsQuery' is not null or undefined
            assertParamExists(
                "computeValidDescendants",
                "afmValidDescendantsQuery",
                afmValidDescendantsQuery,
            );
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidDescendants`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidDescendantsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidDescendantsQuery !== undefined ? afmValidDescendantsQuery : {})
                : afmValidDescendantsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: async (
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidObjects", "workspaceId", workspaceId);
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            assertParamExists("computeValidObjects", "afmValidObjectsQuery", afmValidObjectsQuery);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS",
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("explainAFM", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("explainAFM", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (explainType !== undefined) {
                localVarQueryParameter["explainType"] = explainType;
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast: async (
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecast", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecast", "resultId", resultId);
            // verify required parameter 'forecastRequest' is not null or undefined
            assertParamExists("forecast", "forecastRequest", forecastRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof forecastRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(forecastRequest !== undefined ? forecastRequest : {})
                : forecastRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecastResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecastResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata: async (
            workspaceId: string,
            resultId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}/metadata`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: async (
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }

            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }

            if (excludedTotalDimensions) {
                localVarQueryParameter["excludedTotalDimensions"] = excludedTotalDimensions.join(
                    COLLECTION_FORMATS.csv,
                );
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeLabelElementsPost(
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeLabelElementsPost(
                workspaceId,
                elementsRequest,
                offset,
                limit,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeReport(
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmExecutionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeReport(
                workspaceId,
                afmExecution,
                skipCache,
                timestamp,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidDescendants(
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidDescendantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidDescendants(
                workspaceId,
                afmValidDescendantsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidObjects(
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidObjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidObjects(
                workspaceId,
                afmValidObjectsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explainAFM(
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS",
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explainAFM(
                workspaceId,
                afmExecution,
                explainType,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecast(
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecast(
                workspaceId,
                resultId,
                forecastRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecastResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForecastResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecastResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveExecutionMetadata(
            workspaceId: string,
            resultId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultCacheMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveExecutionMetadata(
                workspaceId,
                resultId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveResult(
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveResult(
                workspaceId,
                resultId,
                offset,
                limit,
                excludedTotalDimensions,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(
            requestParameters: ActionsApiComputeLabelElementsPostRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ElementsResponse> {
            return localVarFp
                .computeLabelElementsPost(
                    requestParameters.workspaceId,
                    requestParameters.elementsRequest,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            requestParameters: ActionsApiComputeReportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmExecutionResponse> {
            return localVarFp
                .computeReport(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.skipCache,
                    requestParameters.timestamp,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants(
            requestParameters: ActionsApiComputeValidDescendantsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidDescendantsResponse> {
            return localVarFp
                .computeValidDescendants(
                    requestParameters.workspaceId,
                    requestParameters.afmValidDescendantsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            requestParameters: ActionsApiComputeValidObjectsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidObjectsResponse> {
            return localVarFp
                .computeValidObjects(
                    requestParameters.workspaceId,
                    requestParameters.afmValidObjectsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(
            requestParameters: ActionsApiExplainAFMRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<any> {
            return localVarFp
                .explainAFM(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.explainType,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {ActionsApiForecastRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast(
            requestParameters: ActionsApiForecastRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .forecast(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.forecastRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult(
            requestParameters: ActionsApiForecastResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ForecastResult> {
            return localVarFp
                .forecastResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata(
            requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ResultCacheMetadata> {
            return localVarFp
                .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            requestParameters: ActionsApiRetrieveResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExecutionResult> {
            return localVarFp
                .retrieveResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.excludedTotalDimensions,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeLabelElementsPost(
        requestParameters: ActionsApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ElementsResponse>;

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeReport(
        requestParameters: ActionsApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmExecutionResponse>;

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeValidDescendants(
        requestParameters: ActionsApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidDescendantsResponse>;

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeValidObjects(
        requestParameters: ActionsApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidObjectsResponse>;

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    explainAFM(
        requestParameters: ActionsApiExplainAFMRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<any>;

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {ActionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    forecast(
        requestParameters: ActionsApiForecastRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    forecastResult(
        requestParameters: ActionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ForecastResult>;

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    retrieveExecutionMetadata(
        requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResultCacheMetadata>;

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    retrieveResult(
        requestParameters: ActionsApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExecutionResult>;
}

/**
 * Request parameters for computeLabelElementsPost operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeLabelElementsPostRequest
 */
export interface ActionsApiComputeLabelElementsPostRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ElementsRequest}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly elementsRequest: ElementsRequest;

    /**
     * Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly offset?: number;

    /**
     * Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly limit?: number;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for computeReport operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeReportRequest
 */
export interface ActionsApiComputeReportRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeReport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ActionsApiComputeReport
     */
    readonly afmExecution: AfmExecution;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiComputeReport
     */
    readonly skipCache?: boolean;

    /**
     *
     * @type {string}
     * @memberof ActionsApiComputeReport
     */
    readonly timestamp?: string;
}

/**
 * Request parameters for computeValidDescendants operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeValidDescendantsRequest
 */
export interface ActionsApiComputeValidDescendantsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeValidDescendants
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidDescendantsQuery}
     * @memberof ActionsApiComputeValidDescendants
     */
    readonly afmValidDescendantsQuery: AfmValidDescendantsQuery;
}

/**
 * Request parameters for computeValidObjects operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeValidObjectsRequest
 */
export interface ActionsApiComputeValidObjectsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeValidObjects
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidObjectsQuery}
     * @memberof ActionsApiComputeValidObjects
     */
    readonly afmValidObjectsQuery: AfmValidObjectsQuery;
}

/**
 * Request parameters for explainAFM operation in ActionsApi.
 * @export
 * @interface ActionsApiExplainAFMRequest
 */
export interface ActionsApiExplainAFMRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiExplainAFM
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ActionsApiExplainAFM
     */
    readonly afmExecution: AfmExecution;

    /**
     * Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
     * @type {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'}
     * @memberof ActionsApiExplainAFM
     */
    readonly explainType?:
        | "MAQL"
        | "GRPC_MODEL"
        | "GRPC_MODEL_SVG"
        | "WDF"
        | "QT"
        | "QT_SVG"
        | "OPT_QT"
        | "OPT_QT_SVG"
        | "SQL"
        | "SETTINGS";
}

/**
 * Request parameters for forecast operation in ActionsApi.
 * @export
 * @interface ActionsApiForecastRequest
 */
export interface ActionsApiForecastRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiForecast
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof ActionsApiForecast
     */
    readonly resultId: string;

    /**
     *
     * @type {ForecastRequest}
     * @memberof ActionsApiForecast
     */
    readonly forecastRequest: ForecastRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiForecast
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for forecastResult operation in ActionsApi.
 * @export
 * @interface ActionsApiForecastResultRequest
 */
export interface ActionsApiForecastResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiForecastResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiForecastResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiForecastResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiForecastResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for retrieveExecutionMetadata operation in ActionsApi.
 * @export
 * @interface ActionsApiRetrieveExecutionMetadataRequest
 */
export interface ActionsApiRetrieveExecutionMetadataRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiRetrieveExecutionMetadata
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiRetrieveExecutionMetadata
     */
    readonly resultId: string;
}

/**
 * Request parameters for retrieveResult operation in ActionsApi.
 * @export
 * @interface ActionsApiRetrieveResultRequest
 */
export interface ActionsApiRetrieveResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly resultId: string;

    /**
     * Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly offset?: Array<number>;

    /**
     * Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly limit?: Array<number>;

    /**
     * Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
     * @type {Array<string>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly excludedTotalDimensions?: Array<string>;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeLabelElementsPost(
        requestParameters: ActionsApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .computeLabelElementsPost(
                requestParameters.workspaceId,
                requestParameters.elementsRequest,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeReport(requestParameters: ActionsApiComputeReportRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .computeReport(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.skipCache,
                requestParameters.timestamp,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeValidDescendants(
        requestParameters: ActionsApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .computeValidDescendants(
                requestParameters.workspaceId,
                requestParameters.afmValidDescendantsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeValidObjects(
        requestParameters: ActionsApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .computeValidObjects(
                requestParameters.workspaceId,
                requestParameters.afmValidObjectsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public explainAFM(requestParameters: ActionsApiExplainAFMRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .explainAFM(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.explainType,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {ActionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public forecast(requestParameters: ActionsApiForecastRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .forecast(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.forecastRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public forecastResult(requestParameters: ActionsApiForecastResultRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .forecastResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public retrieveExecutionMetadata(
        requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public retrieveResult(requestParameters: ActionsApiRetrieveResultRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .retrieveResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.excludedTotalDimensions,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ComputationApi - axios parameter creator
 * @export
 */
export const ComputationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: async (
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeLabelElementsPost", "workspaceId", workspaceId);
            // verify required parameter 'elementsRequest' is not null or undefined
            assertParamExists("computeLabelElementsPost", "elementsRequest", elementsRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof elementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
                : elementsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeReport", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("computeReport", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants: async (
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidDescendants", "workspaceId", workspaceId);
            // verify required parameter 'afmValidDescendantsQuery' is not null or undefined
            assertParamExists(
                "computeValidDescendants",
                "afmValidDescendantsQuery",
                afmValidDescendantsQuery,
            );
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidDescendants`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidDescendantsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidDescendantsQuery !== undefined ? afmValidDescendantsQuery : {})
                : afmValidDescendantsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: async (
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidObjects", "workspaceId", workspaceId);
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            assertParamExists("computeValidObjects", "afmValidObjectsQuery", afmValidObjectsQuery);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS",
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("explainAFM", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("explainAFM", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (explainType !== undefined) {
                localVarQueryParameter["explainType"] = explainType;
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata: async (
            workspaceId: string,
            resultId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}/metadata`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: async (
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }

            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }

            if (excludedTotalDimensions) {
                localVarQueryParameter["excludedTotalDimensions"] = excludedTotalDimensions.join(
                    COLLECTION_FORMATS.csv,
                );
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ComputationApi - functional programming interface
 * @export
 */
export const ComputationApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ComputationApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeLabelElementsPost(
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeLabelElementsPost(
                workspaceId,
                elementsRequest,
                offset,
                limit,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeReport(
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmExecutionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeReport(
                workspaceId,
                afmExecution,
                skipCache,
                timestamp,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidDescendants(
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidDescendantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidDescendants(
                workspaceId,
                afmValidDescendantsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidObjects(
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidObjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidObjects(
                workspaceId,
                afmValidObjectsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explainAFM(
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS",
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explainAFM(
                workspaceId,
                afmExecution,
                explainType,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveExecutionMetadata(
            workspaceId: string,
            resultId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultCacheMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveExecutionMetadata(
                workspaceId,
                resultId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveResult(
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveResult(
                workspaceId,
                resultId,
                offset,
                limit,
                excludedTotalDimensions,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ComputationApi - factory interface
 * @export
 */
export const ComputationApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ComputationApiFp(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(
            requestParameters: ComputationApiComputeLabelElementsPostRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ElementsResponse> {
            return localVarFp
                .computeLabelElementsPost(
                    requestParameters.workspaceId,
                    requestParameters.elementsRequest,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            requestParameters: ComputationApiComputeReportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmExecutionResponse> {
            return localVarFp
                .computeReport(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.skipCache,
                    requestParameters.timestamp,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants(
            requestParameters: ComputationApiComputeValidDescendantsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidDescendantsResponse> {
            return localVarFp
                .computeValidDescendants(
                    requestParameters.workspaceId,
                    requestParameters.afmValidDescendantsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            requestParameters: ComputationApiComputeValidObjectsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidObjectsResponse> {
            return localVarFp
                .computeValidObjects(
                    requestParameters.workspaceId,
                    requestParameters.afmValidObjectsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(
            requestParameters: ComputationApiExplainAFMRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<any> {
            return localVarFp
                .explainAFM(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.explainType,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata(
            requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ResultCacheMetadata> {
            return localVarFp
                .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            requestParameters: ComputationApiRetrieveResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExecutionResult> {
            return localVarFp
                .retrieveResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.excludedTotalDimensions,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComputationApi - interface
 * @export
 * @interface ComputationApi
 */
export interface ComputationApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeLabelElementsPost(
        requestParameters: ComputationApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ElementsResponse>;

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeReport(
        requestParameters: ComputationApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmExecutionResponse>;

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeValidDescendants(
        requestParameters: ComputationApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidDescendantsResponse>;

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeValidObjects(
        requestParameters: ComputationApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidObjectsResponse>;

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    explainAFM(
        requestParameters: ComputationApiExplainAFMRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<any>;

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    retrieveExecutionMetadata(
        requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResultCacheMetadata>;

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    retrieveResult(
        requestParameters: ComputationApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExecutionResult>;
}

/**
 * Request parameters for computeLabelElementsPost operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeLabelElementsPostRequest
 */
export interface ComputationApiComputeLabelElementsPostRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ElementsRequest}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly elementsRequest: ElementsRequest;

    /**
     * Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly offset?: number;

    /**
     * Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly limit?: number;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for computeReport operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeReportRequest
 */
export interface ComputationApiComputeReportRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeReport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ComputationApiComputeReport
     */
    readonly afmExecution: AfmExecution;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiComputeReport
     */
    readonly skipCache?: boolean;

    /**
     *
     * @type {string}
     * @memberof ComputationApiComputeReport
     */
    readonly timestamp?: string;
}

/**
 * Request parameters for computeValidDescendants operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeValidDescendantsRequest
 */
export interface ComputationApiComputeValidDescendantsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeValidDescendants
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidDescendantsQuery}
     * @memberof ComputationApiComputeValidDescendants
     */
    readonly afmValidDescendantsQuery: AfmValidDescendantsQuery;
}

/**
 * Request parameters for computeValidObjects operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeValidObjectsRequest
 */
export interface ComputationApiComputeValidObjectsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeValidObjects
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidObjectsQuery}
     * @memberof ComputationApiComputeValidObjects
     */
    readonly afmValidObjectsQuery: AfmValidObjectsQuery;
}

/**
 * Request parameters for explainAFM operation in ComputationApi.
 * @export
 * @interface ComputationApiExplainAFMRequest
 */
export interface ComputationApiExplainAFMRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiExplainAFM
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ComputationApiExplainAFM
     */
    readonly afmExecution: AfmExecution;

    /**
     * Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
     * @type {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'}
     * @memberof ComputationApiExplainAFM
     */
    readonly explainType?:
        | "MAQL"
        | "GRPC_MODEL"
        | "GRPC_MODEL_SVG"
        | "WDF"
        | "QT"
        | "QT_SVG"
        | "OPT_QT"
        | "OPT_QT_SVG"
        | "SQL"
        | "SETTINGS";
}

/**
 * Request parameters for retrieveExecutionMetadata operation in ComputationApi.
 * @export
 * @interface ComputationApiRetrieveExecutionMetadataRequest
 */
export interface ComputationApiRetrieveExecutionMetadataRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiRetrieveExecutionMetadata
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiRetrieveExecutionMetadata
     */
    readonly resultId: string;
}

/**
 * Request parameters for retrieveResult operation in ComputationApi.
 * @export
 * @interface ComputationApiRetrieveResultRequest
 */
export interface ComputationApiRetrieveResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiRetrieveResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiRetrieveResult
     */
    readonly resultId: string;

    /**
     * Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly offset?: Array<number>;

    /**
     * Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly limit?: Array<number>;

    /**
     * Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
     * @type {Array<string>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly excludedTotalDimensions?: Array<string>;
}

/**
 * ComputationApi - object-oriented interface
 * @export
 * @class ComputationApi
 * @extends {BaseAPI}
 */
export class ComputationApi extends BaseAPI implements ComputationApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeLabelElementsPost(
        requestParameters: ComputationApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeLabelElementsPost(
                requestParameters.workspaceId,
                requestParameters.elementsRequest,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeReport(
        requestParameters: ComputationApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeReport(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.skipCache,
                requestParameters.timestamp,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeValidDescendants(
        requestParameters: ComputationApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeValidDescendants(
                requestParameters.workspaceId,
                requestParameters.afmValidDescendantsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeValidObjects(
        requestParameters: ComputationApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeValidObjects(
                requestParameters.workspaceId,
                requestParameters.afmValidObjectsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public explainAFM(requestParameters: ComputationApiExplainAFMRequest, options?: AxiosRequestConfig) {
        return ComputationApiFp(this.configuration)
            .explainAFM(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.explainType,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public retrieveExecutionMetadata(
        requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public retrieveResult(
        requestParameters: ComputationApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .retrieveResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.excludedTotalDimensions,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * SmartFunctionsApi - axios parameter creator
 * @export
 */
export const SmartFunctionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast: async (
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecast", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecast", "resultId", resultId);
            // verify required parameter 'forecastRequest' is not null or undefined
            assertParamExists("forecast", "forecastRequest", forecastRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof forecastRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(forecastRequest !== undefined ? forecastRequest : {})
                : forecastRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecastResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecastResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * SmartFunctionsApi - functional programming interface
 * @export
 */
export const SmartFunctionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SmartFunctionsApiAxiosParamCreator(configuration);
    return {
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecast(
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecast(
                workspaceId,
                resultId,
                forecastRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecastResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForecastResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecastResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * SmartFunctionsApi - factory interface
 * @export
 */
export const SmartFunctionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = SmartFunctionsApiFp(configuration);
    return {
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast(
            requestParameters: SmartFunctionsApiForecastRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .forecast(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.forecastRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult(
            requestParameters: SmartFunctionsApiForecastResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ForecastResult> {
            return localVarFp
                .forecastResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * SmartFunctionsApi - interface
 * @export
 * @interface SmartFunctionsApi
 */
export interface SmartFunctionsApiInterface {
    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    forecast(
        requestParameters: SmartFunctionsApiForecastRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    forecastResult(
        requestParameters: SmartFunctionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ForecastResult>;
}

/**
 * Request parameters for forecast operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiForecastRequest
 */
export interface SmartFunctionsApiForecastRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiForecast
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof SmartFunctionsApiForecast
     */
    readonly resultId: string;

    /**
     *
     * @type {ForecastRequest}
     * @memberof SmartFunctionsApiForecast
     */
    readonly forecastRequest: ForecastRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof SmartFunctionsApiForecast
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for forecastResult operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiForecastResultRequest
 */
export interface SmartFunctionsApiForecastResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly limit?: number;
}

/**
 * SmartFunctionsApi - object-oriented interface
 * @export
 * @class SmartFunctionsApi
 * @extends {BaseAPI}
 */
export class SmartFunctionsApi extends BaseAPI implements SmartFunctionsApiInterface {
    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public forecast(requestParameters: SmartFunctionsApiForecastRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .forecast(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.forecastRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public forecastResult(
        requestParameters: SmartFunctionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .forecastResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}
