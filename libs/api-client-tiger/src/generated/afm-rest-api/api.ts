// (C) 2020 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// @ts-ignore
import globalImportUrl from "url";
import globalImportQs from "qs";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from "./base";

// utility function that adds support for nested objects in query
const addFlattenedObjectTo = (object: any, target: any): void => {
    const flattened = globalImportQs.parse(globalImportQs.stringify(object), { depth: 0 });
    Object.keys(flattened).forEach((key) => {
        target[key] = (flattened as any)[key];
    });
};

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 * @export
 * @interface AFM
 */
export interface AFM {
    /**
     *
     * @type {Array<AttributeItem>}
     * @memberof AFM
     */
    attributes: Array<AttributeItem>;
    /**
     * Various filter types to filter execution result.
     * @type {Array<FilterDefinition>}
     * @memberof AFM
     */
    filters: Array<FilterDefinition>;
    /**
     * Measures to be computed.
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    measures: Array<MeasureItem>;
}
/**
 * A date filter specifying exact from and to dates.
 * @export
 * @interface AbsoluteDateFilter
 */
export interface AbsoluteDateFilter {
    /**
     *
     * @type {AbsoluteDateFilterAbsoluteDateFilter}
     * @memberof AbsoluteDateFilter
     */
    absoluteDateFilter: AbsoluteDateFilterAbsoluteDateFilter;
}
/**
 *
 * @export
 * @interface AbsoluteDateFilterAbsoluteDateFilter
 */
export interface AbsoluteDateFilterAbsoluteDateFilter {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    dataset: ObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    from: string;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    to: string;
}
/**
 *
 * @export
 * @interface AfmExecution
 */
export interface AfmExecution {
    /**
     *
     * @type {AFM}
     * @memberof AfmExecution
     */
    execution: AFM;
    /**
     *
     * @type {ResultSpec}
     * @memberof AfmExecution
     */
    resultSpec: ResultSpec;
}
/**
 *
 * @export
 * @interface AfmExecutionResponse
 */
export interface AfmExecutionResponse {
    /**
     *
     * @type {ExecutionResponse}
     * @memberof AfmExecutionResponse
     */
    executionResponse: ExecutionResponse;
}
/**
 * Entity holding AFM and list of object types whose validity should be computed.
 * @export
 * @interface AfmValidObjectsQuery
 */
export interface AfmValidObjectsQuery {
    /**
     *
     * @type {Array<string>}
     * @memberof AfmValidObjectsQuery
     */
    types: Array<AfmValidObjectsQueryTypesEnum>;
    /**
     *
     * @type {AFM}
     * @memberof AfmValidObjectsQuery
     */
    afm: AFM;
}

/**
 * @export
 * @enum {string}
 */
export enum AfmValidObjectsQueryTypesEnum {
    Facts = "facts",
    Attributes = "attributes",
    Measures = "measures",
    UNRECOGNIZED = "UNRECOGNIZED",
}

/**
 * All objects of specified types valid with respect to given AFM.
 * @export
 * @interface AfmValidObjectsResponse
 */
export interface AfmValidObjectsResponse {
    /**
     *
     * @type {Array<ObjectIdentifier>}
     * @memberof AfmValidObjectsResponse
     */
    items: Array<ObjectIdentifier>;
}
/**
 * Measure representing arithmetics between measures.
 * @export
 * @interface ArithmeticMeasureDefinition
 */
export interface ArithmeticMeasureDefinition {
    /**
     *
     * @type {ArithmeticMeasureDefinitionArithmeticMeasure}
     * @memberof ArithmeticMeasureDefinition
     */
    arithmeticMeasure: ArithmeticMeasureDefinitionArithmeticMeasure;
}
/**
 *
 * @export
 * @interface ArithmeticMeasureDefinitionArithmeticMeasure
 */
export interface ArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of measures to apply arithmetic operation by chosen operator.
     * @type {Array<LocalIdentifier>}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    measureIdentifiers: Array<LocalIdentifier>;
    /**
     * Arithmetic operator describing operation between measures.
     * @type {string}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    operator: ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum {
    SUM = "SUM",
    DIFFERENCE = "DIFFERENCE",
    MULTIPLICATION = "MULTIPLICATION",
    RATIO = "RATIO",
    CHANGE = "CHANGE",
}

/**
 *
 * @export
 * @interface AttributeExecutionResultHeader
 */
export interface AttributeExecutionResultHeader {
    /**
     *
     * @type {AttributeResultHeader}
     * @memberof AttributeExecutionResultHeader
     */
    attributeHeader: AttributeResultHeader;
}
/**
 * @type AttributeFilter
 * Abstract filter definition type attributes
 * @export
 */
export type AttributeFilter = NegativeAttributeFilter | PositiveAttributeFilter;
/**
 * Filter on specific set of label values.
 * @export
 * @interface AttributeFilterElements
 */
export interface AttributeFilterElements {
    /**
     * Set of label values.
     * @type {Array<string>}
     * @memberof AttributeFilterElements
     */
    values: Array<string>;
}
/**
 *
 * @export
 * @interface AttributeHeader
 */
export interface AttributeHeader {
    /**
     *
     * @type {AttributeHeaderAttributeHeader}
     * @memberof AttributeHeader
     */
    attributeHeader: AttributeHeaderAttributeHeader;
}
/**
 *
 * @export
 * @interface AttributeHeaderAttributeHeader
 */
export interface AttributeHeaderAttributeHeader {
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    identifier: string;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    localIdentifier: string;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    name: string;
    /**
     *
     * @type {FormOf}
     * @memberof AttributeHeaderAttributeHeader
     */
    formOf: FormOf;
}
/**
 *
 * @export
 * @interface AttributeItem
 */
export interface AttributeItem {
    /**
     *
     * @type {string}
     * @memberof AttributeItem
     */
    localIdentifier: string;
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AttributeItem
     */
    displayForm: ObjectIdentifier;
}
/**
 * Header containing the information related to attributes.
 * @export
 * @interface AttributeResultHeader
 */
export interface AttributeResultHeader {
    /**
     * A value of the current attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    labelValue: string;
    /**
     * A value of the primary attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    primaryLabelValue: string;
}
/**
 * Filter the result by comparing specified measure to given constant value, using given comparison operator.
 * @export
 * @interface ComparisonMeasureValueFilter
 */
export interface ComparisonMeasureValueFilter {
    /**
     *
     * @type {ComparisonMeasureValueFilterComparisonMeasureValueFilter}
     * @memberof ComparisonMeasureValueFilter
     */
    comparisonMeasureValueFilter: ComparisonMeasureValueFilterComparisonMeasureValueFilter;
}
/**
 *
 * @export
 * @interface ComparisonMeasureValueFilterComparisonMeasureValueFilter
 */
export interface ComparisonMeasureValueFilterComparisonMeasureValueFilter {
    /**
     *
     * @type {Identifier}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    measure: Identifier;
    /**
     *
     * @type {string}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    operator: ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    value: number;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    treatNullValuesAs?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum {
    GREATERTHAN = "GREATER_THAN",
    GREATERTHANOREQUALTO = "GREATER_THAN_OR_EQUAL_TO",
    LESSTHAN = "LESS_THAN",
    LESSTHANOREQUALTO = "LESS_THAN_OR_EQUAL_TO",
    EQUALTO = "EQUAL_TO",
    NOTEQUALTO = "NOT_EQUAL_TO",
}

/**
 * @type DateFilter
 * Abstract filter definition type for dates
 * @export
 */
export type DateFilter = AbsoluteDateFilter | RelativeDateFilter;
/**
 * Single dimension description.
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * List of items in current dimension. Can reference \'localIdentifier\' from \'AttributeItem\', or special pseudo attribute \"measureGroup\" representing list of measures.
     * @type {Array<string>}
     * @memberof Dimension
     */
    itemIdentifiers: Array<string>;
    /**
     * Dimension identification within requests. Other entities can reference this dimension by this value.
     * @type {string}
     * @memberof Dimension
     */
    localIdentifier?: string;
    /**
     * List of sorting rules. From most relevant to least relevant (less relevant rule is applied, when more relevant rule compares items as equal).
     * @type {Array<SortKeyAttribute | SortKeyValue>}
     * @memberof Dimension
     */
    sorting?: Array<SortKeyAttribute | SortKeyValue>;
}
/**
 * Contains the dimension-specific header information.
 * @export
 * @interface DimensionHeader
 */
export interface DimensionHeader {
    /**
     * An array containing header groups.
     * @type {Array<HeaderGroup>}
     * @memberof DimensionHeader
     */
    headerGroups: Array<HeaderGroup>;
}
/**
 * Locator of data value in one dimension item.
 * @export
 * @interface DimensionItemValue
 */
export interface DimensionItemValue {
    /**
     * Dimension item reference - either \'localIdentifier\' from \'AttributeItem\', or \"measureGroup\".
     * @type {string}
     * @memberof DimensionItemValue
     */
    itemIdentifier: string;
    /**
     * Attribute value (in case of \'localIdentifier\' from \'AttributeItem\' in \'itemIdentifier\') or \'localIdentifier\' from \'MeasureItem\' (in case of \"measureGroup\" in \'itemIdentifier\').\'
     * @type {string}
     * @memberof DimensionItemValue
     */
    itemValue: string;
}
/**
 * Locator of data value in one dimension
 * @export
 * @interface DimensionLocator
 */
export interface DimensionLocator {
    /**
     * Dimension \'localIdentifier\' reference.
     * @type {string}
     * @memberof DimensionLocator
     */
    dimensionIdentifier: string;
    /**
     * List specifying full location of a dimension tuple.
     * @type {Array<DimensionItemValue>}
     * @memberof DimensionLocator
     */
    locator: Array<DimensionItemValue>;
}
/**
 * List of returned elements.
 * @export
 * @interface Element
 */
export interface Element {
    /**
     * Title of primary label of attribute owning requested label.
     * @type {string}
     * @memberof Element
     */
    primaryTitle: string;
    /**
     * Title of requested label.
     * @type {string}
     * @memberof Element
     */
    title: string;
}
/**
 * Entity holding list of sorted & filtered label elements, related primary label of attribute owning requested label and paging.
 * @export
 * @interface ElementsResponse
 */
export interface ElementsResponse {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof ElementsResponse
     */
    primaryLabel: ObjectIdentifier;
    /**
     * List of returned elements.
     * @type {Array<Element>}
     * @memberof ElementsResponse
     */
    elements: Array<Element>;
    /**
     *
     * @type {Paging}
     * @memberof ElementsResponse
     */
    paging: Paging;
    /**
     * Total count of items ignoring all filters (using on ```project``` and  ```label``` from request).
     * @type {number}
     * @memberof ElementsResponse
     */
    totalCountWithoutFilters?: number;
}
/**
 * Contains information about the error.
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
    /**
     * Error timestamp in ISO 8601.
     * @type {string}
     * @memberof ErrorMessage
     */
    timestamp: string;
    /**
     * HTTP error response status code.
     * @type {number}
     * @memberof ErrorMessage
     */
    status: number;
    /**
     * HTTP error message like: Bad Request, Not Found, etc.
     * @type {string}
     * @memberof ErrorMessage
     */
    error: string;
    /**
     * Error message returned by the server application.
     * @type {string}
     * @memberof ErrorMessage
     */
    message: string;
    /**
     * Path of the failed request.
     * @type {string}
     * @memberof ErrorMessage
     */
    path: string;
}
/**
 *
 * @export
 * @interface ExecutionLinks
 */
export interface ExecutionLinks {
    /**
     *
     * @type {string}
     * @memberof ExecutionLinks
     */
    executionResult: string;
}
/**
 *
 * @export
 * @interface ExecutionResponse
 */
export interface ExecutionResponse {
    /**
     *
     * @type {Array<ResultDimension>}
     * @memberof ExecutionResponse
     */
    dimensions: Array<ResultDimension>;
    /**
     *
     * @type {ExecutionLinks}
     * @memberof ExecutionResponse
     */
    links: ExecutionLinks;
}
/**
 * Contains the result of an AFM execution.
 * @export
 * @interface ExecutionResult
 */
export interface ExecutionResult {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     * @type {Array<object>}
     * @memberof ExecutionResult
     */
    data: Array<object>;
    /**
     * An array containing dimension headers. The size of the array corresponds to dimension size. Their order corresponds to the dimension order in the execution result spec.
     * @type {Array<DimensionHeader>}
     * @memberof ExecutionResult
     */
    dimensionHeaders: Array<DimensionHeader>;
    /**
     *
     * @type {ExecutionResultPaging}
     * @memberof ExecutionResult
     */
    paging: ExecutionResultPaging;
}
/**
 * Abstract execution result header
 * @export
 * @interface ExecutionResultHeader
 */
export interface ExecutionResultHeader {
    /**
     *
     * @type {AttributeResultHeader}
     * @memberof ExecutionResultHeader
     */
    attributeHeader: AttributeResultHeader;
    /**
     *
     * @type {MeasureResultHeader}
     * @memberof ExecutionResultHeader
     */
    measureHeader: MeasureResultHeader;
}
/**
 * A paging information related to the data presented in the execution result. These paging information are multi-dimensional.
 * @export
 * @interface ExecutionResultPaging
 */
export interface ExecutionResultPaging {
    /**
     * A count of the returned results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    count: Array<number>;
    /**
     * The offset of the results returned in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    offset: Array<number>;
    /**
     * A total count of the results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    total: Array<number>;
}
/**
 * @type FilterDefinition
 * Abstract filter definition type
 * @export
 */
export type FilterDefinition = AttributeFilter | DateFilter | InlineFilterDefinition | MeasureValueFilter;
/**
 * @type FilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple measure.
 * @export
 */
export type FilterDefinitionForSimpleMeasure = AttributeFilter | DateFilter;
/**
 *
 * @export
 * @interface FormOf
 */
export interface FormOf {
    /**
     *
     * @type {string}
     * @memberof FormOf
     */
    identifier: string;
    /**
     *
     * @type {string}
     * @memberof FormOf
     */
    primaryLabelIdentifier: string;
    /**
     *
     * @type {string}
     * @memberof FormOf
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof FormOf
     */
    granularity?: FormOfGranularityEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum FormOfGranularityEnum {
    YEAR = "YEAR",
    DAY = "DAY",
    HOUR = "HOUR",
    MINUTE = "MINUTE",
    QUARTER = "QUARTER",
    MONTH = "MONTH",
    WEEK = "WEEK",
    QUARTEROFYEAR = "QUARTER_OF_YEAR",
    MONTHOFYEAR = "MONTH_OF_YEAR",
    DAYOFYEAR = "DAY_OF_YEAR",
    DAYOFWEEK = "DAY_OF_WEEK",
    DAYOFMONTH = "DAY_OF_MONTH",
    HOUROFDAY = "HOUR_OF_DAY",
    MINUTEOFHOUR = "MINUTE_OF_HOUR",
    WEEKOFYEAR = "WEEK_OF_YEAR",
}

/**
 * Contains the information specific for a group of headers. These groups correlate to attributes and measure groups.
 * @export
 * @interface HeaderGroup
 */
export interface HeaderGroup {
    /**
     * An array containing headers.
     * @type {Array<ExecutionResultHeader>}
     * @memberof HeaderGroup
     */
    headers: Array<ExecutionResultHeader>;
}
/**
 * @type Identifier
 * Abstract identifier type
 * @export
 */
export type Identifier = LocalIdentifier | ObjectIdentifier;
/**
 * Filter in form of direct MAQL query.
 * @export
 * @interface InlineFilterDefinition
 */
export interface InlineFilterDefinition {
    /**
     *
     * @type {InlineFilterDefinitionInline}
     * @memberof InlineFilterDefinition
     */
    inline: InlineFilterDefinitionInline;
}
/**
 *
 * @export
 * @interface InlineFilterDefinitionInline
 */
export interface InlineFilterDefinitionInline {
    /**
     *
     * @type {string}
     * @memberof InlineFilterDefinitionInline
     */
    filter: string;
}
/**
 * Measure defined by the raw MAQL query.
 * @export
 * @interface InlineMeasureDefinition
 */
export interface InlineMeasureDefinition {
    /**
     *
     * @type {InlineMeasureDefinitionInline}
     * @memberof InlineMeasureDefinition
     */
    inline: InlineMeasureDefinitionInline;
}
/**
 *
 * @export
 * @interface InlineMeasureDefinitionInline
 */
export interface InlineMeasureDefinitionInline {
    /**
     *
     * @type {string}
     * @memberof InlineMeasureDefinitionInline
     */
    maql: string;
}
/**
 * String that uniquely identifies the measure in the context of the current AFM.
 * @export
 * @interface LocalIdentifier
 */
export interface LocalIdentifier {
    /**
     *
     * @type {string}
     * @memberof LocalIdentifier
     */
    localIdentifier: string;
}
/**
 * @type MeasureDefinition
 * Abstract measure definition type
 * @export
 */
export type MeasureDefinition =
    | ArithmeticMeasureDefinition
    | InlineMeasureDefinition
    | PopDatasetMeasureDefinition
    | PopDateMeasureDefinition
    | SimpleMeasureDefinition;
/**
 *
 * @export
 * @interface MeasureExecutionResultHeader
 */
export interface MeasureExecutionResultHeader {
    /**
     *
     * @type {MeasureResultHeader}
     * @memberof MeasureExecutionResultHeader
     */
    measureHeader: MeasureResultHeader;
}
/**
 *
 * @export
 * @interface MeasureGroupHeader
 */
export interface MeasureGroupHeader {
    /**
     *
     * @type {Array<MeasureGroupHeaderIn>}
     * @memberof MeasureGroupHeader
     */
    measureGroupHeader: Array<MeasureGroupHeaderIn>;
}
/**
 *
 * @export
 * @interface MeasureGroupHeaderIn
 */
export interface MeasureGroupHeaderIn {
    /**
     *
     * @type {MeasureHeaderItem}
     * @memberof MeasureGroupHeaderIn
     */
    items: MeasureHeaderItem;
}
/**
 *
 * @export
 * @interface MeasureHeaderItem
 */
export interface MeasureHeaderItem {
    /**
     *
     * @type {MeasureHeaderItemMeasureHeaderItem}
     * @memberof MeasureHeaderItem
     */
    measureHeaderItem: MeasureHeaderItemMeasureHeaderItem;
}
/**
 *
 * @export
 * @interface MeasureHeaderItemMeasureHeaderItem
 */
export interface MeasureHeaderItemMeasureHeaderItem {
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderItemMeasureHeaderItem
     */
    localIdentifier: string;
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderItemMeasureHeaderItem
     */
    format?: string;
}
/**
 *
 * @export
 * @interface MeasureItem
 */
export interface MeasureItem {
    /**
     *
     * @type {string}
     * @memberof MeasureItem
     */
    localIdentifier: string;
    /**
     *
     * @type {MeasureDefinition}
     * @memberof MeasureItem
     */
    definition: MeasureDefinition;
}
/**
 * Header containing the information related to measures.
 * @export
 * @interface MeasureResultHeader
 */
export interface MeasureResultHeader {
    /**
     * Measure index. Starts at 0.
     * @type {number}
     * @memberof MeasureResultHeader
     */
    measureIndex: number;
}
/**
 * @type MeasureValueFilter
 * Abstract filter definition type filtering by the value of the measure.
 * @export
 */
export type MeasureValueFilter = ComparisonMeasureValueFilter | RangeMeasureValueFilter;
/**
 * Filter able to limit element values by displayForm and related selected negated elements.
 * @export
 * @interface NegativeAttributeFilter
 */
export interface NegativeAttributeFilter {
    /**
     *
     * @type {NegativeAttributeFilterNegativeAttributeFilter}
     * @memberof NegativeAttributeFilter
     */
    negativeAttributeFilter: NegativeAttributeFilterNegativeAttributeFilter;
}
/**
 *
 * @export
 * @interface NegativeAttributeFilterNegativeAttributeFilter
 */
export interface NegativeAttributeFilterNegativeAttributeFilter {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof NegativeAttributeFilterNegativeAttributeFilter
     */
    displayForm: ObjectIdentifier;
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof NegativeAttributeFilterNegativeAttributeFilter
     */
    notIn: AttributeFilterElements;
}
/**
 * Identifier of LDM object determined by ID & type.
 * @export
 * @interface ObjectIdentifier
 */
export interface ObjectIdentifier {
    /**
     *
     * @type {ObjectIdentifierIdentifier}
     * @memberof ObjectIdentifier
     */
    identifier: ObjectIdentifierIdentifier;
}
/**
 *
 * @export
 * @interface ObjectIdentifierIdentifier
 */
export interface ObjectIdentifierIdentifier {
    /**
     *
     * @type {string}
     * @memberof ObjectIdentifierIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ObjectIdentifierIdentifier
     */
    type: string;
}
/**
 * Current page description.
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * Count of returnable items ignoring paging.
     * @type {number}
     * @memberof Paging
     */
    total: number;
    /**
     * Count of items in this page.
     * @type {number}
     * @memberof Paging
     */
    count: number;
    /**
     * Offset of this page.
     * @type {number}
     * @memberof Paging
     */
    offset: number;
    /**
     * Link to next page, or null if this is last page.
     * @type {string}
     * @memberof Paging
     */
    next?: string;
}
/**
 *
 * @export
 * @interface PopDataset
 */
export interface PopDataset {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof PopDataset
     */
    dataset: ObjectIdentifier;
    /**
     *
     * @type {number}
     * @memberof PopDataset
     */
    periodsAgo: number;
}
/**
 * Previous period type of measure.
 * @export
 * @interface PopDatasetMeasureDefinition
 */
export interface PopDatasetMeasureDefinition {
    /**
     *
     * @type {PopDatasetMeasureDefinitionPreviousPeriodMeasure}
     * @memberof PopDatasetMeasureDefinition
     */
    previousPeriodMeasure: PopDatasetMeasureDefinitionPreviousPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDatasetMeasureDefinitionPreviousPeriodMeasure
 */
export interface PopDatasetMeasureDefinitionPreviousPeriodMeasure {
    /**
     *
     * @type {LocalIdentifier}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    measureIdentifier: LocalIdentifier;
    /**
     *
     * @type {Array<PopDataset>}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    dateDatasets: Array<PopDataset>;
}
/**
 *
 * @export
 * @interface PopDate
 */
export interface PopDate {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof PopDate
     */
    attribute: ObjectIdentifier;
    /**
     *
     * @type {number}
     * @memberof PopDate
     */
    periodsAgo: number;
}
/**
 * Period over period type of measure.
 * @export
 * @interface PopDateMeasureDefinition
 */
export interface PopDateMeasureDefinition {
    /**
     *
     * @type {PopDateMeasureDefinitionOverPeriodMeasure}
     * @memberof PopDateMeasureDefinition
     */
    overPeriodMeasure: PopDateMeasureDefinitionOverPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDateMeasureDefinitionOverPeriodMeasure
 */
export interface PopDateMeasureDefinitionOverPeriodMeasure {
    /**
     *
     * @type {LocalIdentifier}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    measureIdentifier: LocalIdentifier;
    /**
     *
     * @type {Array<PopDate>}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    dateAttributes: Array<PopDate>;
}
/**
 * Filter able to limit element values by displayForm and related selected elements.
 * @export
 * @interface PositiveAttributeFilter
 */
export interface PositiveAttributeFilter {
    /**
     *
     * @type {PositiveAttributeFilterPositiveAttributeFilter}
     * @memberof PositiveAttributeFilter
     */
    positiveAttributeFilter: PositiveAttributeFilterPositiveAttributeFilter;
}
/**
 *
 * @export
 * @interface PositiveAttributeFilterPositiveAttributeFilter
 */
export interface PositiveAttributeFilterPositiveAttributeFilter {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof PositiveAttributeFilterPositiveAttributeFilter
     */
    displayForm: ObjectIdentifier;
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof PositiveAttributeFilterPositiveAttributeFilter
     */
    _in: AttributeFilterElements;
}
/**
 * Filter the result by comparing specified measure to given range of values.
 * @export
 * @interface RangeMeasureValueFilter
 */
export interface RangeMeasureValueFilter {
    /**
     *
     * @type {RangeMeasureValueFilterRangeMeasureValueFilter}
     * @memberof RangeMeasureValueFilter
     */
    rangeMeasureValueFilter: RangeMeasureValueFilterRangeMeasureValueFilter;
}
/**
 *
 * @export
 * @interface RangeMeasureValueFilterRangeMeasureValueFilter
 */
export interface RangeMeasureValueFilterRangeMeasureValueFilter {
    /**
     *
     * @type {Identifier}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    measure: Identifier;
    /**
     *
     * @type {string}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    operator: RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    from: number;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    to: number;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    treatNullValuesAs?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum {
    BETWEEN = "BETWEEN",
    NOTBETWEEN = "NOT_BETWEEN",
}

/**
 *
 * @export
 * @interface RelativeDateFilter
 */
export interface RelativeDateFilter {
    /**
     *
     * @type {RelativeDateFilterRelativeDateFilter}
     * @memberof RelativeDateFilter
     */
    relativeDateFilter: RelativeDateFilterRelativeDateFilter;
}
/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension.
 * @export
 * @interface RelativeDateFilterRelativeDateFilter
 */
export interface RelativeDateFilterRelativeDateFilter {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    dataset: ObjectIdentifier;
    /**
     * Date granularity specifying particular date attribute in given dimension.
     * @type {string}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    granularity: string;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     * @type {number}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     * @type {number}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    to: number;
}
/**
 *
 * @export
 * @interface ResultDimension
 */
export interface ResultDimension {
    /**
     *
     * @type {Array<MeasureGroupHeader | AttributeHeader>}
     * @memberof ResultDimension
     */
    headers: Array<MeasureGroupHeader | AttributeHeader>;
}
/**
 * Structure holding array of dimensions related to the request.
 * @export
 * @interface ResultSpec
 */
export interface ResultSpec {
    /**
     *
     * @type {Array<Dimension>}
     * @memberof ResultSpec
     */
    dimensions: Array<Dimension>;
}
/**
 *
 * @export
 * @interface SimpleMeasureDefinition
 */
export interface SimpleMeasureDefinition {
    /**
     *
     * @type {SimpleMeasureDefinitionMeasure}
     * @memberof SimpleMeasureDefinition
     */
    measure: SimpleMeasureDefinitionMeasure;
}
/**
 *
 * @export
 * @interface SimpleMeasureDefinitionMeasure
 */
export interface SimpleMeasureDefinitionMeasure {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    item: ObjectIdentifier;
    /**
     * Definition of aggregation type of the measure.
     * @type {string}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    aggregation?: SimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true compute the percentage of given measure values (broken down by AFM attributes) to the total (not broken down).
     * @type {boolean}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    computeRatio?: boolean;
    /**
     * Measure can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     * @type {Array<FilterDefinitionForSimpleMeasure>}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    filters?: Array<FilterDefinitionForSimpleMeasure>;
}

/**
 * @export
 * @enum {string}
 */
export enum SimpleMeasureDefinitionMeasureAggregationEnum {
    SUM = "SUM",
    COUNT = "COUNT",
    AVG = "AVG",
    MIN = "MIN",
    MAX = "MAX",
    MEDIAN = "MEDIAN",
    RUNSUM = "RUNSUM",
}

/**
 * Sorting elements - ascending/descending order.
 * @export
 * @enum {string}
 */
export enum SortDirection {
    ASC = "ASC",
    DESC = "DESC",
}
/**
 * Sorting rule for sorting by attribute value in current dimension.
 * @export
 * @interface SortKeyAttribute
 */
export interface SortKeyAttribute {
    /**
     *
     * @type {SortKeyAttributeAttribute}
     * @memberof SortKeyAttribute
     */
    attribute: SortKeyAttributeAttribute;
}
/**
 *
 * @export
 * @interface SortKeyAttributeAttribute
 */
export interface SortKeyAttributeAttribute {
    /**
     *
     * @type {SortDirection}
     * @memberof SortKeyAttributeAttribute
     */
    direction?: SortDirection;
    /**
     * One of the \'Dimension.itemIdentifiers\' referencing the attribute which should be used for sorting the dimension.s
     * @type {string}
     * @memberof SortKeyAttributeAttribute
     */
    attributeIdentifier: string;
}
/**
 *
 * @export
 * @interface SortKeyValue
 */
export interface SortKeyValue {
    /**
     *
     * @type {SortKeyValueValue}
     * @memberof SortKeyValue
     */
    value: SortKeyValueValue;
}
/**
 *
 * @export
 * @interface SortKeyValueValue
 */
export interface SortKeyValueValue {
    /**
     *
     * @type {SortDirection}
     * @memberof SortKeyValueValue
     */
    direction?: SortDirection;
    /**
     * For each other dimension, specifies location, which value should be used for sorting.
     * @type {Array<DimensionLocator>}
     * @memberof SortKeyValueValue
     */
    dataColumnLocators: Array<DimensionLocator>;
}

/**
 * AfmControllerApi - axios parameter creator
 * @export
 */
export const AfmControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmRequest(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, afmExecution, skipCache, timestamp } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling processAfmRequest.",
                );
            }
            // verify required parameter 'afmExecution' is not null or undefined
            if (afmExecution === null || afmExecution === undefined) {
                throw new RequiredError(
                    "afmExecution",
                    "Required parameter afmExecution was null or undefined when calling processAfmRequest.",
                );
            }
            const localVarPath = `/api/workspaces/{workspaceId}/afm`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AfmControllerApi - functional programming interface
 * @export
 */
export const AfmControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmRequest(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmExecutionResponse> {
            const localVarAxiosArgs = AfmControllerApiAxiosParamCreator(configuration).processAfmRequest(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * AfmControllerApi - factory interface
 * @export
 */
export const AfmControllerApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmRequest(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options?: any,
        ): AxiosPromise<AfmExecutionResponse> {
            return AfmControllerApiFp(configuration).processAfmRequest(params, options)(axios, basePath);
        },
    };
};

/**
 * AfmControllerApi - interface
 * @export
 * @interface AfmControllerApi
 */
export interface AfmControllerApiInterface {
    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {string} workspaceId Workspace identifier
     * @param {AfmExecution} afmExecution
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {string} [timestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AfmControllerApiInterface
     */
    processAfmRequest(
        params: {
            workspaceId: string;
            afmExecution: AfmExecution;
            skipCache?: boolean;
            timestamp?: string;
        },
        options?: any,
    ): AxiosPromise<AfmExecutionResponse>;
}

/**
 * AfmControllerApi - object-oriented interface
 * @export
 * @class AfmControllerApi
 * @extends {BaseAPI}
 */
export class AfmControllerApi extends BaseAPI implements AfmControllerApiInterface {
    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {string} workspaceId Workspace identifier
     * @param {AfmExecution} afmExecution
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {string} [timestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AfmControllerApi
     */
    public processAfmRequest(
        params: {
            workspaceId: string;
            afmExecution: AfmExecution;
            skipCache?: boolean;
            timestamp?: string;
        },
        options?: any,
    ) {
        return AfmControllerApiFp(this.configuration).processAfmRequest(params, options)(
            this.axios,
            this.basePath,
        );
    }
}

/**
 * ElementsControllerApi - axios parameter creator
 * @export
 */
export const ElementsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processElementsRequest(
            params: {
                workspaceId: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                includeTotalWithoutFilters?: boolean;
                complementFilter?: boolean;
                patternFilter?: string;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const {
                workspaceId,
                label,
                sortOrder,
                includeTotalWithoutFilters,
                complementFilter,
                patternFilter,
                offset,
                limit,
                skipCache,
            } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling processElementsRequest.",
                );
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError(
                    "label",
                    "Required parameter label was null or undefined when calling processElementsRequest.",
                );
            }
            const localVarPath = `/api/workspaces/{workspaceId}/label-elements`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (label !== undefined) {
                if (typeof label === "object") {
                    addFlattenedObjectTo(label, localVarQueryParameter);
                } else {
                    localVarQueryParameter["label"] = label;
                }
            }

            if (sortOrder !== undefined) {
                if (typeof sortOrder === "object") {
                    addFlattenedObjectTo(sortOrder, localVarQueryParameter);
                } else {
                    localVarQueryParameter["sortOrder"] = sortOrder;
                }
            }

            if (includeTotalWithoutFilters !== undefined) {
                if (typeof includeTotalWithoutFilters === "object") {
                    addFlattenedObjectTo(includeTotalWithoutFilters, localVarQueryParameter);
                } else {
                    localVarQueryParameter["includeTotalWithoutFilters"] = includeTotalWithoutFilters;
                }
            }

            if (complementFilter !== undefined) {
                if (typeof complementFilter === "object") {
                    addFlattenedObjectTo(complementFilter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["complementFilter"] = complementFilter;
                }
            }

            if (patternFilter !== undefined) {
                if (typeof patternFilter === "object") {
                    addFlattenedObjectTo(patternFilter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["patternFilter"] = patternFilter;
                }
            }

            if (offset !== undefined) {
                if (typeof offset === "object") {
                    addFlattenedObjectTo(offset, localVarQueryParameter);
                } else {
                    localVarQueryParameter["offset"] = offset;
                }
            }

            if (limit !== undefined) {
                if (typeof limit === "object") {
                    addFlattenedObjectTo(limit, localVarQueryParameter);
                } else {
                    localVarQueryParameter["limit"] = limit;
                }
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ElementsControllerApi - functional programming interface
 * @export
 */
export const ElementsControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processElementsRequest(
            params: {
                workspaceId: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                includeTotalWithoutFilters?: boolean;
                complementFilter?: boolean;
                patternFilter?: string;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse> {
            const localVarAxiosArgs = ElementsControllerApiAxiosParamCreator(
                configuration,
            ).processElementsRequest(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * ElementsControllerApi - factory interface
 * @export
 */
export const ElementsControllerApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processElementsRequest(
            params: {
                workspaceId: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                includeTotalWithoutFilters?: boolean;
                complementFilter?: boolean;
                patternFilter?: string;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options?: any,
        ): AxiosPromise<ElementsResponse> {
            return ElementsControllerApiFp(configuration).processElementsRequest(params, options)(
                axios,
                basePath,
            );
        },
    };
};

/**
 * ElementsControllerApi - interface
 * @export
 * @interface ElementsControllerApi
 */
export interface ElementsControllerApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values.
     * @param {string} workspaceId Workspace identifier
     * @param {string} label Requested label.
     * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
     * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
     * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
     * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ElementsControllerApiInterface
     */
    processElementsRequest(
        params: {
            workspaceId: string;
            label: string;
            sortOrder?: "ASC" | "DESC";
            includeTotalWithoutFilters?: boolean;
            complementFilter?: boolean;
            patternFilter?: string;
            offset?: number;
            limit?: number;
            skipCache?: boolean;
        },
        options?: any,
    ): AxiosPromise<ElementsResponse>;
}

/**
 * ElementsControllerApi - object-oriented interface
 * @export
 * @class ElementsControllerApi
 * @extends {BaseAPI}
 */
export class ElementsControllerApi extends BaseAPI implements ElementsControllerApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values.
     * @param {string} workspaceId Workspace identifier
     * @param {string} label Requested label.
     * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
     * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
     * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
     * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ElementsControllerApi
     */
    public processElementsRequest(
        params: {
            workspaceId: string;
            label: string;
            sortOrder?: "ASC" | "DESC";
            includeTotalWithoutFilters?: boolean;
            complementFilter?: boolean;
            patternFilter?: string;
            offset?: number;
            limit?: number;
            skipCache?: boolean;
        },
        options?: any,
    ) {
        return ElementsControllerApiFp(this.configuration).processElementsRequest(params, options)(
            this.axios,
            this.basePath,
        );
    }
}

/**
 * ResultControllerApi - axios parameter creator
 * @export
 */
export const ResultControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResult(
            params: {
                workspaceId: string;
                resultId: string;
                offset?: Array<number>;
                limit?: Array<number>;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, resultId, offset, limit } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling getResult.",
                );
            }
            // verify required parameter 'resultId' is not null or undefined
            if (resultId === null || resultId === undefined) {
                throw new RequiredError(
                    "resultId",
                    "Required parameter resultId was null or undefined when calling getResult.",
                );
            }
            const localVarPath = `/api/workspaces/{workspaceId}/result/{resultId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit) {
                localVarQueryParameter["limit"] = limit;
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ResultControllerApi - functional programming interface
 * @export
 */
export const ResultControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResult(
            params: {
                workspaceId: string;
                resultId: string;
                offset?: Array<number>;
                limit?: Array<number>;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResult> {
            const localVarAxiosArgs = ResultControllerApiAxiosParamCreator(configuration).getResult(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * ResultControllerApi - factory interface
 * @export
 */
export const ResultControllerApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResult(
            params: {
                workspaceId: string;
                resultId: string;
                offset?: Array<number>;
                limit?: Array<number>;
            },
            options?: any,
        ): AxiosPromise<ExecutionResult> {
            return ResultControllerApiFp(configuration).getResult(params, options)(axios, basePath);
        },
    };
};

/**
 * ResultControllerApi - interface
 * @export
 * @interface ResultControllerApi
 */
export interface ResultControllerApiInterface {
    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {string} workspaceId Workspace identifier
     * @param {string} resultId Result ID
     * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultControllerApiInterface
     */
    getResult(
        params: {
            workspaceId: string;
            resultId: string;
            offset?: Array<number>;
            limit?: Array<number>;
        },
        options?: any,
    ): AxiosPromise<ExecutionResult>;
}

/**
 * ResultControllerApi - object-oriented interface
 * @export
 * @class ResultControllerApi
 * @extends {BaseAPI}
 */
export class ResultControllerApi extends BaseAPI implements ResultControllerApiInterface {
    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {string} workspaceId Workspace identifier
     * @param {string} resultId Result ID
     * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultControllerApi
     */
    public getResult(
        params: {
            workspaceId: string;
            resultId: string;
            offset?: Array<number>;
            limit?: Array<number>;
        },
        options?: any,
    ) {
        return ResultControllerApiFp(this.configuration).getResult(params, options)(
            this.axios,
            this.basePath,
        );
    }
}

/**
 * ValidObjectsControllerApi - axios parameter creator
 * @export
 */
export const ValidObjectsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmValidObjectsQuery(
            params: {
                workspaceId: string;
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, afmValidObjectsQuery } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling processAfmValidObjectsQuery.",
                );
            }
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            if (afmValidObjectsQuery === null || afmValidObjectsQuery === undefined) {
                throw new RequiredError(
                    "afmValidObjectsQuery",
                    "Required parameter afmValidObjectsQuery was null or undefined when calling processAfmValidObjectsQuery.",
                );
            }
            const localVarPath = `/api/workspaces/{workspaceId}/valid-objects`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ValidObjectsControllerApi - functional programming interface
 * @export
 */
export const ValidObjectsControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmValidObjectsQuery(
            params: {
                workspaceId: string;
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidObjectsResponse> {
            const localVarAxiosArgs = ValidObjectsControllerApiAxiosParamCreator(
                configuration,
            ).processAfmValidObjectsQuery(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * ValidObjectsControllerApi - factory interface
 * @export
 */
export const ValidObjectsControllerApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processAfmValidObjectsQuery(
            params: {
                workspaceId: string;
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options?: any,
        ): AxiosPromise<AfmValidObjectsResponse> {
            return ValidObjectsControllerApiFp(configuration).processAfmValidObjectsQuery(params, options)(
                axios,
                basePath,
            );
        },
    };
};

/**
 * ValidObjectsControllerApi - interface
 * @export
 * @interface ValidObjectsControllerApi
 */
export interface ValidObjectsControllerApiInterface {
    /**
     * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {string} workspaceId Workspace identifier
     * @param {AfmValidObjectsQuery} afmValidObjectsQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidObjectsControllerApiInterface
     */
    processAfmValidObjectsQuery(
        params: {
            workspaceId: string;
            afmValidObjectsQuery: AfmValidObjectsQuery;
        },
        options?: any,
    ): AxiosPromise<AfmValidObjectsResponse>;
}

/**
 * ValidObjectsControllerApi - object-oriented interface
 * @export
 * @class ValidObjectsControllerApi
 * @extends {BaseAPI}
 */
export class ValidObjectsControllerApi extends BaseAPI implements ValidObjectsControllerApiInterface {
    /**
     * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {string} workspaceId Workspace identifier
     * @param {AfmValidObjectsQuery} afmValidObjectsQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidObjectsControllerApi
     */
    public processAfmValidObjectsQuery(
        params: {
            workspaceId: string;
            afmValidObjectsQuery: AfmValidObjectsQuery;
        },
        options?: any,
    ) {
        return ValidObjectsControllerApiFp(this.configuration).processAfmValidObjectsQuery(params, options)(
            this.axios,
            this.basePath,
        );
    }
}
