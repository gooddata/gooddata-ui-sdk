// (C) 2021 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// @ts-ignore
import globalImportUrl from "url";
import globalImportQs from "qs";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from "./base";

// utility function that adds support for nested objects in query
const addFlattenedObjectTo = (object: any, target: any): void => {
    const flattened = globalImportQs.parse(globalImportQs.stringify(object, { allowDots: true }), {
        depth: 0,
    });
    Object.keys(flattened).forEach((key) => {
        target[key] = (flattened as any)[key];
    });
};

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 * @export
 * @interface AFM
 */
export interface AFM {
    /**
     *
     * @type {Array<AttributeItem>}
     * @memberof AFM
     */
    attributes: Array<AttributeItem>;
    /**
     * Various filter types to filter execution result.
     * @type {Array<FilterDefinition>}
     * @memberof AFM
     */
    filters: Array<FilterDefinition>;
    /**
     * Measures to be computed.
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    measures: Array<MeasureItem>;
    /**
     * Measures to be referenced from other AFM objects (e.g. filters) but not included in the result.
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    auxMeasures?: Array<MeasureItem>;
}
/**
 * A date filter specifying exact from and to dates.
 * @export
 * @interface AbsoluteDateFilter
 */
export interface AbsoluteDateFilter {
    /**
     *
     * @type {AbsoluteDateFilterBody}
     * @memberof AbsoluteDateFilter
     */
    absoluteDateFilter: AbsoluteDateFilterBody;
}
/**
 *
 * @export
 * @interface AbsoluteDateFilterBody
 */
export interface AbsoluteDateFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof AbsoluteDateFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof AbsoluteDateFilterBody
     */
    dataset: AfmObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBody
     */
    from: string;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBody
     */
    to: string;
}
/**
 *
 * @export
 * @interface AbsoluteDateFilterBodyAllOf
 */
export interface AbsoluteDateFilterBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBodyAllOf
     */
    from: string;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBodyAllOf
     */
    to: string;
}
/**
 *
 * @export
 * @interface AbstractMeasureValueFilter
 */
export interface AbstractMeasureValueFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof AbstractMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof AbstractMeasureValueFilter
     */
    dimensionality?: Array<Identifier>;
}
/**
 *
 * @export
 * @interface AbstractMeasureValueFilterAllOf
 */
export interface AbstractMeasureValueFilterAllOf {
    /**
     *
     * @type {Array<Identifier>}
     * @memberof AbstractMeasureValueFilterAllOf
     */
    dimensionality?: Array<Identifier>;
}
/**
 *
 * @export
 * @interface AfmExecution
 */
export interface AfmExecution {
    /**
     *
     * @type {AFM}
     * @memberof AfmExecution
     */
    execution: AFM;
    /**
     *
     * @type {ResultSpec}
     * @memberof AfmExecution
     */
    resultSpec: ResultSpec;
    /**
     *
     * @type {ExecutionSettings}
     * @memberof AfmExecution
     */
    settings?: ExecutionSettings;
}
/**
 *
 * @export
 * @interface AfmExecutionResponse
 */
export interface AfmExecutionResponse {
    /**
     *
     * @type {ExecutionResponse}
     * @memberof AfmExecutionResponse
     */
    executionResponse: ExecutionResponse;
}
/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 * @export
 * @interface AfmObjectIdentifier
 */
export interface AfmObjectIdentifier {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AfmObjectIdentifier
     */
    identifier: ObjectIdentifier;
}
/**
 * Entity holding AFM and list of object types whose validity should be computed.
 * @export
 * @interface AfmValidObjectsQuery
 */
export interface AfmValidObjectsQuery {
    /**
     *
     * @type {Array<string>}
     * @memberof AfmValidObjectsQuery
     */
    types: Array<AfmValidObjectsQueryTypesEnum>;
    /**
     *
     * @type {AFM}
     * @memberof AfmValidObjectsQuery
     */
    afm: AFM;
}

/**
 * @export
 * @enum {string}
 */
export enum AfmValidObjectsQueryTypesEnum {
    Facts = "facts",
    Attributes = "attributes",
    Measures = "measures",
    UNRECOGNIZED = "UNRECOGNIZED",
}

/**
 * All objects of specified types valid with respect to given AFM.
 * @export
 * @interface AfmValidObjectsResponse
 */
export interface AfmValidObjectsResponse {
    /**
     *
     * @type {Array<ObjectIdentifier>}
     * @memberof AfmValidObjectsResponse
     */
    items: Array<ObjectIdentifier>;
}
/**
 * Measure representing arithmetics between measures.
 * @export
 * @interface ArithmeticMeasureDefinition
 */
export interface ArithmeticMeasureDefinition {
    /**
     *
     * @type {ArithmeticMeasureDefinitionArithmeticMeasure}
     * @memberof ArithmeticMeasureDefinition
     */
    arithmeticMeasure: ArithmeticMeasureDefinitionArithmeticMeasure;
}
/**
 *
 * @export
 * @interface ArithmeticMeasureDefinitionArithmeticMeasure
 */
export interface ArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of measures to apply arithmetic operation by chosen operator.
     * @type {Array<LocalIdentifier>}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    measureIdentifiers: Array<LocalIdentifier>;
    /**
     * Arithmetic operator describing operation between measures.
     * @type {string}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    operator: ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum {
    SUM = "SUM",
    DIFFERENCE = "DIFFERENCE",
    MULTIPLICATION = "MULTIPLICATION",
    RATIO = "RATIO",
    CHANGE = "CHANGE",
}

/**
 *
 * @export
 * @interface AttributeExecutionResultHeader
 */
export interface AttributeExecutionResultHeader {
    /**
     *
     * @type {AttributeResultHeader}
     * @memberof AttributeExecutionResultHeader
     */
    attributeHeader: AttributeResultHeader;
}
/**
 * @type AttributeFilter
 * Abstract filter definition type attributes
 * @export
 */
export type AttributeFilter = NegativeAttributeFilter | PositiveAttributeFilter;
/**
 * Filter on specific set of label values.
 * @export
 * @interface AttributeFilterElements
 */
export interface AttributeFilterElements {
    /**
     * Set of label values.
     * @type {Array<string>}
     * @memberof AttributeFilterElements
     */
    values: Array<string>;
}
/**
 *
 * @export
 * @interface AttributeHeader
 */
export interface AttributeHeader {
    /**
     *
     * @type {AttributeHeaderAttributeHeader}
     * @memberof AttributeHeader
     */
    attributeHeader: AttributeHeaderAttributeHeader;
}
/**
 *
 * @export
 * @interface AttributeHeaderAttributeHeader
 */
export interface AttributeHeaderAttributeHeader {
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    localIdentifier: string;
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    attribute: ObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    attributeName: string;
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    label: ObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    labelName: string;
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    primaryLabel: ObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    granularity?: AttributeHeaderAttributeHeaderGranularityEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum AttributeHeaderAttributeHeaderGranularityEnum {
    YEAR = "YEAR",
    DAY = "DAY",
    HOUR = "HOUR",
    MINUTE = "MINUTE",
    QUARTER = "QUARTER",
    MONTH = "MONTH",
    WEEK = "WEEK",
    QUARTEROFYEAR = "QUARTER_OF_YEAR",
    MONTHOFYEAR = "MONTH_OF_YEAR",
    DAYOFYEAR = "DAY_OF_YEAR",
    DAYOFWEEK = "DAY_OF_WEEK",
    DAYOFMONTH = "DAY_OF_MONTH",
    HOUROFDAY = "HOUR_OF_DAY",
    MINUTEOFHOUR = "MINUTE_OF_HOUR",
    WEEKOFYEAR = "WEEK_OF_YEAR",
}

/**
 *
 * @export
 * @interface AttributeItem
 */
export interface AttributeItem {
    /**
     *
     * @type {string}
     * @memberof AttributeItem
     */
    localIdentifier: string;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof AttributeItem
     */
    label: AfmObjectIdentifier;
}
/**
 * Header containing the information related to attributes.
 * @export
 * @interface AttributeResultHeader
 */
export interface AttributeResultHeader {
    /**
     * A value of the current attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    labelValue: string;
    /**
     * A value of the primary attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    primaryLabelValue: string;
}
/**
 *
 * @export
 * @interface CommonAttributeFilter
 */
export interface CommonAttributeFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonAttributeFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Identifier}
     * @memberof CommonAttributeFilter
     */
    label: Identifier;
}
/**
 *
 * @export
 * @interface CommonAttributeFilterAllOf
 */
export interface CommonAttributeFilterAllOf {
    /**
     *
     * @type {Identifier}
     * @memberof CommonAttributeFilterAllOf
     */
    label: Identifier;
}
/**
 *
 * @export
 * @interface CommonDateFilter
 */
export interface CommonDateFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonDateFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof CommonDateFilter
     */
    dataset: AfmObjectIdentifier;
}
/**
 *
 * @export
 * @interface CommonDateFilterAllOf
 */
export interface CommonDateFilterAllOf {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof CommonDateFilterAllOf
     */
    dataset: AfmObjectIdentifier;
}
/**
 *
 * @export
 * @interface CommonFilter
 */
export interface CommonFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonFilter
     */
    applyOnResult?: boolean;
}
/**
 *
 * @export
 * @interface CommonMeasureValueFilter
 */
export interface CommonMeasureValueFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof CommonMeasureValueFilter
     */
    dimensionality?: Array<Identifier>;
    /**
     *
     * @type {Identifier}
     * @memberof CommonMeasureValueFilter
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof CommonMeasureValueFilter
     */
    treatNullValuesAs?: number;
}
/**
 *
 * @export
 * @interface CommonMeasureValueFilterAllOf
 */
export interface CommonMeasureValueFilterAllOf {
    /**
     *
     * @type {Identifier}
     * @memberof CommonMeasureValueFilterAllOf
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof CommonMeasureValueFilterAllOf
     */
    treatNullValuesAs?: number;
}
/**
 * Filter the result by comparing specified measure to given constant value, using given comparison operator.
 * @export
 * @interface ComparisonMeasureValueFilter
 */
export interface ComparisonMeasureValueFilter {
    /**
     *
     * @type {ComparisonMeasureValueFilterBody}
     * @memberof ComparisonMeasureValueFilter
     */
    comparisonMeasureValueFilter: ComparisonMeasureValueFilterBody;
}
/**
 *
 * @export
 * @interface ComparisonMeasureValueFilterBody
 */
export interface ComparisonMeasureValueFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof ComparisonMeasureValueFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof ComparisonMeasureValueFilterBody
     */
    dimensionality?: Array<Identifier>;
    /**
     *
     * @type {Identifier}
     * @memberof ComparisonMeasureValueFilterBody
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterBody
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof ComparisonMeasureValueFilterBody
     */
    operator: ComparisonMeasureValueFilterBodyOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterBody
     */
    value: number;
}

/**
 * @export
 * @enum {string}
 */
export enum ComparisonMeasureValueFilterBodyOperatorEnum {
    GREATERTHAN = "GREATER_THAN",
    GREATERTHANOREQUALTO = "GREATER_THAN_OR_EQUAL_TO",
    LESSTHAN = "LESS_THAN",
    LESSTHANOREQUALTO = "LESS_THAN_OR_EQUAL_TO",
    EQUALTO = "EQUAL_TO",
    NOTEQUALTO = "NOT_EQUAL_TO",
}

/**
 *
 * @export
 * @interface ComparisonMeasureValueFilterBodyAllOf
 */
export interface ComparisonMeasureValueFilterBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof ComparisonMeasureValueFilterBodyAllOf
     */
    operator: ComparisonMeasureValueFilterBodyAllOfOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterBodyAllOf
     */
    value: number;
}

/**
 * @export
 * @enum {string}
 */
export enum ComparisonMeasureValueFilterBodyAllOfOperatorEnum {
    GREATERTHAN = "GREATER_THAN",
    GREATERTHANOREQUALTO = "GREATER_THAN_OR_EQUAL_TO",
    LESSTHAN = "LESS_THAN",
    LESSTHANOREQUALTO = "LESS_THAN_OR_EQUAL_TO",
    EQUALTO = "EQUAL_TO",
    NOTEQUALTO = "NOT_EQUAL_TO",
}

/**
 * @type DateFilter
 * Abstract filter definition type for dates
 * @export
 */
export type DateFilter = AbsoluteDateFilter | RelativeDateFilter;
/**
 * Single dimension description.
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * List of items in current dimension. Can reference \'localIdentifier\' from \'AttributeItem\', or special pseudo attribute \"measureGroup\" representing list of measures.
     * @type {Array<string>}
     * @memberof Dimension
     */
    itemIdentifiers: Array<string>;
    /**
     * Dimension identification within requests. Other entities can reference this dimension by this value.
     * @type {string}
     * @memberof Dimension
     */
    localIdentifier?: string;
    /**
     * List of sorting rules. From most relevant to least relevant (less relevant rule is applied, when more relevant rule compares items as equal).
     * @type {Array<SortKeyAttribute | SortKeyValue>}
     * @memberof Dimension
     */
    sorting?: Array<SortKeyAttribute | SortKeyValue>;
}
/**
 * Contains the dimension-specific header information.
 * @export
 * @interface DimensionHeader
 */
export interface DimensionHeader {
    /**
     * An array containing header groups.
     * @type {Array<HeaderGroup>}
     * @memberof DimensionHeader
     */
    headerGroups: Array<HeaderGroup>;
}
/**
 * List of returned elements.
 * @export
 * @interface Element
 */
export interface Element {
    /**
     * Title of primary label of attribute owning requested label.
     * @type {string}
     * @memberof Element
     */
    primaryTitle: string;
    /**
     * Title of requested label.
     * @type {string}
     * @memberof Element
     */
    title: string;
}
/**
 *
 * @export
 * @interface ElementsRequest
 */
export interface ElementsRequest {
    /**
     * Requested label.
     * @type {string}
     * @memberof ElementsRequest
     */
    label: string;
    /**
     * Sort order of returned items. Items are sorted by ```label``` title.
     * @type {string}
     * @memberof ElementsRequest
     */
    sortOrder?: ElementsRequestSortOrderEnum;
    /**
     * Inverse filters: * ```false``` - return items matching ```patternFilter``` and ```exactFilter``` * ```true``` - return items not matching ```patternFilter``` and ```exactFilter```
     * @type {boolean}
     * @memberof ElementsRequest
     */
    complementFilter?: boolean;
    /**
     * Return only items, whose ```label``` title case insensitively contains ```filter``` as substring.
     * @type {string}
     * @memberof ElementsRequest
     */
    patternFilter?: string;
    /**
     * Return only items, whose ```label``` title exactly matches one of ```filter```.
     * @type {Array<string>}
     * @memberof ElementsRequest
     */
    exactFilter?: Array<string>;
    /**
     * Specifies percentage of source table data scanned during the computation.
     * @type {number}
     * @memberof ElementsRequest
     */
    dataSamplingPercentage?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum ElementsRequestSortOrderEnum {
    ASC = "ASC",
    DESC = "DESC",
}

/**
 * Entity holding list of sorted & filtered label elements, related primary label of attribute owning requested label and paging.
 * @export
 * @interface ElementsResponse
 */
export interface ElementsResponse {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof ElementsResponse
     */
    primaryLabel: ObjectIdentifier;
    /**
     * List of returned elements.
     * @type {Array<Element>}
     * @memberof ElementsResponse
     */
    elements: Array<Element>;
    /**
     *
     * @type {Paging}
     * @memberof ElementsResponse
     */
    paging: Paging;
}
/**
 * Contains information about the error.
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
    /**
     * Error timestamp in ISO 8601.
     * @type {string}
     * @memberof ErrorMessage
     */
    timestamp: string;
    /**
     * HTTP error response status code.
     * @type {number}
     * @memberof ErrorMessage
     */
    status: number;
    /**
     * HTTP error message like: Bad Request, Not Found, etc.
     * @type {string}
     * @memberof ErrorMessage
     */
    error: string;
    /**
     * Error message returned by the server application.
     * @type {string}
     * @memberof ErrorMessage
     */
    message: string;
    /**
     * Path of the failed request.
     * @type {string}
     * @memberof ErrorMessage
     */
    path: string;
}
/**
 *
 * @export
 * @interface ExecutionLinks
 */
export interface ExecutionLinks {
    /**
     *
     * @type {string}
     * @memberof ExecutionLinks
     */
    executionResult: string;
}
/**
 *
 * @export
 * @interface ExecutionResponse
 */
export interface ExecutionResponse {
    /**
     *
     * @type {Array<ResultDimension>}
     * @memberof ExecutionResponse
     */
    dimensions: Array<ResultDimension>;
    /**
     *
     * @type {ExecutionLinks}
     * @memberof ExecutionResponse
     */
    links: ExecutionLinks;
}
/**
 * Contains the result of an AFM execution.
 * @export
 * @interface ExecutionResult
 */
export interface ExecutionResult {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     * @type {Array<object>}
     * @memberof ExecutionResult
     */
    data: Array<object>;
    /**
     * An array containing dimension headers. The size of the array corresponds to dimension size. Their order corresponds to the dimension order in the execution result spec.
     * @type {Array<DimensionHeader>}
     * @memberof ExecutionResult
     */
    dimensionHeaders: Array<DimensionHeader>;
    /**
     * An array with grand totals data corresponding to grand totals definition in result spec.
     * @type {Array<ExecutionResultGrandTotal>}
     * @memberof ExecutionResult
     */
    grandTotals: Array<ExecutionResultGrandTotal>;
    /**
     *
     * @type {ExecutionResultPaging}
     * @memberof ExecutionResult
     */
    paging: ExecutionResultPaging;
}
/**
 * Contains the data related to a grand total, including the reference to localIdentifier as specified in result spec.
 * @export
 * @interface ExecutionResultGrandTotal
 */
export interface ExecutionResultGrandTotal {
    /**
     *
     * @type {object}
     * @memberof ExecutionResultGrandTotal
     */
    data: object;
    /**
     *
     * @type {string}
     * @memberof ExecutionResultGrandTotal
     */
    localIdentifier: string;
}
/**
 * @type ExecutionResultHeader
 * Abstract execution result header
 * @export
 */
export type ExecutionResultHeader = AttributeExecutionResultHeader | MeasureExecutionResultHeader;
/**
 * A paging information related to the data presented in the execution result. These paging information are multi-dimensional.
 * @export
 * @interface ExecutionResultPaging
 */
export interface ExecutionResultPaging {
    /**
     * A count of the returned results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    count: Array<number>;
    /**
     * The offset of the results returned in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    offset: Array<number>;
    /**
     * A total count of the results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    total: Array<number>;
}
/**
 * Various setting affecting the process of ADM execution or its result
 * @export
 * @interface ExecutionSettings
 */
export interface ExecutionSettings {
    /**
     * Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     * @type {number}
     * @memberof ExecutionSettings
     */
    dataSamplingPercentage?: number;
}
/**
 * @type FilterDefinition
 * Abstract filter definition type
 * @export
 */
export type FilterDefinition =
    | AttributeFilter
    | DateFilter
    | InlineFilterDefinition
    | MeasureValueFilter
    | RankingFilter;
/**
 * @type FilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple measure.
 * @export
 */
export type FilterDefinitionForSimpleMeasure = AttributeFilter | DateFilter;
/**
 * Definition of a grand total. Grand total data will be computed into a separate section of the result structure so that client has more options how to visualize them.
 * @export
 * @interface GrandTotal
 */
export interface GrandTotal {
    /**
     * Grand total identification within this request. The corresponding data in the result are expected to be matched using this identifier.
     * @type {string}
     * @memberof GrandTotal
     */
    localIdentifier: string;
    /**
     * Aggregation function for grand total computation.
     * @type {string}
     * @memberof GrandTotal
     */
    function: string;
    /**
     * Mapping specifying dimensions on which this grand total will be computed. Dimensions are referenced via their localIdentifiers. Optionally one can specify also the values (properties) of the dimensions\' attributes (see ```dimensionAttributesValues```).
     * @type {{ [key: string]: IncludedDimensionProps; }}
     * @memberof GrandTotal
     */
    includedDimensions: { [key: string]: IncludedDimensionProps };
}
/**
 * Contains the information specific for a group of headers. These groups correlate to attributes and measure groups.
 * @export
 * @interface HeaderGroup
 */
export interface HeaderGroup {
    /**
     * An array containing headers.
     * @type {Array<ExecutionResultHeader>}
     * @memberof HeaderGroup
     */
    headers: Array<ExecutionResultHeader>;
}
/**
 * @type Identifier
 * Abstract identifier type
 * @export
 */
export type Identifier = AfmObjectIdentifier | LocalIdentifier;
/**
 *
 * @export
 * @interface IncludedDimensionProps
 */
export interface IncludedDimensionProps {
    /**
     * Allows to customize for which attribute values the grand total will be computed. If the values for particular attribute are not specified then the totals for all values are computed. Note that this also covers the case of individual measures (treated as values of the \"measureGroup\" pseudo attribute).
     * @type {{ [key: string]: Array<string>; }}
     * @memberof IncludedDimensionProps
     */
    dimensionAttributesValues: { [key: string]: Array<string> };
}
/**
 * Filter in form of direct MAQL query.
 * @export
 * @interface InlineFilterDefinition
 */
export interface InlineFilterDefinition {
    /**
     *
     * @type {InlineFilterDefinitionBody}
     * @memberof InlineFilterDefinition
     */
    inline: InlineFilterDefinitionBody;
}
/**
 *
 * @export
 * @interface InlineFilterDefinitionBody
 */
export interface InlineFilterDefinitionBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof InlineFilterDefinitionBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {string}
     * @memberof InlineFilterDefinitionBody
     */
    filter: string;
}
/**
 *
 * @export
 * @interface InlineFilterDefinitionBodyAllOf
 */
export interface InlineFilterDefinitionBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof InlineFilterDefinitionBodyAllOf
     */
    filter: string;
}
/**
 * Measure defined by the raw MAQL query.
 * @export
 * @interface InlineMeasureDefinition
 */
export interface InlineMeasureDefinition {
    /**
     *
     * @type {InlineMeasureDefinitionInline}
     * @memberof InlineMeasureDefinition
     */
    inline: InlineMeasureDefinitionInline;
}
/**
 *
 * @export
 * @interface InlineMeasureDefinitionInline
 */
export interface InlineMeasureDefinitionInline {
    /**
     *
     * @type {string}
     * @memberof InlineMeasureDefinitionInline
     */
    maql: string;
}
/**
 * String that uniquely identifies the measure in the context of the current AFM.
 * @export
 * @interface LocalIdentifier
 */
export interface LocalIdentifier {
    /**
     *
     * @type {string}
     * @memberof LocalIdentifier
     */
    localIdentifier: string;
}
/**
 * @type MeasureDefinition
 * Abstract measure definition type
 * @export
 */
export type MeasureDefinition =
    | ArithmeticMeasureDefinition
    | InlineMeasureDefinition
    | PopDatasetMeasureDefinition
    | PopDateMeasureDefinition
    | SimpleMeasureDefinition;
/**
 *
 * @export
 * @interface MeasureExecutionResultHeader
 */
export interface MeasureExecutionResultHeader {
    /**
     *
     * @type {MeasureResultHeader}
     * @memberof MeasureExecutionResultHeader
     */
    measureHeader: MeasureResultHeader;
}
/**
 *
 * @export
 * @interface MeasureGroupHeader
 */
export interface MeasureGroupHeader {
    /**
     *
     * @type {Array<MeasureHeaderOut>}
     * @memberof MeasureGroupHeader
     */
    measureGroupHeaders: Array<MeasureHeaderOut>;
}
/**
 *
 * @export
 * @interface MeasureHeaderOut
 */
export interface MeasureHeaderOut {
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    localIdentifier: string;
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    format?: string;
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    name?: string;
}
/**
 *
 * @export
 * @interface MeasureItem
 */
export interface MeasureItem {
    /**
     *
     * @type {string}
     * @memberof MeasureItem
     */
    localIdentifier: string;
    /**
     *
     * @type {MeasureDefinition}
     * @memberof MeasureItem
     */
    definition: MeasureDefinition;
}
/**
 * Header containing the information related to measures.
 * @export
 * @interface MeasureResultHeader
 */
export interface MeasureResultHeader {
    /**
     * Measure index. Starts at 0.
     * @type {number}
     * @memberof MeasureResultHeader
     */
    measureIndex: number;
}
/**
 * @type MeasureValueFilter
 * Abstract filter definition type filtering by the value of the measure.
 * @export
 */
export type MeasureValueFilter = ComparisonMeasureValueFilter | RangeMeasureValueFilter;
/**
 * Filter able to limit element values by label and related selected negated elements.
 * @export
 * @interface NegativeAttributeFilter
 */
export interface NegativeAttributeFilter {
    /**
     *
     * @type {NegativeAttributeFilterBody}
     * @memberof NegativeAttributeFilter
     */
    negativeAttributeFilter: NegativeAttributeFilterBody;
}
/**
 *
 * @export
 * @interface NegativeAttributeFilterBody
 */
export interface NegativeAttributeFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof NegativeAttributeFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Identifier}
     * @memberof NegativeAttributeFilterBody
     */
    label: Identifier;
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof NegativeAttributeFilterBody
     */
    notIn: AttributeFilterElements;
}
/**
 *
 * @export
 * @interface NegativeAttributeFilterBodyAllOf
 */
export interface NegativeAttributeFilterBodyAllOf {
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof NegativeAttributeFilterBodyAllOf
     */
    notIn: AttributeFilterElements;
}
/**
 * Identifier of LDM object determined by ID & type.
 * @export
 * @interface ObjectIdentifier
 */
export interface ObjectIdentifier {
    /**
     *
     * @type {string}
     * @memberof ObjectIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ObjectIdentifier
     */
    type: string;
}
/**
 * Current page description.
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * Count of returnable items ignoring paging.
     * @type {number}
     * @memberof Paging
     */
    total: number;
    /**
     * Count of items in this page.
     * @type {number}
     * @memberof Paging
     */
    count: number;
    /**
     * Offset of this page.
     * @type {number}
     * @memberof Paging
     */
    offset: number;
    /**
     * Link to next page, or null if this is last page.
     * @type {string}
     * @memberof Paging
     */
    next?: string;
}
/**
 *
 * @export
 * @interface PopDataset
 */
export interface PopDataset {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof PopDataset
     */
    dataset: AfmObjectIdentifier;
    /**
     *
     * @type {number}
     * @memberof PopDataset
     */
    periodsAgo: number;
}
/**
 * Previous period type of measure.
 * @export
 * @interface PopDatasetMeasureDefinition
 */
export interface PopDatasetMeasureDefinition {
    /**
     *
     * @type {PopDatasetMeasureDefinitionPreviousPeriodMeasure}
     * @memberof PopDatasetMeasureDefinition
     */
    previousPeriodMeasure: PopDatasetMeasureDefinitionPreviousPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDatasetMeasureDefinitionPreviousPeriodMeasure
 */
export interface PopDatasetMeasureDefinitionPreviousPeriodMeasure {
    /**
     *
     * @type {LocalIdentifier}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    measureIdentifier: LocalIdentifier;
    /**
     *
     * @type {Array<PopDataset>}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    dateDatasets: Array<PopDataset>;
}
/**
 *
 * @export
 * @interface PopDate
 */
export interface PopDate {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof PopDate
     */
    attribute: AfmObjectIdentifier;
    /**
     *
     * @type {number}
     * @memberof PopDate
     */
    periodsAgo: number;
}
/**
 * Period over period type of measure.
 * @export
 * @interface PopDateMeasureDefinition
 */
export interface PopDateMeasureDefinition {
    /**
     *
     * @type {PopDateMeasureDefinitionOverPeriodMeasure}
     * @memberof PopDateMeasureDefinition
     */
    overPeriodMeasure: PopDateMeasureDefinitionOverPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDateMeasureDefinitionOverPeriodMeasure
 */
export interface PopDateMeasureDefinitionOverPeriodMeasure {
    /**
     *
     * @type {LocalIdentifier}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    measureIdentifier: LocalIdentifier;
    /**
     *
     * @type {Array<PopDate>}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    dateAttributes: Array<PopDate>;
}
/**
 * Filter able to limit element values by label and related selected elements.
 * @export
 * @interface PositiveAttributeFilter
 */
export interface PositiveAttributeFilter {
    /**
     *
     * @type {PositiveAttributeFilterBody}
     * @memberof PositiveAttributeFilter
     */
    positiveAttributeFilter: PositiveAttributeFilterBody;
}
/**
 *
 * @export
 * @interface PositiveAttributeFilterBody
 */
export interface PositiveAttributeFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof PositiveAttributeFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Identifier}
     * @memberof PositiveAttributeFilterBody
     */
    label: Identifier;
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof PositiveAttributeFilterBody
     */
    in: AttributeFilterElements;
}
/**
 *
 * @export
 * @interface PositiveAttributeFilterBodyAllOf
 */
export interface PositiveAttributeFilterBodyAllOf {
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof PositiveAttributeFilterBodyAllOf
     */
    in: AttributeFilterElements;
}
/**
 * Filter the result by comparing specified measure to given range of values.
 * @export
 * @interface RangeMeasureValueFilter
 */
export interface RangeMeasureValueFilter {
    /**
     *
     * @type {RangeMeasureValueFilterBody}
     * @memberof RangeMeasureValueFilter
     */
    rangeMeasureValueFilter: RangeMeasureValueFilterBody;
}
/**
 *
 * @export
 * @interface RangeMeasureValueFilterBody
 */
export interface RangeMeasureValueFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof RangeMeasureValueFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof RangeMeasureValueFilterBody
     */
    dimensionality?: Array<Identifier>;
    /**
     *
     * @type {Identifier}
     * @memberof RangeMeasureValueFilterBody
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBody
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof RangeMeasureValueFilterBody
     */
    operator: RangeMeasureValueFilterBodyOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBody
     */
    from: number;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBody
     */
    to: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RangeMeasureValueFilterBodyOperatorEnum {
    BETWEEN = "BETWEEN",
    NOTBETWEEN = "NOT_BETWEEN",
}

/**
 *
 * @export
 * @interface RangeMeasureValueFilterBodyAllOf
 */
export interface RangeMeasureValueFilterBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof RangeMeasureValueFilterBodyAllOf
     */
    operator: RangeMeasureValueFilterBodyAllOfOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBodyAllOf
     */
    from: number;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBodyAllOf
     */
    to: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RangeMeasureValueFilterBodyAllOfOperatorEnum {
    BETWEEN = "BETWEEN",
    NOTBETWEEN = "NOT_BETWEEN",
}

/**
 * Filter the result on top/bottom N values according to given measure(s).
 * @export
 * @interface RankingFilter
 */
export interface RankingFilter {
    /**
     *
     * @type {RankingFilterBody}
     * @memberof RankingFilter
     */
    rankingFilter: RankingFilterBody;
}
/**
 *
 * @export
 * @interface RankingFilterBody
 */
export interface RankingFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof RankingFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof RankingFilterBody
     */
    dimensionality?: Array<Identifier>;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof RankingFilterBody
     */
    measures: Array<Identifier>;
    /**
     *
     * @type {string}
     * @memberof RankingFilterBody
     */
    operator: RankingFilterBodyOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RankingFilterBody
     */
    value: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RankingFilterBodyOperatorEnum {
    TOP = "TOP",
    BOTTOM = "BOTTOM",
}

/**
 *
 * @export
 * @interface RankingFilterBodyAllOf
 */
export interface RankingFilterBodyAllOf {
    /**
     *
     * @type {Array<Identifier>}
     * @memberof RankingFilterBodyAllOf
     */
    measures: Array<Identifier>;
    /**
     *
     * @type {string}
     * @memberof RankingFilterBodyAllOf
     */
    operator: RankingFilterBodyAllOfOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RankingFilterBodyAllOf
     */
    value: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RankingFilterBodyAllOfOperatorEnum {
    TOP = "TOP",
    BOTTOM = "BOTTOM",
}

/**
 *
 * @export
 * @interface RelativeDateFilter
 */
export interface RelativeDateFilter {
    /**
     *
     * @type {RelativeDateFilterBody}
     * @memberof RelativeDateFilter
     */
    relativeDateFilter: RelativeDateFilterBody;
}
/**
 *
 * @export
 * @interface RelativeDateFilterBody
 */
export interface RelativeDateFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof RelativeDateFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof RelativeDateFilterBody
     */
    dataset: AfmObjectIdentifier;
    /**
     * Date granularity specifying particular date attribute in given dimension.
     * @type {string}
     * @memberof RelativeDateFilterBody
     */
    granularity: RelativeDateFilterBodyGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     * @type {number}
     * @memberof RelativeDateFilterBody
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     * @type {number}
     * @memberof RelativeDateFilterBody
     */
    to: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RelativeDateFilterBodyGranularityEnum {
    MINUTE = "MINUTE",
    HOUR = "HOUR",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    QUARTER = "QUARTER",
    YEAR = "YEAR",
    MINUTEOFHOUR = "MINUTE_OF_HOUR",
    HOUROFDAY = "HOUR_OF_DAY",
    DAYOFWEEK = "DAY_OF_WEEK",
    DAYOFMONTH = "DAY_OF_MONTH",
    DAYOFYEAR = "DAY_OF_YEAR",
    WEEKOFYEAR = "WEEK_OF_YEAR",
    MONTHOFYEAR = "MONTH_OF_YEAR",
    QUARTEROFYEAR = "QUARTER_OF_YEAR",
}

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension.
 * @export
 * @interface RelativeDateFilterBodyAllOf
 */
export interface RelativeDateFilterBodyAllOf {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     * @type {string}
     * @memberof RelativeDateFilterBodyAllOf
     */
    granularity: RelativeDateFilterBodyAllOfGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     * @type {number}
     * @memberof RelativeDateFilterBodyAllOf
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     * @type {number}
     * @memberof RelativeDateFilterBodyAllOf
     */
    to: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RelativeDateFilterBodyAllOfGranularityEnum {
    MINUTE = "MINUTE",
    HOUR = "HOUR",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    QUARTER = "QUARTER",
    YEAR = "YEAR",
    MINUTEOFHOUR = "MINUTE_OF_HOUR",
    HOUROFDAY = "HOUR_OF_DAY",
    DAYOFWEEK = "DAY_OF_WEEK",
    DAYOFMONTH = "DAY_OF_MONTH",
    DAYOFYEAR = "DAY_OF_YEAR",
    WEEKOFYEAR = "WEEK_OF_YEAR",
    MONTHOFYEAR = "MONTH_OF_YEAR",
    QUARTEROFYEAR = "QUARTER_OF_YEAR",
}

/**
 *
 * @export
 * @interface ResultDimension
 */
export interface ResultDimension {
    /**
     *
     * @type {Array<MeasureGroupHeader | AttributeHeader>}
     * @memberof ResultDimension
     */
    headers: Array<MeasureGroupHeader | AttributeHeader>;
}
/**
 * Specifies how the result data will formatted (```dimensions```) and which additional data shall be computed (```grandTotals```).
 * @export
 * @interface ResultSpec
 */
export interface ResultSpec {
    /**
     *
     * @type {Array<Dimension>}
     * @memberof ResultSpec
     */
    dimensions: Array<Dimension>;
    /**
     *
     * @type {Array<GrandTotal>}
     * @memberof ResultSpec
     */
    grandTotals?: Array<GrandTotal>;
}
/**
 *
 * @export
 * @interface SimpleMeasureDefinition
 */
export interface SimpleMeasureDefinition {
    /**
     *
     * @type {SimpleMeasureDefinitionMeasure}
     * @memberof SimpleMeasureDefinition
     */
    measure: SimpleMeasureDefinitionMeasure;
}
/**
 *
 * @export
 * @interface SimpleMeasureDefinitionMeasure
 */
export interface SimpleMeasureDefinitionMeasure {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    item: AfmObjectIdentifier;
    /**
     * Definition of aggregation type of the measure.
     * @type {string}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    aggregation?: SimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true compute the percentage of given measure values (broken down by AFM attributes) to the total (not broken down).
     * @type {boolean}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    computeRatio?: boolean;
    /**
     * Measure can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     * @type {Array<FilterDefinitionForSimpleMeasure>}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    filters?: Array<FilterDefinitionForSimpleMeasure>;
}

/**
 * @export
 * @enum {string}
 */
export enum SimpleMeasureDefinitionMeasureAggregationEnum {
    SUM = "SUM",
    COUNT = "COUNT",
    APPROXIMATECOUNT = "APPROXIMATE_COUNT",
    AVG = "AVG",
    MIN = "MIN",
    MAX = "MAX",
    MEDIAN = "MEDIAN",
    RUNSUM = "RUNSUM",
}

/**
 * Sorting elements - ascending/descending order.
 * @export
 * @enum {string}
 */
export enum SortDirection {
    ASC = "ASC",
    DESC = "DESC",
}
/**
 * Sorting rule for sorting by attribute value in current dimension.
 * @export
 * @interface SortKeyAttribute
 */
export interface SortKeyAttribute {
    /**
     *
     * @type {SortKeyAttributeAttribute}
     * @memberof SortKeyAttribute
     */
    attribute: SortKeyAttributeAttribute;
}
/**
 *
 * @export
 * @interface SortKeyAttributeAttribute
 */
export interface SortKeyAttributeAttribute {
    /**
     *
     * @type {SortDirection}
     * @memberof SortKeyAttributeAttribute
     */
    direction?: SortDirection;
    /**
     * One of the \'Dimension.itemIdentifiers\' referencing the attribute which should be used for sorting the dimension.s
     * @type {string}
     * @memberof SortKeyAttributeAttribute
     */
    attributeIdentifier: string;
}
/**
 *
 * @export
 * @interface SortKeyValue
 */
export interface SortKeyValue {
    /**
     *
     * @type {SortKeyValueValue}
     * @memberof SortKeyValue
     */
    value: SortKeyValueValue;
}
/**
 *
 * @export
 * @interface SortKeyValueValue
 */
export interface SortKeyValueValue {
    /**
     *
     * @type {SortDirection}
     * @memberof SortKeyValueValue
     */
    direction?: SortDirection;
    /**
     * Mapping from dimensions to data column locators. Locators for each dimension opposite to the sorted one must be specified.
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof SortKeyValueValue
     */
    dataColumnLocators: { [key: string]: { [key: string]: string } };
}
/**
 * Sorting elements - ascending/descending order.
 * @export
 * @enum {string}
 */
export enum TotalFunction {
    SUM = "SUM",
    MIN = "MIN",
    MAX = "MAX",
    AVG = "AVG",
    MED = "MED",
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {Array<string>} [exactFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title exactly matches one of &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60;.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {number} [dataSamplingPercentage] Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElements(
            params: {
                workspaceId: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                complementFilter?: boolean;
                patternFilter?: string;
                exactFilter?: Array<string>;
                offset?: number;
                limit?: number;
                dataSamplingPercentage?: number;
                skipCache?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const {
                workspaceId,
                label,
                sortOrder,
                complementFilter,
                patternFilter,
                exactFilter,
                offset,
                limit,
                dataSamplingPercentage,
                skipCache,
            } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling computeLabelElements.",
                );
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError(
                    "label",
                    "Required parameter label was null or undefined when calling computeLabelElements.",
                );
            }
            const localVarPath =
                `/api/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (label !== undefined) {
                if (typeof label === "object") {
                    addFlattenedObjectTo(label, localVarQueryParameter);
                } else {
                    localVarQueryParameter["label"] = label;
                }
            }

            if (sortOrder !== undefined) {
                if (typeof sortOrder === "object") {
                    addFlattenedObjectTo(sortOrder, localVarQueryParameter);
                } else {
                    localVarQueryParameter["sortOrder"] = sortOrder;
                }
            }

            if (complementFilter !== undefined) {
                if (typeof complementFilter === "object") {
                    addFlattenedObjectTo(complementFilter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["complementFilter"] = complementFilter;
                }
            }

            if (patternFilter !== undefined) {
                if (typeof patternFilter === "object") {
                    addFlattenedObjectTo(patternFilter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["patternFilter"] = patternFilter;
                }
            }

            if (exactFilter) {
                localVarQueryParameter["exactFilter"] = exactFilter;
            }

            if (offset !== undefined) {
                if (typeof offset === "object") {
                    addFlattenedObjectTo(offset, localVarQueryParameter);
                } else {
                    localVarQueryParameter["offset"] = offset;
                }
            }

            if (limit !== undefined) {
                if (typeof limit === "object") {
                    addFlattenedObjectTo(limit, localVarQueryParameter);
                } else {
                    localVarQueryParameter["limit"] = limit;
                }
            }

            if (dataSamplingPercentage !== undefined) {
                if (typeof dataSamplingPercentage === "object") {
                    addFlattenedObjectTo(dataSamplingPercentage, localVarQueryParameter);
                } else {
                    localVarQueryParameter["dataSamplingPercentage"] = dataSamplingPercentage;
                }
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(
            params: {
                workspaceId: string;
                elementsRequest: ElementsRequest;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, elementsRequest, offset, limit, skipCache } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling computeLabelElementsPost.",
                );
            }
            // verify required parameter 'elementsRequest' is not null or undefined
            if (elementsRequest === null || elementsRequest === undefined) {
                throw new RequiredError(
                    "elementsRequest",
                    "Required parameter elementsRequest was null or undefined when calling computeLabelElementsPost.",
                );
            }
            const localVarPath =
                `/api/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                if (typeof offset === "object") {
                    addFlattenedObjectTo(offset, localVarQueryParameter);
                } else {
                    localVarQueryParameter["offset"] = offset;
                }
            }

            if (limit !== undefined) {
                if (typeof limit === "object") {
                    addFlattenedObjectTo(limit, localVarQueryParameter);
                } else {
                    localVarQueryParameter["limit"] = limit;
                }
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof elementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
                : elementsRequest || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, afmExecution, skipCache, timestamp } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling computeReport.",
                );
            }
            // verify required parameter 'afmExecution' is not null or undefined
            if (afmExecution === null || afmExecution === undefined) {
                throw new RequiredError(
                    "afmExecution",
                    "Required parameter afmExecution was null or undefined when calling computeReport.",
                );
            }
            const localVarPath = `/api/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            params: {
                workspaceId: string;
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, afmValidObjectsQuery } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling computeValidObjects.",
                );
            }
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            if (afmValidObjectsQuery === null || afmValidObjectsQuery === undefined) {
                throw new RequiredError(
                    "afmValidObjectsQuery",
                    "Required parameter afmValidObjectsQuery was null or undefined when calling computeValidObjects.",
                );
            }
            const localVarPath =
                `/api/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM), and logical and physical models (LDM and PDM) of corresponding workspace.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {string} [explainType] Requested explain type (LDM, PDM or MAQL). If not specified all types are bundled in a ZIP archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                explainType?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, afmExecution, explainType } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling explainAFM.",
                );
            }
            // verify required parameter 'afmExecution' is not null or undefined
            if (afmExecution === null || afmExecution === undefined) {
                throw new RequiredError(
                    "afmExecution",
                    "Required parameter afmExecution was null or undefined when calling explainAFM.",
                );
            }
            const localVarPath = `/api/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (explainType !== undefined) {
                if (typeof explainType === "object") {
                    addFlattenedObjectTo(explainType, localVarQueryParameter);
                } else {
                    localVarQueryParameter["explainType"] = explainType;
                }
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            params: {
                workspaceId: string;
                resultId: string;
                offset?: Array<number>;
                limit?: Array<number>;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, resultId, offset, limit } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling retrieveResult.",
                );
            }
            // verify required parameter 'resultId' is not null or undefined
            if (resultId === null || resultId === undefined) {
                throw new RequiredError(
                    "resultId",
                    "Required parameter resultId was null or undefined when calling retrieveResult.",
                );
            }
            const localVarPath =
                `/api/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }

            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {Array<string>} [exactFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title exactly matches one of &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60;.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {number} [dataSamplingPercentage] Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElements(
            params: {
                workspaceId: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                complementFilter?: boolean;
                patternFilter?: string;
                exactFilter?: Array<string>;
                offset?: number;
                limit?: number;
                dataSamplingPercentage?: number;
                skipCache?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse> {
            const localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).computeLabelElements(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(
            params: {
                workspaceId: string;
                elementsRequest: ElementsRequest;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse> {
            const localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).computeLabelElementsPost(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmExecutionResponse> {
            const localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).computeReport(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            params: {
                workspaceId: string;
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidObjectsResponse> {
            const localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).computeValidObjects(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM), and logical and physical models (LDM and PDM) of corresponding workspace.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {string} [explainType] Requested explain type (LDM, PDM or MAQL). If not specified all types are bundled in a ZIP archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                explainType?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any> {
            const localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).explainAFM(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            params: {
                workspaceId: string;
                resultId: string;
                offset?: Array<number>;
                limit?: Array<number>;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResult> {
            const localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).retrieveResult(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {Array<string>} [exactFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title exactly matches one of &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60;.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {number} [dataSamplingPercentage] Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElements(
            params: {
                workspaceId: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                complementFilter?: boolean;
                patternFilter?: string;
                exactFilter?: Array<string>;
                offset?: number;
                limit?: number;
                dataSamplingPercentage?: number;
                skipCache?: boolean;
            },
            options?: any,
        ): AxiosPromise<ElementsResponse> {
            return ActionsApiFp(configuration).computeLabelElements(params, options)(axios, basePath);
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(
            params: {
                workspaceId: string;
                elementsRequest: ElementsRequest;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options?: any,
        ): AxiosPromise<ElementsResponse> {
            return ActionsApiFp(configuration).computeLabelElementsPost(params, options)(axios, basePath);
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options?: any,
        ): AxiosPromise<AfmExecutionResponse> {
            return ActionsApiFp(configuration).computeReport(params, options)(axios, basePath);
        },
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            params: {
                workspaceId: string;
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options?: any,
        ): AxiosPromise<AfmValidObjectsResponse> {
            return ActionsApiFp(configuration).computeValidObjects(params, options)(axios, basePath);
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM), and logical and physical models (LDM and PDM) of corresponding workspace.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {string} [explainType] Requested explain type (LDM, PDM or MAQL). If not specified all types are bundled in a ZIP archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                explainType?: string;
            },
            options?: any,
        ): AxiosPromise<any> {
            return ActionsApiFp(configuration).explainAFM(params, options)(axios, basePath);
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            params: {
                workspaceId: string;
                resultId: string;
                offset?: Array<number>;
                limit?: Array<number>;
            },
            options?: any,
        ): AxiosPromise<ExecutionResult> {
            return ActionsApiFp(configuration).retrieveResult(params, options)(axios, basePath);
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values.
     * @param {string} workspaceId Workspace identifier
     * @param {string} label Requested label.
     * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
     * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60;
     * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
     * @param {Array<string>} [exactFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title exactly matches one of &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60;.
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {number} [dataSamplingPercentage] Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeLabelElements(
        params: {
            workspaceId: string;
            label: string;
            sortOrder?: "ASC" | "DESC";
            complementFilter?: boolean;
            patternFilter?: string;
            exactFilter?: Array<string>;
            offset?: number;
            limit?: number;
            dataSamplingPercentage?: number;
            skipCache?: boolean;
        },
        options?: any,
    ): AxiosPromise<ElementsResponse>;

    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values.
     * @param {string} workspaceId Workspace identifier
     * @param {ElementsRequest} elementsRequest
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeLabelElementsPost(
        params: {
            workspaceId: string;
            elementsRequest: ElementsRequest;
            offset?: number;
            limit?: number;
            skipCache?: boolean;
        },
        options?: any,
    ): AxiosPromise<ElementsResponse>;

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {string} workspaceId Workspace identifier
     * @param {AfmExecution} afmExecution
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {string} [timestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeReport(
        params: {
            workspaceId: string;
            afmExecution: AfmExecution;
            skipCache?: boolean;
            timestamp?: string;
        },
        options?: any,
    ): AxiosPromise<AfmExecutionResponse>;

    /**
     * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {string} workspaceId Workspace identifier
     * @param {AfmValidObjectsQuery} afmValidObjectsQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeValidObjects(
        params: {
            workspaceId: string;
            afmValidObjectsQuery: AfmValidObjectsQuery;
        },
        options?: any,
    ): AxiosPromise<AfmValidObjectsResponse>;

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM), and logical and physical models (LDM and PDM) of corresponding workspace.
     * @summary AFM explain resource.
     * @param {string} workspaceId Workspace identifier
     * @param {AfmExecution} afmExecution
     * @param {string} [explainType] Requested explain type (LDM, PDM or MAQL). If not specified all types are bundled in a ZIP archive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    explainAFM(
        params: {
            workspaceId: string;
            afmExecution: AfmExecution;
            explainType?: string;
        },
        options?: any,
    ): AxiosPromise<any>;

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {string} workspaceId Workspace identifier
     * @param {string} resultId Result ID
     * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    retrieveResult(
        params: {
            workspaceId: string;
            resultId: string;
            offset?: Array<number>;
            limit?: Array<number>;
        },
        options?: any,
    ): AxiosPromise<ExecutionResult>;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values.
     * @param {string} workspaceId Workspace identifier
     * @param {string} label Requested label.
     * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
     * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60;
     * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
     * @param {Array<string>} [exactFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title exactly matches one of &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60;.
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {number} [dataSamplingPercentage] Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeLabelElements(
        params: {
            workspaceId: string;
            label: string;
            sortOrder?: "ASC" | "DESC";
            complementFilter?: boolean;
            patternFilter?: string;
            exactFilter?: Array<string>;
            offset?: number;
            limit?: number;
            dataSamplingPercentage?: number;
            skipCache?: boolean;
        },
        options?: any,
    ) {
        return ActionsApiFp(this.configuration).computeLabelElements(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values.
     * @param {string} workspaceId Workspace identifier
     * @param {ElementsRequest} elementsRequest
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeLabelElementsPost(
        params: {
            workspaceId: string;
            elementsRequest: ElementsRequest;
            offset?: number;
            limit?: number;
            skipCache?: boolean;
        },
        options?: any,
    ) {
        return ActionsApiFp(this.configuration).computeLabelElementsPost(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {string} workspaceId Workspace identifier
     * @param {AfmExecution} afmExecution
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {string} [timestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeReport(
        params: {
            workspaceId: string;
            afmExecution: AfmExecution;
            skipCache?: boolean;
            timestamp?: string;
        },
        options?: any,
    ) {
        return ActionsApiFp(this.configuration).computeReport(params, options)(this.axios, this.basePath);
    }

    /**
     * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {string} workspaceId Workspace identifier
     * @param {AfmValidObjectsQuery} afmValidObjectsQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeValidObjects(
        params: {
            workspaceId: string;
            afmValidObjectsQuery: AfmValidObjectsQuery;
        },
        options?: any,
    ) {
        return ActionsApiFp(this.configuration).computeValidObjects(params, options)(
            this.axios,
            this.basePath,
        );
    }

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM), and logical and physical models (LDM and PDM) of corresponding workspace.
     * @summary AFM explain resource.
     * @param {string} workspaceId Workspace identifier
     * @param {AfmExecution} afmExecution
     * @param {string} [explainType] Requested explain type (LDM, PDM or MAQL). If not specified all types are bundled in a ZIP archive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public explainAFM(
        params: {
            workspaceId: string;
            afmExecution: AfmExecution;
            explainType?: string;
        },
        options?: any,
    ) {
        return ActionsApiFp(this.configuration).explainAFM(params, options)(this.axios, this.basePath);
    }

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {string} workspaceId Workspace identifier
     * @param {string} resultId Result ID
     * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public retrieveResult(
        params: {
            workspaceId: string;
            resultId: string;
            offset?: Array<number>;
            limit?: Array<number>;
        },
        options?: any,
    ) {
        return ActionsApiFp(this.configuration).retrieveResult(params, options)(this.axios, this.basePath);
    }
}
