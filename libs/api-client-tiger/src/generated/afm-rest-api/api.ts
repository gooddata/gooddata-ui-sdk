// (C) 2025 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 */
export interface AFM {
    /**
     * Attributes to be used in the computation.
     */
    attributes: Array<AttributeItem>;
    /**
     * Various filter types to filter the execution result.
     */
    filters: Array<FilterDefinition>;
    /**
     * Metrics to be computed.
     */
    measures: Array<MeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     */
    auxMeasures?: Array<MeasureItem>;
}
/**
 * A datetime filter specifying exact from and to values.
 */
export interface AbsoluteDateFilter {
    absoluteDateFilter: AbsoluteDateFilterAbsoluteDateFilter;
}
export interface AbsoluteDateFilterAbsoluteDateFilter {
    from: string;
    to: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
    dataset: AfmObjectIdentifierDataset;
}
/**
 * @type AbstractMeasureValueFilter
 */
export type AbstractMeasureValueFilter =
    | ComparisonMeasureValueFilter
    | RangeMeasureValueFilter
    | RankingFilter;

/**
 * Object, with which the user is actively working.
 */
export interface ActiveObjectIdentification {
    /**
     * Object ID.
     */
    id: string;
    /**
     * Object type, e.g. dashboard.
     */
    type: string;
    /**
     * Workspace ID.
     */
    workspaceId: string;
}
/**
 * Any information related to cancellation.
 */
export interface AfmCancelTokens {
    /**
     * resultId to cancel token pairs
     */
    resultIdToCancelTokenPairs: { [key: string]: string };
}
export interface AfmExecution {
    execution: AFM;
    resultSpec: ResultSpec;
    settings?: ExecutionSettings;
}
/**
 * Response to AFM execution request
 */
export interface AfmExecutionResponse {
    executionResponse: ExecutionResponse;
}
/**
 * @type AfmIdentifier
 * Reference to the attribute label to which the filter should be applied.
 */
export type AfmIdentifier = AfmLocalIdentifier | AfmObjectIdentifier;

export interface AfmLocalIdentifier {
    localIdentifier: string;
}
/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 */
export interface AfmObjectIdentifier {
    identifier: AfmObjectIdentifierIdentifier;
}
/**
 * Reference to the date attribute to use.
 */
export interface AfmObjectIdentifierAttribute {
    identifier: AfmObjectIdentifierAttributeIdentifier;
}
export interface AfmObjectIdentifierAttributeIdentifier {
    id: string;
    type: AfmObjectIdentifierAttributeIdentifierTypeEnum;
}

export const AfmObjectIdentifierAttributeIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
} as const;

export type AfmObjectIdentifierAttributeIdentifierTypeEnum =
    (typeof AfmObjectIdentifierAttributeIdentifierTypeEnum)[keyof typeof AfmObjectIdentifierAttributeIdentifierTypeEnum];

/**
 * Reference to the metric, fact or attribute object to use for the metric.
 */
export interface AfmObjectIdentifierCore {
    identifier: AfmObjectIdentifierCoreIdentifier;
}
export interface AfmObjectIdentifierCoreIdentifier {
    id: string;
    type: AfmObjectIdentifierCoreIdentifierTypeEnum;
}

export const AfmObjectIdentifierCoreIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
    LABEL: "label",
    FACT: "fact",
    METRIC: "metric",
} as const;

export type AfmObjectIdentifierCoreIdentifierTypeEnum =
    (typeof AfmObjectIdentifierCoreIdentifierTypeEnum)[keyof typeof AfmObjectIdentifierCoreIdentifierTypeEnum];

/**
 * Reference to the date dataset to which the filter should be applied.
 */
export interface AfmObjectIdentifierDataset {
    identifier: AfmObjectIdentifierDatasetIdentifier;
}
export interface AfmObjectIdentifierDatasetIdentifier {
    id: string;
    type: AfmObjectIdentifierDatasetIdentifierTypeEnum;
}

export const AfmObjectIdentifierDatasetIdentifierTypeEnum = {
    DATASET: "dataset",
} as const;

export type AfmObjectIdentifierDatasetIdentifierTypeEnum =
    (typeof AfmObjectIdentifierDatasetIdentifierTypeEnum)[keyof typeof AfmObjectIdentifierDatasetIdentifierTypeEnum];

export interface AfmObjectIdentifierIdentifier {
    type: AfmObjectIdentifierIdentifierTypeEnum;
    id: string;
}

export const AfmObjectIdentifierIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
} as const;

export type AfmObjectIdentifierIdentifierTypeEnum =
    (typeof AfmObjectIdentifierIdentifierTypeEnum)[keyof typeof AfmObjectIdentifierIdentifierTypeEnum];

export interface AfmObjectIdentifierLabel {
    identifier: AfmObjectIdentifierLabelIdentifier;
}
export interface AfmObjectIdentifierLabelIdentifier {
    type: AfmObjectIdentifierLabelIdentifierTypeEnum;
    id: string;
}

export const AfmObjectIdentifierLabelIdentifierTypeEnum = {
    LABEL: "label",
} as const;

export type AfmObjectIdentifierLabelIdentifierTypeEnum =
    (typeof AfmObjectIdentifierLabelIdentifierTypeEnum)[keyof typeof AfmObjectIdentifierLabelIdentifierTypeEnum];

/**
 * Entity describing the valid descendants request.
 */
export interface AfmValidDescendantsQuery {
    /**
     * List of identifiers of the attributes to get the valid descendants for.
     */
    attributes: Array<AfmObjectIdentifierAttribute>;
}
/**
 * Entity describing the valid descendants response.
 */
export interface AfmValidDescendantsResponse {
    /**
     * Map of attribute identifiers to list of valid descendants identifiers.
     */
    validDescendants: { [key: string]: Array<AfmObjectIdentifierAttribute> };
}
/**
 * Entity holding AFM and list of object types whose validity should be computed.
 */
export interface AfmValidObjectsQuery {
    types: Array<AfmValidObjectsQueryTypesEnum>;
    afm: AFM;
}

export const AfmValidObjectsQueryTypesEnum = {
    FACTS: "facts",
    ATTRIBUTES: "attributes",
    MEASURES: "measures",
} as const;

export type AfmValidObjectsQueryTypesEnum =
    (typeof AfmValidObjectsQueryTypesEnum)[keyof typeof AfmValidObjectsQueryTypesEnum];

/**
 * All objects of specified types valid with respect to given AFM.
 */
export interface AfmValidObjectsResponse {
    items: Array<RestApiIdentifier>;
}
export interface AnalyticsCatalogCreatedBy {
    /**
     * Users who created any object in the catalog
     */
    users: Array<AnalyticsCatalogUser>;
    /**
     * Reasoning for error states
     */
    reasoning: string;
}
export interface AnalyticsCatalogTags {
    tags: Array<string>;
}
/**
 * Users who created any object in the catalog
 */
export interface AnalyticsCatalogUser {
    /**
     * User ID of the user who created any objects
     */
    userId: string;
    /**
     * First name of the user who created any objects
     */
    firstname: string;
    /**
     * Last name of the user who created any objects
     */
    lastname: string;
}
export interface AnomalyDetectionRequest {
    /**
     * Anomaly detection sensitivity.
     */
    sensitivity: number;
}
export interface AnomalyDetectionResult {
    attribute: Array<string>;
    values: Array<number | null>;
    anomalyFlag: Array<boolean | null>;
}
/**
 * Metric representing arithmetics between other metrics.
 */
export interface ArithmeticMeasureDefinition {
    arithmeticMeasure: ArithmeticMeasureDefinitionArithmeticMeasure;
}
export interface ArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of metrics to apply arithmetic operation by chosen operator.
     */
    measureIdentifiers: Array<AfmLocalIdentifier>;
    /**
     * Arithmetic operator describing operation between metrics.
     */
    operator: ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

export const ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum = {
    SUM: "SUM",
    DIFFERENCE: "DIFFERENCE",
    MULTIPLICATION: "MULTIPLICATION",
    RATIO: "RATIO",
    CHANGE: "CHANGE",
} as const;

export type ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum =
    (typeof ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum)[keyof typeof ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum];

export interface AttributeExecutionResultHeader {
    attributeHeader: AttributeResultHeader;
}
/**
 * @type AttributeFilter
 * Abstract filter definition type attributes
 */
export type AttributeFilter = NegativeAttributeFilter | PositiveAttributeFilter;

/**
 * Filter on specific set of label values.
 */
export interface AttributeFilterElements {
    /**
     * Set of label values.
     */
    values: Array<string | null>;
}
/**
 * Attribute format describes formatting information to effectively format attribute values when needed.
 */
export interface AttributeFormat {
    /**
     * Format locale code like \'en-US\', \'cs-CZ\', etc.
     */
    locale: string;
    /**
     * ICU formatting pattern like \'y\', \'dd.MM.y\', etc.
     */
    pattern: string;
    /**
     * Timezone for date formatting like \'America/New_York\', \'Europe/Prague\', etc.
     */
    timezone?: string;
}
export interface AttributeHeader {
    attributeHeader: AttributeHeaderAttributeHeader;
}
export interface AttributeHeaderAttributeHeader {
    /**
     * Local identifier of the attribute this header relates to.
     */
    localIdentifier: string;
    label: RestApiIdentifier;
    /**
     * Label name.
     */
    labelName: string;
    attribute: RestApiIdentifier;
    /**
     * Attribute name.
     */
    attributeName: string;
    /**
     * Date granularity of the attribute, only filled for date attributes.
     */
    granularity?: AttributeHeaderAttributeHeaderGranularityEnum;
    primaryLabel: RestApiIdentifier;
    format?: AttributeFormat;
    /**
     * Attribute value type.
     */
    valueType?: AttributeHeaderAttributeHeaderValueTypeEnum;
}

export const AttributeHeaderAttributeHeaderGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_QUARTER: "DAY_OF_QUARTER",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type AttributeHeaderAttributeHeaderGranularityEnum =
    (typeof AttributeHeaderAttributeHeaderGranularityEnum)[keyof typeof AttributeHeaderAttributeHeaderGranularityEnum];
export const AttributeHeaderAttributeHeaderValueTypeEnum = {
    TEXT: "TEXT",
    HYPERLINK: "HYPERLINK",
    GEO: "GEO",
    GEO_LONGITUDE: "GEO_LONGITUDE",
    GEO_LATITUDE: "GEO_LATITUDE",
    IMAGE: "IMAGE",
} as const;

export type AttributeHeaderAttributeHeaderValueTypeEnum =
    (typeof AttributeHeaderAttributeHeaderValueTypeEnum)[keyof typeof AttributeHeaderAttributeHeaderValueTypeEnum];

export interface AttributeItem {
    /**
     * Local identifier of the attribute. This can be used to reference the attribute in other parts of the execution definition.
     */
    localIdentifier: string;
    label: AfmObjectIdentifierLabel;
    /**
     * Indicates whether to show all values of given attribute even if the data bound to those values is not available.
     */
    showAllValues?: boolean;
}
export interface AttributeNegativeFilter {
    using: string;
    exclude: Array<string>;
}
export interface AttributePositiveFilter {
    using: string;
    include: Array<string>;
}
/**
 * Header containing the information related to attributes.
 */
export interface AttributeResultHeader {
    /**
     * A value of the current attribute label.
     */
    labelValue: string;
    /**
     * A value of the primary attribute label.
     */
    primaryLabelValue: string;
}
/**
 * Bounding filter for this relative date filter. This can be used to limit the range of the relative date filter to a specific date range.
 */
export interface BoundedFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: BoundedFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\'). If null, then start of the range is unbounded.
     */
    from?: number | null;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...). If null, then end of the range is unbounded.
     */
    to?: number | null;
}

export const BoundedFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_QUARTER: "DAY_OF_QUARTER",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type BoundedFilterGranularityEnum =
    (typeof BoundedFilterGranularityEnum)[keyof typeof BoundedFilterGranularityEnum];

/**
 * List of chat history interactions.
 */
export interface ChatHistoryInteraction {
    /**
     * User question
     */
    question: string;
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     */
    threadIdSuffix?: string;
    /**
     * Chat History interaction ID. Unique ID for each interaction.
     */
    chatHistoryInteractionId: string;
    /**
     * Has the interaction already finished? Can be used for polling when interaction is in progress.
     */
    interactionFinished: boolean;
    routing: RouteResult;
    /**
     * Text response for general questions.
     */
    textResponse?: string;
    /**
     * Error response in anything fails.
     */
    errorResponse?: string;
    foundObjects?: FoundObjects;
    createdVisualizations?: CreatedVisualizations;
    /**
     * User feedback.
     */
    userFeedback?: ChatHistoryInteractionUserFeedbackEnum;
}

export const ChatHistoryInteractionUserFeedbackEnum = {
    POSITIVE: "POSITIVE",
    NEGATIVE: "NEGATIVE",
    NONE: "NONE",
} as const;

export type ChatHistoryInteractionUserFeedbackEnum =
    (typeof ChatHistoryInteractionUserFeedbackEnum)[keyof typeof ChatHistoryInteractionUserFeedbackEnum];

export interface ChatHistoryRequest {
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     */
    threadIdSuffix?: string;
    /**
     * Return chat history records only after this interaction ID. If empty, complete chat history is returned.
     */
    chatHistoryInteractionId?: string;
    /**
     * User feedback.
     */
    userFeedback?: ChatHistoryRequestUserFeedbackEnum;
    /**
     * User feedback.
     */
    reset?: boolean;
    savedVisualization?: SavedVisualization;
    /**
     * Response state indicating the outcome of the AI interaction.
     */
    responseState?: ChatHistoryRequestResponseStateEnum;
}

export const ChatHistoryRequestUserFeedbackEnum = {
    POSITIVE: "POSITIVE",
    NEGATIVE: "NEGATIVE",
    NONE: "NONE",
} as const;

export type ChatHistoryRequestUserFeedbackEnum =
    (typeof ChatHistoryRequestUserFeedbackEnum)[keyof typeof ChatHistoryRequestUserFeedbackEnum];
export const ChatHistoryRequestResponseStateEnum = {
    SUCCESSFUL: "SUCCESSFUL",
    UNEXPECTED_ERROR: "UNEXPECTED_ERROR",
    NOT_FOUND_ATTRIBUTES: "NOT_FOUND_ATTRIBUTES",
    TOO_MANY_DATA_POINTS: "TOO_MANY_DATA_POINTS",
    NO_DATA: "NO_DATA",
    NO_RESULTS: "NO_RESULTS",
    OUT_OF_TOPIC: "OUT_OF_TOPIC",
} as const;

export type ChatHistoryRequestResponseStateEnum =
    (typeof ChatHistoryRequestResponseStateEnum)[keyof typeof ChatHistoryRequestResponseStateEnum];

export interface ChatHistoryResult {
    /**
     * List of chat history interactions.
     */
    interactions: Array<ChatHistoryInteraction>;
    /**
     * The conversation thread ID.
     */
    threadId: string;
}
export interface ChatRequest {
    /**
     * User question
     */
    question: string;
    /**
     * Maximum number of search results.
     */
    limitSearch?: number;
    /**
     * Maximum number of relevant objects included into context for LLM (for each object type).
     */
    limitCreateContext?: number;
    /**
     * Maximum number of created results.
     */
    limitCreate?: number;
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     */
    threadIdSuffix?: string;
    userContext?: UserContext;
    /**
     * Temporary for experiments. Ratio of title score to descriptor score.
     */
    titleToDescriptorRatio?: number;
    /**
     * Score, above which we return found object(s) and don\'t call LLM to create new objects.
     */
    searchScoreThreshold?: number;
    /**
     * Score, above which we return found objects. Below this score objects are not relevant.
     */
    relevantScoreThreshold?: number;
    /**
     * If true, includes hidden objects in search and visualization building. If false (default), excludes objects where isHidden=true.
     */
    includeHidden?: boolean;
}
export interface ChatResult {
    routing?: RouteResult;
    /**
     * Text response for general questions.
     */
    textResponse?: string;
    /**
     * Error response in anything fails.
     */
    errorResponse?: string;
    foundObjects?: FoundObjects;
    createdVisualizations?: CreatedVisualizations;
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     */
    threadIdSuffix?: string;
    /**
     * Chat History interaction ID. Unique ID for each interaction.
     */
    chatHistoryInteractionId?: string;
}
export interface ChatUsageResponse {
    /**
     * Number of interactions in the time window
     */
    interactionCount: number;
    /**
     * Maximum number of interactions in the time window any user can do in the workspace
     */
    interactionLimit: number;
    /**
     * Time window in hours
     */
    timeWindowHours: number;
}
export interface ClusteringRequest {
    /**
     * Number of clusters to create
     */
    numberOfClusters: number;
    /**
     * Threshold used for algorithm
     */
    threshold?: number;
}
export interface ClusteringResult {
    attribute: Array<object>;
    xCoord?: Array<number | null>;
    yCoord?: Array<number | null>;
    clusters: Array<number | null>;
    xcoord: Array<number>;
    ycoord: Array<number>;
}
/**
 * Filter the result by comparing specified metric to given constant value, using given comparison operator.
 */
export interface ComparisonMeasureValueFilter {
    comparisonMeasureValueFilter: ComparisonMeasureValueFilterComparisonMeasureValueFilter;
}
export interface ComparisonMeasureValueFilterComparisonMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum;
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: AfmIdentifier;
}

export const ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum = {
    GREATER_THAN: "GREATER_THAN",
    GREATER_THAN_OR_EQUAL_TO: "GREATER_THAN_OR_EQUAL_TO",
    LESS_THAN: "LESS_THAN",
    LESS_THAN_OR_EQUAL_TO: "LESS_THAN_OR_EQUAL_TO",
    EQUAL_TO: "EQUAL_TO",
    NOT_EQUAL_TO: "NOT_EQUAL_TO",
} as const;

export type ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum =
    (typeof ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum)[keyof typeof ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum];

/**
 * List of created visualization objects
 */
export interface CreatedVisualization {
    /**
     * Proposed ID of the new visualization
     */
    id: string;
    /**
     * Proposed title of the new visualization
     */
    title: string;
    /**
     * Visualization type requested in question
     */
    visualizationType: CreatedVisualizationVisualizationTypeEnum;
    /**
     * List of metrics to be used in the new visualization
     */
    metrics: Array<Metric>;
    /**
     * List of attributes representing the dimensionality of the new visualization
     */
    dimensionality: Array<DimAttribute>;
    /**
     * List of filters to be applied to the new visualization
     */
    filters: Array<CreatedVisualizationFiltersInner>;
    /**
     * Suggestions for next steps
     */
    suggestions: Array<Suggestion>;
    /**
     * Saved visualization ID.
     */
    savedVisualizationId?: string;
}

export const CreatedVisualizationVisualizationTypeEnum = {
    TABLE: "TABLE",
    HEADLINE: "HEADLINE",
    BAR: "BAR",
    LINE: "LINE",
    PIE: "PIE",
    COLUMN: "COLUMN",
} as const;

export type CreatedVisualizationVisualizationTypeEnum =
    (typeof CreatedVisualizationVisualizationTypeEnum)[keyof typeof CreatedVisualizationVisualizationTypeEnum];

/**
 * @type CreatedVisualizationFiltersInner
 */
export type CreatedVisualizationFiltersInner =
    | AttributeNegativeFilter
    | AttributePositiveFilter
    | DateAbsoluteFilter
    | DateRelativeFilter
    | RankingFilter;

/**
 * Visualization definitions created by AI.
 */
export interface CreatedVisualizations {
    /**
     * List of created visualization objects
     */
    objects: Array<CreatedVisualization>;
    /**
     * Reasoning from LLM. Description of how and why the answer was generated.
     */
    reasoning: string;
    /**
     * List of suggestions for next steps. Filled when no visualization was created, suggests alternatives.
     */
    suggestions: Array<Suggestion>;
}
/**
 * Mapping from dimension items (either \'localIdentifier\' from \'AttributeItem\', or \"measureGroup\") to their respective values. This effectively specifies the path (location) of the data column used for sorting. Therefore values for all dimension items must be specified.
 */
export interface DataColumnLocator {
    /**
     * Mapping from dimension items (either \'localIdentifier\' from \'AttributeItem\', or \"measureGroup\") to their respective values. This effectively specifies the path (location) of the data column used for sorting. Therefore values for all dimension items must be specified.
     */
    properties: { [key: string]: string };
}
/**
 * Data column locators for the values.
 */
export interface DataColumnLocators {
    /**
     * Mapping from dimensions to data column locators.
     */
    properties?: { [key: string]: DataColumnLocator };
}
export interface DateAbsoluteFilter {
    using: string;
    from: string;
    to: string;
}
/**
 * @type DateFilter
 * Abstract filter definition type for dates.
 */
export type DateFilter = AbsoluteDateFilter | RelativeDateFilter;

export interface DateRelativeFilter {
    using: string;
    granularity: DateRelativeFilterGranularityEnum;
    from: number;
    to: number;
}

export const DateRelativeFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_QUARTER: "DAY_OF_QUARTER",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type DateRelativeFilterGranularityEnum =
    (typeof DateRelativeFilterGranularityEnum)[keyof typeof DateRelativeFilterGranularityEnum];

/**
 * Filter definition type specified by label and values.
 */
export interface DependsOn {
    /**
     * Specifies on which label the filter depends on.
     */
    label: string;
    /**
     * Specifies values of the label for element filtering.
     */
    values: Array<string | null>;
    /**
     * Inverse filtering mode.
     */
    complementFilter?: boolean;
}
/**
 * Filter definition type for dates.
 */
export interface DependsOnDateFilter {
    dateFilter: DateFilter;
}
/**
 * List of attributes representing the dimensionality of the new visualization
 */
export interface DimAttribute {
    /**
     * ID of the object
     */
    id: string;
    /**
     * Object type
     */
    type: DimAttributeTypeEnum;
    /**
     * Title of attribute.
     */
    title: string;
}

export const DimAttributeTypeEnum = {
    ATTRIBUTE: "attribute",
} as const;

export type DimAttributeTypeEnum = (typeof DimAttributeTypeEnum)[keyof typeof DimAttributeTypeEnum];

/**
 * Single dimension description.
 */
export interface Dimension {
    /**
     * Dimension identification within requests. Other entities can reference this dimension by this value.
     */
    localIdentifier?: string;
    /**
     * List of items in current dimension. Can reference \'localIdentifier\' from \'AttributeItem\', or special pseudo attribute \"measureGroup\" representing list of metrics.
     */
    itemIdentifiers: Array<string>;
    /**
     * List of sorting rules. From most relevant to least relevant (less relevant rule is applied, when more relevant rule compares items as equal).
     */
    sorting?: Array<SortKey>;
}
/**
 * Contains the dimension-specific header information.
 */
export interface DimensionHeader {
    /**
     * An array containing header groups.
     */
    headerGroups: Array<HeaderGroup>;
}
/**
 * List of returned elements.
 */
export interface Element {
    /**
     * Title of requested label.
     */
    title: string | null;
    /**
     * Title of primary label of attribute owning requested label, null if the title is null or the primary label is excluded
     */
    primaryTitle: string | null;
}
export interface ElementsRequest {
    /**
     * Requested label.
     */
    label: string;
    /**
     * Excludes items from the result that differ only by primary label * ```false``` - return items with distinct primary label * ```true``` - return items with distinct requested label
     */
    excludePrimaryLabel?: boolean;
    filterBy?: FilterBy;
    /**
     * Sort order of returned items. Items are sorted by ```label``` title. If no sort order is specified then attribute\'s ```sortDirection``` is used, which is ASC by default
     */
    sortOrder?: ElementsRequestSortOrderEnum;
    /**
     * Inverse filters: * ```false``` - return items matching ```patternFilter``` and ```exactFilter``` * ```true``` - return items not matching ```patternFilter``` and ```exactFilter```
     */
    complementFilter?: boolean;
    /**
     * Return only items, whose ```label``` title case insensitively contains ```filter``` as substring.
     */
    patternFilter?: string;
    /**
     * Return only items, whose ```label``` title exactly matches one of ```filter```.
     */
    exactFilter?: Array<string | null>;
    /**
     * Return only items that are not filtered-out by the parent filters.
     */
    dependsOn?: Array<ElementsRequestDependsOnInner>;
    /**
     * Return only items that are computable on metric.
     */
    validateBy?: Array<ValidateByItem>;
    /**
     * Specifies percentage of source table data scanned during the computation. This field is deprecated and is no longer used during the elements computation.
     * @deprecated
     */
    dataSamplingPercentage?: number;
    /**
     * If specified, the element data will be taken from the result with the same cacheId if it is available.
     */
    cacheId?: string;
}

export const ElementsRequestSortOrderEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type ElementsRequestSortOrderEnum =
    (typeof ElementsRequestSortOrderEnum)[keyof typeof ElementsRequestSortOrderEnum];

/**
 * @type ElementsRequestDependsOnInner
 */
export type ElementsRequestDependsOnInner = DependsOn | DependsOnDateFilter;

/**
 * Entity holding list of sorted & filtered label elements, related primary label of attribute owning requested label and paging.
 */
export interface ElementsResponse {
    primaryLabel: RestApiIdentifier;
    /**
     * List of returned elements.
     */
    elements: Array<Element>;
    paging: Paging;
    /**
     * Granularity of requested label in case of date attribute
     */
    granularity?: ElementsResponseGranularityEnum;
    format?: AttributeFormat;
    /**
     * The client can use this in subsequent requests (like paging or search) to get results from the same point in time as the previous request. This is useful when the underlying data source has caches disabled and the client wants to avoid seeing inconsistent results and to also avoid excessive queries to the database itself.
     */
    cacheId?: string;
}

export const ElementsResponseGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_QUARTER: "DAY_OF_QUARTER",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type ElementsResponseGranularityEnum =
    (typeof ElementsResponseGranularityEnum)[keyof typeof ElementsResponseGranularityEnum];

/**
 * Links to the execution result.
 */
export interface ExecutionLinks {
    /**
     * Link to the result data.
     */
    executionResult: string;
}
/**
 * Response to AFM execution request body
 */
export interface ExecutionResponse {
    /**
     * Dimensions of the result
     */
    dimensions: Array<ResultDimension>;
    links: ExecutionLinks;
}
/**
 * Contains the result of an AFM execution.
 */
export interface ExecutionResult {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     */
    data: Array<object>;
    /**
     * An array containing dimension headers. The size of the array corresponds to the number of dimensions. Their order corresponds to the dimension order in the execution result spec.
     */
    dimensionHeaders: Array<DimensionHeader>;
    grandTotals: Array<ExecutionResultGrandTotal>;
    paging: ExecutionResultPaging;
    metadata: ExecutionResultMetadata;
}
/**
 * A piece of extra information related to the results (e.g. debug information, warnings, etc.).
 */
export interface ExecutionResultDataSourceMessage {
    /**
     * Id correlating different pieces of supplementary info together.
     */
    correlationId: string;
    /**
     * Information about what part of the system created this piece of supplementary info.
     */
    source: string;
    /**
     * Type of the supplementary info instance. There are currently no well-known values for this, but there might be some in the future.
     */
    type: string;
    /**
     * Data of this particular supplementary info item: a free-form JSON specific to the particular supplementary info item type.
     */
    data?: object;
}
/**
 * Contains the data of grand totals with the same dimensions.
 */
export interface ExecutionResultGrandTotal {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     */
    data: Array<object>;
    /**
     * Contains headers for a subset of `totalDimensions` in which the totals are grand totals.
     */
    dimensionHeaders: Array<DimensionHeader>;
    /**
     * Dimensions of the grand totals.
     */
    totalDimensions: Array<string>;
}
/**
 * @type ExecutionResultHeader
 * Abstract execution result header
 */
export type ExecutionResultHeader =
    | AttributeExecutionResultHeader
    | MeasureExecutionResultHeader
    | TotalExecutionResultHeader;

/**
 * Additional metadata for the particular execution result.
 */
export interface ExecutionResultMetadata {
    /**
     * Additional information sent by the underlying data source.
     */
    dataSourceMessages: Array<ExecutionResultDataSourceMessage>;
}
/**
 * A paging information related to the data presented in the execution result. These paging information are multi-dimensional.
 */
export interface ExecutionResultPaging {
    /**
     * A count of the returned results in every dimension.
     */
    count: Array<number>;
    /**
     * The offset of the results returned in every dimension.
     */
    offset: Array<number>;
    /**
     * A total count of the results in every dimension.
     */
    total: Array<number>;
}
/**
 * Various settings affecting the process of AFM execution or its result
 */
export interface ExecutionSettings {
    /**
     * Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     */
    dataSamplingPercentage?: number;
    /**
     * Specifies the timestamp of the execution from which relative filters are resolved. If not set, the current time is used.
     */
    timestamp?: string;
}
/**
 * Specifies what is used for filtering.
 */
export interface FilterBy {
    /**
     * Specifies which label is used for filtering - primary or requested.
     */
    labelType?: FilterByLabelTypeEnum;
}

export const FilterByLabelTypeEnum = {
    PRIMARY: "PRIMARY",
    REQUESTED: "REQUESTED",
} as const;

export type FilterByLabelTypeEnum = (typeof FilterByLabelTypeEnum)[keyof typeof FilterByLabelTypeEnum];

/**
 * @type FilterDefinition
 * Abstract filter definition type
 */
export type FilterDefinition =
    | AbsoluteDateFilter
    | ComparisonMeasureValueFilter
    | InlineFilterDefinition
    | NegativeAttributeFilter
    | PositiveAttributeFilter
    | RangeMeasureValueFilter
    | RankingFilter
    | RelativeDateFilter;

/**
 * @type FilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple metric.
 */
export type FilterDefinitionForSimpleMeasure = AttributeFilter | DateFilter;

export interface ForecastRequest {
    /**
     * Number of future periods that should be forecasted
     */
    forecastPeriod: number;
    /**
     * Confidence interval boundary value.
     */
    confidenceLevel?: number;
    /**
     * Whether the input data is seasonal
     */
    seasonal?: boolean;
}
export interface ForecastResult {
    attribute: Array<string>;
    origin: Array<number | null>;
    prediction: Array<number | null>;
    lowerBound: Array<number | null>;
    upperBound: Array<number | null>;
}
/**
 * List of objects found by similarity search and post-processed by LLM.
 */
export interface FoundObjects {
    /**
     * List of objects found with a similarity search.
     */
    objects: Array<SearchResultObject>;
    /**
     * Reasoning from LLM. Description of how and why the answer was generated.
     */
    reasoning: string;
}
export interface GetQualityIssuesResponse {
    issues: Array<QualityIssue>;
}
/**
 * Contains the information specific for a group of headers. These groups correlate to attributes and metric groups.
 */
export interface HeaderGroup {
    /**
     * An array containing headers.
     */
    headers: Array<ExecutionResultHeader>;
}
/**
 * Filter in form of direct MAQL query.
 */
export interface InlineFilterDefinition {
    inline: InlineFilterDefinitionInline;
}
export interface InlineFilterDefinitionInline {
    /**
     * MAQL query representing the filter.
     */
    filter: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
}
/**
 * Metric defined by the raw MAQL query.
 */
export interface InlineMeasureDefinition {
    inline: InlineMeasureDefinitionInline;
}
export interface InlineMeasureDefinitionInline {
    /**
     * MAQL query defining the metric.
     */
    maql: string;
}
export interface KeyDriversDimension {
    label: RestApiIdentifier;
    labelName: string;
    attribute: RestApiIdentifier;
    attributeName: string;
    granularity?: KeyDriversDimensionGranularityEnum;
    format?: AttributeFormat;
    valueType?: KeyDriversDimensionValueTypeEnum;
}

export const KeyDriversDimensionGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_QUARTER: "DAY_OF_QUARTER",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type KeyDriversDimensionGranularityEnum =
    (typeof KeyDriversDimensionGranularityEnum)[keyof typeof KeyDriversDimensionGranularityEnum];
export const KeyDriversDimensionValueTypeEnum = {
    TEXT: "TEXT",
    HYPERLINK: "HYPERLINK",
    GEO: "GEO",
    GEO_LONGITUDE: "GEO_LONGITUDE",
    GEO_LATITUDE: "GEO_LATITUDE",
    IMAGE: "IMAGE",
} as const;

export type KeyDriversDimensionValueTypeEnum =
    (typeof KeyDriversDimensionValueTypeEnum)[keyof typeof KeyDriversDimensionValueTypeEnum];

export interface KeyDriversRequest {
    metric: MeasureItem;
    /**
     * Additional metrics to be included in the computation, but excluded from the analysis.
     */
    auxMetrics?: Array<MeasureItem>;
    /**
     * Sorting elements - ascending/descending order.
     */
    sortDirection?: KeyDriversRequestSortDirectionEnum;
}

export const KeyDriversRequestSortDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type KeyDriversRequestSortDirectionEnum =
    (typeof KeyDriversRequestSortDirectionEnum)[keyof typeof KeyDriversRequestSortDirectionEnum];

export interface KeyDriversResponse {
    dimensions: Array<KeyDriversDimension>;
    links: ExecutionLinks;
}
export interface KeyDriversResult {
    data: object;
}
/**
 * @type MeasureDefinition
 * Abstract metric definition type
 */
export type MeasureDefinition =
    | ArithmeticMeasureDefinition
    | InlineMeasureDefinition
    | PopMeasureDefinition
    | SimpleMeasureDefinition;

export interface MeasureExecutionResultHeader {
    measureHeader: MeasureResultHeader;
}
/**
 * Measure group headers
 */
export interface MeasureGroupHeaders {
    measureGroupHeaders?: Array<MeasureHeader>;
}
export interface MeasureHeader {
    /**
     * Local identifier of the measure this header relates to.
     */
    localIdentifier: string;
    /**
     * Format to be used to format the measure data.
     */
    format?: string;
    /**
     * Name of the measure.
     */
    name?: string;
}
/**
 * Metric is a quantity that is calculated from the data.
 */
export interface MeasureItem {
    /**
     * Local identifier of the metric. This can be used to reference the metric in other parts of the execution definition.
     */
    localIdentifier: string;
    definition: MeasureDefinition;
}
/**
 * Header containing the information related to metrics.
 */
export interface MeasureResultHeader {
    /**
     * Metric index. Starts at 0.
     */
    measureIndex: number;
}
/**
 * @type MeasureValueFilter
 * Abstract filter definition type filtering by the value of the metric.
 */
export type MeasureValueFilter = ComparisonMeasureValueFilter | RangeMeasureValueFilter;

export interface MemoryItem {
    /**
     * Memory item ID
     */
    id: string;
    useCases?: MemoryItemUseCases;
    /**
     * Defines the application strategy.
     */
    strategy?: MemoryItemStrategyEnum;
    /**
     * Instruction that will be injected into the prompt.
     */
    instruction: string;
    /**
     * List of keywords used to match the memory item.
     */
    keywords: Array<string>;
}

export const MemoryItemStrategyEnum = {
    MEMORY_ITEM_STRATEGY_ALLWAYS: "MEMORY_ITEM_STRATEGY_ALLWAYS",
    MEMORY_ITEM_STRATEGY_NEVER: "MEMORY_ITEM_STRATEGY_NEVER",
    MEMORY_ITEM_STRATEGY_AUTO: "MEMORY_ITEM_STRATEGY_AUTO",
} as const;

export type MemoryItemStrategyEnum = (typeof MemoryItemStrategyEnum)[keyof typeof MemoryItemStrategyEnum];

/**
 * Defines the prompts where the given instruction should be applied.
 */
export interface MemoryItemUseCases {
    /**
     * Appy this memory item to the router prompt.
     */
    router: boolean;
    /**
     * Apply this memory item to the search keyword extraction prompt.
     */
    keywords: boolean;
    /**
     * Apply this memory item to the search prompt.
     */
    search: boolean;
    /**
     * Apply this memory item to the visualization prompt.
     */
    visualization: boolean;
    /**
     * Apply this memory item to the general answer prompt.
     */
    general: boolean;
    /**
     * Apply this memory item to the how-to prompt.
     */
    howto: boolean;
    /**
     * Apply this memory item to the normalize prompt.
     */
    normalize: boolean;
    /**
     * Apply this memory item to the metric selection prompt.
     */
    metric: boolean;
}
/**
 * List of metrics to be used in the new visualization
 */
export interface Metric {
    /**
     * ID of the object
     */
    id: string;
    /**
     * Object type
     */
    type: MetricTypeEnum;
    /**
     * Title of metric.
     */
    title: string;
    /**
     * Agg function. Empty if a stored metric is used.
     */
    aggFunction?: MetricAggFunctionEnum;
}

export const MetricTypeEnum = {
    METRIC: "metric",
    FACT: "fact",
    ATTRIBUTE: "attribute",
} as const;

export type MetricTypeEnum = (typeof MetricTypeEnum)[keyof typeof MetricTypeEnum];
export const MetricAggFunctionEnum = {
    COUNT: "COUNT",
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    AVG: "AVG",
    MEDIAN: "MEDIAN",
} as const;

export type MetricAggFunctionEnum = (typeof MetricAggFunctionEnum)[keyof typeof MetricAggFunctionEnum];

/**
 * Filter able to limit element values by label and related selected negated elements.
 */
export interface NegativeAttributeFilter {
    negativeAttributeFilter: NegativeAttributeFilterNegativeAttributeFilter;
}
export interface NegativeAttributeFilterNegativeAttributeFilter {
    notIn: AttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: AfmIdentifier;
}
/**
 * Current page description.
 */
export interface Paging {
    /**
     * Count of returnable items ignoring paging.
     */
    total: number;
    /**
     * Count of items in this page.
     */
    count: number;
    /**
     * Offset of this page.
     */
    offset: number;
    /**
     * Link to next page, or null if this is last page.
     */
    next?: string;
}
/**
 * Combination of the date data set to use and how many periods ago to calculate the previous period for.
 */
export interface PopDataset {
    dataset: AfmObjectIdentifierDataset;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}
/**
 * Previous period type of metric.
 */
export interface PopDatasetMeasureDefinition {
    previousPeriodMeasure: PopDatasetMeasureDefinitionPreviousPeriodMeasure;
}
export interface PopDatasetMeasureDefinitionPreviousPeriodMeasure {
    measureIdentifier: AfmLocalIdentifier;
    /**
     * Specification of which date data sets to use for determining the period to calculate the previous period for.
     */
    dateDatasets: Array<PopDataset>;
}
/**
 * Combination of the date attribute to use and how many periods ago to calculate the PoP for.
 */
export interface PopDate {
    attribute: AfmObjectIdentifierAttribute;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}
/**
 * Period over period type of metric.
 */
export interface PopDateMeasureDefinition {
    overPeriodMeasure: PopDateMeasureDefinitionOverPeriodMeasure;
}
export interface PopDateMeasureDefinitionOverPeriodMeasure {
    measureIdentifier: AfmLocalIdentifier;
    /**
     * Attributes to use for determining the period to calculate the PoP for.
     */
    dateAttributes: Array<PopDate>;
}
/**
 * @type PopMeasureDefinition
 */
export type PopMeasureDefinition = PopDatasetMeasureDefinition | PopDateMeasureDefinition;

/**
 * Filter able to limit element values by label and related selected elements.
 */
export interface PositiveAttributeFilter {
    positiveAttributeFilter: PositiveAttributeFilterPositiveAttributeFilter;
}
export interface PositiveAttributeFilterPositiveAttributeFilter {
    in: AttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: AfmIdentifier;
}
export interface QualityIssue {
    objects: Array<QualityIssueObject>;
    severity: string;
    code: string;
    detail: { [key: string]: object };
}
export interface QualityIssueObject {
    type: string;
    id: string;
}
/**
 * Filter the result by comparing specified metric to given range of values.
 */
export interface RangeMeasureValueFilter {
    rangeMeasureValueFilter: RangeMeasureValueFilterRangeMeasureValueFilter;
}
export interface RangeMeasureValueFilterRangeMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum;
    from: number;
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: AfmIdentifier;
}

export const RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum = {
    BETWEEN: "BETWEEN",
    NOT_BETWEEN: "NOT_BETWEEN",
} as const;

export type RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum =
    (typeof RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum)[keyof typeof RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum];

/**
 * Filter the result on top/bottom N values according to given metric(s).
 */
export interface RankingFilter {
    rankingFilter: RankingFilterRankingFilter;
}
export interface RankingFilterRankingFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AfmIdentifier>;
    /**
     * References to the metrics to be used when filtering.
     */
    measures: Array<AfmIdentifier>;
    /**
     * The type of ranking to use, TOP or BOTTOM.
     */
    operator: RankingFilterRankingFilterOperatorEnum;
    /**
     * Number of top/bottom values to filter.
     */
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
}

export const RankingFilterRankingFilterOperatorEnum = {
    TOP: "TOP",
    BOTTOM: "BOTTOM",
} as const;

export type RankingFilterRankingFilterOperatorEnum =
    (typeof RankingFilterRankingFilterOperatorEnum)[keyof typeof RankingFilterRankingFilterOperatorEnum];

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension. The \'from\' and \'to\' properties mark the boundaries of the interval. If \'from\' is omitted, all values earlier than \'to\' are included. If \'to\' is omitted, all values later than \'from\' are included. It is not allowed to omit both.
 */
export interface RelativeDateFilter {
    relativeDateFilter: RelativeDateFilterRelativeDateFilter;
}
export interface RelativeDateFilterRelativeDateFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: RelativeDateFilterRelativeDateFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     */
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    boundedFilter?: BoundedFilter;
    dataset: AfmObjectIdentifierDataset;
}

export const RelativeDateFilterRelativeDateFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_QUARTER: "DAY_OF_QUARTER",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type RelativeDateFilterRelativeDateFilterGranularityEnum =
    (typeof RelativeDateFilterRelativeDateFilterGranularityEnum)[keyof typeof RelativeDateFilterRelativeDateFilterGranularityEnum];

export interface ResolvedLlmEndpoint {
    /**
     * Endpoint Id
     */
    id: string;
    /**
     * Endpoint Title
     */
    title: string;
}
export interface ResolvedLlmEndpoints {
    data: Array<ResolvedLlmEndpoint>;
}
/**
 * Object identifier.
 */
export interface RestApiIdentifier {
    id: string;
    type: string;
}
/**
 * All execution result\'s metadata used for calculation including ExecutionResponse
 */
export interface ResultCacheMetadata {
    afm: AFM;
    executionResponse: ExecutionResponse;
    resultSpec: ResultSpec;
    resultSize: number;
}
/**
 * Single result dimension
 */
export interface ResultDimension {
    headers: Array<ResultDimensionHeader>;
    /**
     * Local identifier of the dimension.
     */
    localIdentifier: string;
}
/**
 * @type ResultDimensionHeader
 * One of the headers in a result dimension.
 */
export type ResultDimensionHeader = AttributeHeader | MeasureGroupHeaders;

/**
 * Specifies how the result data will be formatted (```dimensions```) and which additional data shall be computed (```totals```).
 */
export interface ResultSpec {
    dimensions: Array<Dimension>;
    totals?: Array<Total>;
}
/**
 * Question -> Use Case routing. May contain final answer is a special use case is not required.
 */
export interface RouteResult {
    /**
     * Use case where LLM routed based on question.
     */
    useCase: RouteResultUseCaseEnum;
    /**
     * Explanation why LLM picked this use case.
     */
    reasoning: string;
}

export const RouteResultUseCaseEnum = {
    INVALID: "INVALID",
    GENERAL: "GENERAL",
    SEARCH: "SEARCH",
    CREATE_VISUALIZATION: "CREATE_VISUALIZATION",
    EXTEND_VISUALIZATION: "EXTEND_VISUALIZATION",
    HOWTO: "HOWTO",
} as const;

export type RouteResultUseCaseEnum = (typeof RouteResultUseCaseEnum)[keyof typeof RouteResultUseCaseEnum];

/**
 * Created and saved visualization IDs.
 */
export interface SavedVisualization {
    /**
     * Created visualization ID.
     */
    createdVisualizationId: string;
    /**
     * Saved visualization ID.
     */
    savedVisualizationId: string;
}
export interface SearchRelationshipObject {
    /**
     * Source workspace ID. If relationship is dashboard->visualization, this is the workspace where the dashboard is located.
     */
    sourceWorkspaceId: string;
    /**
     * Source object ID.
     */
    sourceObjectId: string;
    /**
     * Source object type, e.g. dashboard.
     */
    sourceObjectType: string;
    /**
     * Source object title.
     */
    sourceObjectTitle: string;
    /**
     * Target workspace ID. If relationship is dashboard->visualization, this is the workspace where the visualization is located.
     */
    targetWorkspaceId: string;
    /**
     * Target object ID.
     */
    targetObjectId: string;
    /**
     * Target object type, e.g. visualization.
     */
    targetObjectType: string;
    /**
     * Target object title.
     */
    targetObjectTitle: string;
}
export interface SearchRequest {
    /**
     * Keyword/sentence is input for search.
     */
    question: string;
    /**
     * List of object types to search for.
     */
    objectTypes?: Array<SearchRequestObjectTypesEnum>;
    /**
     * Turn on deep search. If true, content of complex objects will be searched as well, e.g. metrics in visualizations.
     */
    deepSearch?: boolean;
    /**
     * Maximum number of results to return. There is a hard limit and the actual number of returned results may be lower than what is requested.
     */
    limit?: number;
    /**
     * Temporary for experiments. Ratio of title score to descriptor score.
     */
    titleToDescriptorRatio?: number;
    /**
     * Score, above which we return found objects. Below this score objects are not relevant.
     */
    relevantScoreThreshold?: number;
    /**
     * If true, includes hidden objects in search results. If false (default), excludes objects where isHidden=true.
     */
    includeHidden?: boolean;
}

export const SearchRequestObjectTypesEnum = {
    ATTRIBUTE: "attribute",
    METRIC: "metric",
    FACT: "fact",
    LABEL: "label",
    DATE: "date",
    DATASET: "dataset",
    VISUALIZATION: "visualization",
    DASHBOARD: "dashboard",
} as const;

export type SearchRequestObjectTypesEnum =
    (typeof SearchRequestObjectTypesEnum)[keyof typeof SearchRequestObjectTypesEnum];

export interface SearchResult {
    results: Array<SearchResultObject>;
    relationships: Array<SearchRelationshipObject>;
    /**
     * If something is not working properly this field will contain explanation.
     */
    reasoning: string;
}
export interface SearchResultObject {
    /**
     * Object ID.
     */
    id: string;
    /**
     * Object type, e.g. dashboard.
     */
    type: string;
    /**
     * Workspace ID.
     */
    workspaceId: string;
    /**
     * Object title.
     */
    title: string;
    /**
     * Object description.
     */
    description?: string;
    tags?: Array<string>;
    /**
     * Timestamp when object was created.
     */
    createdAt?: string;
    /**
     * Timestamp when object was last modified.
     */
    modifiedAt?: string;
    /**
     * If the object is visualization, this field defines the type of visualization.
     */
    visualizationUrl?: string;
    /**
     * Result score calculated by a similarity search algorithm (cosine_distance).
     */
    score?: number;
    /**
     * Result score for object title.
     */
    scoreTitle?: number;
    /**
     * Result score for descriptor containing(now) description and tags.
     */
    scoreDescriptor?: number;
    /**
     * Result score for exact match(id/title). 1/1000. Other scores are multiplied by this.
     */
    scoreExactMatch?: number;
    /**
     * If true, this object is hidden from AI search results by default.
     */
    isHidden?: boolean;
}
/**
 * Metric defined by referencing a MAQL metric or an LDM fact object with aggregation.
 */
export interface SimpleMeasureDefinition {
    measure: SimpleMeasureDefinitionMeasure;
}
export interface SimpleMeasureDefinitionMeasure {
    item: AfmObjectIdentifierCore;
    /**
     * Definition of aggregation type of the metric.
     */
    aggregation?: SimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true, compute the percentage of given metric values (broken down by AFM attributes) to the total (not broken down).
     */
    computeRatio?: boolean;
    /**
     * Metrics can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     */
    filters?: Array<FilterDefinitionForSimpleMeasure>;
}

export const SimpleMeasureDefinitionMeasureAggregationEnum = {
    SUM: "SUM",
    COUNT: "COUNT",
    AVG: "AVG",
    MIN: "MIN",
    MAX: "MAX",
    MEDIAN: "MEDIAN",
    RUNSUM: "RUNSUM",
    APPROXIMATE_COUNT: "APPROXIMATE_COUNT",
} as const;

export type SimpleMeasureDefinitionMeasureAggregationEnum =
    (typeof SimpleMeasureDefinitionMeasureAggregationEnum)[keyof typeof SimpleMeasureDefinitionMeasureAggregationEnum];

export interface SmartFunctionResponse {
    links: ExecutionLinks;
}
/**
 * @type SortKey
 */
export type SortKey = SortKeyAttribute | SortKeyTotal | SortKeyValue;

/**
 * Sorting rule for sorting by attribute value in current dimension.
 */
export interface SortKeyAttribute {
    attribute: SortKeyAttributeAttribute;
}
export interface SortKeyAttributeAttribute {
    /**
     * Item reference (to \'itemIdentifiers\') referencing, which item should be used for sorting. Only references to attributes are allowed.
     */
    attributeIdentifier: string;
    /**
     * Mechanism by which this attribute should be sorted. Available options are: - DEFAULT: sorting based on default rules (using sort column if defined, otherwise this label)  - LABEL: sorting by this label values  - ATTRIBUTE: sorting by values of this label\'s attribute (or rather the primary label)  - ATTRIBUTE: sorting by values of this label\'s attribute (or rather the primary label)- AREA: sorting by area (total or subtotal) corresponding to each attribute value. The area is computed by summing up all metric values in all other dimensions.
     */
    sortType?: SortKeyAttributeAttributeSortTypeEnum;
    /**
     * Sorting elements - ascending/descending order.
     */
    direction?: SortKeyAttributeAttributeDirectionEnum;
}

export const SortKeyAttributeAttributeSortTypeEnum = {
    DEFAULT: "DEFAULT",
    LABEL: "LABEL",
    ATTRIBUTE: "ATTRIBUTE",
    AREA: "AREA",
} as const;

export type SortKeyAttributeAttributeSortTypeEnum =
    (typeof SortKeyAttributeAttributeSortTypeEnum)[keyof typeof SortKeyAttributeAttributeSortTypeEnum];
export const SortKeyAttributeAttributeDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type SortKeyAttributeAttributeDirectionEnum =
    (typeof SortKeyAttributeAttributeDirectionEnum)[keyof typeof SortKeyAttributeAttributeDirectionEnum];

/**
 * Sorting rule for sorting by total value. DataColumnLocators are only required if there is ambiguity. Locator for measureGroup is taken from the metric of the total.
 */
export interface SortKeyTotal {
    total: SortKeyTotalTotal;
}
export interface SortKeyTotalTotal {
    /**
     * Local identifier of the total to sort by.
     */
    totalIdentifier: string;
    dataColumnLocators?: DataColumnLocators;
    /**
     * Sorting elements - ascending/descending order.
     */
    direction?: SortKeyTotalTotalDirectionEnum;
}

export const SortKeyTotalTotalDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type SortKeyTotalTotalDirectionEnum =
    (typeof SortKeyTotalTotalDirectionEnum)[keyof typeof SortKeyTotalTotalDirectionEnum];

/**
 * Sorting rule for sorting by measure value. DataColumnLocators for each dimension opposite to the sorted one must be specified.
 */
export interface SortKeyValue {
    value: SortKeyValueValue;
}
export interface SortKeyValueValue {
    dataColumnLocators: DataColumnLocators;
    /**
     * Sorting elements - ascending/descending order.
     */
    direction?: SortKeyValueValueDirectionEnum;
}

export const SortKeyValueValueDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type SortKeyValueValueDirectionEnum =
    (typeof SortKeyValueValueDirectionEnum)[keyof typeof SortKeyValueValueDirectionEnum];

/**
 * List of suggestions for next steps. Filled when no visualization was created, suggests alternatives.
 */
export interface Suggestion {
    /**
     * Suggestion query
     */
    query: string;
    /**
     * Suggestion button label
     */
    label: string;
}
/**
 * Definition of a total. There are two types of totals: grand totals and subtotals. Grand total data will be returned in a separate section of the result structure while subtotals are fully integrated into the main result data. The mechanism for this distinction is automatic and it\'s described in `TotalDimension`
 */
export interface Total {
    /**
     * Total identification within this request. Used e.g. in sorting by a total.
     */
    localIdentifier: string;
    /**
     * Aggregation function to compute the total.
     */
    function: TotalFunctionEnum;
    /**
     * The metric for which the total will be computed
     */
    metric: string;
    totalDimensions: Array<TotalDimension>;
}

export const TotalFunctionEnum = {
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    AVG: "AVG",
    MED: "MED",
    NAT: "NAT",
} as const;

export type TotalFunctionEnum = (typeof TotalFunctionEnum)[keyof typeof TotalFunctionEnum];

/**
 * A list of dimensions across which the total will be computed. Total headers for only these dimensions will be returned in the result.
 */
export interface TotalDimension {
    /**
     * An identifier of a dimension for which the total will be computed.
     */
    dimensionIdentifier: string;
    /**
     * List of dimension items which will be used for total computation. The total is a grand total in this dimension if the list is empty or it includes the first dimension item from the dimension definition, and its data and header will be returned in a separate `ExecutionResultGrandTotal` structure. Otherwise, it is a subtotal and the data will be integrated into the main result.
     */
    totalDimensionItems: Array<string>;
}
export interface TotalExecutionResultHeader {
    totalHeader: TotalResultHeader;
}
/**
 * Header containing the information related to a subtotal.
 */
export interface TotalResultHeader {
    function: string;
}
/**
 * User context, which can affect the behavior of the underlying AI features.
 */
export interface UserContext {
    activeObject: ActiveObjectIdentification;
}
export interface ValidateByItem {
    /**
     * Specifies entity used for valid elements computation.
     */
    id: string;
    /**
     * Specifies entity type which could be label, attribute, fact, or metric.
     */
    type: string;
}
export interface ValidateLLMEndpointByIdRequest {
    /**
     * Provider for the LLM endpoint validation
     */
    provider?: string;
    /**
     * Base URL for the LLM endpoint validation
     */
    baseUrl?: string;
    /**
     * Token for the LLM endpoint validation
     */
    token?: string;
    /**
     * Organization name for the LLM endpoint validation
     */
    llmOrganization?: string;
    /**
     * LLM model for the LLM endpoint validation
     */
    llmModel?: string;
}
export interface ValidateLLMEndpointRequest {
    /**
     * Provider for the LLM endpoint validation
     */
    provider: string;
    /**
     * Base URL for the LLM endpoint validation
     */
    baseUrl?: string;
    /**
     * Token for the LLM endpoint validation
     */
    token: string;
    /**
     * Organization name for the LLM endpoint validation
     */
    llmOrganization?: string;
    /**
     * LLM model for the LLM endpoint validation
     */
    llmModel?: string;
}
export interface ValidateLLMEndpointResponse {
    /**
     * Whether the LLM endpoint validation was successful
     */
    successful: boolean;
    /**
     * Additional message about the LLM endpoint validation
     */
    message: string;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChat: async (
            workspaceId: string,
            chatRequest: ChatRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChat", "workspaceId", workspaceId);
            // verify required parameter 'chatRequest' is not null or undefined
            assertParamExists("aiChat", "chatRequest", chatRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chat`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
                : chatRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {string} workspaceId Workspace identifier
         * @param {ChatHistoryRequest} chatHistoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatHistory: async (
            workspaceId: string,
            chatHistoryRequest: ChatHistoryRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChatHistory", "workspaceId", workspaceId);
            // verify required parameter 'chatHistoryRequest' is not null or undefined
            assertParamExists("aiChatHistory", "chatHistoryRequest", chatHistoryRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatHistory`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatHistoryRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatHistoryRequest !== undefined ? chatHistoryRequest : {})
                : chatHistoryRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatStream: async (
            workspaceId: string,
            chatRequest: ChatRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChatStream", "workspaceId", workspaceId);
            // verify required parameter 'chatRequest' is not null or undefined
            assertParamExists("aiChatStream", "chatRequest", chatRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatStream`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
                : chatRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns usage statistics of chat for a user in a workspace.
         * @summary Get Chat Usage
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatUsage: async (workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChatUsage", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatUsage`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {string} workspaceId Workspace identifier
         * @param {SearchRequest} searchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiSearch: async (
            workspaceId: string,
            searchRequest: SearchRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiSearch", "workspaceId", workspaceId);
            // verify required parameter 'searchRequest' is not null or undefined
            assertParamExists("aiSearch", "searchRequest", searchRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/search`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof searchRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(searchRequest !== undefined ? searchRequest : {})
                : searchRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {AnomalyDetectionRequest} anomalyDetectionRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetection: async (
            workspaceId: string,
            resultId: string,
            anomalyDetectionRequest: AnomalyDetectionRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("anomalyDetection", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("anomalyDetection", "resultId", resultId);
            // verify required parameter 'anomalyDetectionRequest' is not null or undefined
            assertParamExists("anomalyDetection", "anomalyDetectionRequest", anomalyDetectionRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof anomalyDetectionRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(anomalyDetectionRequest !== undefined ? anomalyDetectionRequest : {})
                : anomalyDetectionRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetectionResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("anomalyDetectionResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("anomalyDetectionResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
         * @summary Applies all the given cancel tokens.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmCancelTokens} afmCancelTokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelExecutions: async (
            workspaceId: string,
            afmCancelTokens: AfmCancelTokens,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("cancelExecutions", "workspaceId", workspaceId);
            // verify required parameter 'afmCancelTokens' is not null or undefined
            assertParamExists("cancelExecutions", "afmCancelTokens", afmCancelTokens);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/cancel`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmCancelTokens !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmCancelTokens !== undefined ? afmCancelTokens : {})
                : afmCancelTokens || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ClusteringRequest} clusteringRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustering: async (
            workspaceId: string,
            resultId: string,
            clusteringRequest: ClusteringRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("clustering", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("clustering", "resultId", resultId);
            // verify required parameter 'clusteringRequest' is not null or undefined
            assertParamExists("clustering", "clusteringRequest", clusteringRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof clusteringRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(clusteringRequest !== undefined ? clusteringRequest : {})
                : clusteringRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusteringResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("clusteringResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("clusteringResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: async (
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeLabelElementsPost", "workspaceId", workspaceId);
            // verify required parameter 'elementsRequest' is not null or undefined
            assertParamExists("computeLabelElementsPost", "elementsRequest", elementsRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof elementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
                : elementsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeReport", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("computeReport", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants: async (
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidDescendants", "workspaceId", workspaceId);
            // verify required parameter 'afmValidDescendantsQuery' is not null or undefined
            assertParamExists(
                "computeValidDescendants",
                "afmValidDescendantsQuery",
                afmValidDescendantsQuery,
            );
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidDescendants`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidDescendantsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidDescendantsQuery !== undefined ? afmValidDescendantsQuery : {})
                : afmValidDescendantsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: async (
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidObjects", "workspaceId", workspaceId);
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            assertParamExists("computeValidObjects", "afmValidObjectsQuery", afmValidObjectsQuery);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Creates a new memory item and returns it
         * @summary (EXPERIMENTAL) Create new memory item
         * @param {string} workspaceId Workspace identifier
         * @param {MemoryItem} memoryItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemoryItem: async (
            workspaceId: string,
            memoryItem: MemoryItem,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createMemoryItem", "workspaceId", workspaceId);
            // verify required parameter 'memoryItem' is not null or undefined
            assertParamExists("createMemoryItem", "memoryItem", memoryItem);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof memoryItem !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(memoryItem !== undefined ? memoryItem : {})
                : memoryItem || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users who created any object for this workspace
         * @summary Get Analytics Catalog CreatedBy
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createdBy: async (workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createdBy", "workspaceId", workspaceId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/ai/analyticsCatalog/createdBy`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS' | 'COMPRESSED_SQL'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;COMPRESSED_GRPC_MODEL_SVG&#x60; - Generated SVG image of the model fragment used in the query  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;COMPRESSED_SQL&#x60; - Final SQL to be executed with rolled SQL datasets  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS"
                | "COMPRESSED_SQL",
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("explainAFM", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("explainAFM", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (explainType !== undefined) {
                localVarQueryParameter["explainType"] = explainType;
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast: async (
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecast", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecast", "resultId", resultId);
            // verify required parameter 'forecastRequest' is not null or undefined
            assertParamExists("forecast", "forecastRequest", forecastRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof forecastRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(forecastRequest !== undefined ? forecastRequest : {})
                : forecastRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecastResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecastResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Get memory item by id
         * @summary (EXPERIMENTAL) Get memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemoryItem: async (
            workspaceId: string,
            memoryId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getMemoryItem", "workspaceId", workspaceId);
            // verify required parameter 'memoryId' is not null or undefined
            assertParamExists("getMemoryItem", "memoryId", memoryId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory/{memoryId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"memoryId"}}`, encodeURIComponent(String(memoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata quality issues detected by the platform linter.
         * @summary Get Quality Issues
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQualityIssues: async (
            workspaceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getQualityIssues", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/issues`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {string} workspaceId Workspace identifier
         * @param {KeyDriversRequest} keyDriversRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysis: async (
            workspaceId: string,
            keyDriversRequest: KeyDriversRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("keyDriverAnalysis", "workspaceId", workspaceId);
            // verify required parameter 'keyDriversRequest' is not null or undefined
            assertParamExists("keyDriverAnalysis", "keyDriversRequest", keyDriversRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof keyDriversRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(keyDriversRequest !== undefined ? keyDriversRequest : {})
                : keyDriversRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysisResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("keyDriverAnalysisResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("keyDriverAnalysisResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Returns a list of memory items
         * @summary (EXPERIMENTAL) List all memory items
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemoryItems: async (
            workspaceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("listMemoryItems", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Removes memory item
         * @summary (EXPERIMENTAL) Remove memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemoryItem: async (
            workspaceId: string,
            memoryId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("removeMemoryItem", "workspaceId", workspaceId);
            // verify required parameter 'memoryId' is not null or undefined
            assertParamExists("removeMemoryItem", "memoryId", memoryId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory/{memoryId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"memoryId"}}`, encodeURIComponent(String(memoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of available LLM Endpoints
         * @summary Get Active LLM Endpoints for this workspace
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveLlmEndpoints: async (
            workspaceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("resolveLlmEndpoints", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/resolveLlmEndpoints`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata: async (
            workspaceId: string,
            resultId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}/metadata`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {string} [xGDCCANCELTOKEN]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: async (
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            xGDCCANCELTOKEN?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }

            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }

            if (excludedTotalDimensions) {
                localVarQueryParameter["excludedTotalDimensions"] = excludedTotalDimensions.join(
                    COLLECTION_FORMATS.csv,
                );
            }

            if (xGDCCANCELTOKEN !== undefined && xGDCCANCELTOKEN !== null) {
                localVarHeaderParameter["X-GDC-CANCEL-TOKEN"] = String(xGDCCANCELTOKEN);
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of tags for this workspace
         * @summary Get Analytics Catalog Tags
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tags: async (workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("tags", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/analyticsCatalog/tags`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Updates memory item and returns it
         * @summary (EXPERIMENTAL) Update memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {MemoryItem} memoryItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemoryItem: async (
            workspaceId: string,
            memoryId: string,
            memoryItem: MemoryItem,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateMemoryItem", "workspaceId", workspaceId);
            // verify required parameter 'memoryId' is not null or undefined
            assertParamExists("updateMemoryItem", "memoryId", memoryId);
            // verify required parameter 'memoryItem' is not null or undefined
            assertParamExists("updateMemoryItem", "memoryItem", memoryItem);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory/{memoryId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"memoryId"}}`, encodeURIComponent(String(memoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof memoryItem !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(memoryItem !== undefined ? memoryItem : {})
                : memoryItem || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates LLM endpoint with provided parameters.
         * @summary Validate LLM Endpoint
         * @param {ValidateLLMEndpointRequest} validateLLMEndpointRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLLMEndpoint: async (
            validateLLMEndpointRequest: ValidateLLMEndpointRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'validateLLMEndpointRequest' is not null or undefined
            assertParamExists(
                "validateLLMEndpoint",
                "validateLLMEndpointRequest",
                validateLLMEndpointRequest,
            );
            const localVarPath = `/api/v1/actions/ai/llmEndpoint/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof validateLLMEndpointRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(validateLLMEndpointRequest !== undefined ? validateLLMEndpointRequest : {})
                : validateLLMEndpointRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
         * @summary Validate LLM Endpoint By Id
         * @param {string} llmEndpointId
         * @param {ValidateLLMEndpointByIdRequest} [validateLLMEndpointByIdRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLLMEndpointById: async (
            llmEndpointId: string,
            validateLLMEndpointByIdRequest?: ValidateLLMEndpointByIdRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'llmEndpointId' is not null or undefined
            assertParamExists("validateLLMEndpointById", "llmEndpointId", llmEndpointId);
            const localVarPath = `/api/v1/actions/ai/llmEndpoint/{llmEndpointId}/test`.replace(
                `{${"llmEndpointId"}}`,
                encodeURIComponent(String(llmEndpointId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof validateLLMEndpointByIdRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      validateLLMEndpointByIdRequest !== undefined ? validateLLMEndpointByIdRequest : {},
                  )
                : validateLLMEndpointByIdRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChat(
            workspaceId: string,
            chatRequest: ChatRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChat(
                workspaceId,
                chatRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {string} workspaceId Workspace identifier
         * @param {ChatHistoryRequest} chatHistoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatHistory(
            workspaceId: string,
            chatHistoryRequest: ChatHistoryRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatHistoryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatHistory(
                workspaceId,
                chatHistoryRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatStream(
            workspaceId: string,
            chatRequest: ChatRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatStream(
                workspaceId,
                chatRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns usage statistics of chat for a user in a workspace.
         * @summary Get Chat Usage
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatUsage(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatUsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatUsage(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {string} workspaceId Workspace identifier
         * @param {SearchRequest} searchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiSearch(
            workspaceId: string,
            searchRequest: SearchRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiSearch(
                workspaceId,
                searchRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {AnomalyDetectionRequest} anomalyDetectionRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async anomalyDetection(
            workspaceId: string,
            resultId: string,
            anomalyDetectionRequest: AnomalyDetectionRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.anomalyDetection(
                workspaceId,
                resultId,
                anomalyDetectionRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async anomalyDetectionResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnomalyDetectionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.anomalyDetectionResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
         * @summary Applies all the given cancel tokens.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmCancelTokens} afmCancelTokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelExecutions(
            workspaceId: string,
            afmCancelTokens: AfmCancelTokens,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmCancelTokens>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelExecutions(
                workspaceId,
                afmCancelTokens,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ClusteringRequest} clusteringRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clustering(
            workspaceId: string,
            resultId: string,
            clusteringRequest: ClusteringRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clustering(
                workspaceId,
                resultId,
                clusteringRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusteringResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusteringResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusteringResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeLabelElementsPost(
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeLabelElementsPost(
                workspaceId,
                elementsRequest,
                offset,
                limit,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeReport(
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmExecutionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeReport(
                workspaceId,
                afmExecution,
                skipCache,
                timestamp,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidDescendants(
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidDescendantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidDescendants(
                workspaceId,
                afmValidDescendantsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidObjects(
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidObjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidObjects(
                workspaceId,
                afmValidObjectsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Creates a new memory item and returns it
         * @summary (EXPERIMENTAL) Create new memory item
         * @param {string} workspaceId Workspace identifier
         * @param {MemoryItem} memoryItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMemoryItem(
            workspaceId: string,
            memoryItem: MemoryItem,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMemoryItem(
                workspaceId,
                memoryItem,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users who created any object for this workspace
         * @summary Get Analytics Catalog CreatedBy
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createdBy(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyticsCatalogCreatedBy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createdBy(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS' | 'COMPRESSED_SQL'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;COMPRESSED_GRPC_MODEL_SVG&#x60; - Generated SVG image of the model fragment used in the query  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;COMPRESSED_SQL&#x60; - Final SQL to be executed with rolled SQL datasets  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explainAFM(
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS"
                | "COMPRESSED_SQL",
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explainAFM(
                workspaceId,
                afmExecution,
                explainType,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecast(
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecast(
                workspaceId,
                resultId,
                forecastRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecastResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForecastResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecastResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Get memory item by id
         * @summary (EXPERIMENTAL) Get memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemoryItem(
            workspaceId: string,
            memoryId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemoryItem(
                workspaceId,
                memoryId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns metadata quality issues detected by the platform linter.
         * @summary Get Quality Issues
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQualityIssues(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetQualityIssuesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQualityIssues(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {string} workspaceId Workspace identifier
         * @param {KeyDriversRequest} keyDriversRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyDriverAnalysis(
            workspaceId: string,
            keyDriversRequest: KeyDriversRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDriversResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyDriverAnalysis(
                workspaceId,
                keyDriversRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyDriverAnalysisResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDriversResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyDriverAnalysisResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Returns a list of memory items
         * @summary (EXPERIMENTAL) List all memory items
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMemoryItems(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemoryItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMemoryItems(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Removes memory item
         * @summary (EXPERIMENTAL) Remove memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMemoryItem(
            workspaceId: string,
            memoryId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeMemoryItem(
                workspaceId,
                memoryId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of available LLM Endpoints
         * @summary Get Active LLM Endpoints for this workspace
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveLlmEndpoints(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolvedLlmEndpoints>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveLlmEndpoints(
                workspaceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveExecutionMetadata(
            workspaceId: string,
            resultId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultCacheMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveExecutionMetadata(
                workspaceId,
                resultId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {string} [xGDCCANCELTOKEN]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveResult(
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            xGDCCANCELTOKEN?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveResult(
                workspaceId,
                resultId,
                offset,
                limit,
                excludedTotalDimensions,
                xGDCCANCELTOKEN,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of tags for this workspace
         * @summary Get Analytics Catalog Tags
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tags(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyticsCatalogTags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tags(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Updates memory item and returns it
         * @summary (EXPERIMENTAL) Update memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {MemoryItem} memoryItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMemoryItem(
            workspaceId: string,
            memoryId: string,
            memoryItem: MemoryItem,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMemoryItem(
                workspaceId,
                memoryId,
                memoryItem,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates LLM endpoint with provided parameters.
         * @summary Validate LLM Endpoint
         * @param {ValidateLLMEndpointRequest} validateLLMEndpointRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateLLMEndpoint(
            validateLLMEndpointRequest: ValidateLLMEndpointRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateLLMEndpointResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateLLMEndpoint(
                validateLLMEndpointRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
         * @summary Validate LLM Endpoint By Id
         * @param {string} llmEndpointId
         * @param {ValidateLLMEndpointByIdRequest} [validateLLMEndpointByIdRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateLLMEndpointById(
            llmEndpointId: string,
            validateLLMEndpointByIdRequest?: ValidateLLMEndpointByIdRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateLLMEndpointResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateLLMEndpointById(
                llmEndpointId,
                validateLLMEndpointByIdRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {ActionsApiAiChatRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChat(
            requestParameters: ActionsApiAiChatRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ChatResult> {
            return localVarFp
                .aiChat(requestParameters.workspaceId, requestParameters.chatRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {ActionsApiAiChatHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatHistory(
            requestParameters: ActionsApiAiChatHistoryRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ChatHistoryResult> {
            return localVarFp
                .aiChatHistory(requestParameters.workspaceId, requestParameters.chatHistoryRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {ActionsApiAiChatStreamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatStream(
            requestParameters: ActionsApiAiChatStreamRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<object>> {
            return localVarFp
                .aiChatStream(requestParameters.workspaceId, requestParameters.chatRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns usage statistics of chat for a user in a workspace.
         * @summary Get Chat Usage
         * @param {ActionsApiAiChatUsageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatUsage(
            requestParameters: ActionsApiAiChatUsageRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ChatUsageResponse> {
            return localVarFp
                .aiChatUsage(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {ActionsApiAiSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiSearch(
            requestParameters: ActionsApiAiSearchRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SearchResult> {
            return localVarFp
                .aiSearch(requestParameters.workspaceId, requestParameters.searchRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {ActionsApiAnomalyDetectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetection(
            requestParameters: ActionsApiAnomalyDetectionRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .anomalyDetection(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.anomalyDetectionRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {ActionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetectionResult(
            requestParameters: ActionsApiAnomalyDetectionResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AnomalyDetectionResult> {
            return localVarFp
                .anomalyDetectionResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
         * @summary Applies all the given cancel tokens.
         * @param {ActionsApiCancelExecutionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelExecutions(
            requestParameters: ActionsApiCancelExecutionsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmCancelTokens> {
            return localVarFp
                .cancelExecutions(requestParameters.workspaceId, requestParameters.afmCancelTokens, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {ActionsApiClusteringRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustering(
            requestParameters: ActionsApiClusteringRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .clustering(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.clusteringRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {ActionsApiClusteringResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusteringResult(
            requestParameters: ActionsApiClusteringResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ClusteringResult> {
            return localVarFp
                .clusteringResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(
            requestParameters: ActionsApiComputeLabelElementsPostRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ElementsResponse> {
            return localVarFp
                .computeLabelElementsPost(
                    requestParameters.workspaceId,
                    requestParameters.elementsRequest,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            requestParameters: ActionsApiComputeReportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmExecutionResponse> {
            return localVarFp
                .computeReport(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.skipCache,
                    requestParameters.timestamp,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants(
            requestParameters: ActionsApiComputeValidDescendantsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidDescendantsResponse> {
            return localVarFp
                .computeValidDescendants(
                    requestParameters.workspaceId,
                    requestParameters.afmValidDescendantsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            requestParameters: ActionsApiComputeValidObjectsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidObjectsResponse> {
            return localVarFp
                .computeValidObjects(
                    requestParameters.workspaceId,
                    requestParameters.afmValidObjectsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Creates a new memory item and returns it
         * @summary (EXPERIMENTAL) Create new memory item
         * @param {ActionsApiCreateMemoryItemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemoryItem(
            requestParameters: ActionsApiCreateMemoryItemRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<MemoryItem> {
            return localVarFp
                .createMemoryItem(requestParameters.workspaceId, requestParameters.memoryItem, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users who created any object for this workspace
         * @summary Get Analytics Catalog CreatedBy
         * @param {ActionsApiCreatedByRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createdBy(
            requestParameters: ActionsApiCreatedByRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AnalyticsCatalogCreatedBy> {
            return localVarFp
                .createdBy(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(
            requestParameters: ActionsApiExplainAFMRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .explainAFM(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.explainType,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {ActionsApiForecastRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast(
            requestParameters: ActionsApiForecastRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .forecast(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.forecastRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult(
            requestParameters: ActionsApiForecastResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ForecastResult> {
            return localVarFp
                .forecastResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Get memory item by id
         * @summary (EXPERIMENTAL) Get memory item
         * @param {ActionsApiGetMemoryItemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemoryItem(
            requestParameters: ActionsApiGetMemoryItemRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<MemoryItem> {
            return localVarFp
                .getMemoryItem(requestParameters.workspaceId, requestParameters.memoryId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata quality issues detected by the platform linter.
         * @summary Get Quality Issues
         * @param {ActionsApiGetQualityIssuesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQualityIssues(
            requestParameters: ActionsApiGetQualityIssuesRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<GetQualityIssuesResponse> {
            return localVarFp
                .getQualityIssues(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {ActionsApiKeyDriverAnalysisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysis(
            requestParameters: ActionsApiKeyDriverAnalysisRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<KeyDriversResponse> {
            return localVarFp
                .keyDriverAnalysis(
                    requestParameters.workspaceId,
                    requestParameters.keyDriversRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {ActionsApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysisResult(
            requestParameters: ActionsApiKeyDriverAnalysisResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<KeyDriversResult> {
            return localVarFp
                .keyDriverAnalysisResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Returns a list of memory items
         * @summary (EXPERIMENTAL) List all memory items
         * @param {ActionsApiListMemoryItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemoryItems(
            requestParameters: ActionsApiListMemoryItemsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<MemoryItem>> {
            return localVarFp
                .listMemoryItems(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Removes memory item
         * @summary (EXPERIMENTAL) Remove memory item
         * @param {ActionsApiRemoveMemoryItemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemoryItem(
            requestParameters: ActionsApiRemoveMemoryItemRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .removeMemoryItem(requestParameters.workspaceId, requestParameters.memoryId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of available LLM Endpoints
         * @summary Get Active LLM Endpoints for this workspace
         * @param {ActionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveLlmEndpoints(
            requestParameters: ActionsApiResolveLlmEndpointsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ResolvedLlmEndpoints> {
            return localVarFp
                .resolveLlmEndpoints(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata(
            requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ResultCacheMetadata> {
            return localVarFp
                .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            requestParameters: ActionsApiRetrieveResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExecutionResult> {
            return localVarFp
                .retrieveResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.excludedTotalDimensions,
                    requestParameters.xGDCCANCELTOKEN,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of tags for this workspace
         * @summary Get Analytics Catalog Tags
         * @param {ActionsApiTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tags(
            requestParameters: ActionsApiTagsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AnalyticsCatalogTags> {
            return localVarFp
                .tags(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Updates memory item and returns it
         * @summary (EXPERIMENTAL) Update memory item
         * @param {ActionsApiUpdateMemoryItemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemoryItem(
            requestParameters: ActionsApiUpdateMemoryItemRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<MemoryItem> {
            return localVarFp
                .updateMemoryItem(
                    requestParameters.workspaceId,
                    requestParameters.memoryId,
                    requestParameters.memoryItem,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Validates LLM endpoint with provided parameters.
         * @summary Validate LLM Endpoint
         * @param {ActionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLLMEndpoint(
            requestParameters: ActionsApiValidateLLMEndpointRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ValidateLLMEndpointResponse> {
            return localVarFp
                .validateLLMEndpoint(requestParameters.validateLLMEndpointRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
         * @summary Validate LLM Endpoint By Id
         * @param {ActionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLLMEndpointById(
            requestParameters: ActionsApiValidateLLMEndpointByIdRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ValidateLLMEndpointResponse> {
            return localVarFp
                .validateLLMEndpointById(
                    requestParameters.llmEndpointId,
                    requestParameters.validateLLMEndpointByIdRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiChat(
        requestParameters: ActionsApiAiChatRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatResult>;

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {ActionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiChatHistory(
        requestParameters: ActionsApiAiChatHistoryRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatHistoryResult>;

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiChatStream(
        requestParameters: ActionsApiAiChatStreamRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<object>>;

    /**
     * Returns usage statistics of chat for a user in a workspace.
     * @summary Get Chat Usage
     * @param {ActionsApiAiChatUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiChatUsage(
        requestParameters: ActionsApiAiChatUsageRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatUsageResponse>;

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {ActionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiSearch(
        requestParameters: ActionsApiAiSearchRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SearchResult>;

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {ActionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    anomalyDetection(
        requestParameters: ActionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {ActionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    anomalyDetectionResult(
        requestParameters: ActionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnomalyDetectionResult>;

    /**
     * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
     * @summary Applies all the given cancel tokens.
     * @param {ActionsApiCancelExecutionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    cancelExecutions(
        requestParameters: ActionsApiCancelExecutionsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmCancelTokens>;

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {ActionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    clustering(
        requestParameters: ActionsApiClusteringRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {ActionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    clusteringResult(
        requestParameters: ActionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ClusteringResult>;

    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeLabelElementsPost(
        requestParameters: ActionsApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ElementsResponse>;

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeReport(
        requestParameters: ActionsApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmExecutionResponse>;

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeValidDescendants(
        requestParameters: ActionsApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidDescendantsResponse>;

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeValidObjects(
        requestParameters: ActionsApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidObjectsResponse>;

    /**
     * (EXPERIMENTAL) Creates a new memory item and returns it
     * @summary (EXPERIMENTAL) Create new memory item
     * @param {ActionsApiCreateMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    createMemoryItem(
        requestParameters: ActionsApiCreateMemoryItemRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<MemoryItem>;

    /**
     * Returns a list of Users who created any object for this workspace
     * @summary Get Analytics Catalog CreatedBy
     * @param {ActionsApiCreatedByRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    createdBy(
        requestParameters: ActionsApiCreatedByRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnalyticsCatalogCreatedBy>;

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    explainAFM(
        requestParameters: ActionsApiExplainAFMRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {ActionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    forecast(
        requestParameters: ActionsApiForecastRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    forecastResult(
        requestParameters: ActionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ForecastResult>;

    /**
     * (EXPERIMENTAL) Get memory item by id
     * @summary (EXPERIMENTAL) Get memory item
     * @param {ActionsApiGetMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getMemoryItem(
        requestParameters: ActionsApiGetMemoryItemRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<MemoryItem>;

    /**
     * Returns metadata quality issues detected by the platform linter.
     * @summary Get Quality Issues
     * @param {ActionsApiGetQualityIssuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getQualityIssues(
        requestParameters: ActionsApiGetQualityIssuesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<GetQualityIssuesResponse>;

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ActionsApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    keyDriverAnalysis(
        requestParameters: ActionsApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResponse>;

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ActionsApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    keyDriverAnalysisResult(
        requestParameters: ActionsApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResult>;

    /**
     * (EXPERIMENTAL) Returns a list of memory items
     * @summary (EXPERIMENTAL) List all memory items
     * @param {ActionsApiListMemoryItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    listMemoryItems(
        requestParameters: ActionsApiListMemoryItemsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<MemoryItem>>;

    /**
     * (EXPERIMENTAL) Removes memory item
     * @summary (EXPERIMENTAL) Remove memory item
     * @param {ActionsApiRemoveMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    removeMemoryItem(
        requestParameters: ActionsApiRemoveMemoryItemRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Returns a list of available LLM Endpoints
     * @summary Get Active LLM Endpoints for this workspace
     * @param {ActionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    resolveLlmEndpoints(
        requestParameters: ActionsApiResolveLlmEndpointsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResolvedLlmEndpoints>;

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    retrieveExecutionMetadata(
        requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResultCacheMetadata>;

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    retrieveResult(
        requestParameters: ActionsApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExecutionResult>;

    /**
     * Returns a list of tags for this workspace
     * @summary Get Analytics Catalog Tags
     * @param {ActionsApiTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    tags(
        requestParameters: ActionsApiTagsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnalyticsCatalogTags>;

    /**
     * (EXPERIMENTAL) Updates memory item and returns it
     * @summary (EXPERIMENTAL) Update memory item
     * @param {ActionsApiUpdateMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    updateMemoryItem(
        requestParameters: ActionsApiUpdateMemoryItemRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<MemoryItem>;

    /**
     * Validates LLM endpoint with provided parameters.
     * @summary Validate LLM Endpoint
     * @param {ActionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    validateLLMEndpoint(
        requestParameters: ActionsApiValidateLLMEndpointRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ValidateLLMEndpointResponse>;

    /**
     * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
     * @summary Validate LLM Endpoint By Id
     * @param {ActionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    validateLLMEndpointById(
        requestParameters: ActionsApiValidateLLMEndpointByIdRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ValidateLLMEndpointResponse>;
}

/**
 * Request parameters for aiChat operation in ActionsApi.
 * @export
 * @interface ActionsApiAiChatRequest
 */
export interface ActionsApiAiChatRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiChat
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof ActionsApiAiChat
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiChatHistory operation in ActionsApi.
 * @export
 * @interface ActionsApiAiChatHistoryRequest
 */
export interface ActionsApiAiChatHistoryRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiChatHistory
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatHistoryRequest}
     * @memberof ActionsApiAiChatHistory
     */
    readonly chatHistoryRequest: ChatHistoryRequest;
}

/**
 * Request parameters for aiChatStream operation in ActionsApi.
 * @export
 * @interface ActionsApiAiChatStreamRequest
 */
export interface ActionsApiAiChatStreamRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiChatStream
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof ActionsApiAiChatStream
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiChatUsage operation in ActionsApi.
 * @export
 * @interface ActionsApiAiChatUsageRequest
 */
export interface ActionsApiAiChatUsageRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiChatUsage
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for aiSearch operation in ActionsApi.
 * @export
 * @interface ActionsApiAiSearchRequest
 */
export interface ActionsApiAiSearchRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiSearch
     */
    readonly workspaceId: string;

    /**
     *
     * @type {SearchRequest}
     * @memberof ActionsApiAiSearch
     */
    readonly searchRequest: SearchRequest;
}

/**
 * Request parameters for anomalyDetection operation in ActionsApi.
 * @export
 * @interface ActionsApiAnomalyDetectionRequest
 */
export interface ActionsApiAnomalyDetectionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly resultId: string;

    /**
     *
     * @type {AnomalyDetectionRequest}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly anomalyDetectionRequest: AnomalyDetectionRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for anomalyDetectionResult operation in ActionsApi.
 * @export
 * @interface ActionsApiAnomalyDetectionResultRequest
 */
export interface ActionsApiAnomalyDetectionResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for cancelExecutions operation in ActionsApi.
 * @export
 * @interface ActionsApiCancelExecutionsRequest
 */
export interface ActionsApiCancelExecutionsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiCancelExecutions
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmCancelTokens}
     * @memberof ActionsApiCancelExecutions
     */
    readonly afmCancelTokens: AfmCancelTokens;
}

/**
 * Request parameters for clustering operation in ActionsApi.
 * @export
 * @interface ActionsApiClusteringRequest
 */
export interface ActionsApiClusteringRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiClustering
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof ActionsApiClustering
     */
    readonly resultId: string;

    /**
     *
     * @type {ClusteringRequest}
     * @memberof ActionsApiClustering
     */
    readonly clusteringRequest: ClusteringRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiClustering
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for clusteringResult operation in ActionsApi.
 * @export
 * @interface ActionsApiClusteringResultRequest
 */
export interface ActionsApiClusteringResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiClusteringResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiClusteringResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiClusteringResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiClusteringResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for computeLabelElementsPost operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeLabelElementsPostRequest
 */
export interface ActionsApiComputeLabelElementsPostRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ElementsRequest}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly elementsRequest: ElementsRequest;

    /**
     * Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly offset?: number;

    /**
     * Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly limit?: number;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for computeReport operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeReportRequest
 */
export interface ActionsApiComputeReportRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeReport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ActionsApiComputeReport
     */
    readonly afmExecution: AfmExecution;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiComputeReport
     */
    readonly skipCache?: boolean;

    /**
     *
     * @type {string}
     * @memberof ActionsApiComputeReport
     */
    readonly timestamp?: string;
}

/**
 * Request parameters for computeValidDescendants operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeValidDescendantsRequest
 */
export interface ActionsApiComputeValidDescendantsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeValidDescendants
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidDescendantsQuery}
     * @memberof ActionsApiComputeValidDescendants
     */
    readonly afmValidDescendantsQuery: AfmValidDescendantsQuery;
}

/**
 * Request parameters for computeValidObjects operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeValidObjectsRequest
 */
export interface ActionsApiComputeValidObjectsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeValidObjects
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidObjectsQuery}
     * @memberof ActionsApiComputeValidObjects
     */
    readonly afmValidObjectsQuery: AfmValidObjectsQuery;
}

/**
 * Request parameters for createMemoryItem operation in ActionsApi.
 * @export
 * @interface ActionsApiCreateMemoryItemRequest
 */
export interface ActionsApiCreateMemoryItemRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiCreateMemoryItem
     */
    readonly workspaceId: string;

    /**
     *
     * @type {MemoryItem}
     * @memberof ActionsApiCreateMemoryItem
     */
    readonly memoryItem: MemoryItem;
}

/**
 * Request parameters for createdBy operation in ActionsApi.
 * @export
 * @interface ActionsApiCreatedByRequest
 */
export interface ActionsApiCreatedByRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiCreatedBy
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for explainAFM operation in ActionsApi.
 * @export
 * @interface ActionsApiExplainAFMRequest
 */
export interface ActionsApiExplainAFMRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiExplainAFM
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ActionsApiExplainAFM
     */
    readonly afmExecution: AfmExecution;

    /**
     * Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;COMPRESSED_GRPC_MODEL_SVG&#x60; - Generated SVG image of the model fragment used in the query  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;COMPRESSED_SQL&#x60; - Final SQL to be executed with rolled SQL datasets  &#x60;SETTINGS&#x60; - Settings used to execute explain request
     * @type {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS' | 'COMPRESSED_SQL'}
     * @memberof ActionsApiExplainAFM
     */
    readonly explainType?:
        | "MAQL"
        | "GRPC_MODEL"
        | "GRPC_MODEL_SVG"
        | "WDF"
        | "QT"
        | "QT_SVG"
        | "OPT_QT"
        | "OPT_QT_SVG"
        | "SQL"
        | "SETTINGS"
        | "COMPRESSED_SQL";
}

/**
 * Request parameters for forecast operation in ActionsApi.
 * @export
 * @interface ActionsApiForecastRequest
 */
export interface ActionsApiForecastRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiForecast
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof ActionsApiForecast
     */
    readonly resultId: string;

    /**
     *
     * @type {ForecastRequest}
     * @memberof ActionsApiForecast
     */
    readonly forecastRequest: ForecastRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiForecast
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for forecastResult operation in ActionsApi.
 * @export
 * @interface ActionsApiForecastResultRequest
 */
export interface ActionsApiForecastResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiForecastResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiForecastResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiForecastResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiForecastResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for getMemoryItem operation in ActionsApi.
 * @export
 * @interface ActionsApiGetMemoryItemRequest
 */
export interface ActionsApiGetMemoryItemRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiGetMemoryItem
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsApiGetMemoryItem
     */
    readonly memoryId: string;
}

/**
 * Request parameters for getQualityIssues operation in ActionsApi.
 * @export
 * @interface ActionsApiGetQualityIssuesRequest
 */
export interface ActionsApiGetQualityIssuesRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiGetQualityIssues
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for keyDriverAnalysis operation in ActionsApi.
 * @export
 * @interface ActionsApiKeyDriverAnalysisRequest
 */
export interface ActionsApiKeyDriverAnalysisRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiKeyDriverAnalysis
     */
    readonly workspaceId: string;

    /**
     *
     * @type {KeyDriversRequest}
     * @memberof ActionsApiKeyDriverAnalysis
     */
    readonly keyDriversRequest: KeyDriversRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiKeyDriverAnalysis
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for keyDriverAnalysisResult operation in ActionsApi.
 * @export
 * @interface ActionsApiKeyDriverAnalysisResultRequest
 */
export interface ActionsApiKeyDriverAnalysisResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for listMemoryItems operation in ActionsApi.
 * @export
 * @interface ActionsApiListMemoryItemsRequest
 */
export interface ActionsApiListMemoryItemsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiListMemoryItems
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for removeMemoryItem operation in ActionsApi.
 * @export
 * @interface ActionsApiRemoveMemoryItemRequest
 */
export interface ActionsApiRemoveMemoryItemRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiRemoveMemoryItem
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsApiRemoveMemoryItem
     */
    readonly memoryId: string;
}

/**
 * Request parameters for resolveLlmEndpoints operation in ActionsApi.
 * @export
 * @interface ActionsApiResolveLlmEndpointsRequest
 */
export interface ActionsApiResolveLlmEndpointsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiResolveLlmEndpoints
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for retrieveExecutionMetadata operation in ActionsApi.
 * @export
 * @interface ActionsApiRetrieveExecutionMetadataRequest
 */
export interface ActionsApiRetrieveExecutionMetadataRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiRetrieveExecutionMetadata
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiRetrieveExecutionMetadata
     */
    readonly resultId: string;
}

/**
 * Request parameters for retrieveResult operation in ActionsApi.
 * @export
 * @interface ActionsApiRetrieveResultRequest
 */
export interface ActionsApiRetrieveResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly resultId: string;

    /**
     * Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly offset?: Array<number>;

    /**
     * Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly limit?: Array<number>;

    /**
     * Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
     * @type {Array<string>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly excludedTotalDimensions?: Array<string>;

    /**
     *
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly xGDCCANCELTOKEN?: string;
}

/**
 * Request parameters for tags operation in ActionsApi.
 * @export
 * @interface ActionsApiTagsRequest
 */
export interface ActionsApiTagsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiTags
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for updateMemoryItem operation in ActionsApi.
 * @export
 * @interface ActionsApiUpdateMemoryItemRequest
 */
export interface ActionsApiUpdateMemoryItemRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiUpdateMemoryItem
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsApiUpdateMemoryItem
     */
    readonly memoryId: string;

    /**
     *
     * @type {MemoryItem}
     * @memberof ActionsApiUpdateMemoryItem
     */
    readonly memoryItem: MemoryItem;
}

/**
 * Request parameters for validateLLMEndpoint operation in ActionsApi.
 * @export
 * @interface ActionsApiValidateLLMEndpointRequest
 */
export interface ActionsApiValidateLLMEndpointRequest {
    /**
     *
     * @type {ValidateLLMEndpointRequest}
     * @memberof ActionsApiValidateLLMEndpoint
     */
    readonly validateLLMEndpointRequest: ValidateLLMEndpointRequest;
}

/**
 * Request parameters for validateLLMEndpointById operation in ActionsApi.
 * @export
 * @interface ActionsApiValidateLLMEndpointByIdRequest
 */
export interface ActionsApiValidateLLMEndpointByIdRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiValidateLLMEndpointById
     */
    readonly llmEndpointId: string;

    /**
     *
     * @type {ValidateLLMEndpointByIdRequest}
     * @memberof ActionsApiValidateLLMEndpointById
     */
    readonly validateLLMEndpointByIdRequest?: ValidateLLMEndpointByIdRequest;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiChat(requestParameters: ActionsApiAiChatRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .aiChat(requestParameters.workspaceId, requestParameters.chatRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {ActionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiChatHistory(requestParameters: ActionsApiAiChatHistoryRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .aiChatHistory(requestParameters.workspaceId, requestParameters.chatHistoryRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiChatStream(requestParameters: ActionsApiAiChatStreamRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .aiChatStream(requestParameters.workspaceId, requestParameters.chatRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns usage statistics of chat for a user in a workspace.
     * @summary Get Chat Usage
     * @param {ActionsApiAiChatUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiChatUsage(requestParameters: ActionsApiAiChatUsageRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .aiChatUsage(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {ActionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiSearch(requestParameters: ActionsApiAiSearchRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .aiSearch(requestParameters.workspaceId, requestParameters.searchRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {ActionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public anomalyDetection(
        requestParameters: ActionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .anomalyDetection(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.anomalyDetectionRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {ActionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public anomalyDetectionResult(
        requestParameters: ActionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .anomalyDetectionResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
     * @summary Applies all the given cancel tokens.
     * @param {ActionsApiCancelExecutionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public cancelExecutions(
        requestParameters: ActionsApiCancelExecutionsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .cancelExecutions(requestParameters.workspaceId, requestParameters.afmCancelTokens, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {ActionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public clustering(requestParameters: ActionsApiClusteringRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .clustering(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.clusteringRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {ActionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public clusteringResult(
        requestParameters: ActionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .clusteringResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeLabelElementsPost(
        requestParameters: ActionsApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .computeLabelElementsPost(
                requestParameters.workspaceId,
                requestParameters.elementsRequest,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeReport(requestParameters: ActionsApiComputeReportRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .computeReport(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.skipCache,
                requestParameters.timestamp,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeValidDescendants(
        requestParameters: ActionsApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .computeValidDescendants(
                requestParameters.workspaceId,
                requestParameters.afmValidDescendantsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeValidObjects(
        requestParameters: ActionsApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .computeValidObjects(
                requestParameters.workspaceId,
                requestParameters.afmValidObjectsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Creates a new memory item and returns it
     * @summary (EXPERIMENTAL) Create new memory item
     * @param {ActionsApiCreateMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public createMemoryItem(
        requestParameters: ActionsApiCreateMemoryItemRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .createMemoryItem(requestParameters.workspaceId, requestParameters.memoryItem, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users who created any object for this workspace
     * @summary Get Analytics Catalog CreatedBy
     * @param {ActionsApiCreatedByRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public createdBy(requestParameters: ActionsApiCreatedByRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .createdBy(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public explainAFM(requestParameters: ActionsApiExplainAFMRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .explainAFM(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.explainType,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {ActionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public forecast(requestParameters: ActionsApiForecastRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .forecast(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.forecastRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public forecastResult(requestParameters: ActionsApiForecastResultRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .forecastResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Get memory item by id
     * @summary (EXPERIMENTAL) Get memory item
     * @param {ActionsApiGetMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getMemoryItem(requestParameters: ActionsApiGetMemoryItemRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .getMemoryItem(requestParameters.workspaceId, requestParameters.memoryId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata quality issues detected by the platform linter.
     * @summary Get Quality Issues
     * @param {ActionsApiGetQualityIssuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getQualityIssues(
        requestParameters: ActionsApiGetQualityIssuesRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .getQualityIssues(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ActionsApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public keyDriverAnalysis(
        requestParameters: ActionsApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .keyDriverAnalysis(
                requestParameters.workspaceId,
                requestParameters.keyDriversRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ActionsApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public keyDriverAnalysisResult(
        requestParameters: ActionsApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .keyDriverAnalysisResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Returns a list of memory items
     * @summary (EXPERIMENTAL) List all memory items
     * @param {ActionsApiListMemoryItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public listMemoryItems(
        requestParameters: ActionsApiListMemoryItemsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .listMemoryItems(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Removes memory item
     * @summary (EXPERIMENTAL) Remove memory item
     * @param {ActionsApiRemoveMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public removeMemoryItem(
        requestParameters: ActionsApiRemoveMemoryItemRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .removeMemoryItem(requestParameters.workspaceId, requestParameters.memoryId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of available LLM Endpoints
     * @summary Get Active LLM Endpoints for this workspace
     * @param {ActionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public resolveLlmEndpoints(
        requestParameters: ActionsApiResolveLlmEndpointsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .resolveLlmEndpoints(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public retrieveExecutionMetadata(
        requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public retrieveResult(requestParameters: ActionsApiRetrieveResultRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .retrieveResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.excludedTotalDimensions,
                requestParameters.xGDCCANCELTOKEN,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of tags for this workspace
     * @summary Get Analytics Catalog Tags
     * @param {ActionsApiTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public tags(requestParameters: ActionsApiTagsRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .tags(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Updates memory item and returns it
     * @summary (EXPERIMENTAL) Update memory item
     * @param {ActionsApiUpdateMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public updateMemoryItem(
        requestParameters: ActionsApiUpdateMemoryItemRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .updateMemoryItem(
                requestParameters.workspaceId,
                requestParameters.memoryId,
                requestParameters.memoryItem,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates LLM endpoint with provided parameters.
     * @summary Validate LLM Endpoint
     * @param {ActionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public validateLLMEndpoint(
        requestParameters: ActionsApiValidateLLMEndpointRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .validateLLMEndpoint(requestParameters.validateLLMEndpointRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
     * @summary Validate LLM Endpoint By Id
     * @param {ActionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public validateLLMEndpointById(
        requestParameters: ActionsApiValidateLLMEndpointByIdRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .validateLLMEndpointById(
                requestParameters.llmEndpointId,
                requestParameters.validateLLMEndpointByIdRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ComputationApi - axios parameter creator
 * @export
 */
export const ComputationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: async (
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeLabelElementsPost", "workspaceId", workspaceId);
            // verify required parameter 'elementsRequest' is not null or undefined
            assertParamExists("computeLabelElementsPost", "elementsRequest", elementsRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof elementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
                : elementsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeReport", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("computeReport", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants: async (
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidDescendants", "workspaceId", workspaceId);
            // verify required parameter 'afmValidDescendantsQuery' is not null or undefined
            assertParamExists(
                "computeValidDescendants",
                "afmValidDescendantsQuery",
                afmValidDescendantsQuery,
            );
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidDescendants`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidDescendantsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidDescendantsQuery !== undefined ? afmValidDescendantsQuery : {})
                : afmValidDescendantsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: async (
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidObjects", "workspaceId", workspaceId);
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            assertParamExists("computeValidObjects", "afmValidObjectsQuery", afmValidObjectsQuery);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS' | 'COMPRESSED_SQL'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;COMPRESSED_GRPC_MODEL_SVG&#x60; - Generated SVG image of the model fragment used in the query  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;COMPRESSED_SQL&#x60; - Final SQL to be executed with rolled SQL datasets  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS"
                | "COMPRESSED_SQL",
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("explainAFM", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("explainAFM", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (explainType !== undefined) {
                localVarQueryParameter["explainType"] = explainType;
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {string} workspaceId Workspace identifier
         * @param {KeyDriversRequest} keyDriversRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysis: async (
            workspaceId: string,
            keyDriversRequest: KeyDriversRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("keyDriverAnalysis", "workspaceId", workspaceId);
            // verify required parameter 'keyDriversRequest' is not null or undefined
            assertParamExists("keyDriverAnalysis", "keyDriversRequest", keyDriversRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof keyDriversRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(keyDriversRequest !== undefined ? keyDriversRequest : {})
                : keyDriversRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysisResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("keyDriverAnalysisResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("keyDriverAnalysisResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata: async (
            workspaceId: string,
            resultId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}/metadata`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {string} [xGDCCANCELTOKEN]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: async (
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            xGDCCANCELTOKEN?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }

            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }

            if (excludedTotalDimensions) {
                localVarQueryParameter["excludedTotalDimensions"] = excludedTotalDimensions.join(
                    COLLECTION_FORMATS.csv,
                );
            }

            if (xGDCCANCELTOKEN !== undefined && xGDCCANCELTOKEN !== null) {
                localVarHeaderParameter["X-GDC-CANCEL-TOKEN"] = String(xGDCCANCELTOKEN);
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ComputationApi - functional programming interface
 * @export
 */
export const ComputationApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ComputationApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeLabelElementsPost(
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeLabelElementsPost(
                workspaceId,
                elementsRequest,
                offset,
                limit,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeReport(
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmExecutionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeReport(
                workspaceId,
                afmExecution,
                skipCache,
                timestamp,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidDescendants(
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidDescendantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidDescendants(
                workspaceId,
                afmValidDescendantsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidObjects(
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidObjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidObjects(
                workspaceId,
                afmValidObjectsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS' | 'COMPRESSED_SQL'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;COMPRESSED_GRPC_MODEL_SVG&#x60; - Generated SVG image of the model fragment used in the query  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;COMPRESSED_SQL&#x60; - Final SQL to be executed with rolled SQL datasets  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explainAFM(
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS"
                | "COMPRESSED_SQL",
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explainAFM(
                workspaceId,
                afmExecution,
                explainType,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {string} workspaceId Workspace identifier
         * @param {KeyDriversRequest} keyDriversRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyDriverAnalysis(
            workspaceId: string,
            keyDriversRequest: KeyDriversRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDriversResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyDriverAnalysis(
                workspaceId,
                keyDriversRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyDriverAnalysisResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDriversResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyDriverAnalysisResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveExecutionMetadata(
            workspaceId: string,
            resultId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultCacheMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveExecutionMetadata(
                workspaceId,
                resultId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {string} [xGDCCANCELTOKEN]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveResult(
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            xGDCCANCELTOKEN?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveResult(
                workspaceId,
                resultId,
                offset,
                limit,
                excludedTotalDimensions,
                xGDCCANCELTOKEN,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ComputationApi - factory interface
 * @export
 */
export const ComputationApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ComputationApiFp(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(
            requestParameters: ComputationApiComputeLabelElementsPostRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ElementsResponse> {
            return localVarFp
                .computeLabelElementsPost(
                    requestParameters.workspaceId,
                    requestParameters.elementsRequest,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            requestParameters: ComputationApiComputeReportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmExecutionResponse> {
            return localVarFp
                .computeReport(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.skipCache,
                    requestParameters.timestamp,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants(
            requestParameters: ComputationApiComputeValidDescendantsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidDescendantsResponse> {
            return localVarFp
                .computeValidDescendants(
                    requestParameters.workspaceId,
                    requestParameters.afmValidDescendantsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            requestParameters: ComputationApiComputeValidObjectsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidObjectsResponse> {
            return localVarFp
                .computeValidObjects(
                    requestParameters.workspaceId,
                    requestParameters.afmValidObjectsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(
            requestParameters: ComputationApiExplainAFMRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<File> {
            return localVarFp
                .explainAFM(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.explainType,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {ComputationApiKeyDriverAnalysisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysis(
            requestParameters: ComputationApiKeyDriverAnalysisRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<KeyDriversResponse> {
            return localVarFp
                .keyDriverAnalysis(
                    requestParameters.workspaceId,
                    requestParameters.keyDriversRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {ComputationApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysisResult(
            requestParameters: ComputationApiKeyDriverAnalysisResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<KeyDriversResult> {
            return localVarFp
                .keyDriverAnalysisResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata(
            requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ResultCacheMetadata> {
            return localVarFp
                .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            requestParameters: ComputationApiRetrieveResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExecutionResult> {
            return localVarFp
                .retrieveResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.excludedTotalDimensions,
                    requestParameters.xGDCCANCELTOKEN,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComputationApi - interface
 * @export
 * @interface ComputationApi
 */
export interface ComputationApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeLabelElementsPost(
        requestParameters: ComputationApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ElementsResponse>;

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeReport(
        requestParameters: ComputationApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmExecutionResponse>;

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeValidDescendants(
        requestParameters: ComputationApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidDescendantsResponse>;

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeValidObjects(
        requestParameters: ComputationApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidObjectsResponse>;

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    explainAFM(
        requestParameters: ComputationApiExplainAFMRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ComputationApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    keyDriverAnalysis(
        requestParameters: ComputationApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResponse>;

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ComputationApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    keyDriverAnalysisResult(
        requestParameters: ComputationApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResult>;

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    retrieveExecutionMetadata(
        requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResultCacheMetadata>;

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    retrieveResult(
        requestParameters: ComputationApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExecutionResult>;
}

/**
 * Request parameters for computeLabelElementsPost operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeLabelElementsPostRequest
 */
export interface ComputationApiComputeLabelElementsPostRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ElementsRequest}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly elementsRequest: ElementsRequest;

    /**
     * Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly offset?: number;

    /**
     * Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly limit?: number;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for computeReport operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeReportRequest
 */
export interface ComputationApiComputeReportRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeReport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ComputationApiComputeReport
     */
    readonly afmExecution: AfmExecution;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiComputeReport
     */
    readonly skipCache?: boolean;

    /**
     *
     * @type {string}
     * @memberof ComputationApiComputeReport
     */
    readonly timestamp?: string;
}

/**
 * Request parameters for computeValidDescendants operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeValidDescendantsRequest
 */
export interface ComputationApiComputeValidDescendantsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeValidDescendants
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidDescendantsQuery}
     * @memberof ComputationApiComputeValidDescendants
     */
    readonly afmValidDescendantsQuery: AfmValidDescendantsQuery;
}

/**
 * Request parameters for computeValidObjects operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeValidObjectsRequest
 */
export interface ComputationApiComputeValidObjectsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeValidObjects
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidObjectsQuery}
     * @memberof ComputationApiComputeValidObjects
     */
    readonly afmValidObjectsQuery: AfmValidObjectsQuery;
}

/**
 * Request parameters for explainAFM operation in ComputationApi.
 * @export
 * @interface ComputationApiExplainAFMRequest
 */
export interface ComputationApiExplainAFMRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiExplainAFM
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ComputationApiExplainAFM
     */
    readonly afmExecution: AfmExecution;

    /**
     * Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;COMPRESSED_GRPC_MODEL_SVG&#x60; - Generated SVG image of the model fragment used in the query  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;COMPRESSED_SQL&#x60; - Final SQL to be executed with rolled SQL datasets  &#x60;SETTINGS&#x60; - Settings used to execute explain request
     * @type {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS' | 'COMPRESSED_SQL'}
     * @memberof ComputationApiExplainAFM
     */
    readonly explainType?:
        | "MAQL"
        | "GRPC_MODEL"
        | "GRPC_MODEL_SVG"
        | "WDF"
        | "QT"
        | "QT_SVG"
        | "OPT_QT"
        | "OPT_QT_SVG"
        | "SQL"
        | "SETTINGS"
        | "COMPRESSED_SQL";
}

/**
 * Request parameters for keyDriverAnalysis operation in ComputationApi.
 * @export
 * @interface ComputationApiKeyDriverAnalysisRequest
 */
export interface ComputationApiKeyDriverAnalysisRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiKeyDriverAnalysis
     */
    readonly workspaceId: string;

    /**
     *
     * @type {KeyDriversRequest}
     * @memberof ComputationApiKeyDriverAnalysis
     */
    readonly keyDriversRequest: KeyDriversRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiKeyDriverAnalysis
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for keyDriverAnalysisResult operation in ComputationApi.
 * @export
 * @interface ComputationApiKeyDriverAnalysisResultRequest
 */
export interface ComputationApiKeyDriverAnalysisResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for retrieveExecutionMetadata operation in ComputationApi.
 * @export
 * @interface ComputationApiRetrieveExecutionMetadataRequest
 */
export interface ComputationApiRetrieveExecutionMetadataRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiRetrieveExecutionMetadata
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiRetrieveExecutionMetadata
     */
    readonly resultId: string;
}

/**
 * Request parameters for retrieveResult operation in ComputationApi.
 * @export
 * @interface ComputationApiRetrieveResultRequest
 */
export interface ComputationApiRetrieveResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiRetrieveResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiRetrieveResult
     */
    readonly resultId: string;

    /**
     * Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly offset?: Array<number>;

    /**
     * Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly limit?: Array<number>;

    /**
     * Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
     * @type {Array<string>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly excludedTotalDimensions?: Array<string>;

    /**
     *
     * @type {string}
     * @memberof ComputationApiRetrieveResult
     */
    readonly xGDCCANCELTOKEN?: string;
}

/**
 * ComputationApi - object-oriented interface
 * @export
 * @class ComputationApi
 * @extends {BaseAPI}
 */
export class ComputationApi extends BaseAPI implements ComputationApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeLabelElementsPost(
        requestParameters: ComputationApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeLabelElementsPost(
                requestParameters.workspaceId,
                requestParameters.elementsRequest,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeReport(
        requestParameters: ComputationApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeReport(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.skipCache,
                requestParameters.timestamp,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeValidDescendants(
        requestParameters: ComputationApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeValidDescendants(
                requestParameters.workspaceId,
                requestParameters.afmValidDescendantsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeValidObjects(
        requestParameters: ComputationApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeValidObjects(
                requestParameters.workspaceId,
                requestParameters.afmValidObjectsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public explainAFM(requestParameters: ComputationApiExplainAFMRequest, options?: AxiosRequestConfig) {
        return ComputationApiFp(this.configuration)
            .explainAFM(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.explainType,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ComputationApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public keyDriverAnalysis(
        requestParameters: ComputationApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .keyDriverAnalysis(
                requestParameters.workspaceId,
                requestParameters.keyDriversRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ComputationApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public keyDriverAnalysisResult(
        requestParameters: ComputationApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .keyDriverAnalysisResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public retrieveExecutionMetadata(
        requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public retrieveResult(
        requestParameters: ComputationApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .retrieveResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.excludedTotalDimensions,
                requestParameters.xGDCCANCELTOKEN,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * SmartFunctionsApi - axios parameter creator
 * @export
 */
export const SmartFunctionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChat: async (
            workspaceId: string,
            chatRequest: ChatRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChat", "workspaceId", workspaceId);
            // verify required parameter 'chatRequest' is not null or undefined
            assertParamExists("aiChat", "chatRequest", chatRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chat`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
                : chatRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {string} workspaceId Workspace identifier
         * @param {ChatHistoryRequest} chatHistoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatHistory: async (
            workspaceId: string,
            chatHistoryRequest: ChatHistoryRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChatHistory", "workspaceId", workspaceId);
            // verify required parameter 'chatHistoryRequest' is not null or undefined
            assertParamExists("aiChatHistory", "chatHistoryRequest", chatHistoryRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatHistory`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatHistoryRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatHistoryRequest !== undefined ? chatHistoryRequest : {})
                : chatHistoryRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatStream: async (
            workspaceId: string,
            chatRequest: ChatRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChatStream", "workspaceId", workspaceId);
            // verify required parameter 'chatRequest' is not null or undefined
            assertParamExists("aiChatStream", "chatRequest", chatRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatStream`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
                : chatRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns usage statistics of chat for a user in a workspace.
         * @summary Get Chat Usage
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatUsage: async (workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChatUsage", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatUsage`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {string} workspaceId Workspace identifier
         * @param {SearchRequest} searchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiSearch: async (
            workspaceId: string,
            searchRequest: SearchRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiSearch", "workspaceId", workspaceId);
            // verify required parameter 'searchRequest' is not null or undefined
            assertParamExists("aiSearch", "searchRequest", searchRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/search`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof searchRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(searchRequest !== undefined ? searchRequest : {})
                : searchRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {AnomalyDetectionRequest} anomalyDetectionRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetection: async (
            workspaceId: string,
            resultId: string,
            anomalyDetectionRequest: AnomalyDetectionRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("anomalyDetection", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("anomalyDetection", "resultId", resultId);
            // verify required parameter 'anomalyDetectionRequest' is not null or undefined
            assertParamExists("anomalyDetection", "anomalyDetectionRequest", anomalyDetectionRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof anomalyDetectionRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(anomalyDetectionRequest !== undefined ? anomalyDetectionRequest : {})
                : anomalyDetectionRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetectionResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("anomalyDetectionResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("anomalyDetectionResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ClusteringRequest} clusteringRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustering: async (
            workspaceId: string,
            resultId: string,
            clusteringRequest: ClusteringRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("clustering", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("clustering", "resultId", resultId);
            // verify required parameter 'clusteringRequest' is not null or undefined
            assertParamExists("clustering", "clusteringRequest", clusteringRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof clusteringRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(clusteringRequest !== undefined ? clusteringRequest : {})
                : clusteringRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusteringResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("clusteringResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("clusteringResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Creates a new memory item and returns it
         * @summary (EXPERIMENTAL) Create new memory item
         * @param {string} workspaceId Workspace identifier
         * @param {MemoryItem} memoryItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemoryItem: async (
            workspaceId: string,
            memoryItem: MemoryItem,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createMemoryItem", "workspaceId", workspaceId);
            // verify required parameter 'memoryItem' is not null or undefined
            assertParamExists("createMemoryItem", "memoryItem", memoryItem);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof memoryItem !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(memoryItem !== undefined ? memoryItem : {})
                : memoryItem || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users who created any object for this workspace
         * @summary Get Analytics Catalog CreatedBy
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createdBy: async (workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("createdBy", "workspaceId", workspaceId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/ai/analyticsCatalog/createdBy`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast: async (
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecast", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecast", "resultId", resultId);
            // verify required parameter 'forecastRequest' is not null or undefined
            assertParamExists("forecast", "forecastRequest", forecastRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof forecastRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(forecastRequest !== undefined ? forecastRequest : {})
                : forecastRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecastResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecastResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Get memory item by id
         * @summary (EXPERIMENTAL) Get memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemoryItem: async (
            workspaceId: string,
            memoryId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getMemoryItem", "workspaceId", workspaceId);
            // verify required parameter 'memoryId' is not null or undefined
            assertParamExists("getMemoryItem", "memoryId", memoryId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory/{memoryId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"memoryId"}}`, encodeURIComponent(String(memoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metadata quality issues detected by the platform linter.
         * @summary Get Quality Issues
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQualityIssues: async (
            workspaceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("getQualityIssues", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/issues`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Returns a list of memory items
         * @summary (EXPERIMENTAL) List all memory items
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemoryItems: async (
            workspaceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("listMemoryItems", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Removes memory item
         * @summary (EXPERIMENTAL) Remove memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemoryItem: async (
            workspaceId: string,
            memoryId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("removeMemoryItem", "workspaceId", workspaceId);
            // verify required parameter 'memoryId' is not null or undefined
            assertParamExists("removeMemoryItem", "memoryId", memoryId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory/{memoryId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"memoryId"}}`, encodeURIComponent(String(memoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of available LLM Endpoints
         * @summary Get Active LLM Endpoints for this workspace
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveLlmEndpoints: async (
            workspaceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("resolveLlmEndpoints", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/resolveLlmEndpoints`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of tags for this workspace
         * @summary Get Analytics Catalog Tags
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tags: async (workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("tags", "workspaceId", workspaceId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/analyticsCatalog/tags`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Updates memory item and returns it
         * @summary (EXPERIMENTAL) Update memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {MemoryItem} memoryItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemoryItem: async (
            workspaceId: string,
            memoryId: string,
            memoryItem: MemoryItem,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("updateMemoryItem", "workspaceId", workspaceId);
            // verify required parameter 'memoryId' is not null or undefined
            assertParamExists("updateMemoryItem", "memoryId", memoryId);
            // verify required parameter 'memoryItem' is not null or undefined
            assertParamExists("updateMemoryItem", "memoryItem", memoryItem);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory/{memoryId}`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"memoryId"}}`, encodeURIComponent(String(memoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof memoryItem !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(memoryItem !== undefined ? memoryItem : {})
                : memoryItem || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates LLM endpoint with provided parameters.
         * @summary Validate LLM Endpoint
         * @param {ValidateLLMEndpointRequest} validateLLMEndpointRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLLMEndpoint: async (
            validateLLMEndpointRequest: ValidateLLMEndpointRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'validateLLMEndpointRequest' is not null or undefined
            assertParamExists(
                "validateLLMEndpoint",
                "validateLLMEndpointRequest",
                validateLLMEndpointRequest,
            );
            const localVarPath = `/api/v1/actions/ai/llmEndpoint/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof validateLLMEndpointRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(validateLLMEndpointRequest !== undefined ? validateLLMEndpointRequest : {})
                : validateLLMEndpointRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
         * @summary Validate LLM Endpoint By Id
         * @param {string} llmEndpointId
         * @param {ValidateLLMEndpointByIdRequest} [validateLLMEndpointByIdRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLLMEndpointById: async (
            llmEndpointId: string,
            validateLLMEndpointByIdRequest?: ValidateLLMEndpointByIdRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'llmEndpointId' is not null or undefined
            assertParamExists("validateLLMEndpointById", "llmEndpointId", llmEndpointId);
            const localVarPath = `/api/v1/actions/ai/llmEndpoint/{llmEndpointId}/test`.replace(
                `{${"llmEndpointId"}}`,
                encodeURIComponent(String(llmEndpointId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof validateLLMEndpointByIdRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(
                      validateLLMEndpointByIdRequest !== undefined ? validateLLMEndpointByIdRequest : {},
                  )
                : validateLLMEndpointByIdRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * SmartFunctionsApi - functional programming interface
 * @export
 */
export const SmartFunctionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SmartFunctionsApiAxiosParamCreator(configuration);
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChat(
            workspaceId: string,
            chatRequest: ChatRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChat(
                workspaceId,
                chatRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {string} workspaceId Workspace identifier
         * @param {ChatHistoryRequest} chatHistoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatHistory(
            workspaceId: string,
            chatHistoryRequest: ChatHistoryRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatHistoryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatHistory(
                workspaceId,
                chatHistoryRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatStream(
            workspaceId: string,
            chatRequest: ChatRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatStream(
                workspaceId,
                chatRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns usage statistics of chat for a user in a workspace.
         * @summary Get Chat Usage
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatUsage(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatUsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatUsage(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {string} workspaceId Workspace identifier
         * @param {SearchRequest} searchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiSearch(
            workspaceId: string,
            searchRequest: SearchRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiSearch(
                workspaceId,
                searchRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {AnomalyDetectionRequest} anomalyDetectionRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async anomalyDetection(
            workspaceId: string,
            resultId: string,
            anomalyDetectionRequest: AnomalyDetectionRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.anomalyDetection(
                workspaceId,
                resultId,
                anomalyDetectionRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async anomalyDetectionResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnomalyDetectionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.anomalyDetectionResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ClusteringRequest} clusteringRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clustering(
            workspaceId: string,
            resultId: string,
            clusteringRequest: ClusteringRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clustering(
                workspaceId,
                resultId,
                clusteringRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusteringResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusteringResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusteringResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Creates a new memory item and returns it
         * @summary (EXPERIMENTAL) Create new memory item
         * @param {string} workspaceId Workspace identifier
         * @param {MemoryItem} memoryItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMemoryItem(
            workspaceId: string,
            memoryItem: MemoryItem,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMemoryItem(
                workspaceId,
                memoryItem,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users who created any object for this workspace
         * @summary Get Analytics Catalog CreatedBy
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createdBy(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyticsCatalogCreatedBy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createdBy(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecast(
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecast(
                workspaceId,
                resultId,
                forecastRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecastResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForecastResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecastResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Get memory item by id
         * @summary (EXPERIMENTAL) Get memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMemoryItem(
            workspaceId: string,
            memoryId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMemoryItem(
                workspaceId,
                memoryId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns metadata quality issues detected by the platform linter.
         * @summary Get Quality Issues
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQualityIssues(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetQualityIssuesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQualityIssues(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Returns a list of memory items
         * @summary (EXPERIMENTAL) List all memory items
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMemoryItems(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MemoryItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMemoryItems(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Removes memory item
         * @summary (EXPERIMENTAL) Remove memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeMemoryItem(
            workspaceId: string,
            memoryId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeMemoryItem(
                workspaceId,
                memoryId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of available LLM Endpoints
         * @summary Get Active LLM Endpoints for this workspace
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveLlmEndpoints(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolvedLlmEndpoints>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveLlmEndpoints(
                workspaceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of tags for this workspace
         * @summary Get Analytics Catalog Tags
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tags(
            workspaceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalyticsCatalogTags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tags(workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Updates memory item and returns it
         * @summary (EXPERIMENTAL) Update memory item
         * @param {string} workspaceId Workspace identifier
         * @param {string} memoryId
         * @param {MemoryItem} memoryItem
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMemoryItem(
            workspaceId: string,
            memoryId: string,
            memoryItem: MemoryItem,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MemoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMemoryItem(
                workspaceId,
                memoryId,
                memoryItem,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates LLM endpoint with provided parameters.
         * @summary Validate LLM Endpoint
         * @param {ValidateLLMEndpointRequest} validateLLMEndpointRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateLLMEndpoint(
            validateLLMEndpointRequest: ValidateLLMEndpointRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateLLMEndpointResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateLLMEndpoint(
                validateLLMEndpointRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
         * @summary Validate LLM Endpoint By Id
         * @param {string} llmEndpointId
         * @param {ValidateLLMEndpointByIdRequest} [validateLLMEndpointByIdRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateLLMEndpointById(
            llmEndpointId: string,
            validateLLMEndpointByIdRequest?: ValidateLLMEndpointByIdRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateLLMEndpointResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateLLMEndpointById(
                llmEndpointId,
                validateLLMEndpointByIdRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * SmartFunctionsApi - factory interface
 * @export
 */
export const SmartFunctionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = SmartFunctionsApiFp(configuration);
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {SmartFunctionsApiAiChatRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChat(
            requestParameters: SmartFunctionsApiAiChatRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ChatResult> {
            return localVarFp
                .aiChat(requestParameters.workspaceId, requestParameters.chatRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {SmartFunctionsApiAiChatHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatHistory(
            requestParameters: SmartFunctionsApiAiChatHistoryRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ChatHistoryResult> {
            return localVarFp
                .aiChatHistory(requestParameters.workspaceId, requestParameters.chatHistoryRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {SmartFunctionsApiAiChatStreamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatStream(
            requestParameters: SmartFunctionsApiAiChatStreamRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<object>> {
            return localVarFp
                .aiChatStream(requestParameters.workspaceId, requestParameters.chatRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns usage statistics of chat for a user in a workspace.
         * @summary Get Chat Usage
         * @param {SmartFunctionsApiAiChatUsageRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatUsage(
            requestParameters: SmartFunctionsApiAiChatUsageRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ChatUsageResponse> {
            return localVarFp
                .aiChatUsage(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {SmartFunctionsApiAiSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiSearch(
            requestParameters: SmartFunctionsApiAiSearchRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SearchResult> {
            return localVarFp
                .aiSearch(requestParameters.workspaceId, requestParameters.searchRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {SmartFunctionsApiAnomalyDetectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetection(
            requestParameters: SmartFunctionsApiAnomalyDetectionRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .anomalyDetection(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.anomalyDetectionRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {SmartFunctionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetectionResult(
            requestParameters: SmartFunctionsApiAnomalyDetectionResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AnomalyDetectionResult> {
            return localVarFp
                .anomalyDetectionResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {SmartFunctionsApiClusteringRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustering(
            requestParameters: SmartFunctionsApiClusteringRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .clustering(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.clusteringRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {SmartFunctionsApiClusteringResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusteringResult(
            requestParameters: SmartFunctionsApiClusteringResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ClusteringResult> {
            return localVarFp
                .clusteringResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Creates a new memory item and returns it
         * @summary (EXPERIMENTAL) Create new memory item
         * @param {SmartFunctionsApiCreateMemoryItemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMemoryItem(
            requestParameters: SmartFunctionsApiCreateMemoryItemRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<MemoryItem> {
            return localVarFp
                .createMemoryItem(requestParameters.workspaceId, requestParameters.memoryItem, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users who created any object for this workspace
         * @summary Get Analytics Catalog CreatedBy
         * @param {SmartFunctionsApiCreatedByRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createdBy(
            requestParameters: SmartFunctionsApiCreatedByRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AnalyticsCatalogCreatedBy> {
            return localVarFp
                .createdBy(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast(
            requestParameters: SmartFunctionsApiForecastRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .forecast(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.forecastRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult(
            requestParameters: SmartFunctionsApiForecastResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ForecastResult> {
            return localVarFp
                .forecastResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Get memory item by id
         * @summary (EXPERIMENTAL) Get memory item
         * @param {SmartFunctionsApiGetMemoryItemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMemoryItem(
            requestParameters: SmartFunctionsApiGetMemoryItemRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<MemoryItem> {
            return localVarFp
                .getMemoryItem(requestParameters.workspaceId, requestParameters.memoryId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns metadata quality issues detected by the platform linter.
         * @summary Get Quality Issues
         * @param {SmartFunctionsApiGetQualityIssuesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQualityIssues(
            requestParameters: SmartFunctionsApiGetQualityIssuesRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<GetQualityIssuesResponse> {
            return localVarFp
                .getQualityIssues(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Returns a list of memory items
         * @summary (EXPERIMENTAL) List all memory items
         * @param {SmartFunctionsApiListMemoryItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMemoryItems(
            requestParameters: SmartFunctionsApiListMemoryItemsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<MemoryItem>> {
            return localVarFp
                .listMemoryItems(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Removes memory item
         * @summary (EXPERIMENTAL) Remove memory item
         * @param {SmartFunctionsApiRemoveMemoryItemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMemoryItem(
            requestParameters: SmartFunctionsApiRemoveMemoryItemRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .removeMemoryItem(requestParameters.workspaceId, requestParameters.memoryId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of available LLM Endpoints
         * @summary Get Active LLM Endpoints for this workspace
         * @param {SmartFunctionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveLlmEndpoints(
            requestParameters: SmartFunctionsApiResolveLlmEndpointsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ResolvedLlmEndpoints> {
            return localVarFp
                .resolveLlmEndpoints(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of tags for this workspace
         * @summary Get Analytics Catalog Tags
         * @param {SmartFunctionsApiTagsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tags(
            requestParameters: SmartFunctionsApiTagsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AnalyticsCatalogTags> {
            return localVarFp
                .tags(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Updates memory item and returns it
         * @summary (EXPERIMENTAL) Update memory item
         * @param {SmartFunctionsApiUpdateMemoryItemRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemoryItem(
            requestParameters: SmartFunctionsApiUpdateMemoryItemRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<MemoryItem> {
            return localVarFp
                .updateMemoryItem(
                    requestParameters.workspaceId,
                    requestParameters.memoryId,
                    requestParameters.memoryItem,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Validates LLM endpoint with provided parameters.
         * @summary Validate LLM Endpoint
         * @param {SmartFunctionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLLMEndpoint(
            requestParameters: SmartFunctionsApiValidateLLMEndpointRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ValidateLLMEndpointResponse> {
            return localVarFp
                .validateLLMEndpoint(requestParameters.validateLLMEndpointRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
         * @summary Validate LLM Endpoint By Id
         * @param {SmartFunctionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateLLMEndpointById(
            requestParameters: SmartFunctionsApiValidateLLMEndpointByIdRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ValidateLLMEndpointResponse> {
            return localVarFp
                .validateLLMEndpointById(
                    requestParameters.llmEndpointId,
                    requestParameters.validateLLMEndpointByIdRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * SmartFunctionsApi - interface
 * @export
 * @interface SmartFunctionsApi
 */
export interface SmartFunctionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiChat(
        requestParameters: SmartFunctionsApiAiChatRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatResult>;

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {SmartFunctionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiChatHistory(
        requestParameters: SmartFunctionsApiAiChatHistoryRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatHistoryResult>;

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiChatStream(
        requestParameters: SmartFunctionsApiAiChatStreamRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<object>>;

    /**
     * Returns usage statistics of chat for a user in a workspace.
     * @summary Get Chat Usage
     * @param {SmartFunctionsApiAiChatUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiChatUsage(
        requestParameters: SmartFunctionsApiAiChatUsageRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatUsageResponse>;

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {SmartFunctionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiSearch(
        requestParameters: SmartFunctionsApiAiSearchRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SearchResult>;

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {SmartFunctionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    anomalyDetection(
        requestParameters: SmartFunctionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {SmartFunctionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    anomalyDetectionResult(
        requestParameters: SmartFunctionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnomalyDetectionResult>;

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {SmartFunctionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    clustering(
        requestParameters: SmartFunctionsApiClusteringRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {SmartFunctionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    clusteringResult(
        requestParameters: SmartFunctionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ClusteringResult>;

    /**
     * (EXPERIMENTAL) Creates a new memory item and returns it
     * @summary (EXPERIMENTAL) Create new memory item
     * @param {SmartFunctionsApiCreateMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    createMemoryItem(
        requestParameters: SmartFunctionsApiCreateMemoryItemRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<MemoryItem>;

    /**
     * Returns a list of Users who created any object for this workspace
     * @summary Get Analytics Catalog CreatedBy
     * @param {SmartFunctionsApiCreatedByRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    createdBy(
        requestParameters: SmartFunctionsApiCreatedByRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnalyticsCatalogCreatedBy>;

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    forecast(
        requestParameters: SmartFunctionsApiForecastRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    forecastResult(
        requestParameters: SmartFunctionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ForecastResult>;

    /**
     * (EXPERIMENTAL) Get memory item by id
     * @summary (EXPERIMENTAL) Get memory item
     * @param {SmartFunctionsApiGetMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    getMemoryItem(
        requestParameters: SmartFunctionsApiGetMemoryItemRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<MemoryItem>;

    /**
     * Returns metadata quality issues detected by the platform linter.
     * @summary Get Quality Issues
     * @param {SmartFunctionsApiGetQualityIssuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    getQualityIssues(
        requestParameters: SmartFunctionsApiGetQualityIssuesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<GetQualityIssuesResponse>;

    /**
     * (EXPERIMENTAL) Returns a list of memory items
     * @summary (EXPERIMENTAL) List all memory items
     * @param {SmartFunctionsApiListMemoryItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    listMemoryItems(
        requestParameters: SmartFunctionsApiListMemoryItemsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<MemoryItem>>;

    /**
     * (EXPERIMENTAL) Removes memory item
     * @summary (EXPERIMENTAL) Remove memory item
     * @param {SmartFunctionsApiRemoveMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    removeMemoryItem(
        requestParameters: SmartFunctionsApiRemoveMemoryItemRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Returns a list of available LLM Endpoints
     * @summary Get Active LLM Endpoints for this workspace
     * @param {SmartFunctionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    resolveLlmEndpoints(
        requestParameters: SmartFunctionsApiResolveLlmEndpointsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResolvedLlmEndpoints>;

    /**
     * Returns a list of tags for this workspace
     * @summary Get Analytics Catalog Tags
     * @param {SmartFunctionsApiTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    tags(
        requestParameters: SmartFunctionsApiTagsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnalyticsCatalogTags>;

    /**
     * (EXPERIMENTAL) Updates memory item and returns it
     * @summary (EXPERIMENTAL) Update memory item
     * @param {SmartFunctionsApiUpdateMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    updateMemoryItem(
        requestParameters: SmartFunctionsApiUpdateMemoryItemRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<MemoryItem>;

    /**
     * Validates LLM endpoint with provided parameters.
     * @summary Validate LLM Endpoint
     * @param {SmartFunctionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    validateLLMEndpoint(
        requestParameters: SmartFunctionsApiValidateLLMEndpointRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ValidateLLMEndpointResponse>;

    /**
     * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
     * @summary Validate LLM Endpoint By Id
     * @param {SmartFunctionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    validateLLMEndpointById(
        requestParameters: SmartFunctionsApiValidateLLMEndpointByIdRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ValidateLLMEndpointResponse>;
}

/**
 * Request parameters for aiChat operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiChatRequest
 */
export interface SmartFunctionsApiAiChatRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiChat
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof SmartFunctionsApiAiChat
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiChatHistory operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiChatHistoryRequest
 */
export interface SmartFunctionsApiAiChatHistoryRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiChatHistory
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatHistoryRequest}
     * @memberof SmartFunctionsApiAiChatHistory
     */
    readonly chatHistoryRequest: ChatHistoryRequest;
}

/**
 * Request parameters for aiChatStream operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiChatStreamRequest
 */
export interface SmartFunctionsApiAiChatStreamRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiChatStream
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof SmartFunctionsApiAiChatStream
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiChatUsage operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiChatUsageRequest
 */
export interface SmartFunctionsApiAiChatUsageRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiChatUsage
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for aiSearch operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiSearchRequest
 */
export interface SmartFunctionsApiAiSearchRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiSearch
     */
    readonly workspaceId: string;

    /**
     *
     * @type {SearchRequest}
     * @memberof SmartFunctionsApiAiSearch
     */
    readonly searchRequest: SearchRequest;
}

/**
 * Request parameters for anomalyDetection operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAnomalyDetectionRequest
 */
export interface SmartFunctionsApiAnomalyDetectionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly resultId: string;

    /**
     *
     * @type {AnomalyDetectionRequest}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly anomalyDetectionRequest: AnomalyDetectionRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for anomalyDetectionResult operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAnomalyDetectionResultRequest
 */
export interface SmartFunctionsApiAnomalyDetectionResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for clustering operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiClusteringRequest
 */
export interface SmartFunctionsApiClusteringRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiClustering
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof SmartFunctionsApiClustering
     */
    readonly resultId: string;

    /**
     *
     * @type {ClusteringRequest}
     * @memberof SmartFunctionsApiClustering
     */
    readonly clusteringRequest: ClusteringRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof SmartFunctionsApiClustering
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for clusteringResult operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiClusteringResultRequest
 */
export interface SmartFunctionsApiClusteringResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for createMemoryItem operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiCreateMemoryItemRequest
 */
export interface SmartFunctionsApiCreateMemoryItemRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiCreateMemoryItem
     */
    readonly workspaceId: string;

    /**
     *
     * @type {MemoryItem}
     * @memberof SmartFunctionsApiCreateMemoryItem
     */
    readonly memoryItem: MemoryItem;
}

/**
 * Request parameters for createdBy operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiCreatedByRequest
 */
export interface SmartFunctionsApiCreatedByRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiCreatedBy
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for forecast operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiForecastRequest
 */
export interface SmartFunctionsApiForecastRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiForecast
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof SmartFunctionsApiForecast
     */
    readonly resultId: string;

    /**
     *
     * @type {ForecastRequest}
     * @memberof SmartFunctionsApiForecast
     */
    readonly forecastRequest: ForecastRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof SmartFunctionsApiForecast
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for forecastResult operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiForecastResultRequest
 */
export interface SmartFunctionsApiForecastResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for getMemoryItem operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiGetMemoryItemRequest
 */
export interface SmartFunctionsApiGetMemoryItemRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiGetMemoryItem
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof SmartFunctionsApiGetMemoryItem
     */
    readonly memoryId: string;
}

/**
 * Request parameters for getQualityIssues operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiGetQualityIssuesRequest
 */
export interface SmartFunctionsApiGetQualityIssuesRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiGetQualityIssues
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for listMemoryItems operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiListMemoryItemsRequest
 */
export interface SmartFunctionsApiListMemoryItemsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiListMemoryItems
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for removeMemoryItem operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiRemoveMemoryItemRequest
 */
export interface SmartFunctionsApiRemoveMemoryItemRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiRemoveMemoryItem
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof SmartFunctionsApiRemoveMemoryItem
     */
    readonly memoryId: string;
}

/**
 * Request parameters for resolveLlmEndpoints operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiResolveLlmEndpointsRequest
 */
export interface SmartFunctionsApiResolveLlmEndpointsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiResolveLlmEndpoints
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for tags operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiTagsRequest
 */
export interface SmartFunctionsApiTagsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiTags
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for updateMemoryItem operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiUpdateMemoryItemRequest
 */
export interface SmartFunctionsApiUpdateMemoryItemRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiUpdateMemoryItem
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof SmartFunctionsApiUpdateMemoryItem
     */
    readonly memoryId: string;

    /**
     *
     * @type {MemoryItem}
     * @memberof SmartFunctionsApiUpdateMemoryItem
     */
    readonly memoryItem: MemoryItem;
}

/**
 * Request parameters for validateLLMEndpoint operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiValidateLLMEndpointRequest
 */
export interface SmartFunctionsApiValidateLLMEndpointRequest {
    /**
     *
     * @type {ValidateLLMEndpointRequest}
     * @memberof SmartFunctionsApiValidateLLMEndpoint
     */
    readonly validateLLMEndpointRequest: ValidateLLMEndpointRequest;
}

/**
 * Request parameters for validateLLMEndpointById operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiValidateLLMEndpointByIdRequest
 */
export interface SmartFunctionsApiValidateLLMEndpointByIdRequest {
    /**
     *
     * @type {string}
     * @memberof SmartFunctionsApiValidateLLMEndpointById
     */
    readonly llmEndpointId: string;

    /**
     *
     * @type {ValidateLLMEndpointByIdRequest}
     * @memberof SmartFunctionsApiValidateLLMEndpointById
     */
    readonly validateLLMEndpointByIdRequest?: ValidateLLMEndpointByIdRequest;
}

/**
 * SmartFunctionsApi - object-oriented interface
 * @export
 * @class SmartFunctionsApi
 * @extends {BaseAPI}
 */
export class SmartFunctionsApi extends BaseAPI implements SmartFunctionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiChat(requestParameters: SmartFunctionsApiAiChatRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .aiChat(requestParameters.workspaceId, requestParameters.chatRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {SmartFunctionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiChatHistory(
        requestParameters: SmartFunctionsApiAiChatHistoryRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .aiChatHistory(requestParameters.workspaceId, requestParameters.chatHistoryRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiChatStream(
        requestParameters: SmartFunctionsApiAiChatStreamRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .aiChatStream(requestParameters.workspaceId, requestParameters.chatRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns usage statistics of chat for a user in a workspace.
     * @summary Get Chat Usage
     * @param {SmartFunctionsApiAiChatUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiChatUsage(requestParameters: SmartFunctionsApiAiChatUsageRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .aiChatUsage(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {SmartFunctionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiSearch(requestParameters: SmartFunctionsApiAiSearchRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .aiSearch(requestParameters.workspaceId, requestParameters.searchRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {SmartFunctionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public anomalyDetection(
        requestParameters: SmartFunctionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .anomalyDetection(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.anomalyDetectionRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {SmartFunctionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public anomalyDetectionResult(
        requestParameters: SmartFunctionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .anomalyDetectionResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {SmartFunctionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public clustering(requestParameters: SmartFunctionsApiClusteringRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .clustering(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.clusteringRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {SmartFunctionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public clusteringResult(
        requestParameters: SmartFunctionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .clusteringResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Creates a new memory item and returns it
     * @summary (EXPERIMENTAL) Create new memory item
     * @param {SmartFunctionsApiCreateMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public createMemoryItem(
        requestParameters: SmartFunctionsApiCreateMemoryItemRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .createMemoryItem(requestParameters.workspaceId, requestParameters.memoryItem, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users who created any object for this workspace
     * @summary Get Analytics Catalog CreatedBy
     * @param {SmartFunctionsApiCreatedByRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public createdBy(requestParameters: SmartFunctionsApiCreatedByRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .createdBy(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public forecast(requestParameters: SmartFunctionsApiForecastRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .forecast(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.forecastRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public forecastResult(
        requestParameters: SmartFunctionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .forecastResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Get memory item by id
     * @summary (EXPERIMENTAL) Get memory item
     * @param {SmartFunctionsApiGetMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public getMemoryItem(
        requestParameters: SmartFunctionsApiGetMemoryItemRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .getMemoryItem(requestParameters.workspaceId, requestParameters.memoryId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metadata quality issues detected by the platform linter.
     * @summary Get Quality Issues
     * @param {SmartFunctionsApiGetQualityIssuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public getQualityIssues(
        requestParameters: SmartFunctionsApiGetQualityIssuesRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .getQualityIssues(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Returns a list of memory items
     * @summary (EXPERIMENTAL) List all memory items
     * @param {SmartFunctionsApiListMemoryItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public listMemoryItems(
        requestParameters: SmartFunctionsApiListMemoryItemsRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .listMemoryItems(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Removes memory item
     * @summary (EXPERIMENTAL) Remove memory item
     * @param {SmartFunctionsApiRemoveMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public removeMemoryItem(
        requestParameters: SmartFunctionsApiRemoveMemoryItemRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .removeMemoryItem(requestParameters.workspaceId, requestParameters.memoryId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of available LLM Endpoints
     * @summary Get Active LLM Endpoints for this workspace
     * @param {SmartFunctionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public resolveLlmEndpoints(
        requestParameters: SmartFunctionsApiResolveLlmEndpointsRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .resolveLlmEndpoints(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of tags for this workspace
     * @summary Get Analytics Catalog Tags
     * @param {SmartFunctionsApiTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public tags(requestParameters: SmartFunctionsApiTagsRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .tags(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Updates memory item and returns it
     * @summary (EXPERIMENTAL) Update memory item
     * @param {SmartFunctionsApiUpdateMemoryItemRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public updateMemoryItem(
        requestParameters: SmartFunctionsApiUpdateMemoryItemRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .updateMemoryItem(
                requestParameters.workspaceId,
                requestParameters.memoryId,
                requestParameters.memoryItem,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates LLM endpoint with provided parameters.
     * @summary Validate LLM Endpoint
     * @param {SmartFunctionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public validateLLMEndpoint(
        requestParameters: SmartFunctionsApiValidateLLMEndpointRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .validateLLMEndpoint(requestParameters.validateLLMEndpointRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
     * @summary Validate LLM Endpoint By Id
     * @param {SmartFunctionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public validateLLMEndpointById(
        requestParameters: SmartFunctionsApiValidateLLMEndpointByIdRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .validateLLMEndpointById(
                requestParameters.llmEndpointId,
                requestParameters.validateLLMEndpointByIdRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}
