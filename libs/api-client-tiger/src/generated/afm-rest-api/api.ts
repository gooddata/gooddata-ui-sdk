// (C) 2025-2026 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 */
export interface AFM {
    /**
     * Attributes to be used in the computation.
     */
    attributes: Array<AttributeItem>;
    /**
     * Various filter types to filter the execution result.
     */
    filters: Array<FilterDefinition>;
    /**
     * Metrics to be computed.
     */
    measures: Array<MeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     */
    auxMeasures?: Array<MeasureItem>;
}

/**
 * A datetime filter specifying exact from and to values.
 */
export interface AbsoluteDateFilter {
    absoluteDateFilter: AbsoluteDateFilterAbsoluteDateFilter;
}

export interface AbsoluteDateFilterAbsoluteDateFilter {
    from: string;
    to: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
    dataset: AfmObjectIdentifierDataset;
}

/**
 * @type AbstractMeasureValueFilter
 */
export type AbstractMeasureValueFilter =
    | ComparisonMeasureValueFilter
    | CompoundMeasureValueFilter
    | RangeMeasureValueFilter
    | RankingFilter;

/**
 * Object, with which the user is actively working.
 */
export interface ActiveObjectIdentification {
    /**
     * Object ID.
     */
    id: string;
    /**
     * Object type, e.g. dashboard.
     */
    type: string;
    /**
     * Workspace ID.
     */
    workspaceId: string;
}

/**
 * Any information related to cancellation.
 */
export interface AfmCancelTokens {
    /**
     * resultId to cancel token pairs
     */
    resultIdToCancelTokenPairs: { [key: string]: string };
}

export interface AfmExecution {
    execution: AFM;
    resultSpec: ResultSpec;
    settings?: ExecutionSettings;
}

/**
 * Response to AFM execution request
 */
export interface AfmExecutionResponse {
    executionResponse: ExecutionResponse;
}

/**
 * @type AfmIdentifier
 * Reference to the attribute label to which the filter should be applied.
 */
export type AfmIdentifier = AfmLocalIdentifier | AfmObjectIdentifier;

export interface AfmLocalIdentifier {
    localIdentifier: string;
}

/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 */
export interface AfmObjectIdentifier {
    identifier: AfmObjectIdentifierIdentifier;
}

/**
 * Reference to the date attribute to use.
 */
export interface AfmObjectIdentifierAttribute {
    identifier: AfmObjectIdentifierAttributeIdentifier;
}

export interface AfmObjectIdentifierAttributeIdentifier {
    id: string;
    type: AfmObjectIdentifierAttributeIdentifierTypeEnum;
}

export type AfmObjectIdentifierAttributeIdentifierTypeEnum = "attribute";

/**
 * Reference to the metric, fact or attribute object to use for the metric.
 */
export interface AfmObjectIdentifierCore {
    identifier: AfmObjectIdentifierCoreIdentifier;
}

export interface AfmObjectIdentifierCoreIdentifier {
    id: string;
    type: AfmObjectIdentifierCoreIdentifierTypeEnum;
}

export type AfmObjectIdentifierCoreIdentifierTypeEnum = "attribute" | "label" | "fact" | "metric";

/**
 * Reference to the date dataset to which the filter should be applied.
 */
export interface AfmObjectIdentifierDataset {
    identifier: AfmObjectIdentifierDatasetIdentifier;
}

export interface AfmObjectIdentifierDatasetIdentifier {
    id: string;
    type: AfmObjectIdentifierDatasetIdentifierTypeEnum;
}

export type AfmObjectIdentifierDatasetIdentifierTypeEnum = "dataset";

export interface AfmObjectIdentifierIdentifier {
    type: AfmObjectIdentifierIdentifierTypeEnum;
    id: string;
}

export type AfmObjectIdentifierIdentifierTypeEnum =
    | "analyticalDashboard"
    | "attribute"
    | "dashboardPlugin"
    | "dataset"
    | "fact"
    | "label"
    | "metric"
    | "prompt"
    | "visualizationObject"
    | "filterContext";

export interface AfmObjectIdentifierLabel {
    identifier: AfmObjectIdentifierLabelIdentifier;
}

export interface AfmObjectIdentifierLabelIdentifier {
    type: AfmObjectIdentifierLabelIdentifierTypeEnum;
    id: string;
}

export type AfmObjectIdentifierLabelIdentifierTypeEnum = "label";

/**
 * Entity describing the valid descendants request.
 */
export interface AfmValidDescendantsQuery {
    /**
     * List of identifiers of the attributes to get the valid descendants for.
     */
    attributes: Array<AfmObjectIdentifierAttribute>;
}

/**
 * Entity describing the valid descendants response.
 */
export interface AfmValidDescendantsResponse {
    /**
     * Map of attribute identifiers to list of valid descendants identifiers.
     */
    validDescendants: { [key: string]: Array<AfmObjectIdentifierAttribute> };
}

/**
 * Entity holding AFM and list of object types whose validity should be computed.
 */
export interface AfmValidObjectsQuery {
    types: Array<AfmValidObjectsQueryTypesEnum>;
    afm: AFM;
}

export type AfmValidObjectsQueryTypesEnum = "facts" | "attributes" | "measures";

/**
 * All objects of specified types valid with respect to given AFM.
 */
export interface AfmValidObjectsResponse {
    items: Array<RestApiIdentifier>;
}

export interface AnalyticsCatalogCreatedBy {
    /**
     * Users who created any object in the catalog
     */
    users: Array<AnalyticsCatalogUser>;
    /**
     * Reasoning for error states
     */
    reasoning: string;
}

export interface AnalyticsCatalogTags {
    tags: Array<string>;
}

/**
 * Users who created any object in the catalog
 */
export interface AnalyticsCatalogUser {
    /**
     * User ID of the user who created any objects
     */
    userId: string;
    /**
     * First name of the user who created any objects
     */
    firstname: string;
    /**
     * Last name of the user who created any objects
     */
    lastname: string;
}

export interface AnomalyDetectionRequest {
    /**
     * Anomaly detection sensitivity.
     */
    sensitivity: number;
}

export interface AnomalyDetectionResult {
    attribute: Array<string>;
    values: Array<number | null>;
    anomalyFlag: Array<boolean | null>;
}

/**
 * Metric representing arithmetics between other metrics.
 */
export interface ArithmeticMeasureDefinition {
    arithmeticMeasure: ArithmeticMeasureDefinitionArithmeticMeasure;
}

export interface ArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of metrics to apply arithmetic operation by chosen operator.
     */
    measureIdentifiers: Array<AfmLocalIdentifier>;
    /**
     * Arithmetic operator describing operation between metrics.
     */
    operator: ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

export type ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum =
    | "SUM"
    | "DIFFERENCE"
    | "MULTIPLICATION"
    | "RATIO"
    | "CHANGE";

export interface AttributeExecutionResultHeader {
    attributeHeader: AttributeResultHeader;
}

/**
 * @type AttributeFilter
 * Abstract filter definition type attributes
 */
export type AttributeFilter = NegativeAttributeFilter | PositiveAttributeFilter;

/**
 * Filter on specific set of label values.
 */
export interface AttributeFilterElements {
    /**
     * Set of label values.
     */
    values: Array<string | null>;
}

/**
 * Attribute format describes formatting information to effectively format attribute values when needed.
 */
export interface AttributeFormat {
    /**
     * Format locale code like \'en-US\', \'cs-CZ\', etc.
     */
    locale: string;
    /**
     * ICU formatting pattern like \'y\', \'dd.MM.y\', etc.
     */
    pattern: string;
    /**
     * Timezone for date formatting like \'America/New_York\', \'Europe/Prague\', etc.
     */
    timezone?: string;
}

export interface AttributeHeader {
    attributeHeader: AttributeHeaderAttributeHeader;
}

export interface AttributeHeaderAttributeHeader {
    /**
     * Local identifier of the attribute this header relates to.
     */
    localIdentifier: string;
    label: RestApiIdentifier;
    /**
     * Label name.
     */
    labelName: string;
    attribute: RestApiIdentifier;
    /**
     * Attribute name.
     */
    attributeName: string;
    /**
     * Date granularity of the attribute, only filled for date attributes.
     */
    granularity?: AttributeHeaderAttributeHeaderGranularityEnum;
    primaryLabel: RestApiIdentifier;
    format?: AttributeFormat;
    /**
     * Attribute value type.
     */
    valueType?: AttributeHeaderAttributeHeaderValueTypeEnum;
    geoAreaConfig?: GeoAreaConfig;
}

export type AttributeHeaderAttributeHeaderGranularityEnum =
    | "MINUTE"
    | "HOUR"
    | "DAY"
    | "WEEK"
    | "MONTH"
    | "QUARTER"
    | "YEAR"
    | "MINUTE_OF_HOUR"
    | "HOUR_OF_DAY"
    | "DAY_OF_WEEK"
    | "DAY_OF_MONTH"
    | "DAY_OF_QUARTER"
    | "DAY_OF_YEAR"
    | "WEEK_OF_YEAR"
    | "MONTH_OF_YEAR"
    | "QUARTER_OF_YEAR"
    | "FISCAL_MONTH"
    | "FISCAL_QUARTER"
    | "FISCAL_YEAR";
export type AttributeHeaderAttributeHeaderValueTypeEnum =
    | "TEXT"
    | "HYPERLINK"
    | "GEO"
    | "GEO_LONGITUDE"
    | "GEO_LATITUDE"
    | "GEO_AREA"
    | "IMAGE";

export interface AttributeItem {
    /**
     * Local identifier of the attribute. This can be used to reference the attribute in other parts of the execution definition.
     */
    localIdentifier: string;
    label: AfmObjectIdentifierLabel;
    /**
     * Indicates whether to show all values of given attribute even if the data bound to those values is not available.
     */
    showAllValues?: boolean;
}

export interface AttributeNegativeFilter {
    using: string;
    exclude: Array<string>;
}

export interface AttributePositiveFilter {
    using: string;
    include: Array<string>;
}

/**
 * Header containing the information related to attributes.
 */
export interface AttributeResultHeader {
    /**
     * A value of the current attribute label.
     */
    labelValue: string;
    /**
     * A value of the primary attribute label.
     */
    primaryLabelValue: string;
}

/**
 * Bounding filter for this relative date filter. This can be used to limit the range of the relative date filter to a specific date range.
 */
export interface BoundedFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: BoundedFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\'). If null, then start of the range is unbounded.
     */
    from?: number | null;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...). If null, then end of the range is unbounded.
     */
    to?: number | null;
}

export type BoundedFilterGranularityEnum =
    | "MINUTE"
    | "HOUR"
    | "DAY"
    | "WEEK"
    | "MONTH"
    | "QUARTER"
    | "YEAR"
    | "MINUTE_OF_HOUR"
    | "HOUR_OF_DAY"
    | "DAY_OF_WEEK"
    | "DAY_OF_MONTH"
    | "DAY_OF_QUARTER"
    | "DAY_OF_YEAR"
    | "WEEK_OF_YEAR"
    | "MONTH_OF_YEAR"
    | "QUARTER_OF_YEAR"
    | "FISCAL_MONTH"
    | "FISCAL_QUARTER"
    | "FISCAL_YEAR";

/**
 * Change analysis specification.
 */
export interface ChangeAnalysisParams {
    measure: MeasureItem;
    /**
     * The title of the measure being analyzed
     */
    measureTitle: string;
    dateAttribute: AttributeItem;
    /**
     * The reference time period
     */
    referencePeriod: string;
    /**
     * The analyzed time period
     */
    analyzedPeriod: string;
    /**
     * Attributes to analyze for significant changes
     */
    attributes: Array<AttributeItem>;
    /**
     * Optional filters to apply
     */
    filters: Array<OutlierDetectionRequestFiltersInner>;
    /**
     * Whether to use smart attribute selection
     */
    useSmartAttributeSelection: boolean;
}

/**
 * Request for change analysis computation
 */
export interface ChangeAnalysisRequest {
    measure: MeasureItem;
    dateAttribute: AttributeItem;
    /**
     * The reference time period (e.g., \'2025-01\')
     */
    referencePeriod: string;
    /**
     * The analyzed time period (e.g., \'2025-02\')
     */
    analyzedPeriod: string;
    /**
     * Attributes to analyze for significant changes. If empty, valid attributes will be automatically discovered.
     */
    attributes?: Array<AttributeItem>;
    /**
     * Optional filters to apply.
     */
    filters?: Array<OutlierDetectionRequestFiltersInner>;
    /**
     * Auxiliary measures
     */
    auxMeasures?: Array<MeasureItem>;
    /**
     * Whether to use smart attribute selection (LLM-based) instead of discovering all valid attributes. If true, GenAI will intelligently select the most relevant attributes for change analysis. If false or not set, all valid attributes will be discovered using Calcique. Smart attribute selection applies only when no attributes are provided.
     */
    useSmartAttributeSelection?: boolean;
    /**
     * Only include attributes with at least one of these tags. If empty, no inclusion filter is applied. This filter applies to both auto-discovered and explicitly provided attributes.
     */
    includeTags?: Array<string>;
    /**
     * Exclude attributes with any of these tags. This filter applies to both auto-discovered and explicitly provided attributes.
     */
    excludeTags?: Array<string>;
}

/**
 * Response for change analysis computation
 */
export interface ChangeAnalysisResponse {
    links: ExecutionLinks;
}

/**
 * Result of a change analysis execution.
 */
export interface ChangeAnalysisResult {
    /**
     * The change analysis result data containing significant changes.
     */
    data: Array<MetricValueChange>;
}

/**
 * List of chat history interactions.
 */
export interface ChatHistoryInteraction {
    /**
     * User question
     */
    question: string;
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     */
    threadIdSuffix?: string;
    /**
     * Chat History interaction ID. Unique ID for each interaction.
     */
    chatHistoryInteractionId: string;
    /**
     * Has the interaction already finished? Can be used for polling when interaction is in progress.
     */
    interactionFinished: boolean;
    routing: RouteResult;
    /**
     * Text response for general questions.
     */
    textResponse?: string;
    /**
     * Error response in anything fails.
     */
    errorResponse?: string;
    foundObjects?: FoundObjects;
    semanticSearch?: SearchResult;
    createdVisualizations?: CreatedVisualizations;
    changeAnalysisParams?: ChangeAnalysisParams;
    /**
     * User feedback.
     */
    userFeedback?: ChatHistoryInteractionUserFeedbackEnum;
    reasoning?: Reasoning;
}

export type ChatHistoryInteractionUserFeedbackEnum = "POSITIVE" | "NEGATIVE" | "NONE";

export interface ChatHistoryRequest {
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     */
    threadIdSuffix?: string;
    /**
     * Return chat history records only after this interaction ID. If empty, complete chat history is returned.
     */
    chatHistoryInteractionId?: string;
    /**
     * User feedback.
     */
    userFeedback?: ChatHistoryRequestUserFeedbackEnum;
    /**
     * User feedback.
     */
    reset?: boolean;
    savedVisualization?: SavedVisualization;
    /**
     * Response state indicating the outcome of the AI interaction.
     */
    responseState?: ChatHistoryRequestResponseStateEnum;
    /**
     * User text feedback for the interaction.
     */
    userTextFeedback?: string;
}

export type ChatHistoryRequestUserFeedbackEnum = "POSITIVE" | "NEGATIVE" | "NONE";
export type ChatHistoryRequestResponseStateEnum =
    | "SUCCESSFUL"
    | "UNEXPECTED_ERROR"
    | "NOT_FOUND_ATTRIBUTES"
    | "TOO_MANY_DATA_POINTS"
    | "NO_DATA"
    | "NO_RESULTS"
    | "OUT_OF_TOPIC";

export interface ChatHistoryResult {
    /**
     * List of chat history interactions.
     */
    interactions: Array<ChatHistoryInteraction>;
    /**
     * The conversation thread ID.
     */
    threadId: string;
}

export interface ChatRequest {
    /**
     * User question
     */
    question: string;
    /**
     * Maximum number of search results.
     */
    limitSearch?: number;
    /**
     * Maximum number of relevant objects included into context for LLM (for each object type).
     */
    limitCreateContext?: number;
    /**
     * Maximum number of created results.
     */
    limitCreate?: number;
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     */
    threadIdSuffix?: string;
    userContext?: UserContext;
    /**
     * Temporary for experiments. Ratio of title score to descriptor score.
     */
    titleToDescriptorRatio?: number;
    /**
     * Score, above which we return found object(s) and don\'t call LLM to create new objects.
     */
    searchScoreThreshold?: number;
    /**
     * Score, above which we return found objects. Below this score objects are not relevant.
     */
    relevantScoreThreshold?: number;
    /**
     * If true, includes hidden objects in search and visualization building. If false (default), excludes objects where isHidden=true.
     */
    includeHidden?: boolean;
    /**
     * List of object types to filter the search and visualization building. If empty or null, all object types are considered.
     */
    objectTypes?: Array<ChatRequestObjectTypesEnum>;
}

export type ChatRequestObjectTypesEnum =
    | "attribute"
    | "metric"
    | "fact"
    | "label"
    | "date"
    | "dataset"
    | "visualization"
    | "dashboard";

export interface ChatResult {
    routing?: RouteResult;
    /**
     * Text response for general questions.
     */
    textResponse?: string;
    /**
     * Error response in anything fails.
     */
    errorResponse?: string;
    foundObjects?: FoundObjects;
    createdVisualizations?: CreatedVisualizations;
    changeAnalysisParams?: ChangeAnalysisParams;
    semanticSearch?: SearchResult;
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     */
    threadIdSuffix?: string;
    /**
     * Chat History interaction ID. Unique ID for each interaction.
     */
    chatHistoryInteractionId?: string;
    reasoning?: Reasoning;
}

export interface ChatUsageResponse {
    /**
     * Number of interactions in the time window
     */
    interactionCount: number;
    /**
     * Maximum number of interactions in the time window any user can do in the workspace
     */
    interactionLimit: number;
    /**
     * Time window in hours
     */
    timeWindowHours: number;
}

export interface ClusteringRequest {
    /**
     * Number of clusters to create
     */
    numberOfClusters: number;
    /**
     * Threshold used for algorithm
     */
    threshold?: number;
}

export interface ClusteringResult {
    attribute: Array<object>;
    xCoord?: Array<number | null>;
    yCoord?: Array<number | null>;
    clusters: Array<number | null>;
    ycoord: Array<number>;
    xcoord: Array<number>;
}

/**
 * Condition that compares the metric value to a given constant value using a comparison operator.
 */
export interface ComparisonCondition {
    comparison: ComparisonConditionComparison;
}

export interface ComparisonConditionComparison {
    operator: ComparisonConditionComparisonOperatorEnum;
    value: number;
}

export type ComparisonConditionComparisonOperatorEnum =
    | "GREATER_THAN"
    | "GREATER_THAN_OR_EQUAL_TO"
    | "LESS_THAN"
    | "LESS_THAN_OR_EQUAL_TO"
    | "EQUAL_TO"
    | "NOT_EQUAL_TO";

/**
 * Filter the result by comparing specified metric to given constant value, using given comparison operator.
 */
export interface ComparisonMeasureValueFilter {
    comparisonMeasureValueFilter: ComparisonMeasureValueFilterComparisonMeasureValueFilter;
}

export interface ComparisonMeasureValueFilterComparisonMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum;
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: AfmIdentifier;
}

export type ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum =
    | "GREATER_THAN"
    | "GREATER_THAN_OR_EQUAL_TO"
    | "LESS_THAN"
    | "LESS_THAN_OR_EQUAL_TO"
    | "EQUAL_TO"
    | "NOT_EQUAL_TO";

/**
 * Filter the result by applying multiple comparison and/or range conditions combined with OR logic. If conditions list is empty, no filtering is applied (all rows are returned).
 */
export interface CompoundMeasureValueFilter {
    compoundMeasureValueFilter: CompoundMeasureValueFilterCompoundMeasureValueFilter;
}

export interface CompoundMeasureValueFilterCompoundMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    /**
     * List of conditions to apply. Conditions are combined with OR logic. Each condition can be either a comparison (e.g., > 100) or a range (e.g., BETWEEN 10 AND 50). If empty, no filtering is applied and all rows are returned.
     */
    conditions: Array<MeasureValueCondition>;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: AfmIdentifier;
}

/**
 * List of created visualization objects
 */
export interface CreatedVisualization {
    /**
     * Proposed ID of the new visualization
     */
    id: string;
    /**
     * Proposed title of the new visualization
     */
    title: string;
    /**
     * Visualization type requested in question
     */
    visualizationType: CreatedVisualizationVisualizationTypeEnum;
    /**
     * List of metrics to be used in the new visualization
     */
    metrics: Array<Metric>;
    /**
     * List of attributes representing the dimensionality of the new visualization
     */
    dimensionality: Array<DimAttribute>;
    /**
     * List of filters to be applied to the new visualization
     */
    filters: Array<CreatedVisualizationFiltersInner>;
    /**
     * Suggestions for next steps
     */
    suggestions: Array<Suggestion>;
    /**
     * Saved visualization ID.
     */
    savedVisualizationId?: string;
}

export type CreatedVisualizationVisualizationTypeEnum =
    | "TABLE"
    | "HEADLINE"
    | "BAR"
    | "LINE"
    | "PIE"
    | "COLUMN";

/**
 * @type CreatedVisualizationFiltersInner
 */
export type CreatedVisualizationFiltersInner =
    | AttributeNegativeFilter
    | AttributePositiveFilter
    | DateAbsoluteFilter
    | DateRelativeFilter
    | RankingFilter;

/**
 * Visualization definitions created by AI.
 */
export interface CreatedVisualizations {
    /**
     * List of created visualization objects
     */
    objects: Array<CreatedVisualization>;
    /**
     * DEPRECATED: Use top-level reasoning.steps instead. Reasoning from LLM. Description of how and why the answer was generated.
     */
    reasoning: string;
    /**
     * List of suggestions for next steps. Filled when no visualization was created, suggests alternatives.
     */
    suggestions: Array<Suggestion>;
}

/**
 * Mapping from dimension items (either \'localIdentifier\' from \'AttributeItem\', or \"measureGroup\") to their respective values. This effectively specifies the path (location) of the data column used for sorting. Therefore values for all dimension items must be specified.
 */
export interface DataColumnLocator {
    /**
     * Mapping from dimension items (either \'localIdentifier\' from \'AttributeItem\', or \"measureGroup\") to their respective values. This effectively specifies the path (location) of the data column used for sorting. Therefore values for all dimension items must be specified.
     */
    properties: { [key: string]: string };
}

/**
 * Data column locators for the values.
 */
export interface DataColumnLocators {
    /**
     * Mapping from dimensions to data column locators.
     */
    properties?: { [key: string]: DataColumnLocator };
}

export interface DateAbsoluteFilter {
    using: string;
    from: string;
    to: string;
}

/**
 * @type DateFilter
 * Abstract filter definition type for dates.
 */
export type DateFilter = AbsoluteDateFilter | RelativeDateFilter;

export interface DateRelativeFilter {
    using: string;
    granularity: DateRelativeFilterGranularityEnum;
    from: number;
    to: number;
}

export type DateRelativeFilterGranularityEnum =
    | "MINUTE"
    | "HOUR"
    | "DAY"
    | "WEEK"
    | "MONTH"
    | "QUARTER"
    | "YEAR"
    | "MINUTE_OF_HOUR"
    | "HOUR_OF_DAY"
    | "DAY_OF_WEEK"
    | "DAY_OF_MONTH"
    | "DAY_OF_QUARTER"
    | "DAY_OF_YEAR"
    | "WEEK_OF_YEAR"
    | "MONTH_OF_YEAR"
    | "QUARTER_OF_YEAR"
    | "FISCAL_MONTH"
    | "FISCAL_QUARTER"
    | "FISCAL_YEAR";

/**
 * Filter definition type specified by label and values.
 */
export interface DependsOn {
    /**
     * Specifies on which label the filter depends on.
     */
    label: string;
    /**
     * Specifies values of the label for element filtering.
     */
    values: Array<string | null>;
    /**
     * Inverse filtering mode.
     */
    complementFilter?: boolean;
}

/**
 * Filter definition type for dates.
 */
export interface DependsOnDateFilter {
    dateFilter: DateFilter;
}

/**
 * List of attributes representing the dimensionality of the new visualization
 */
export interface DimAttribute {
    /**
     * ID of the object
     */
    id: string;
    /**
     * Object type
     */
    type: DimAttributeTypeEnum;
    /**
     * Title of attribute.
     */
    title: string;
}

export type DimAttributeTypeEnum = "attribute";

/**
 * Single dimension description.
 */
export interface Dimension {
    /**
     * Dimension identification within requests. Other entities can reference this dimension by this value.
     */
    localIdentifier?: string;
    /**
     * List of items in current dimension. Can reference \'localIdentifier\' from \'AttributeItem\', or special pseudo attribute \"measureGroup\" representing list of metrics.
     */
    itemIdentifiers: Array<string>;
    /**
     * List of sorting rules. From most relevant to least relevant (less relevant rule is applied, when more relevant rule compares items as equal).
     */
    sorting?: Array<SortKey>;
}

/**
 * Contains the dimension-specific header information.
 */
export interface DimensionHeader {
    /**
     * An array containing header groups.
     */
    headerGroups: Array<HeaderGroup>;
}

/**
 * List of returned elements.
 */
export interface Element {
    /**
     * Title of requested label.
     */
    title: string | null;
    /**
     * Title of primary label of attribute owning requested label, null if the title is null or the primary label is excluded
     */
    primaryTitle: string | null;
}

export interface ElementsRequest {
    /**
     * Requested label.
     */
    label: string;
    /**
     * Excludes items from the result that differ only by primary label * ```false``` - return items with distinct primary label * ```true``` - return items with distinct requested label
     */
    excludePrimaryLabel?: boolean;
    filterBy?: FilterBy;
    /**
     * Sort order of returned items. Items are sorted by ```label``` title. If no sort order is specified then attribute\'s ```sortDirection``` is used, which is ASC by default
     */
    sortOrder?: ElementsRequestSortOrderEnum;
    /**
     * Inverse filters: * ```false``` - return items matching ```patternFilter``` and ```exactFilter``` * ```true``` - return items not matching ```patternFilter``` and ```exactFilter```
     */
    complementFilter?: boolean;
    /**
     * Return only items, whose ```label``` title case insensitively contains ```filter``` as substring.
     */
    patternFilter?: string;
    /**
     * Return only items, whose ```label``` title exactly matches one of ```filter```.
     */
    exactFilter?: Array<string | null>;
    /**
     * Return only items that are not filtered-out by the parent filters.
     */
    dependsOn?: Array<ElementsRequestDependsOnInner>;
    /**
     * Return only items that are computable on metric.
     */
    validateBy?: Array<ValidateByItem>;
    /**
     * Specifies percentage of source table data scanned during the computation. This field is deprecated and is no longer used during the elements computation.
     * @deprecated
     */
    dataSamplingPercentage?: number;
    /**
     * If specified, the element data will be taken from the result with the same cacheId if it is available.
     */
    cacheId?: string;
}

export type ElementsRequestSortOrderEnum = "ASC" | "DESC";

/**
 * @type ElementsRequestDependsOnInner
 */
export type ElementsRequestDependsOnInner = DependsOn | DependsOnDateFilter;

/**
 * Entity holding list of sorted & filtered label elements, related primary label of attribute owning requested label and paging.
 */
export interface ElementsResponse {
    primaryLabel: RestApiIdentifier;
    /**
     * List of returned elements.
     */
    elements: Array<Element>;
    paging: Paging;
    /**
     * Granularity of requested label in case of date attribute
     */
    granularity?: ElementsResponseGranularityEnum;
    format?: AttributeFormat;
    /**
     * The client can use this in subsequent requests (like paging or search) to get results from the same point in time as the previous request. This is useful when the underlying data source has caches disabled and the client wants to avoid seeing inconsistent results and to also avoid excessive queries to the database itself.
     */
    cacheId?: string;
}

export type ElementsResponseGranularityEnum =
    | "MINUTE"
    | "HOUR"
    | "DAY"
    | "WEEK"
    | "MONTH"
    | "QUARTER"
    | "YEAR"
    | "MINUTE_OF_HOUR"
    | "HOUR_OF_DAY"
    | "DAY_OF_WEEK"
    | "DAY_OF_MONTH"
    | "DAY_OF_QUARTER"
    | "DAY_OF_YEAR"
    | "WEEK_OF_YEAR"
    | "MONTH_OF_YEAR"
    | "QUARTER_OF_YEAR"
    | "FISCAL_MONTH"
    | "FISCAL_QUARTER"
    | "FISCAL_YEAR";

/**
 * Links to the execution result.
 */
export interface ExecutionLinks {
    /**
     * Link to the result data.
     */
    executionResult: string;
}

/**
 * Response to AFM execution request body
 */
export interface ExecutionResponse {
    /**
     * Dimensions of the result
     */
    dimensions: Array<ResultDimension>;
    links: ExecutionLinks;
}

/**
 * Contains the result of an AFM execution.
 */
export interface ExecutionResult {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     */
    data: Array<object>;
    /**
     * An array containing dimension headers. The size of the array corresponds to the number of dimensions. Their order corresponds to the dimension order in the execution result spec.
     */
    dimensionHeaders: Array<DimensionHeader>;
    grandTotals: Array<ExecutionResultGrandTotal>;
    paging: ExecutionResultPaging;
    metadata: ExecutionResultMetadata;
}

/**
 * A piece of extra information related to the results (e.g. debug information, warnings, etc.).
 */
export interface ExecutionResultDataSourceMessage {
    /**
     * Id correlating different pieces of supplementary info together.
     */
    correlationId: string;
    /**
     * Information about what part of the system created this piece of supplementary info.
     */
    source: string;
    /**
     * Type of the supplementary info instance. There are currently no well-known values for this, but there might be some in the future.
     */
    type: string;
    /**
     * Data of this particular supplementary info item: a free-form JSON specific to the particular supplementary info item type.
     */
    data?: object;
}

/**
 * Contains the data of grand totals with the same dimensions.
 */
export interface ExecutionResultGrandTotal {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     */
    data: Array<object>;
    /**
     * Contains headers for a subset of `totalDimensions` in which the totals are grand totals.
     */
    dimensionHeaders: Array<DimensionHeader>;
    /**
     * Dimensions of the grand totals.
     */
    totalDimensions: Array<string>;
}

/**
 * @type ExecutionResultHeader
 * Abstract execution result header
 */
export type ExecutionResultHeader =
    | AttributeExecutionResultHeader
    | MeasureExecutionResultHeader
    | TotalExecutionResultHeader;

/**
 * Additional metadata for the particular execution result.
 */
export interface ExecutionResultMetadata {
    /**
     * Additional information sent by the underlying data source.
     */
    dataSourceMessages: Array<ExecutionResultDataSourceMessage>;
}

/**
 * A paging information related to the data presented in the execution result. These paging information are multi-dimensional.
 */
export interface ExecutionResultPaging {
    /**
     * A count of the returned results in every dimension.
     */
    count: Array<number>;
    /**
     * The offset of the results returned in every dimension.
     */
    offset: Array<number>;
    /**
     * A total count of the results in every dimension.
     */
    total: Array<number>;
}

/**
 * Various settings affecting the process of AFM execution or its result
 */
export interface ExecutionSettings {
    /**
     * Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     */
    dataSamplingPercentage?: number;
    /**
     * Specifies the timestamp of the execution from which relative filters are resolved. If not set, the current time is used.
     */
    timestamp?: string;
}

/**
 * Specifies what is used for filtering.
 */
export interface FilterBy {
    /**
     * Specifies which label is used for filtering - primary or requested.
     */
    labelType?: FilterByLabelTypeEnum;
}

export type FilterByLabelTypeEnum = "PRIMARY" | "REQUESTED";

/**
 * @type FilterDefinition
 * Abstract filter definition type
 */
export type FilterDefinition =
    | AbsoluteDateFilter
    | ComparisonMeasureValueFilter
    | CompoundMeasureValueFilter
    | InlineFilterDefinition
    | NegativeAttributeFilter
    | PositiveAttributeFilter
    | RangeMeasureValueFilter
    | RankingFilter
    | RelativeDateFilter;

/**
 * @type FilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple metric.
 */
export type FilterDefinitionForSimpleMeasure = AttributeFilter | DateFilter;

export interface ForecastRequest {
    /**
     * Number of future periods that should be forecasted
     */
    forecastPeriod: number;
    /**
     * Confidence interval boundary value.
     */
    confidenceLevel?: number;
    /**
     * Whether the input data is seasonal
     */
    seasonal?: boolean;
}

export interface ForecastResult {
    attribute: Array<string>;
    origin: Array<number | null>;
    prediction: Array<number | null>;
    lowerBound: Array<number | null>;
    upperBound: Array<number | null>;
}

/**
 * List of objects found by similarity search and post-processed by LLM.
 */
export interface FoundObjects {
    /**
     * List of objects found with a similarity search.
     */
    objects: Array<SearchResultObject>;
    /**
     * DEPRECATED: Use top-level reasoning.steps instead. Reasoning from LLM. Description of how and why the answer was generated.
     */
    reasoning: string;
}

/**
 * Configuration specific to geo area labels.
 */
export interface GeoAreaConfig {
    collection: GeoCollectionIdentifier;
}

export interface GeoCollectionIdentifier {
    /**
     * Geo collection identifier.
     */
    id: string;
    /**
     * Type of geo collection.
     */
    kind?: GeoCollectionIdentifierKindEnum;
}

export type GeoCollectionIdentifierKindEnum = "STATIC" | "CUSTOM";

export interface GetQualityIssuesResponse {
    /**
     * List of quality issues found in the workspace
     */
    issues: Array<QualityIssue>;
    /**
     * Timestamp when the quality issues were last updated (ISO format)
     */
    updatedAt?: string;
    /**
     * Status of the latest triggered quality check process
     */
    status: GetQualityIssuesResponseStatusEnum;
}

export type GetQualityIssuesResponseStatusEnum =
    | "RUNNING"
    | "COMPLETED"
    | "FAILED"
    | "NOT_FOUND"
    | "DISABLED";

/**
 * Contains the information specific for a group of headers. These groups correlate to attributes and metric groups.
 */
export interface HeaderGroup {
    /**
     * An array containing headers.
     */
    headers: Array<ExecutionResultHeader>;
}

/**
 * Filter in form of direct MAQL query.
 */
export interface InlineFilterDefinition {
    inline: InlineFilterDefinitionInline;
}

export interface InlineFilterDefinitionInline {
    /**
     * MAQL query representing the filter.
     */
    filter: string;
    localIdentifier?: string;
    applyOnResult?: boolean;
}

/**
 * Metric defined by the raw MAQL query.
 */
export interface InlineMeasureDefinition {
    inline: InlineMeasureDefinitionInline;
}

export interface InlineMeasureDefinitionInline {
    /**
     * MAQL query defining the metric.
     */
    maql: string;
}

export interface KeyDriversDimension {
    label: RestApiIdentifier;
    labelName: string;
    attribute: RestApiIdentifier;
    attributeName: string;
    granularity?: KeyDriversDimensionGranularityEnum;
    format?: AttributeFormat;
    valueType?: KeyDriversDimensionValueTypeEnum;
}

export type KeyDriversDimensionGranularityEnum =
    | "MINUTE"
    | "HOUR"
    | "DAY"
    | "WEEK"
    | "MONTH"
    | "QUARTER"
    | "YEAR"
    | "MINUTE_OF_HOUR"
    | "HOUR_OF_DAY"
    | "DAY_OF_WEEK"
    | "DAY_OF_MONTH"
    | "DAY_OF_QUARTER"
    | "DAY_OF_YEAR"
    | "WEEK_OF_YEAR"
    | "MONTH_OF_YEAR"
    | "QUARTER_OF_YEAR"
    | "FISCAL_MONTH"
    | "FISCAL_QUARTER"
    | "FISCAL_YEAR";
export type KeyDriversDimensionValueTypeEnum =
    | "TEXT"
    | "HYPERLINK"
    | "GEO"
    | "GEO_LONGITUDE"
    | "GEO_LATITUDE"
    | "GEO_AREA"
    | "IMAGE";

export interface KeyDriversRequest {
    metric: MeasureItem;
    /**
     * Additional metrics to be included in the computation, but excluded from the analysis.
     */
    auxMetrics?: Array<MeasureItem>;
    /**
     * Sorting elements - ascending/descending order.
     */
    sortDirection?: KeyDriversRequestSortDirectionEnum;
}

export type KeyDriversRequestSortDirectionEnum = "ASC" | "DESC";

export interface KeyDriversResponse {
    dimensions: Array<KeyDriversDimension>;
    links: ExecutionLinks;
}

export interface KeyDriversResult {
    data: object;
}

/**
 * @type MeasureDefinition
 * Abstract metric definition type
 */
export type MeasureDefinition =
    | ArithmeticMeasureDefinition
    | InlineMeasureDefinition
    | PopMeasureDefinition
    | SimpleMeasureDefinition;

export interface MeasureExecutionResultHeader {
    measureHeader: MeasureResultHeader;
}

/**
 * Measure group headers
 */
export interface MeasureGroupHeaders {
    measureGroupHeaders?: Array<MeasureHeader>;
}

export interface MeasureHeader {
    /**
     * Local identifier of the measure this header relates to.
     */
    localIdentifier: string;
    /**
     * Format to be used to format the measure data.
     */
    format?: string;
    /**
     * Name of the measure.
     */
    name?: string;
}

/**
 * Metric is a quantity that is calculated from the data.
 */
export interface MeasureItem {
    /**
     * Local identifier of the metric. This can be used to reference the metric in other parts of the execution definition.
     */
    localIdentifier: string;
    definition: MeasureDefinition;
}

/**
 * Header containing the information related to metrics.
 */
export interface MeasureResultHeader {
    /**
     * Metric index. Starts at 0.
     */
    measureIndex: number;
}

/**
 * @type MeasureValueCondition
 * A condition for filtering by measure value. Can be either a comparison or a range condition.
 */
export type MeasureValueCondition = ComparisonCondition | RangeCondition;

/**
 * @type MeasureValueFilter
 * Abstract filter definition type filtering by the value of the metric.
 */
export type MeasureValueFilter =
    | ComparisonMeasureValueFilter
    | CompoundMeasureValueFilter
    | RangeMeasureValueFilter;

export interface MemoryItemCreatedByUsers {
    /**
     * Users who created memory item
     */
    users: Array<MemoryItemUser>;
    /**
     * Reasoning for error states
     */
    reasoning: string;
}

/**
 * Users who created memory item
 */
export interface MemoryItemUser {
    /**
     * User ID of the user who created memory item
     */
    userId: string;
    /**
     * First name of the user who created memory item
     */
    firstname: string;
    /**
     * Last name of the user who created memory item
     */
    lastname: string;
}

/**
 * List of metrics to be used in the new visualization
 */
export interface Metric {
    /**
     * ID of the object
     */
    id: string;
    /**
     * Object type
     */
    type: MetricTypeEnum;
    /**
     * Title of metric.
     */
    title: string;
    /**
     * Agg function. Empty if a stored metric is used.
     */
    aggFunction?: MetricAggFunctionEnum;
}

export type MetricTypeEnum = "metric" | "fact" | "attribute";
export type MetricAggFunctionEnum = "COUNT" | "SUM" | "MIN" | "MAX" | "AVG" | "MEDIAN";

/**
 * Individual change analysis data item
 */
export interface MetricValueChange {
    /**
     * The name of the attribute being analyzed
     */
    attributeName: string;
    /**
     * The value of the attribute being analyzed
     */
    attributeValue: string;
    /**
     * The metric value in the analyzed period
     */
    metricValueInAnalyzedPeriod: number;
    /**
     * The metric value in the reference period
     */
    metricValueInReferencePeriod: number;
    /**
     * The delta between analyzed and reference periods
     */
    metricValueDelta: number;
    /**
     * The absolute delta between analyzed and reference periods
     */
    metricValueDeltaAbs: number;
    /**
     * The mean of attribute value changes for the attribute being analyzed
     */
    attributeValuesChangeMean: number;
    /**
     * The standard deviation of attribute value changes for the attribute being analyzed
     */
    attributeValuesChangeStd: number;
    /**
     * Whether the change is statistically significant
     */
    isSignificantChange: boolean;
    /**
     * The overall metric value in the analyzed period
     */
    overallMetricValueInAnalyzedPeriod: number;
    /**
     * The overall metric value in the reference period
     */
    overallMetricValueInReferencePeriod: number;
}

/**
 * Filter able to limit element values by label and related selected negated elements.
 */
export interface NegativeAttributeFilter {
    negativeAttributeFilter: NegativeAttributeFilterNegativeAttributeFilter;
}

export interface NegativeAttributeFilterNegativeAttributeFilter {
    notIn: AttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: AfmIdentifier;
}

export interface OutlierDetectionRequest {
    /**
     * Attributes to be used in the computation.
     */
    attributes: Array<AttributeItem>;
    /**
     * Various filter types to filter the execution result.
     */
    filters: Array<OutlierDetectionRequestFiltersInner>;
    measures: Array<MeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     */
    auxMeasures?: Array<MeasureItem>;
    /**
     * Sensitivity level for outlier detection
     */
    sensitivity: OutlierDetectionRequestSensitivityEnum;
    /**
     * Date granularity for anomaly detection. Only time-based granularities are supported (HOUR, DAY, WEEK, MONTH, QUARTER, YEAR).
     */
    granularity: OutlierDetectionRequestGranularityEnum;
}

export type OutlierDetectionRequestSensitivityEnum = "LOW" | "MEDIUM" | "HIGH";
export type OutlierDetectionRequestGranularityEnum = "HOUR" | "DAY" | "WEEK" | "MONTH" | "QUARTER" | "YEAR";

/**
 * @type OutlierDetectionRequestFiltersInner
 */
export type OutlierDetectionRequestFiltersInner =
    | AbstractMeasureValueFilter
    | FilterDefinitionForSimpleMeasure
    | InlineFilterDefinition;

export interface OutlierDetectionResponse {
    links: ExecutionLinks;
}

export interface OutlierDetectionResult {
    /**
     * Attribute values for outlier detection results.
     */
    attribute: Array<string> | null;
    /**
     * Map of measure identifiers to their outlier detection values. Each value is a list of nullable numbers.
     */
    values: { [key: string]: Array<number | null> | null } | null;
}

/**
 * Current page description.
 */
export interface Paging {
    /**
     * Count of returnable items ignoring paging.
     */
    total: number;
    /**
     * Count of items in this page.
     */
    count: number;
    /**
     * Offset of this page.
     */
    offset: number;
    /**
     * Link to next page, or null if this is last page.
     */
    next?: string;
}

/**
 * Combination of the date data set to use and how many periods ago to calculate the previous period for.
 */
export interface PopDataset {
    dataset: AfmObjectIdentifierDataset;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}

/**
 * Previous period type of metric.
 */
export interface PopDatasetMeasureDefinition {
    previousPeriodMeasure: PopDatasetMeasureDefinitionPreviousPeriodMeasure;
}

export interface PopDatasetMeasureDefinitionPreviousPeriodMeasure {
    measureIdentifier: AfmLocalIdentifier;
    /**
     * Specification of which date data sets to use for determining the period to calculate the previous period for.
     */
    dateDatasets: Array<PopDataset>;
}

/**
 * Combination of the date attribute to use and how many periods ago to calculate the PoP for.
 */
export interface PopDate {
    attribute: AfmObjectIdentifierAttribute;
    /**
     * Number of periods ago to calculate the previous period for.
     */
    periodsAgo: number;
}

/**
 * Period over period type of metric.
 */
export interface PopDateMeasureDefinition {
    overPeriodMeasure: PopDateMeasureDefinitionOverPeriodMeasure;
}

export interface PopDateMeasureDefinitionOverPeriodMeasure {
    measureIdentifier: AfmLocalIdentifier;
    /**
     * Attributes to use for determining the period to calculate the PoP for.
     */
    dateAttributes: Array<PopDate>;
}

/**
 * @type PopMeasureDefinition
 */
export type PopMeasureDefinition = PopDatasetMeasureDefinition | PopDateMeasureDefinition;

/**
 * Filter able to limit element values by label and related selected elements.
 */
export interface PositiveAttributeFilter {
    positiveAttributeFilter: PositiveAttributeFilterPositiveAttributeFilter;
}

export interface PositiveAttributeFilterPositiveAttributeFilter {
    in: AttributeFilterElements;
    localIdentifier?: string;
    applyOnResult?: boolean;
    label: AfmIdentifier;
}

/**
 * List of quality issues (available when status is COMPLETED)
 */
export interface QualityIssue {
    /**
     * Unique identifier for the quality issue
     */
    id: string;
    /**
     * List of objects affected by this quality issue
     */
    objects: Array<QualityIssueObject>;
    /**
     * Severity level
     */
    severity: QualityIssueSeverityEnum;
    /**
     * Quality issue code
     */
    code: string;
    /**
     * Detailed information about the quality issue
     */
    detail: { [key: string]: object };
}

export type QualityIssueSeverityEnum = "WARNING" | "INFO";

/**
 * List of objects affected by this quality issue
 */
export interface QualityIssueObject {
    /**
     * Object type
     */
    type: string;
    /**
     * Object ID
     */
    id: string;
    /**
     * Workspace ID where the object belongs
     */
    workspaceId: string;
    /**
     * Object title
     */
    title: string;
}

export interface QualityIssuesCalculationStatusResponse {
    /**
     * Current status of the calculation
     */
    status: QualityIssuesCalculationStatusResponseStatusEnum;
    /**
     * List of quality issues (available when status is COMPLETED)
     */
    issues?: Array<QualityIssue>;
    /**
     * Error message (available when status is FAILED or NOT_FOUND)
     */
    error?: string;
}

export type QualityIssuesCalculationStatusResponseStatusEnum =
    | "RUNNING"
    | "COMPLETED"
    | "FAILED"
    | "NOT_FOUND"
    | "DISABLED";

/**
 * Condition that checks if the metric value is within a given range.
 */
export interface RangeCondition {
    range: RangeConditionRange;
}

export interface RangeConditionRange {
    operator: RangeConditionRangeOperatorEnum;
    from: number;
    to: number;
}

export type RangeConditionRangeOperatorEnum = "BETWEEN" | "NOT_BETWEEN";

/**
 * Filter the result by comparing specified metric to given range of values.
 */
export interface RangeMeasureValueFilter {
    rangeMeasureValueFilter: RangeMeasureValueFilterRangeMeasureValueFilter;
}

export interface RangeMeasureValueFilterRangeMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     */
    treatNullValuesAs?: number;
    operator: RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum;
    from: number;
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    measure: AfmIdentifier;
}

export type RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum = "BETWEEN" | "NOT_BETWEEN";

/**
 * Filter the result on top/bottom N values according to given metric(s).
 */
export interface RankingFilter {
    rankingFilter: RankingFilterRankingFilter;
}

export interface RankingFilterRankingFilter {
    /**
     * References to the attributes to be used when filtering.
     */
    dimensionality?: Array<AfmIdentifier>;
    /**
     * References to the metrics to be used when filtering.
     */
    measures: Array<AfmIdentifier>;
    /**
     * The type of ranking to use, TOP or BOTTOM.
     */
    operator: RankingFilterRankingFilterOperatorEnum;
    /**
     * Number of top/bottom values to filter.
     */
    value: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
}

export type RankingFilterRankingFilterOperatorEnum = "TOP" | "BOTTOM";

/**
 * Reasoning wrapper containing steps taken during request handling.
 */
export interface Reasoning {
    /**
     * Steps taken during processing, showing the AI\'s reasoning process.
     */
    steps: Array<ReasoningStep>;
    /**
     * Final answer/reasoning from the use case result.
     */
    answer?: string;
}

/**
 * Steps taken during processing, showing the AI\'s reasoning process.
 */
export interface ReasoningStep {
    /**
     * Title describing this reasoning step.
     */
    title: string;
    /**
     * Detailed thoughts/messages within this step.
     */
    thoughts: Array<Thought>;
}

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension. The \'from\' and \'to\' properties mark the boundaries of the interval. If \'from\' is omitted, all values earlier than \'to\' are included. If \'to\' is omitted, all values later than \'from\' are included. It is not allowed to omit both.
 */
export interface RelativeDateFilter {
    relativeDateFilter: RelativeDateFilterRelativeDateFilter;
}

export interface RelativeDateFilterRelativeDateFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     */
    granularity: RelativeDateFilterRelativeDateFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     */
    to: number;
    localIdentifier?: string;
    applyOnResult?: boolean;
    boundedFilter?: BoundedFilter;
    dataset: AfmObjectIdentifierDataset;
}

export type RelativeDateFilterRelativeDateFilterGranularityEnum =
    | "MINUTE"
    | "HOUR"
    | "DAY"
    | "WEEK"
    | "MONTH"
    | "QUARTER"
    | "YEAR"
    | "MINUTE_OF_HOUR"
    | "HOUR_OF_DAY"
    | "DAY_OF_WEEK"
    | "DAY_OF_MONTH"
    | "DAY_OF_QUARTER"
    | "DAY_OF_YEAR"
    | "WEEK_OF_YEAR"
    | "MONTH_OF_YEAR"
    | "QUARTER_OF_YEAR"
    | "FISCAL_MONTH"
    | "FISCAL_QUARTER"
    | "FISCAL_YEAR";

export interface ResolvedLlmEndpoint {
    /**
     * Endpoint Id
     */
    id: string;
    /**
     * Endpoint Title
     */
    title: string;
}

export interface ResolvedLlmEndpoints {
    data: Array<ResolvedLlmEndpoint>;
}

/**
 * Object identifier.
 */
export interface RestApiIdentifier {
    id: string;
    type: string;
}

/**
 * All execution result\'s metadata used for calculation including ExecutionResponse
 */
export interface ResultCacheMetadata {
    afm: AFM;
    executionResponse: ExecutionResponse;
    resultSpec: ResultSpec;
    resultSize: number;
}

/**
 * Single result dimension
 */
export interface ResultDimension {
    headers: Array<ResultDimensionHeader>;
    /**
     * Local identifier of the dimension.
     */
    localIdentifier: string;
}

/**
 * @type ResultDimensionHeader
 * One of the headers in a result dimension.
 */
export type ResultDimensionHeader = AttributeHeader | MeasureGroupHeaders;

/**
 * Specifies how the result data will be formatted (```dimensions```) and which additional data shall be computed (```totals```).
 */
export interface ResultSpec {
    dimensions: Array<Dimension>;
    totals?: Array<Total>;
}

/**
 * Question -> Use Case routing. May contain final answer is a special use case is not required.
 */
export interface RouteResult {
    /**
     * Use case where LLM routed based on question.
     */
    useCase: RouteResultUseCaseEnum;
    /**
     * Explanation why LLM picked this use case.
     */
    reasoning: string;
}

export type RouteResultUseCaseEnum =
    | "INVALID"
    | "GENERAL"
    | "SEARCH"
    | "CREATE_VISUALIZATION"
    | "EXTEND_VISUALIZATION"
    | "HOWTO"
    | "CHANGE_ANALYSIS"
    | "ALERT";

/**
 * Created and saved visualization IDs.
 */
export interface SavedVisualization {
    /**
     * Created visualization ID.
     */
    createdVisualizationId: string;
    /**
     * Saved visualization ID.
     */
    savedVisualizationId: string;
}

export interface SearchRelationshipObject {
    /**
     * Source workspace ID. If relationship is dashboard->visualization, this is the workspace where the dashboard is located.
     */
    sourceWorkspaceId: string;
    /**
     * Source object ID.
     */
    sourceObjectId: string;
    /**
     * Source object type, e.g. dashboard.
     */
    sourceObjectType: string;
    /**
     * Source object title.
     */
    sourceObjectTitle: string;
    /**
     * Target workspace ID. If relationship is dashboard->visualization, this is the workspace where the visualization is located.
     */
    targetWorkspaceId: string;
    /**
     * Target object ID.
     */
    targetObjectId: string;
    /**
     * Target object type, e.g. visualization.
     */
    targetObjectType: string;
    /**
     * Target object title.
     */
    targetObjectTitle: string;
}

export interface SearchRequest {
    /**
     * Keyword/sentence is input for search.
     */
    question: string;
    /**
     * List of object types to search for.
     */
    objectTypes?: Array<SearchRequestObjectTypesEnum>;
    /**
     * Turn on deep search. If true, content of complex objects will be searched as well, e.g. metrics in visualizations.
     */
    deepSearch?: boolean;
    /**
     * Maximum number of results to return. There is a hard limit and the actual number of returned results may be lower than what is requested.
     */
    limit?: number;
    /**
     * Temporary for experiments. Ratio of title score to descriptor score.
     */
    titleToDescriptorRatio?: number;
    /**
     * Score, above which we return found objects. Below this score objects are not relevant.
     */
    relevantScoreThreshold?: number;
    /**
     * If true, includes hidden objects in search results. If false (default), excludes objects where isHidden=true.
     */
    includeHidden?: boolean;
}

export type SearchRequestObjectTypesEnum =
    | "attribute"
    | "metric"
    | "fact"
    | "label"
    | "date"
    | "dataset"
    | "visualization"
    | "dashboard";

export interface SearchResult {
    results: Array<SearchResultObject>;
    relationships: Array<SearchRelationshipObject>;
    /**
     * DEPRECATED: Use top-level reasoning.steps instead. If something is not working properly this field will contain explanation.
     */
    reasoning: string;
}

export interface SearchResultObject {
    /**
     * Object ID.
     */
    id: string;
    /**
     * Object type, e.g. dashboard.
     */
    type: string;
    /**
     * Workspace ID.
     */
    workspaceId: string;
    /**
     * Object title.
     */
    title: string;
    /**
     * Object description.
     */
    description?: string;
    tags?: Array<string>;
    /**
     * Timestamp when object was created.
     */
    createdAt?: string;
    /**
     * Timestamp when object was last modified.
     */
    modifiedAt?: string;
    /**
     * If the object is visualization, this field defines the type of visualization.
     */
    visualizationUrl?: string;
    /**
     * Result score calculated by a similarity search algorithm (cosine_distance).
     */
    score?: number;
    /**
     * Result score for object title.
     */
    scoreTitle?: number;
    /**
     * Result score for descriptor containing(now) description and tags.
     */
    scoreDescriptor?: number;
    /**
     * Result score for exact match(id/title). 1/1000. Other scores are multiplied by this.
     */
    scoreExactMatch?: number;
    /**
     * If true, this object is hidden from AI search results by default.
     */
    isHidden?: boolean;
}

/**
 * Metric defined by referencing a MAQL metric or an LDM fact object with aggregation.
 */
export interface SimpleMeasureDefinition {
    measure: SimpleMeasureDefinitionMeasure;
}

export interface SimpleMeasureDefinitionMeasure {
    item: AfmObjectIdentifierCore;
    /**
     * Definition of aggregation type of the metric.
     */
    aggregation?: SimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true, compute the percentage of given metric values (broken down by AFM attributes) to the total (not broken down).
     */
    computeRatio?: boolean;
    /**
     * Metrics can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     */
    filters?: Array<FilterDefinitionForSimpleMeasure>;
}

export type SimpleMeasureDefinitionMeasureAggregationEnum =
    | "SUM"
    | "COUNT"
    | "AVG"
    | "MIN"
    | "MAX"
    | "MEDIAN"
    | "RUNSUM"
    | "APPROXIMATE_COUNT";

export interface SmartFunctionResponse {
    links: ExecutionLinks;
}

/**
 * @type SortKey
 */
export type SortKey = SortKeyAttribute | SortKeyTotal | SortKeyValue;

/**
 * Sorting rule for sorting by attribute value in current dimension.
 */
export interface SortKeyAttribute {
    attribute: SortKeyAttributeAttribute;
}

export interface SortKeyAttributeAttribute {
    /**
     * Item reference (to \'itemIdentifiers\') referencing, which item should be used for sorting. Only references to attributes are allowed.
     */
    attributeIdentifier: string;
    /**
     * Mechanism by which this attribute should be sorted. Available options are: - DEFAULT: sorting based on default rules (using sort column if defined, otherwise this label)  - LABEL: sorting by this label values  - ATTRIBUTE: sorting by values of this label\'s attribute (or rather the primary label)  - ATTRIBUTE: sorting by values of this label\'s attribute (or rather the primary label)- AREA: sorting by area (total or subtotal) corresponding to each attribute value. The area is computed by summing up all metric values in all other dimensions.
     */
    sortType?: SortKeyAttributeAttributeSortTypeEnum;
    /**
     * Sorting elements - ascending/descending order.
     */
    direction?: SortKeyAttributeAttributeDirectionEnum;
}

export type SortKeyAttributeAttributeSortTypeEnum = "DEFAULT" | "LABEL" | "ATTRIBUTE" | "AREA";
export type SortKeyAttributeAttributeDirectionEnum = "ASC" | "DESC";

/**
 * Sorting rule for sorting by total value. DataColumnLocators are only required if there is ambiguity. Locator for measureGroup is taken from the metric of the total.
 */
export interface SortKeyTotal {
    total: SortKeyTotalTotal;
}

export interface SortKeyTotalTotal {
    /**
     * Local identifier of the total to sort by.
     */
    totalIdentifier: string;
    dataColumnLocators?: DataColumnLocators;
    /**
     * Sorting elements - ascending/descending order.
     */
    direction?: SortKeyTotalTotalDirectionEnum;
}

export type SortKeyTotalTotalDirectionEnum = "ASC" | "DESC";

/**
 * Sorting rule for sorting by measure value. DataColumnLocators for each dimension opposite to the sorted one must be specified.
 */
export interface SortKeyValue {
    value: SortKeyValueValue;
}

export interface SortKeyValueValue {
    dataColumnLocators: DataColumnLocators;
    /**
     * Sorting elements - ascending/descending order.
     */
    direction?: SortKeyValueValueDirectionEnum;
}

export type SortKeyValueValueDirectionEnum = "ASC" | "DESC";

/**
 * List of suggestions for next steps. Filled when no visualization was created, suggests alternatives.
 */
export interface Suggestion {
    /**
     * Suggestion query
     */
    query: string;
    /**
     * Suggestion button label
     */
    label: string;
}

/**
 * Detailed thoughts/messages within this step.
 */
export interface Thought {
    /**
     * The text content of this thought.
     */
    text: string;
}

/**
 * Definition of a total. There are two types of totals: grand totals and subtotals. Grand total data will be returned in a separate section of the result structure while subtotals are fully integrated into the main result data. The mechanism for this distinction is automatic and it\'s described in `TotalDimension`
 */
export interface Total {
    /**
     * Total identification within this request. Used e.g. in sorting by a total.
     */
    localIdentifier: string;
    /**
     * Aggregation function to compute the total.
     */
    function: TotalFunctionEnum;
    /**
     * The metric for which the total will be computed
     */
    metric: string;
    totalDimensions: Array<TotalDimension>;
}

export type TotalFunctionEnum = "SUM" | "MIN" | "MAX" | "AVG" | "MED" | "NAT";

/**
 * A list of dimensions across which the total will be computed. Total headers for only these dimensions will be returned in the result.
 */
export interface TotalDimension {
    /**
     * An identifier of a dimension for which the total will be computed.
     */
    dimensionIdentifier: string;
    /**
     * List of dimension items which will be used for total computation. The total is a grand total in this dimension if the list is empty or it includes the first dimension item from the dimension definition, and its data and header will be returned in a separate `ExecutionResultGrandTotal` structure. Otherwise, it is a subtotal and the data will be integrated into the main result.
     */
    totalDimensionItems: Array<string>;
}

export interface TotalExecutionResultHeader {
    totalHeader: TotalResultHeader;
}

/**
 * Header containing the information related to a subtotal.
 */
export interface TotalResultHeader {
    function: string;
}

export interface TriggerQualityIssuesCalculationResponse {
    /**
     * Process ID for tracking the calculation status
     */
    processId: string;
    /**
     * Current status of the calculation
     */
    status: TriggerQualityIssuesCalculationResponseStatusEnum;
}

export type TriggerQualityIssuesCalculationResponseStatusEnum =
    | "RUNNING"
    | "COMPLETED"
    | "FAILED"
    | "DISABLED";

/**
 * User context, which can affect the behavior of the underlying AI features.
 */
export interface UserContext {
    activeObject: ActiveObjectIdentification;
}

export interface ValidateByItem {
    /**
     * Specifies entity used for valid elements computation.
     */
    id: string;
    /**
     * Specifies entity type which could be label, attribute, fact, or metric.
     */
    type: string;
}

export interface ValidateLLMEndpointByIdRequest {
    /**
     * Provider for the LLM endpoint validation
     */
    provider?: string;
    /**
     * Base URL for the LLM endpoint validation
     */
    baseUrl?: string;
    /**
     * Token for the LLM endpoint validation
     */
    token?: string;
    /**
     * Organization name for the LLM endpoint validation
     */
    llmOrganization?: string;
    /**
     * LLM model for the LLM endpoint validation
     */
    llmModel?: string;
}

export interface ValidateLLMEndpointRequest {
    /**
     * Provider for the LLM endpoint validation
     */
    provider: string;
    /**
     * Base URL for the LLM endpoint validation
     */
    baseUrl?: string;
    /**
     * Token for the LLM endpoint validation
     */
    token: string;
    /**
     * Organization name for the LLM endpoint validation
     */
    llmOrganization?: string;
    /**
     * LLM model for the LLM endpoint validation
     */
    llmModel?: string;
}

export interface ValidateLLMEndpointResponse {
    /**
     * Whether the LLM endpoint validation was successful
     */
    successful: boolean;
    /**
     * Additional message about the LLM endpoint validation
     */
    message: string;
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (BETA) Combines multiple use cases such as search, create visualizations, ...
 * @summary (BETA) Chat with AI
 * @param {string} workspaceId Workspace identifier
 * @param {ChatRequest} chatRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_AiChat(
    workspaceId: string,
    chatRequest: ChatRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("aiChat", "workspaceId", workspaceId);
    // verify required parameter 'chatRequest' is not null or undefined
    assertParamExists("aiChat", "chatRequest", chatRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chat`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof chatRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
        : chatRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
 * @summary (BETA) Get Chat History
 * @param {string} workspaceId Workspace identifier
 * @param {ChatHistoryRequest} chatHistoryRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_AiChatHistory(
    workspaceId: string,
    chatHistoryRequest: ChatHistoryRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("aiChatHistory", "workspaceId", workspaceId);
    // verify required parameter 'chatHistoryRequest' is not null or undefined
    assertParamExists("aiChatHistory", "chatHistoryRequest", chatHistoryRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatHistory`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof chatHistoryRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(chatHistoryRequest !== undefined ? chatHistoryRequest : {})
        : chatHistoryRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (BETA) Combines multiple use cases such as search, create visualizations, ...
 * @summary (BETA) Chat with AI
 * @param {string} workspaceId Workspace identifier
 * @param {ChatRequest} chatRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_AiChatStream(
    workspaceId: string,
    chatRequest: ChatRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("aiChatStream", "workspaceId", workspaceId);
    // verify required parameter 'chatRequest' is not null or undefined
    assertParamExists("aiChatStream", "chatRequest", chatRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatStream`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof chatRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
        : chatRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Returns usage statistics of chat for a user in a workspace.
 * @summary Get Chat Usage
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_AiChatUsage(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("aiChatUsage", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatUsage`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
 * @summary (BETA) Semantic Search in Metadata
 * @param {string} workspaceId Workspace identifier
 * @param {SearchRequest} searchRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_AiSearch(
    workspaceId: string,
    searchRequest: SearchRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("aiSearch", "workspaceId", workspaceId);
    // verify required parameter 'searchRequest' is not null or undefined
    assertParamExists("aiSearch", "searchRequest", searchRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/search`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof searchRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(searchRequest !== undefined ? searchRequest : {})
        : searchRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Computes anomaly detection.
 * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Input result ID to be used in the computation
 * @param {AnomalyDetectionRequest} anomalyDetectionRequest
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_AnomalyDetection(
    workspaceId: string,
    resultId: string,
    anomalyDetectionRequest: AnomalyDetectionRequest,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("anomalyDetection", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("anomalyDetection", "resultId", resultId);
    // verify required parameter 'anomalyDetectionRequest' is not null or undefined
    assertParamExists("anomalyDetection", "anomalyDetectionRequest", anomalyDetectionRequest);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof anomalyDetectionRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(anomalyDetectionRequest !== undefined ? anomalyDetectionRequest : {})
        : anomalyDetectionRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Gets anomalies.
 * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {number} [offset]
 * @param {number} [limit]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_AnomalyDetectionResult(
    workspaceId: string,
    resultId: string,
    offset?: number,
    limit?: number,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("anomalyDetectionResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("anomalyDetectionResult", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/result/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
 * @summary Applies all the given cancel tokens.
 * @param {string} workspaceId Workspace identifier
 * @param {AfmCancelTokens} afmCancelTokens
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_CancelExecutions(
    workspaceId: string,
    afmCancelTokens: AfmCancelTokens,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("cancelExecutions", "workspaceId", workspaceId);
    // verify required parameter 'afmCancelTokens' is not null or undefined
    assertParamExists("cancelExecutions", "afmCancelTokens", afmCancelTokens);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/cancel`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof afmCancelTokens !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(afmCancelTokens !== undefined ? afmCancelTokens : {})
        : afmCancelTokens || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Computes change analysis for the provided execution definition.
 * @summary Compute change analysis
 * @param {string} workspaceId Workspace identifier
 * @param {ChangeAnalysisRequest} changeAnalysisRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ChangeAnalysis(
    workspaceId: string,
    changeAnalysisRequest: ChangeAnalysisRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("changeAnalysis", "workspaceId", workspaceId);
    // verify required parameter 'changeAnalysisRequest' is not null or undefined
    assertParamExists("changeAnalysis", "changeAnalysisRequest", changeAnalysisRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/computeChangeAnalysis`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof changeAnalysisRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(changeAnalysisRequest !== undefined ? changeAnalysisRequest : {})
        : changeAnalysisRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Gets change analysis result.
 * @summary Get change analysis result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ChangeAnalysisResult(
    workspaceId: string,
    resultId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("changeAnalysisResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("changeAnalysisResult", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/computeChangeAnalysis/result/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
 * @summary (EXPERIMENTAL) Smart functions - Clustering
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Input result ID to be used in the computation
 * @param {ClusteringRequest} clusteringRequest
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_Clustering(
    workspaceId: string,
    resultId: string,
    clusteringRequest: ClusteringRequest,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("clustering", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("clustering", "resultId", resultId);
    // verify required parameter 'clusteringRequest' is not null or undefined
    assertParamExists("clustering", "clusteringRequest", clusteringRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/{resultId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof clusteringRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(clusteringRequest !== undefined ? clusteringRequest : {})
        : clusteringRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Gets clustering result.
 * @summary (EXPERIMENTAL) Smart functions - Clustering Result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {number} [offset]
 * @param {number} [limit]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ClusteringResult(
    workspaceId: string,
    resultId: string,
    offset?: number,
    limit?: number,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("clusteringResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("clusteringResult", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/result/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Returns paged list of elements (values) of given label satisfying given filtering criteria.
 * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
 * @param {string} workspaceId Workspace identifier
 * @param {ElementsRequest} elementsRequest
 * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
 * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ComputeLabelElementsPost(
    workspaceId: string,
    elementsRequest: ElementsRequest,
    offset?: number,
    limit?: number,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("computeLabelElementsPost", "workspaceId", workspaceId);
    // verify required parameter 'elementsRequest' is not null or undefined
    assertParamExists("computeLabelElementsPost", "elementsRequest", elementsRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof elementsRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
        : elementsRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
 * @summary Executes analytical request and returns link to the result
 * @param {string} workspaceId Workspace identifier
 * @param {AfmExecution} afmExecution
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {string} [timestamp]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ComputeReport(
    workspaceId: string,
    afmExecution: AfmExecution,
    skipCache?: boolean,
    timestamp?: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("computeReport", "workspaceId", workspaceId);
    // verify required parameter 'afmExecution' is not null or undefined
    assertParamExists("computeReport", "afmExecution", afmExecution);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    if (timestamp !== undefined && timestamp !== null) {
        localVarHeaderParameter["timestamp"] = String(timestamp);
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof afmExecution !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
        : afmExecution || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
 * @summary (BETA) Valid descendants
 * @param {string} workspaceId Workspace identifier
 * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ComputeValidDescendants(
    workspaceId: string,
    afmValidDescendantsQuery: AfmValidDescendantsQuery,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("computeValidDescendants", "workspaceId", workspaceId);
    // verify required parameter 'afmValidDescendantsQuery' is not null or undefined
    assertParamExists("computeValidDescendants", "afmValidDescendantsQuery", afmValidDescendantsQuery);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidDescendants`.replace(
            `{${"workspaceId"}}`,
            encodeURIComponent(String(workspaceId)),
        );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof afmValidDescendantsQuery !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(afmValidDescendantsQuery !== undefined ? afmValidDescendantsQuery : {})
        : afmValidDescendantsQuery || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
 * @summary Valid objects
 * @param {string} workspaceId Workspace identifier
 * @param {AfmValidObjectsQuery} afmValidObjectsQuery
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ComputeValidObjects(
    workspaceId: string,
    afmValidObjectsQuery: AfmValidObjectsQuery,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("computeValidObjects", "workspaceId", workspaceId);
    // verify required parameter 'afmValidObjectsQuery' is not null or undefined
    assertParamExists("computeValidObjects", "afmValidObjectsQuery", afmValidObjectsQuery);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof afmValidObjectsQuery !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
        : afmValidObjectsQuery || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Returns a list of Users who created any object for this workspace
 * @summary Get Analytics Catalog CreatedBy Users
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_CreatedBy(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createdBy", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/analyticsCatalog/createdBy`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * The resource provides static structures needed for investigation of a problem with given AFM.
 * @summary AFM explain resource.
 * @param {string} workspaceId Workspace identifier
 * @param {AfmExecution} afmExecution
 * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS' | 'COMPRESSED_SQL'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;COMPRESSED_GRPC_MODEL_SVG&#x60; - Generated SVG image of the model fragment used in the query  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;COMPRESSED_SQL&#x60; - Final SQL to be executed with rolled SQL datasets  &#x60;SETTINGS&#x60; - Settings used to execute explain request
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ExplainAFM(
    workspaceId: string,
    afmExecution: AfmExecution,
    explainType?:
        | "MAQL"
        | "GRPC_MODEL"
        | "GRPC_MODEL_SVG"
        | "WDF"
        | "QT"
        | "QT_SVG"
        | "OPT_QT"
        | "OPT_QT_SVG"
        | "SQL"
        | "SETTINGS"
        | "COMPRESSED_SQL",
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("explainAFM", "workspaceId", workspaceId);
    // verify required parameter 'afmExecution' is not null or undefined
    assertParamExists("explainAFM", "afmExecution", afmExecution);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (explainType !== undefined) {
        localVarQueryParameter["explainType"] = explainType;
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof afmExecution !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
        : afmExecution || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (BETA) Computes forecasted data points from the provided execution result and parameters.
 * @summary (BETA) Smart functions - Forecast
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Input result ID to be used in the computation
 * @param {ForecastRequest} forecastRequest
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_Forecast(
    workspaceId: string,
    resultId: string,
    forecastRequest: ForecastRequest,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("forecast", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("forecast", "resultId", resultId);
    // verify required parameter 'forecastRequest' is not null or undefined
    assertParamExists("forecast", "forecastRequest", forecastRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/{resultId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof forecastRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(forecastRequest !== undefined ? forecastRequest : {})
        : forecastRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (BETA) Gets forecast result.
 * @summary (BETA) Smart functions - Forecast Result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {number} [offset]
 * @param {number} [limit]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ForecastResult(
    workspaceId: string,
    resultId: string,
    offset?: number,
    limit?: number,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("forecastResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("forecastResult", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/result/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Returns metadata quality issues detected by the platform linter.
 * @summary Get Quality Issues
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_GetQualityIssues(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getQualityIssues", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/issues`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Returns the status of a quality issues calculation process identified by process ID.
 * @summary Get Quality Issues Calculation Status
 * @param {string} workspaceId Workspace identifier
 * @param {string} processId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_GetQualityIssuesCalculationStatus(
    workspaceId: string,
    processId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getQualityIssuesCalculationStatus", "workspaceId", workspaceId);
    // verify required parameter 'processId' is not null or undefined
    assertParamExists("getQualityIssuesCalculationStatus", "processId", processId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/issues/status/{processId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"processId"}}`, encodeURIComponent(String(processId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
 * @summary (EXPERIMENTAL) Compute key driver analysis
 * @param {string} workspaceId Workspace identifier
 * @param {KeyDriversRequest} keyDriversRequest
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_KeyDriverAnalysis(
    workspaceId: string,
    keyDriversRequest: KeyDriversRequest,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("keyDriverAnalysis", "workspaceId", workspaceId);
    // verify required parameter 'keyDriversRequest' is not null or undefined
    assertParamExists("keyDriverAnalysis", "keyDriversRequest", keyDriversRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof keyDriversRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(keyDriversRequest !== undefined ? keyDriversRequest : {})
        : keyDriversRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Gets key driver analysis.
 * @summary (EXPERIMENTAL) Get key driver analysis result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {number} [offset]
 * @param {number} [limit]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_KeyDriverAnalysisResult(
    workspaceId: string,
    resultId: string,
    offset?: number,
    limit?: number,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("keyDriverAnalysisResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("keyDriverAnalysisResult", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers/result/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Returns a list of Users who created any memory item for this workspace
 * @summary Get AI Memory CreatedBy Users
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_MemoryCreatedByUsers(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("memoryCreatedByUsers", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory/createdBy`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (BETA) Computes outlier detection for the provided execution definition.
 * @summary (BETA) Outlier Detection
 * @param {string} workspaceId Workspace identifier
 * @param {OutlierDetectionRequest} outlierDetectionRequest
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_OutlierDetection(
    workspaceId: string,
    outlierDetectionRequest: OutlierDetectionRequest,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("outlierDetection", "workspaceId", workspaceId);
    // verify required parameter 'outlierDetectionRequest' is not null or undefined
    assertParamExists("outlierDetection", "outlierDetectionRequest", outlierDetectionRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/detectOutliers`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof outlierDetectionRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(outlierDetectionRequest !== undefined ? outlierDetectionRequest : {})
        : outlierDetectionRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (BETA) Gets outlier detection result.
 * @summary (BETA) Outlier Detection Result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {number} [offset]
 * @param {number} [limit]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_OutlierDetectionResult(
    workspaceId: string,
    resultId: string,
    offset?: number,
    limit?: number,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("outlierDetectionResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("outlierDetectionResult", "resultId", resultId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/detectOutliers/result/{resultId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Returns a list of available LLM Endpoints
 * @summary Get Active LLM Endpoints for this workspace
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ResolveLlmEndpoints(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("resolveLlmEndpoints", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/resolveLlmEndpoints`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
 * @summary Get a single execution result\'s metadata.
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_RetrieveExecutionMetadata(
    workspaceId: string,
    resultId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("retrieveExecutionMetadata", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("retrieveExecutionMetadata", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}/metadata`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Gets a single execution result.
 * @summary Get a single execution result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
 * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
 * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
 * @param {string} [xGDCCANCELTOKEN]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_RetrieveResult(
    workspaceId: string,
    resultId: string,
    offset?: Array<number>,
    limit?: Array<number>,
    excludedTotalDimensions?: Array<string>,
    xGDCCANCELTOKEN?: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("retrieveResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("retrieveResult", "resultId", resultId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset) {
        localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
    }

    if (limit) {
        localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
    }

    if (excludedTotalDimensions) {
        localVarQueryParameter["excludedTotalDimensions"] = excludedTotalDimensions.join(
            COLLECTION_FORMATS.csv,
        );
    }

    if (xGDCCANCELTOKEN !== undefined && xGDCCANCELTOKEN !== null) {
        localVarHeaderParameter["X-GDC-CANCEL-TOKEN"] = String(xGDCCANCELTOKEN);
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Returns a list of tags for this workspace
 * @summary Get Analytics Catalog Tags
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_Tags(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("tags", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/analyticsCatalog/tags`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Triggers asynchronous calculation of metadata quality issues and returns a process ID for status tracking.
 * @summary Trigger Quality Issues Calculation
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_TriggerQualityIssuesCalculation(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("triggerQualityIssuesCalculation", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/issues/triggerCheck`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Validates LLM endpoint with provided parameters.
 * @summary Validate LLM Endpoint
 * @param {ValidateLLMEndpointRequest} validateLLMEndpointRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ValidateLLMEndpoint(
    validateLLMEndpointRequest: ValidateLLMEndpointRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'validateLLMEndpointRequest' is not null or undefined
    assertParamExists("validateLLMEndpoint", "validateLLMEndpointRequest", validateLLMEndpointRequest);
    const localVarPath = `/api/v1/actions/ai/llmEndpoint/test`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof validateLLMEndpointRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(validateLLMEndpointRequest !== undefined ? validateLLMEndpointRequest : {})
        : validateLLMEndpointRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
 * @summary Validate LLM Endpoint By Id
 * @param {string} llmEndpointId
 * @param {ValidateLLMEndpointByIdRequest} [validateLLMEndpointByIdRequest]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ValidateLLMEndpointById(
    llmEndpointId: string,
    validateLLMEndpointByIdRequest?: ValidateLLMEndpointByIdRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'llmEndpointId' is not null or undefined
    assertParamExists("validateLLMEndpointById", "llmEndpointId", llmEndpointId);
    const localVarPath = `/api/v1/actions/ai/llmEndpoint/{llmEndpointId}/test`.replace(
        `{${"llmEndpointId"}}`,
        encodeURIComponent(String(llmEndpointId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof validateLLMEndpointByIdRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(validateLLMEndpointByIdRequest !== undefined ? validateLLMEndpointByIdRequest : {})
        : validateLLMEndpointByIdRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ActionsApi Api FP
/**
 * (BETA) Combines multiple use cases such as search, create visualizations, ...
 * @summary (BETA) Chat with AI
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiAiChatRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_AiChat(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiAiChatRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ChatResult> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_AiChat(
        requestParameters.workspaceId,
        requestParameters.chatRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
 * @summary (BETA) Get Chat History
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiAiChatHistoryRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_AiChatHistory(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiAiChatHistoryRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ChatHistoryResult> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_AiChatHistory(
        requestParameters.workspaceId,
        requestParameters.chatHistoryRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (BETA) Combines multiple use cases such as search, create visualizations, ...
 * @summary (BETA) Chat with AI
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiAiChatStreamRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_AiChatStream(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiAiChatStreamRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<Array<object>> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_AiChatStream(
        requestParameters.workspaceId,
        requestParameters.chatRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Returns usage statistics of chat for a user in a workspace.
 * @summary Get Chat Usage
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiAiChatUsageRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_AiChatUsage(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiAiChatUsageRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ChatUsageResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_AiChatUsage(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
 * @summary (BETA) Semantic Search in Metadata
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiAiSearchRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_AiSearch(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiAiSearchRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<SearchResult> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_AiSearch(
        requestParameters.workspaceId,
        requestParameters.searchRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (EXPERIMENTAL) Computes anomaly detection.
 * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiAnomalyDetectionRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_AnomalyDetection(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiAnomalyDetectionRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<SmartFunctionResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_AnomalyDetection(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.anomalyDetectionRequest,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (EXPERIMENTAL) Gets anomalies.
 * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_AnomalyDetectionResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiAnomalyDetectionResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AnomalyDetectionResult> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_AnomalyDetectionResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
 * @summary Applies all the given cancel tokens.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiCancelExecutionsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_CancelExecutions(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiCancelExecutionsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AfmCancelTokens> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_CancelExecutions(
        requestParameters.workspaceId,
        requestParameters.afmCancelTokens,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Computes change analysis for the provided execution definition.
 * @summary Compute change analysis
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiChangeAnalysisRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ChangeAnalysis(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiChangeAnalysisRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ChangeAnalysisResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ChangeAnalysis(
        requestParameters.workspaceId,
        requestParameters.changeAnalysisRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Gets change analysis result.
 * @summary Get change analysis result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiChangeAnalysisResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ChangeAnalysisResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiChangeAnalysisResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ChangeAnalysisResult> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ChangeAnalysisResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
 * @summary (EXPERIMENTAL) Smart functions - Clustering
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiClusteringRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_Clustering(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiClusteringRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<SmartFunctionResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_Clustering(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.clusteringRequest,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (EXPERIMENTAL) Gets clustering result.
 * @summary (EXPERIMENTAL) Smart functions - Clustering Result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiClusteringResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ClusteringResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiClusteringResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ClusteringResult> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ClusteringResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Returns paged list of elements (values) of given label satisfying given filtering criteria.
 * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ComputeLabelElementsPost(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiComputeLabelElementsPostRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ElementsResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ComputeLabelElementsPost(
        requestParameters.workspaceId,
        requestParameters.elementsRequest,
        requestParameters.offset,
        requestParameters.limit,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
 * @summary Executes analytical request and returns link to the result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ComputeReport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiComputeReportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AfmExecutionResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ComputeReport(
        requestParameters.workspaceId,
        requestParameters.afmExecution,
        requestParameters.skipCache,
        requestParameters.timestamp,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
 * @summary (BETA) Valid descendants
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ComputeValidDescendants(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiComputeValidDescendantsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AfmValidDescendantsResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ComputeValidDescendants(
        requestParameters.workspaceId,
        requestParameters.afmValidDescendantsQuery,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
 * @summary Valid objects
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ComputeValidObjects(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiComputeValidObjectsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AfmValidObjectsResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ComputeValidObjects(
        requestParameters.workspaceId,
        requestParameters.afmValidObjectsQuery,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Returns a list of Users who created any object for this workspace
 * @summary Get Analytics Catalog CreatedBy Users
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiCreatedByRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_CreatedBy(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiCreatedByRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AnalyticsCatalogCreatedBy> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_CreatedBy(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * The resource provides static structures needed for investigation of a problem with given AFM.
 * @summary AFM explain resource.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ExplainAFM(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiExplainAFMRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ExplainAFM(
        requestParameters.workspaceId,
        requestParameters.afmExecution,
        requestParameters.explainType,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (BETA) Computes forecasted data points from the provided execution result and parameters.
 * @summary (BETA) Smart functions - Forecast
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiForecastRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_Forecast(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiForecastRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<SmartFunctionResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_Forecast(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.forecastRequest,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (BETA) Gets forecast result.
 * @summary (BETA) Smart functions - Forecast Result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ForecastResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiForecastResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ForecastResult> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ForecastResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Returns metadata quality issues detected by the platform linter.
 * @summary Get Quality Issues
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiGetQualityIssuesRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_GetQualityIssues(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiGetQualityIssuesRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<GetQualityIssuesResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_GetQualityIssues(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Returns the status of a quality issues calculation process identified by process ID.
 * @summary Get Quality Issues Calculation Status
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiGetQualityIssuesCalculationStatusRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_GetQualityIssuesCalculationStatus(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiGetQualityIssuesCalculationStatusRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<QualityIssuesCalculationStatusResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_GetQualityIssuesCalculationStatus(
        requestParameters.workspaceId,
        requestParameters.processId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
 * @summary (EXPERIMENTAL) Compute key driver analysis
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiKeyDriverAnalysisRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_KeyDriverAnalysis(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiKeyDriverAnalysisRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<KeyDriversResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_KeyDriverAnalysis(
        requestParameters.workspaceId,
        requestParameters.keyDriversRequest,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (EXPERIMENTAL) Gets key driver analysis.
 * @summary (EXPERIMENTAL) Get key driver analysis result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_KeyDriverAnalysisResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiKeyDriverAnalysisResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<KeyDriversResult> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_KeyDriverAnalysisResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Returns a list of Users who created any memory item for this workspace
 * @summary Get AI Memory CreatedBy Users
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiMemoryCreatedByUsersRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_MemoryCreatedByUsers(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiMemoryCreatedByUsersRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<MemoryItemCreatedByUsers> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_MemoryCreatedByUsers(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (BETA) Computes outlier detection for the provided execution definition.
 * @summary (BETA) Outlier Detection
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiOutlierDetectionRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_OutlierDetection(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiOutlierDetectionRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<OutlierDetectionResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_OutlierDetection(
        requestParameters.workspaceId,
        requestParameters.outlierDetectionRequest,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * (BETA) Gets outlier detection result.
 * @summary (BETA) Outlier Detection Result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiOutlierDetectionResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_OutlierDetectionResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiOutlierDetectionResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<OutlierDetectionResult> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_OutlierDetectionResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Returns a list of available LLM Endpoints
 * @summary Get Active LLM Endpoints for this workspace
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ResolveLlmEndpoints(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiResolveLlmEndpointsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ResolvedLlmEndpoints> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ResolveLlmEndpoints(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
 * @summary Get a single execution result\'s metadata.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_RetrieveExecutionMetadata(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ResultCacheMetadata> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_RetrieveExecutionMetadata(
        requestParameters.workspaceId,
        requestParameters.resultId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Gets a single execution result.
 * @summary Get a single execution result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_RetrieveResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiRetrieveResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExecutionResult> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_RetrieveResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        requestParameters.excludedTotalDimensions,
        requestParameters.xGDCCANCELTOKEN,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Returns a list of tags for this workspace
 * @summary Get Analytics Catalog Tags
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiTagsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_Tags(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiTagsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AnalyticsCatalogTags> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_Tags(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Triggers asynchronous calculation of metadata quality issues and returns a process ID for status tracking.
 * @summary Trigger Quality Issues Calculation
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiTriggerQualityIssuesCalculationRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_TriggerQualityIssuesCalculation(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiTriggerQualityIssuesCalculationRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<TriggerQualityIssuesCalculationResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_TriggerQualityIssuesCalculation(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Validates LLM endpoint with provided parameters.
 * @summary Validate LLM Endpoint
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ValidateLLMEndpoint(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiValidateLLMEndpointRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ValidateLLMEndpointResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ValidateLLMEndpoint(
        requestParameters.validateLLMEndpointRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ActionsApi Api FP
/**
 * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
 * @summary Validate LLM Endpoint By Id
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ValidateLLMEndpointById(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ActionsApiValidateLLMEndpointByIdRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ValidateLLMEndpointResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ValidateLLMEndpointById(
        requestParameters.llmEndpointId,
        requestParameters.validateLLMEndpointByIdRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiChat(
        requestParameters: ActionsApiAiChatRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatResult>;

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {ActionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiChatHistory(
        requestParameters: ActionsApiAiChatHistoryRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatHistoryResult>;

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiChatStream(
        requestParameters: ActionsApiAiChatStreamRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<object>>;

    /**
     * Returns usage statistics of chat for a user in a workspace.
     * @summary Get Chat Usage
     * @param {ActionsApiAiChatUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiChatUsage(
        requestParameters: ActionsApiAiChatUsageRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatUsageResponse>;

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {ActionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiSearch(
        requestParameters: ActionsApiAiSearchRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SearchResult>;

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {ActionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    anomalyDetection(
        requestParameters: ActionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {ActionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    anomalyDetectionResult(
        requestParameters: ActionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnomalyDetectionResult>;

    /**
     * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
     * @summary Applies all the given cancel tokens.
     * @param {ActionsApiCancelExecutionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    cancelExecutions(
        requestParameters: ActionsApiCancelExecutionsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmCancelTokens>;

    /**
     * Computes change analysis for the provided execution definition.
     * @summary Compute change analysis
     * @param {ActionsApiChangeAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    changeAnalysis(
        requestParameters: ActionsApiChangeAnalysisRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChangeAnalysisResponse>;

    /**
     * Gets change analysis result.
     * @summary Get change analysis result
     * @param {ActionsApiChangeAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    changeAnalysisResult(
        requestParameters: ActionsApiChangeAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChangeAnalysisResult>;

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {ActionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    clustering(
        requestParameters: ActionsApiClusteringRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {ActionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    clusteringResult(
        requestParameters: ActionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ClusteringResult>;

    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeLabelElementsPost(
        requestParameters: ActionsApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ElementsResponse>;

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeReport(
        requestParameters: ActionsApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmExecutionResponse>;

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeValidDescendants(
        requestParameters: ActionsApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidDescendantsResponse>;

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeValidObjects(
        requestParameters: ActionsApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidObjectsResponse>;

    /**
     * Returns a list of Users who created any object for this workspace
     * @summary Get Analytics Catalog CreatedBy Users
     * @param {ActionsApiCreatedByRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    createdBy(
        requestParameters: ActionsApiCreatedByRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnalyticsCatalogCreatedBy>;

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    explainAFM(
        requestParameters: ActionsApiExplainAFMRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {ActionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    forecast(
        requestParameters: ActionsApiForecastRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    forecastResult(
        requestParameters: ActionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ForecastResult>;

    /**
     * Returns metadata quality issues detected by the platform linter.
     * @summary Get Quality Issues
     * @param {ActionsApiGetQualityIssuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getQualityIssues(
        requestParameters: ActionsApiGetQualityIssuesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<GetQualityIssuesResponse>;

    /**
     * Returns the status of a quality issues calculation process identified by process ID.
     * @summary Get Quality Issues Calculation Status
     * @param {ActionsApiGetQualityIssuesCalculationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getQualityIssuesCalculationStatus(
        requestParameters: ActionsApiGetQualityIssuesCalculationStatusRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<QualityIssuesCalculationStatusResponse>;

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ActionsApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    keyDriverAnalysis(
        requestParameters: ActionsApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResponse>;

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ActionsApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    keyDriverAnalysisResult(
        requestParameters: ActionsApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResult>;

    /**
     * Returns a list of Users who created any memory item for this workspace
     * @summary Get AI Memory CreatedBy Users
     * @param {ActionsApiMemoryCreatedByUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    memoryCreatedByUsers(
        requestParameters: ActionsApiMemoryCreatedByUsersRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<MemoryItemCreatedByUsers>;

    /**
     * (BETA) Computes outlier detection for the provided execution definition.
     * @summary (BETA) Outlier Detection
     * @param {ActionsApiOutlierDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    outlierDetection(
        requestParameters: ActionsApiOutlierDetectionRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<OutlierDetectionResponse>;

    /**
     * (BETA) Gets outlier detection result.
     * @summary (BETA) Outlier Detection Result
     * @param {ActionsApiOutlierDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    outlierDetectionResult(
        requestParameters: ActionsApiOutlierDetectionResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<OutlierDetectionResult>;

    /**
     * Returns a list of available LLM Endpoints
     * @summary Get Active LLM Endpoints for this workspace
     * @param {ActionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    resolveLlmEndpoints(
        requestParameters: ActionsApiResolveLlmEndpointsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResolvedLlmEndpoints>;

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    retrieveExecutionMetadata(
        requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResultCacheMetadata>;

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    retrieveResult(
        requestParameters: ActionsApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExecutionResult>;

    /**
     * Returns a list of tags for this workspace
     * @summary Get Analytics Catalog Tags
     * @param {ActionsApiTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    tags(
        requestParameters: ActionsApiTagsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnalyticsCatalogTags>;

    /**
     * Triggers asynchronous calculation of metadata quality issues and returns a process ID for status tracking.
     * @summary Trigger Quality Issues Calculation
     * @param {ActionsApiTriggerQualityIssuesCalculationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    triggerQualityIssuesCalculation(
        requestParameters: ActionsApiTriggerQualityIssuesCalculationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TriggerQualityIssuesCalculationResponse>;

    /**
     * Validates LLM endpoint with provided parameters.
     * @summary Validate LLM Endpoint
     * @param {ActionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    validateLLMEndpoint(
        requestParameters: ActionsApiValidateLLMEndpointRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ValidateLLMEndpointResponse>;

    /**
     * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
     * @summary Validate LLM Endpoint By Id
     * @param {ActionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    validateLLMEndpointById(
        requestParameters: ActionsApiValidateLLMEndpointByIdRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ValidateLLMEndpointResponse>;
}

/**
 * Request parameters for aiChat operation in ActionsApi.
 * @export
 * @interface ActionsApiAiChatRequest
 */
export interface ActionsApiAiChatRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiChat
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof ActionsApiAiChat
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiChatHistory operation in ActionsApi.
 * @export
 * @interface ActionsApiAiChatHistoryRequest
 */
export interface ActionsApiAiChatHistoryRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiChatHistory
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatHistoryRequest}
     * @memberof ActionsApiAiChatHistory
     */
    readonly chatHistoryRequest: ChatHistoryRequest;
}

/**
 * Request parameters for aiChatStream operation in ActionsApi.
 * @export
 * @interface ActionsApiAiChatStreamRequest
 */
export interface ActionsApiAiChatStreamRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiChatStream
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof ActionsApiAiChatStream
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiChatUsage operation in ActionsApi.
 * @export
 * @interface ActionsApiAiChatUsageRequest
 */
export interface ActionsApiAiChatUsageRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiChatUsage
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for aiSearch operation in ActionsApi.
 * @export
 * @interface ActionsApiAiSearchRequest
 */
export interface ActionsApiAiSearchRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiSearch
     */
    readonly workspaceId: string;

    /**
     *
     * @type {SearchRequest}
     * @memberof ActionsApiAiSearch
     */
    readonly searchRequest: SearchRequest;
}

/**
 * Request parameters for anomalyDetection operation in ActionsApi.
 * @export
 * @interface ActionsApiAnomalyDetectionRequest
 */
export interface ActionsApiAnomalyDetectionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly resultId: string;

    /**
     *
     * @type {AnomalyDetectionRequest}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly anomalyDetectionRequest: AnomalyDetectionRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for anomalyDetectionResult operation in ActionsApi.
 * @export
 * @interface ActionsApiAnomalyDetectionResultRequest
 */
export interface ActionsApiAnomalyDetectionResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for cancelExecutions operation in ActionsApi.
 * @export
 * @interface ActionsApiCancelExecutionsRequest
 */
export interface ActionsApiCancelExecutionsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiCancelExecutions
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmCancelTokens}
     * @memberof ActionsApiCancelExecutions
     */
    readonly afmCancelTokens: AfmCancelTokens;
}

/**
 * Request parameters for changeAnalysis operation in ActionsApi.
 * @export
 * @interface ActionsApiChangeAnalysisRequest
 */
export interface ActionsApiChangeAnalysisRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiChangeAnalysis
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChangeAnalysisRequest}
     * @memberof ActionsApiChangeAnalysis
     */
    readonly changeAnalysisRequest: ChangeAnalysisRequest;
}

/**
 * Request parameters for changeAnalysisResult operation in ActionsApi.
 * @export
 * @interface ActionsApiChangeAnalysisResultRequest
 */
export interface ActionsApiChangeAnalysisResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiChangeAnalysisResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiChangeAnalysisResult
     */
    readonly resultId: string;
}

/**
 * Request parameters for clustering operation in ActionsApi.
 * @export
 * @interface ActionsApiClusteringRequest
 */
export interface ActionsApiClusteringRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiClustering
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof ActionsApiClustering
     */
    readonly resultId: string;

    /**
     *
     * @type {ClusteringRequest}
     * @memberof ActionsApiClustering
     */
    readonly clusteringRequest: ClusteringRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiClustering
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for clusteringResult operation in ActionsApi.
 * @export
 * @interface ActionsApiClusteringResultRequest
 */
export interface ActionsApiClusteringResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiClusteringResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiClusteringResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiClusteringResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiClusteringResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for computeLabelElementsPost operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeLabelElementsPostRequest
 */
export interface ActionsApiComputeLabelElementsPostRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ElementsRequest}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly elementsRequest: ElementsRequest;

    /**
     * Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly offset?: number;

    /**
     * Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly limit?: number;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for computeReport operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeReportRequest
 */
export interface ActionsApiComputeReportRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeReport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ActionsApiComputeReport
     */
    readonly afmExecution: AfmExecution;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiComputeReport
     */
    readonly skipCache?: boolean;

    /**
     *
     * @type {string}
     * @memberof ActionsApiComputeReport
     */
    readonly timestamp?: string;
}

/**
 * Request parameters for computeValidDescendants operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeValidDescendantsRequest
 */
export interface ActionsApiComputeValidDescendantsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeValidDescendants
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidDescendantsQuery}
     * @memberof ActionsApiComputeValidDescendants
     */
    readonly afmValidDescendantsQuery: AfmValidDescendantsQuery;
}

/**
 * Request parameters for computeValidObjects operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeValidObjectsRequest
 */
export interface ActionsApiComputeValidObjectsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeValidObjects
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidObjectsQuery}
     * @memberof ActionsApiComputeValidObjects
     */
    readonly afmValidObjectsQuery: AfmValidObjectsQuery;
}

/**
 * Request parameters for createdBy operation in ActionsApi.
 * @export
 * @interface ActionsApiCreatedByRequest
 */
export interface ActionsApiCreatedByRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiCreatedBy
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for explainAFM operation in ActionsApi.
 * @export
 * @interface ActionsApiExplainAFMRequest
 */
export interface ActionsApiExplainAFMRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiExplainAFM
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ActionsApiExplainAFM
     */
    readonly afmExecution: AfmExecution;

    /**
     * Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;COMPRESSED_GRPC_MODEL_SVG&#x60; - Generated SVG image of the model fragment used in the query  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;COMPRESSED_SQL&#x60; - Final SQL to be executed with rolled SQL datasets  &#x60;SETTINGS&#x60; - Settings used to execute explain request
     * @type {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS' | 'COMPRESSED_SQL'}
     * @memberof ActionsApiExplainAFM
     */
    readonly explainType?:
        | "MAQL"
        | "GRPC_MODEL"
        | "GRPC_MODEL_SVG"
        | "WDF"
        | "QT"
        | "QT_SVG"
        | "OPT_QT"
        | "OPT_QT_SVG"
        | "SQL"
        | "SETTINGS"
        | "COMPRESSED_SQL";
}

/**
 * Request parameters for forecast operation in ActionsApi.
 * @export
 * @interface ActionsApiForecastRequest
 */
export interface ActionsApiForecastRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiForecast
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof ActionsApiForecast
     */
    readonly resultId: string;

    /**
     *
     * @type {ForecastRequest}
     * @memberof ActionsApiForecast
     */
    readonly forecastRequest: ForecastRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiForecast
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for forecastResult operation in ActionsApi.
 * @export
 * @interface ActionsApiForecastResultRequest
 */
export interface ActionsApiForecastResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiForecastResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiForecastResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiForecastResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiForecastResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for getQualityIssues operation in ActionsApi.
 * @export
 * @interface ActionsApiGetQualityIssuesRequest
 */
export interface ActionsApiGetQualityIssuesRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiGetQualityIssues
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for getQualityIssuesCalculationStatus operation in ActionsApi.
 * @export
 * @interface ActionsApiGetQualityIssuesCalculationStatusRequest
 */
export interface ActionsApiGetQualityIssuesCalculationStatusRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiGetQualityIssuesCalculationStatus
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsApiGetQualityIssuesCalculationStatus
     */
    readonly processId: string;
}

/**
 * Request parameters for keyDriverAnalysis operation in ActionsApi.
 * @export
 * @interface ActionsApiKeyDriverAnalysisRequest
 */
export interface ActionsApiKeyDriverAnalysisRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiKeyDriverAnalysis
     */
    readonly workspaceId: string;

    /**
     *
     * @type {KeyDriversRequest}
     * @memberof ActionsApiKeyDriverAnalysis
     */
    readonly keyDriversRequest: KeyDriversRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiKeyDriverAnalysis
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for keyDriverAnalysisResult operation in ActionsApi.
 * @export
 * @interface ActionsApiKeyDriverAnalysisResultRequest
 */
export interface ActionsApiKeyDriverAnalysisResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for memoryCreatedByUsers operation in ActionsApi.
 * @export
 * @interface ActionsApiMemoryCreatedByUsersRequest
 */
export interface ActionsApiMemoryCreatedByUsersRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiMemoryCreatedByUsers
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for outlierDetection operation in ActionsApi.
 * @export
 * @interface ActionsApiOutlierDetectionRequest
 */
export interface ActionsApiOutlierDetectionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiOutlierDetection
     */
    readonly workspaceId: string;

    /**
     *
     * @type {OutlierDetectionRequest}
     * @memberof ActionsApiOutlierDetection
     */
    readonly outlierDetectionRequest: OutlierDetectionRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiOutlierDetection
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for outlierDetectionResult operation in ActionsApi.
 * @export
 * @interface ActionsApiOutlierDetectionResultRequest
 */
export interface ActionsApiOutlierDetectionResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiOutlierDetectionResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiOutlierDetectionResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiOutlierDetectionResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiOutlierDetectionResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for resolveLlmEndpoints operation in ActionsApi.
 * @export
 * @interface ActionsApiResolveLlmEndpointsRequest
 */
export interface ActionsApiResolveLlmEndpointsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiResolveLlmEndpoints
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for retrieveExecutionMetadata operation in ActionsApi.
 * @export
 * @interface ActionsApiRetrieveExecutionMetadataRequest
 */
export interface ActionsApiRetrieveExecutionMetadataRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiRetrieveExecutionMetadata
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiRetrieveExecutionMetadata
     */
    readonly resultId: string;
}

/**
 * Request parameters for retrieveResult operation in ActionsApi.
 * @export
 * @interface ActionsApiRetrieveResultRequest
 */
export interface ActionsApiRetrieveResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly resultId: string;

    /**
     * Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly offset?: Array<number>;

    /**
     * Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly limit?: Array<number>;

    /**
     * Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
     * @type {Array<string>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly excludedTotalDimensions?: Array<string>;

    /**
     *
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly xGDCCANCELTOKEN?: string;
}

/**
 * Request parameters for tags operation in ActionsApi.
 * @export
 * @interface ActionsApiTagsRequest
 */
export interface ActionsApiTagsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiTags
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for triggerQualityIssuesCalculation operation in ActionsApi.
 * @export
 * @interface ActionsApiTriggerQualityIssuesCalculationRequest
 */
export interface ActionsApiTriggerQualityIssuesCalculationRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiTriggerQualityIssuesCalculation
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for validateLLMEndpoint operation in ActionsApi.
 * @export
 * @interface ActionsApiValidateLLMEndpointRequest
 */
export interface ActionsApiValidateLLMEndpointRequest {
    /**
     *
     * @type {ValidateLLMEndpointRequest}
     * @memberof ActionsApiValidateLLMEndpoint
     */
    readonly validateLLMEndpointRequest: ValidateLLMEndpointRequest;
}

/**
 * Request parameters for validateLLMEndpointById operation in ActionsApi.
 * @export
 * @interface ActionsApiValidateLLMEndpointByIdRequest
 */
export interface ActionsApiValidateLLMEndpointByIdRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiValidateLLMEndpointById
     */
    readonly llmEndpointId: string;

    /**
     *
     * @type {ValidateLLMEndpointByIdRequest}
     * @memberof ActionsApiValidateLLMEndpointById
     */
    readonly validateLLMEndpointByIdRequest?: ValidateLLMEndpointByIdRequest;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiChat(requestParameters: ActionsApiAiChatRequest, options?: AxiosRequestConfig) {
        return ActionsApi_AiChat(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {ActionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiChatHistory(requestParameters: ActionsApiAiChatHistoryRequest, options?: AxiosRequestConfig) {
        return ActionsApi_AiChatHistory(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiChatStream(requestParameters: ActionsApiAiChatStreamRequest, options?: AxiosRequestConfig) {
        return ActionsApi_AiChatStream(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns usage statistics of chat for a user in a workspace.
     * @summary Get Chat Usage
     * @param {ActionsApiAiChatUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiChatUsage(requestParameters: ActionsApiAiChatUsageRequest, options?: AxiosRequestConfig) {
        return ActionsApi_AiChatUsage(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {ActionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiSearch(requestParameters: ActionsApiAiSearchRequest, options?: AxiosRequestConfig) {
        return ActionsApi_AiSearch(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {ActionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public anomalyDetection(
        requestParameters: ActionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_AnomalyDetection(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {ActionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public anomalyDetectionResult(
        requestParameters: ActionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_AnomalyDetectionResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
     * @summary Applies all the given cancel tokens.
     * @param {ActionsApiCancelExecutionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public cancelExecutions(
        requestParameters: ActionsApiCancelExecutionsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_CancelExecutions(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Computes change analysis for the provided execution definition.
     * @summary Compute change analysis
     * @param {ActionsApiChangeAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public changeAnalysis(requestParameters: ActionsApiChangeAnalysisRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ChangeAnalysis(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Gets change analysis result.
     * @summary Get change analysis result
     * @param {ActionsApiChangeAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public changeAnalysisResult(
        requestParameters: ActionsApiChangeAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_ChangeAnalysisResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {ActionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public clustering(requestParameters: ActionsApiClusteringRequest, options?: AxiosRequestConfig) {
        return ActionsApi_Clustering(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {ActionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public clusteringResult(
        requestParameters: ActionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_ClusteringResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeLabelElementsPost(
        requestParameters: ActionsApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_ComputeLabelElementsPost(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeReport(requestParameters: ActionsApiComputeReportRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ComputeReport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeValidDescendants(
        requestParameters: ActionsApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_ComputeValidDescendants(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeValidObjects(
        requestParameters: ActionsApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_ComputeValidObjects(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns a list of Users who created any object for this workspace
     * @summary Get Analytics Catalog CreatedBy Users
     * @param {ActionsApiCreatedByRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public createdBy(requestParameters: ActionsApiCreatedByRequest, options?: AxiosRequestConfig) {
        return ActionsApi_CreatedBy(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public explainAFM(requestParameters: ActionsApiExplainAFMRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ExplainAFM(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {ActionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public forecast(requestParameters: ActionsApiForecastRequest, options?: AxiosRequestConfig) {
        return ActionsApi_Forecast(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public forecastResult(requestParameters: ActionsApiForecastResultRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ForecastResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns metadata quality issues detected by the platform linter.
     * @summary Get Quality Issues
     * @param {ActionsApiGetQualityIssuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getQualityIssues(
        requestParameters: ActionsApiGetQualityIssuesRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_GetQualityIssues(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns the status of a quality issues calculation process identified by process ID.
     * @summary Get Quality Issues Calculation Status
     * @param {ActionsApiGetQualityIssuesCalculationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getQualityIssuesCalculationStatus(
        requestParameters: ActionsApiGetQualityIssuesCalculationStatusRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_GetQualityIssuesCalculationStatus(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ActionsApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public keyDriverAnalysis(
        requestParameters: ActionsApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_KeyDriverAnalysis(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ActionsApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public keyDriverAnalysisResult(
        requestParameters: ActionsApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_KeyDriverAnalysisResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns a list of Users who created any memory item for this workspace
     * @summary Get AI Memory CreatedBy Users
     * @param {ActionsApiMemoryCreatedByUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public memoryCreatedByUsers(
        requestParameters: ActionsApiMemoryCreatedByUsersRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_MemoryCreatedByUsers(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Computes outlier detection for the provided execution definition.
     * @summary (BETA) Outlier Detection
     * @param {ActionsApiOutlierDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public outlierDetection(
        requestParameters: ActionsApiOutlierDetectionRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_OutlierDetection(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Gets outlier detection result.
     * @summary (BETA) Outlier Detection Result
     * @param {ActionsApiOutlierDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public outlierDetectionResult(
        requestParameters: ActionsApiOutlierDetectionResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_OutlierDetectionResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns a list of available LLM Endpoints
     * @summary Get Active LLM Endpoints for this workspace
     * @param {ActionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public resolveLlmEndpoints(
        requestParameters: ActionsApiResolveLlmEndpointsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_ResolveLlmEndpoints(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public retrieveExecutionMetadata(
        requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_RetrieveExecutionMetadata(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public retrieveResult(requestParameters: ActionsApiRetrieveResultRequest, options?: AxiosRequestConfig) {
        return ActionsApi_RetrieveResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns a list of tags for this workspace
     * @summary Get Analytics Catalog Tags
     * @param {ActionsApiTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public tags(requestParameters: ActionsApiTagsRequest, options?: AxiosRequestConfig) {
        return ActionsApi_Tags(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Triggers asynchronous calculation of metadata quality issues and returns a process ID for status tracking.
     * @summary Trigger Quality Issues Calculation
     * @param {ActionsApiTriggerQualityIssuesCalculationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public triggerQualityIssuesCalculation(
        requestParameters: ActionsApiTriggerQualityIssuesCalculationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_TriggerQualityIssuesCalculation(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Validates LLM endpoint with provided parameters.
     * @summary Validate LLM Endpoint
     * @param {ActionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public validateLLMEndpoint(
        requestParameters: ActionsApiValidateLLMEndpointRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_ValidateLLMEndpoint(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
     * @summary Validate LLM Endpoint By Id
     * @param {ActionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public validateLLMEndpointById(
        requestParameters: ActionsApiValidateLLMEndpointByIdRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApi_ValidateLLMEndpointById(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
 * @summary Applies all the given cancel tokens.
 * @param {string} workspaceId Workspace identifier
 * @param {AfmCancelTokens} afmCancelTokens
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_CancelExecutions(
    workspaceId: string,
    afmCancelTokens: AfmCancelTokens,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("cancelExecutions", "workspaceId", workspaceId);
    // verify required parameter 'afmCancelTokens' is not null or undefined
    assertParamExists("cancelExecutions", "afmCancelTokens", afmCancelTokens);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/cancel`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof afmCancelTokens !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(afmCancelTokens !== undefined ? afmCancelTokens : {})
        : afmCancelTokens || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * Computes change analysis for the provided execution definition.
 * @summary Compute change analysis
 * @param {string} workspaceId Workspace identifier
 * @param {ChangeAnalysisRequest} changeAnalysisRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_ChangeAnalysis(
    workspaceId: string,
    changeAnalysisRequest: ChangeAnalysisRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("changeAnalysis", "workspaceId", workspaceId);
    // verify required parameter 'changeAnalysisRequest' is not null or undefined
    assertParamExists("changeAnalysis", "changeAnalysisRequest", changeAnalysisRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/computeChangeAnalysis`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof changeAnalysisRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(changeAnalysisRequest !== undefined ? changeAnalysisRequest : {})
        : changeAnalysisRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * Gets change analysis result.
 * @summary Get change analysis result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_ChangeAnalysisResult(
    workspaceId: string,
    resultId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("changeAnalysisResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("changeAnalysisResult", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/computeChangeAnalysis/result/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * Returns paged list of elements (values) of given label satisfying given filtering criteria.
 * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
 * @param {string} workspaceId Workspace identifier
 * @param {ElementsRequest} elementsRequest
 * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
 * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_ComputeLabelElementsPost(
    workspaceId: string,
    elementsRequest: ElementsRequest,
    offset?: number,
    limit?: number,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("computeLabelElementsPost", "workspaceId", workspaceId);
    // verify required parameter 'elementsRequest' is not null or undefined
    assertParamExists("computeLabelElementsPost", "elementsRequest", elementsRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof elementsRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
        : elementsRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
 * @summary Executes analytical request and returns link to the result
 * @param {string} workspaceId Workspace identifier
 * @param {AfmExecution} afmExecution
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {string} [timestamp]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_ComputeReport(
    workspaceId: string,
    afmExecution: AfmExecution,
    skipCache?: boolean,
    timestamp?: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("computeReport", "workspaceId", workspaceId);
    // verify required parameter 'afmExecution' is not null or undefined
    assertParamExists("computeReport", "afmExecution", afmExecution);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    if (timestamp !== undefined && timestamp !== null) {
        localVarHeaderParameter["timestamp"] = String(timestamp);
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof afmExecution !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
        : afmExecution || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
 * @summary (BETA) Valid descendants
 * @param {string} workspaceId Workspace identifier
 * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_ComputeValidDescendants(
    workspaceId: string,
    afmValidDescendantsQuery: AfmValidDescendantsQuery,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("computeValidDescendants", "workspaceId", workspaceId);
    // verify required parameter 'afmValidDescendantsQuery' is not null or undefined
    assertParamExists("computeValidDescendants", "afmValidDescendantsQuery", afmValidDescendantsQuery);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidDescendants`.replace(
            `{${"workspaceId"}}`,
            encodeURIComponent(String(workspaceId)),
        );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof afmValidDescendantsQuery !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(afmValidDescendantsQuery !== undefined ? afmValidDescendantsQuery : {})
        : afmValidDescendantsQuery || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
 * @summary Valid objects
 * @param {string} workspaceId Workspace identifier
 * @param {AfmValidObjectsQuery} afmValidObjectsQuery
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_ComputeValidObjects(
    workspaceId: string,
    afmValidObjectsQuery: AfmValidObjectsQuery,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("computeValidObjects", "workspaceId", workspaceId);
    // verify required parameter 'afmValidObjectsQuery' is not null or undefined
    assertParamExists("computeValidObjects", "afmValidObjectsQuery", afmValidObjectsQuery);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof afmValidObjectsQuery !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
        : afmValidObjectsQuery || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * The resource provides static structures needed for investigation of a problem with given AFM.
 * @summary AFM explain resource.
 * @param {string} workspaceId Workspace identifier
 * @param {AfmExecution} afmExecution
 * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS' | 'COMPRESSED_SQL'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;COMPRESSED_GRPC_MODEL_SVG&#x60; - Generated SVG image of the model fragment used in the query  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;COMPRESSED_SQL&#x60; - Final SQL to be executed with rolled SQL datasets  &#x60;SETTINGS&#x60; - Settings used to execute explain request
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_ExplainAFM(
    workspaceId: string,
    afmExecution: AfmExecution,
    explainType?:
        | "MAQL"
        | "GRPC_MODEL"
        | "GRPC_MODEL_SVG"
        | "WDF"
        | "QT"
        | "QT_SVG"
        | "OPT_QT"
        | "OPT_QT_SVG"
        | "SQL"
        | "SETTINGS"
        | "COMPRESSED_SQL",
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("explainAFM", "workspaceId", workspaceId);
    // verify required parameter 'afmExecution' is not null or undefined
    assertParamExists("explainAFM", "afmExecution", afmExecution);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (explainType !== undefined) {
        localVarQueryParameter["explainType"] = explainType;
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof afmExecution !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
        : afmExecution || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
 * @summary (EXPERIMENTAL) Compute key driver analysis
 * @param {string} workspaceId Workspace identifier
 * @param {KeyDriversRequest} keyDriversRequest
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_KeyDriverAnalysis(
    workspaceId: string,
    keyDriversRequest: KeyDriversRequest,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("keyDriverAnalysis", "workspaceId", workspaceId);
    // verify required parameter 'keyDriversRequest' is not null or undefined
    assertParamExists("keyDriverAnalysis", "keyDriversRequest", keyDriversRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof keyDriversRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(keyDriversRequest !== undefined ? keyDriversRequest : {})
        : keyDriversRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Gets key driver analysis.
 * @summary (EXPERIMENTAL) Get key driver analysis result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {number} [offset]
 * @param {number} [limit]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_KeyDriverAnalysisResult(
    workspaceId: string,
    resultId: string,
    offset?: number,
    limit?: number,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("keyDriverAnalysisResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("keyDriverAnalysisResult", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers/result/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * (BETA) Computes outlier detection for the provided execution definition.
 * @summary (BETA) Outlier Detection
 * @param {string} workspaceId Workspace identifier
 * @param {OutlierDetectionRequest} outlierDetectionRequest
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_OutlierDetection(
    workspaceId: string,
    outlierDetectionRequest: OutlierDetectionRequest,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("outlierDetection", "workspaceId", workspaceId);
    // verify required parameter 'outlierDetectionRequest' is not null or undefined
    assertParamExists("outlierDetection", "outlierDetectionRequest", outlierDetectionRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/detectOutliers`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof outlierDetectionRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(outlierDetectionRequest !== undefined ? outlierDetectionRequest : {})
        : outlierDetectionRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * (BETA) Gets outlier detection result.
 * @summary (BETA) Outlier Detection Result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {number} [offset]
 * @param {number} [limit]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_OutlierDetectionResult(
    workspaceId: string,
    resultId: string,
    offset?: number,
    limit?: number,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("outlierDetectionResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("outlierDetectionResult", "resultId", resultId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/detectOutliers/result/{resultId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
 * @summary Get a single execution result\'s metadata.
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_RetrieveExecutionMetadata(
    workspaceId: string,
    resultId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("retrieveExecutionMetadata", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("retrieveExecutionMetadata", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}/metadata`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * Gets a single execution result.
 * @summary Get a single execution result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
 * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
 * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
 * @param {string} [xGDCCANCELTOKEN]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_RetrieveResult(
    workspaceId: string,
    resultId: string,
    offset?: Array<number>,
    limit?: Array<number>,
    excludedTotalDimensions?: Array<string>,
    xGDCCANCELTOKEN?: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("retrieveResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("retrieveResult", "resultId", resultId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset) {
        localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
    }

    if (limit) {
        localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
    }

    if (excludedTotalDimensions) {
        localVarQueryParameter["excludedTotalDimensions"] = excludedTotalDimensions.join(
            COLLECTION_FORMATS.csv,
        );
    }

    if (xGDCCANCELTOKEN !== undefined && xGDCCANCELTOKEN !== null) {
        localVarHeaderParameter["X-GDC-CANCEL-TOKEN"] = String(xGDCCANCELTOKEN);
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// ComputationApi Api FP
/**
 * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
 * @summary Applies all the given cancel tokens.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiCancelExecutionsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_CancelExecutions(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiCancelExecutionsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AfmCancelTokens> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_CancelExecutions(
        requestParameters.workspaceId,
        requestParameters.afmCancelTokens,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * Computes change analysis for the provided execution definition.
 * @summary Compute change analysis
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiChangeAnalysisRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_ChangeAnalysis(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiChangeAnalysisRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ChangeAnalysisResponse> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_ChangeAnalysis(
        requestParameters.workspaceId,
        requestParameters.changeAnalysisRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * Gets change analysis result.
 * @summary Get change analysis result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiChangeAnalysisResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_ChangeAnalysisResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiChangeAnalysisResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ChangeAnalysisResult> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_ChangeAnalysisResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * Returns paged list of elements (values) of given label satisfying given filtering criteria.
 * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_ComputeLabelElementsPost(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiComputeLabelElementsPostRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ElementsResponse> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_ComputeLabelElementsPost(
        requestParameters.workspaceId,
        requestParameters.elementsRequest,
        requestParameters.offset,
        requestParameters.limit,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
 * @summary Executes analytical request and returns link to the result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_ComputeReport(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiComputeReportRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AfmExecutionResponse> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_ComputeReport(
        requestParameters.workspaceId,
        requestParameters.afmExecution,
        requestParameters.skipCache,
        requestParameters.timestamp,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
 * @summary (BETA) Valid descendants
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_ComputeValidDescendants(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiComputeValidDescendantsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AfmValidDescendantsResponse> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_ComputeValidDescendants(
        requestParameters.workspaceId,
        requestParameters.afmValidDescendantsQuery,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
 * @summary Valid objects
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_ComputeValidObjects(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiComputeValidObjectsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AfmValidObjectsResponse> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_ComputeValidObjects(
        requestParameters.workspaceId,
        requestParameters.afmValidObjectsQuery,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * The resource provides static structures needed for investigation of a problem with given AFM.
 * @summary AFM explain resource.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_ExplainAFM(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiExplainAFMRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<File> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_ExplainAFM(
        requestParameters.workspaceId,
        requestParameters.afmExecution,
        requestParameters.explainType,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
 * @summary (EXPERIMENTAL) Compute key driver analysis
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiKeyDriverAnalysisRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_KeyDriverAnalysis(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiKeyDriverAnalysisRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<KeyDriversResponse> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_KeyDriverAnalysis(
        requestParameters.workspaceId,
        requestParameters.keyDriversRequest,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * (EXPERIMENTAL) Gets key driver analysis.
 * @summary (EXPERIMENTAL) Get key driver analysis result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_KeyDriverAnalysisResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiKeyDriverAnalysisResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<KeyDriversResult> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_KeyDriverAnalysisResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * (BETA) Computes outlier detection for the provided execution definition.
 * @summary (BETA) Outlier Detection
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiOutlierDetectionRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_OutlierDetection(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiOutlierDetectionRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<OutlierDetectionResponse> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_OutlierDetection(
        requestParameters.workspaceId,
        requestParameters.outlierDetectionRequest,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * (BETA) Gets outlier detection result.
 * @summary (BETA) Outlier Detection Result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiOutlierDetectionResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_OutlierDetectionResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiOutlierDetectionResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<OutlierDetectionResult> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_OutlierDetectionResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
 * @summary Get a single execution result\'s metadata.
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_RetrieveExecutionMetadata(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ResultCacheMetadata> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_RetrieveExecutionMetadata(
        requestParameters.workspaceId,
        requestParameters.resultId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// ComputationApi Api FP
/**
 * Gets a single execution result.
 * @summary Get a single execution result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_RetrieveResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: ComputationApiRetrieveResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ExecutionResult> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_RetrieveResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        requestParameters.excludedTotalDimensions,
        requestParameters.xGDCCANCELTOKEN,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * ComputationApi - interface
 * @export
 * @interface ComputationApi
 */
export interface ComputationApiInterface {
    /**
     * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
     * @summary Applies all the given cancel tokens.
     * @param {ComputationApiCancelExecutionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    cancelExecutions(
        requestParameters: ComputationApiCancelExecutionsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmCancelTokens>;

    /**
     * Computes change analysis for the provided execution definition.
     * @summary Compute change analysis
     * @param {ComputationApiChangeAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    changeAnalysis(
        requestParameters: ComputationApiChangeAnalysisRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChangeAnalysisResponse>;

    /**
     * Gets change analysis result.
     * @summary Get change analysis result
     * @param {ComputationApiChangeAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    changeAnalysisResult(
        requestParameters: ComputationApiChangeAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChangeAnalysisResult>;

    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeLabelElementsPost(
        requestParameters: ComputationApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ElementsResponse>;

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeReport(
        requestParameters: ComputationApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmExecutionResponse>;

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeValidDescendants(
        requestParameters: ComputationApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidDescendantsResponse>;

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeValidObjects(
        requestParameters: ComputationApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidObjectsResponse>;

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    explainAFM(
        requestParameters: ComputationApiExplainAFMRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<File>;

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ComputationApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    keyDriverAnalysis(
        requestParameters: ComputationApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResponse>;

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ComputationApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    keyDriverAnalysisResult(
        requestParameters: ComputationApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResult>;

    /**
     * (BETA) Computes outlier detection for the provided execution definition.
     * @summary (BETA) Outlier Detection
     * @param {ComputationApiOutlierDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    outlierDetection(
        requestParameters: ComputationApiOutlierDetectionRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<OutlierDetectionResponse>;

    /**
     * (BETA) Gets outlier detection result.
     * @summary (BETA) Outlier Detection Result
     * @param {ComputationApiOutlierDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    outlierDetectionResult(
        requestParameters: ComputationApiOutlierDetectionResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<OutlierDetectionResult>;

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    retrieveExecutionMetadata(
        requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResultCacheMetadata>;

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    retrieveResult(
        requestParameters: ComputationApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExecutionResult>;
}

/**
 * Request parameters for cancelExecutions operation in ComputationApi.
 * @export
 * @interface ComputationApiCancelExecutionsRequest
 */
export interface ComputationApiCancelExecutionsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiCancelExecutions
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmCancelTokens}
     * @memberof ComputationApiCancelExecutions
     */
    readonly afmCancelTokens: AfmCancelTokens;
}

/**
 * Request parameters for changeAnalysis operation in ComputationApi.
 * @export
 * @interface ComputationApiChangeAnalysisRequest
 */
export interface ComputationApiChangeAnalysisRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiChangeAnalysis
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChangeAnalysisRequest}
     * @memberof ComputationApiChangeAnalysis
     */
    readonly changeAnalysisRequest: ChangeAnalysisRequest;
}

/**
 * Request parameters for changeAnalysisResult operation in ComputationApi.
 * @export
 * @interface ComputationApiChangeAnalysisResultRequest
 */
export interface ComputationApiChangeAnalysisResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiChangeAnalysisResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiChangeAnalysisResult
     */
    readonly resultId: string;
}

/**
 * Request parameters for computeLabelElementsPost operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeLabelElementsPostRequest
 */
export interface ComputationApiComputeLabelElementsPostRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ElementsRequest}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly elementsRequest: ElementsRequest;

    /**
     * Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly offset?: number;

    /**
     * Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly limit?: number;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for computeReport operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeReportRequest
 */
export interface ComputationApiComputeReportRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeReport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ComputationApiComputeReport
     */
    readonly afmExecution: AfmExecution;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiComputeReport
     */
    readonly skipCache?: boolean;

    /**
     *
     * @type {string}
     * @memberof ComputationApiComputeReport
     */
    readonly timestamp?: string;
}

/**
 * Request parameters for computeValidDescendants operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeValidDescendantsRequest
 */
export interface ComputationApiComputeValidDescendantsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeValidDescendants
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidDescendantsQuery}
     * @memberof ComputationApiComputeValidDescendants
     */
    readonly afmValidDescendantsQuery: AfmValidDescendantsQuery;
}

/**
 * Request parameters for computeValidObjects operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeValidObjectsRequest
 */
export interface ComputationApiComputeValidObjectsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeValidObjects
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidObjectsQuery}
     * @memberof ComputationApiComputeValidObjects
     */
    readonly afmValidObjectsQuery: AfmValidObjectsQuery;
}

/**
 * Request parameters for explainAFM operation in ComputationApi.
 * @export
 * @interface ComputationApiExplainAFMRequest
 */
export interface ComputationApiExplainAFMRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiExplainAFM
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ComputationApiExplainAFM
     */
    readonly afmExecution: AfmExecution;

    /**
     * Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;COMPRESSED_GRPC_MODEL_SVG&#x60; - Generated SVG image of the model fragment used in the query  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;COMPRESSED_SQL&#x60; - Final SQL to be executed with rolled SQL datasets  &#x60;SETTINGS&#x60; - Settings used to execute explain request
     * @type {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS' | 'COMPRESSED_SQL'}
     * @memberof ComputationApiExplainAFM
     */
    readonly explainType?:
        | "MAQL"
        | "GRPC_MODEL"
        | "GRPC_MODEL_SVG"
        | "WDF"
        | "QT"
        | "QT_SVG"
        | "OPT_QT"
        | "OPT_QT_SVG"
        | "SQL"
        | "SETTINGS"
        | "COMPRESSED_SQL";
}

/**
 * Request parameters for keyDriverAnalysis operation in ComputationApi.
 * @export
 * @interface ComputationApiKeyDriverAnalysisRequest
 */
export interface ComputationApiKeyDriverAnalysisRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiKeyDriverAnalysis
     */
    readonly workspaceId: string;

    /**
     *
     * @type {KeyDriversRequest}
     * @memberof ComputationApiKeyDriverAnalysis
     */
    readonly keyDriversRequest: KeyDriversRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiKeyDriverAnalysis
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for keyDriverAnalysisResult operation in ComputationApi.
 * @export
 * @interface ComputationApiKeyDriverAnalysisResultRequest
 */
export interface ComputationApiKeyDriverAnalysisResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for outlierDetection operation in ComputationApi.
 * @export
 * @interface ComputationApiOutlierDetectionRequest
 */
export interface ComputationApiOutlierDetectionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiOutlierDetection
     */
    readonly workspaceId: string;

    /**
     *
     * @type {OutlierDetectionRequest}
     * @memberof ComputationApiOutlierDetection
     */
    readonly outlierDetectionRequest: OutlierDetectionRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiOutlierDetection
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for outlierDetectionResult operation in ComputationApi.
 * @export
 * @interface ComputationApiOutlierDetectionResultRequest
 */
export interface ComputationApiOutlierDetectionResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiOutlierDetectionResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiOutlierDetectionResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ComputationApiOutlierDetectionResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ComputationApiOutlierDetectionResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for retrieveExecutionMetadata operation in ComputationApi.
 * @export
 * @interface ComputationApiRetrieveExecutionMetadataRequest
 */
export interface ComputationApiRetrieveExecutionMetadataRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiRetrieveExecutionMetadata
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiRetrieveExecutionMetadata
     */
    readonly resultId: string;
}

/**
 * Request parameters for retrieveResult operation in ComputationApi.
 * @export
 * @interface ComputationApiRetrieveResultRequest
 */
export interface ComputationApiRetrieveResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiRetrieveResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiRetrieveResult
     */
    readonly resultId: string;

    /**
     * Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly offset?: Array<number>;

    /**
     * Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly limit?: Array<number>;

    /**
     * Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
     * @type {Array<string>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly excludedTotalDimensions?: Array<string>;

    /**
     *
     * @type {string}
     * @memberof ComputationApiRetrieveResult
     */
    readonly xGDCCANCELTOKEN?: string;
}

/**
 * ComputationApi - object-oriented interface
 * @export
 * @class ComputationApi
 * @extends {BaseAPI}
 */
export class ComputationApi extends BaseAPI implements ComputationApiInterface {
    /**
     * Each cancel token corresponds to one unique execution request for the same result id. If all cancel tokens for the same result id are applied, the execution for this result id is cancelled.
     * @summary Applies all the given cancel tokens.
     * @param {ComputationApiCancelExecutionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public cancelExecutions(
        requestParameters: ComputationApiCancelExecutionsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_CancelExecutions(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Computes change analysis for the provided execution definition.
     * @summary Compute change analysis
     * @param {ComputationApiChangeAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public changeAnalysis(
        requestParameters: ComputationApiChangeAnalysisRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_ChangeAnalysis(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Gets change analysis result.
     * @summary Get change analysis result
     * @param {ComputationApiChangeAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public changeAnalysisResult(
        requestParameters: ComputationApiChangeAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_ChangeAnalysisResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeLabelElementsPost(
        requestParameters: ComputationApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_ComputeLabelElementsPost(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeReport(
        requestParameters: ComputationApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_ComputeReport(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeValidDescendants(
        requestParameters: ComputationApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_ComputeValidDescendants(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeValidObjects(
        requestParameters: ComputationApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_ComputeValidObjects(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public explainAFM(requestParameters: ComputationApiExplainAFMRequest, options?: AxiosRequestConfig) {
        return ComputationApi_ExplainAFM(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ComputationApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public keyDriverAnalysis(
        requestParameters: ComputationApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_KeyDriverAnalysis(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ComputationApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public keyDriverAnalysisResult(
        requestParameters: ComputationApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_KeyDriverAnalysisResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Computes outlier detection for the provided execution definition.
     * @summary (BETA) Outlier Detection
     * @param {ComputationApiOutlierDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public outlierDetection(
        requestParameters: ComputationApiOutlierDetectionRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_OutlierDetection(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Gets outlier detection result.
     * @summary (BETA) Outlier Detection Result
     * @param {ComputationApiOutlierDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public outlierDetectionResult(
        requestParameters: ComputationApiOutlierDetectionResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_OutlierDetectionResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public retrieveExecutionMetadata(
        requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_RetrieveExecutionMetadata(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public retrieveResult(
        requestParameters: ComputationApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApi_RetrieveResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * (BETA) Combines multiple use cases such as search, create visualizations, ...
 * @summary (BETA) Chat with AI
 * @param {string} workspaceId Workspace identifier
 * @param {ChatRequest} chatRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_AiChat(
    workspaceId: string,
    chatRequest: ChatRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("aiChat", "workspaceId", workspaceId);
    // verify required parameter 'chatRequest' is not null or undefined
    assertParamExists("aiChat", "chatRequest", chatRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chat`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof chatRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
        : chatRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
 * @summary (BETA) Get Chat History
 * @param {string} workspaceId Workspace identifier
 * @param {ChatHistoryRequest} chatHistoryRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_AiChatHistory(
    workspaceId: string,
    chatHistoryRequest: ChatHistoryRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("aiChatHistory", "workspaceId", workspaceId);
    // verify required parameter 'chatHistoryRequest' is not null or undefined
    assertParamExists("aiChatHistory", "chatHistoryRequest", chatHistoryRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatHistory`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof chatHistoryRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(chatHistoryRequest !== undefined ? chatHistoryRequest : {})
        : chatHistoryRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * (BETA) Combines multiple use cases such as search, create visualizations, ...
 * @summary (BETA) Chat with AI
 * @param {string} workspaceId Workspace identifier
 * @param {ChatRequest} chatRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_AiChatStream(
    workspaceId: string,
    chatRequest: ChatRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("aiChatStream", "workspaceId", workspaceId);
    // verify required parameter 'chatRequest' is not null or undefined
    assertParamExists("aiChatStream", "chatRequest", chatRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatStream`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof chatRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
        : chatRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * Returns usage statistics of chat for a user in a workspace.
 * @summary Get Chat Usage
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_AiChatUsage(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("aiChatUsage", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatUsage`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
 * @summary (BETA) Semantic Search in Metadata
 * @param {string} workspaceId Workspace identifier
 * @param {SearchRequest} searchRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_AiSearch(
    workspaceId: string,
    searchRequest: SearchRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("aiSearch", "workspaceId", workspaceId);
    // verify required parameter 'searchRequest' is not null or undefined
    assertParamExists("aiSearch", "searchRequest", searchRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/search`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof searchRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(searchRequest !== undefined ? searchRequest : {})
        : searchRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Computes anomaly detection.
 * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Input result ID to be used in the computation
 * @param {AnomalyDetectionRequest} anomalyDetectionRequest
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_AnomalyDetection(
    workspaceId: string,
    resultId: string,
    anomalyDetectionRequest: AnomalyDetectionRequest,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("anomalyDetection", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("anomalyDetection", "resultId", resultId);
    // verify required parameter 'anomalyDetectionRequest' is not null or undefined
    assertParamExists("anomalyDetection", "anomalyDetectionRequest", anomalyDetectionRequest);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof anomalyDetectionRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(anomalyDetectionRequest !== undefined ? anomalyDetectionRequest : {})
        : anomalyDetectionRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Gets anomalies.
 * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {number} [offset]
 * @param {number} [limit]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_AnomalyDetectionResult(
    workspaceId: string,
    resultId: string,
    offset?: number,
    limit?: number,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("anomalyDetectionResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("anomalyDetectionResult", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/result/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
 * @summary (EXPERIMENTAL) Smart functions - Clustering
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Input result ID to be used in the computation
 * @param {ClusteringRequest} clusteringRequest
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_Clustering(
    workspaceId: string,
    resultId: string,
    clusteringRequest: ClusteringRequest,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("clustering", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("clustering", "resultId", resultId);
    // verify required parameter 'clusteringRequest' is not null or undefined
    assertParamExists("clustering", "clusteringRequest", clusteringRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/{resultId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof clusteringRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(clusteringRequest !== undefined ? clusteringRequest : {})
        : clusteringRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Gets clustering result.
 * @summary (EXPERIMENTAL) Smart functions - Clustering Result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {number} [offset]
 * @param {number} [limit]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_ClusteringResult(
    workspaceId: string,
    resultId: string,
    offset?: number,
    limit?: number,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("clusteringResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("clusteringResult", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/result/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * Returns a list of Users who created any object for this workspace
 * @summary Get Analytics Catalog CreatedBy Users
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_CreatedBy(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("createdBy", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/analyticsCatalog/createdBy`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * (BETA) Computes forecasted data points from the provided execution result and parameters.
 * @summary (BETA) Smart functions - Forecast
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Input result ID to be used in the computation
 * @param {ForecastRequest} forecastRequest
 * @param {boolean} [skipCache] Ignore all caches during execution of current request.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_Forecast(
    workspaceId: string,
    resultId: string,
    forecastRequest: ForecastRequest,
    skipCache?: boolean,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("forecast", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("forecast", "resultId", resultId);
    // verify required parameter 'forecastRequest' is not null or undefined
    assertParamExists("forecast", "forecastRequest", forecastRequest);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/{resultId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (skipCache !== undefined && skipCache !== null) {
        localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
    }

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof forecastRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(forecastRequest !== undefined ? forecastRequest : {})
        : forecastRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * (BETA) Gets forecast result.
 * @summary (BETA) Smart functions - Forecast Result
 * @param {string} workspaceId Workspace identifier
 * @param {string} resultId Result ID
 * @param {number} [offset]
 * @param {number} [limit]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_ForecastResult(
    workspaceId: string,
    resultId: string,
    offset?: number,
    limit?: number,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("forecastResult", "workspaceId", workspaceId);
    // verify required parameter 'resultId' is not null or undefined
    assertParamExists("forecastResult", "resultId", resultId);
    const localVarPath =
        `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/result/{resultId}`
            .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
            .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    if (offset !== undefined) {
        localVarQueryParameter["offset"] = offset;
    }

    if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
    }

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * Returns metadata quality issues detected by the platform linter.
 * @summary Get Quality Issues
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_GetQualityIssues(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getQualityIssues", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/issues`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * Returns the status of a quality issues calculation process identified by process ID.
 * @summary Get Quality Issues Calculation Status
 * @param {string} workspaceId Workspace identifier
 * @param {string} processId
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_GetQualityIssuesCalculationStatus(
    workspaceId: string,
    processId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("getQualityIssuesCalculationStatus", "workspaceId", workspaceId);
    // verify required parameter 'processId' is not null or undefined
    assertParamExists("getQualityIssuesCalculationStatus", "processId", processId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/issues/status/{processId}`
        .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
        .replace(`{${"processId"}}`, encodeURIComponent(String(processId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * Returns a list of Users who created any memory item for this workspace
 * @summary Get AI Memory CreatedBy Users
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_MemoryCreatedByUsers(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("memoryCreatedByUsers", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/memory/createdBy`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * Returns a list of available LLM Endpoints
 * @summary Get Active LLM Endpoints for this workspace
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_ResolveLlmEndpoints(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("resolveLlmEndpoints", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/resolveLlmEndpoints`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * Returns a list of tags for this workspace
 * @summary Get Analytics Catalog Tags
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_Tags(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("tags", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/analyticsCatalog/tags`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * Triggers asynchronous calculation of metadata quality issues and returns a process ID for status tracking.
 * @summary Trigger Quality Issues Calculation
 * @param {string} workspaceId Workspace identifier
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_TriggerQualityIssuesCalculation(
    workspaceId: string,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'workspaceId' is not null or undefined
    assertParamExists("triggerQualityIssuesCalculation", "workspaceId", workspaceId);
    const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/issues/triggerCheck`.replace(
        `{${"workspaceId"}}`,
        encodeURIComponent(String(workspaceId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * Validates LLM endpoint with provided parameters.
 * @summary Validate LLM Endpoint
 * @param {ValidateLLMEndpointRequest} validateLLMEndpointRequest
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_ValidateLLMEndpoint(
    validateLLMEndpointRequest: ValidateLLMEndpointRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'validateLLMEndpointRequest' is not null or undefined
    assertParamExists("validateLLMEndpoint", "validateLLMEndpointRequest", validateLLMEndpointRequest);
    const localVarPath = `/api/v1/actions/ai/llmEndpoint/test`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof validateLLMEndpointRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(validateLLMEndpointRequest !== undefined ? validateLLMEndpointRequest : {})
        : validateLLMEndpointRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi FP - SmartFunctionsApiAxiosParamCreator
/**
 * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
 * @summary Validate LLM Endpoint By Id
 * @param {string} llmEndpointId
 * @param {ValidateLLMEndpointByIdRequest} [validateLLMEndpointByIdRequest]
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApiAxiosParamCreator_ValidateLLMEndpointById(
    llmEndpointId: string,
    validateLLMEndpointByIdRequest?: ValidateLLMEndpointByIdRequest,
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'llmEndpointId' is not null or undefined
    assertParamExists("validateLLMEndpointById", "llmEndpointId", llmEndpointId);
    const localVarPath = `/api/v1/actions/ai/llmEndpoint/{llmEndpointId}/test`.replace(
        `{${"llmEndpointId"}}`,
        encodeURIComponent(String(llmEndpointId)),
    );
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;

    localVarHeaderParameter["Content-Type"] = "application/json";

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof validateLLMEndpointByIdRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(validateLLMEndpointByIdRequest !== undefined ? validateLLMEndpointByIdRequest : {})
        : validateLLMEndpointByIdRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}

// SmartFunctionsApi Api FP
/**
 * (BETA) Combines multiple use cases such as search, create visualizations, ...
 * @summary (BETA) Chat with AI
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiAiChatRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_AiChat(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiAiChatRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ChatResult> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_AiChat(
        requestParameters.workspaceId,
        requestParameters.chatRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
 * @summary (BETA) Get Chat History
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiAiChatHistoryRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_AiChatHistory(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiAiChatHistoryRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ChatHistoryResult> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_AiChatHistory(
        requestParameters.workspaceId,
        requestParameters.chatHistoryRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * (BETA) Combines multiple use cases such as search, create visualizations, ...
 * @summary (BETA) Chat with AI
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiAiChatStreamRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_AiChatStream(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiAiChatStreamRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<Array<object>> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_AiChatStream(
        requestParameters.workspaceId,
        requestParameters.chatRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * Returns usage statistics of chat for a user in a workspace.
 * @summary Get Chat Usage
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiAiChatUsageRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_AiChatUsage(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiAiChatUsageRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ChatUsageResponse> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_AiChatUsage(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
 * @summary (BETA) Semantic Search in Metadata
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiAiSearchRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_AiSearch(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiAiSearchRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<SearchResult> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_AiSearch(
        requestParameters.workspaceId,
        requestParameters.searchRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * (EXPERIMENTAL) Computes anomaly detection.
 * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiAnomalyDetectionRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_AnomalyDetection(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiAnomalyDetectionRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<SmartFunctionResponse> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_AnomalyDetection(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.anomalyDetectionRequest,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * (EXPERIMENTAL) Gets anomalies.
 * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_AnomalyDetectionResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiAnomalyDetectionResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AnomalyDetectionResult> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_AnomalyDetectionResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
 * @summary (EXPERIMENTAL) Smart functions - Clustering
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiClusteringRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_Clustering(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiClusteringRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<SmartFunctionResponse> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_Clustering(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.clusteringRequest,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * (EXPERIMENTAL) Gets clustering result.
 * @summary (EXPERIMENTAL) Smart functions - Clustering Result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiClusteringResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_ClusteringResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiClusteringResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ClusteringResult> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_ClusteringResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * Returns a list of Users who created any object for this workspace
 * @summary Get Analytics Catalog CreatedBy Users
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiCreatedByRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_CreatedBy(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiCreatedByRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AnalyticsCatalogCreatedBy> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_CreatedBy(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * (BETA) Computes forecasted data points from the provided execution result and parameters.
 * @summary (BETA) Smart functions - Forecast
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_Forecast(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiForecastRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<SmartFunctionResponse> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_Forecast(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.forecastRequest,
        requestParameters.skipCache,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * (BETA) Gets forecast result.
 * @summary (BETA) Smart functions - Forecast Result
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_ForecastResult(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiForecastResultRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ForecastResult> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_ForecastResult(
        requestParameters.workspaceId,
        requestParameters.resultId,
        requestParameters.offset,
        requestParameters.limit,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * Returns metadata quality issues detected by the platform linter.
 * @summary Get Quality Issues
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiGetQualityIssuesRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_GetQualityIssues(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiGetQualityIssuesRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<GetQualityIssuesResponse> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_GetQualityIssues(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * Returns the status of a quality issues calculation process identified by process ID.
 * @summary Get Quality Issues Calculation Status
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiGetQualityIssuesCalculationStatusRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_GetQualityIssuesCalculationStatus(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiGetQualityIssuesCalculationStatusRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<QualityIssuesCalculationStatusResponse> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_GetQualityIssuesCalculationStatus(
        requestParameters.workspaceId,
        requestParameters.processId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * Returns a list of Users who created any memory item for this workspace
 * @summary Get AI Memory CreatedBy Users
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiMemoryCreatedByUsersRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_MemoryCreatedByUsers(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiMemoryCreatedByUsersRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<MemoryItemCreatedByUsers> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_MemoryCreatedByUsers(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * Returns a list of available LLM Endpoints
 * @summary Get Active LLM Endpoints for this workspace
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_ResolveLlmEndpoints(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiResolveLlmEndpointsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ResolvedLlmEndpoints> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_ResolveLlmEndpoints(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * Returns a list of tags for this workspace
 * @summary Get Analytics Catalog Tags
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiTagsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_Tags(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiTagsRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<AnalyticsCatalogTags> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_Tags(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * Triggers asynchronous calculation of metadata quality issues and returns a process ID for status tracking.
 * @summary Trigger Quality Issues Calculation
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiTriggerQualityIssuesCalculationRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_TriggerQualityIssuesCalculation(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiTriggerQualityIssuesCalculationRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<TriggerQualityIssuesCalculationResponse> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_TriggerQualityIssuesCalculation(
        requestParameters.workspaceId,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * Validates LLM endpoint with provided parameters.
 * @summary Validate LLM Endpoint
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_ValidateLLMEndpoint(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiValidateLLMEndpointRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ValidateLLMEndpointResponse> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_ValidateLLMEndpoint(
        requestParameters.validateLLMEndpointRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

// SmartFunctionsApi Api FP
/**
 * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
 * @summary Validate LLM Endpoint By Id
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {SmartFunctionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function SmartFunctionsApi_ValidateLLMEndpointById(
    axios: AxiosInstance,
    basePath: string,
    requestParameters: SmartFunctionsApiValidateLLMEndpointByIdRequest,
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ValidateLLMEndpointResponse> {
    const localVarAxiosArgs = await SmartFunctionsApiAxiosParamCreator_ValidateLLMEndpointById(
        requestParameters.llmEndpointId,
        requestParameters.validateLLMEndpointByIdRequest,
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}

/**
 * SmartFunctionsApi - interface
 * @export
 * @interface SmartFunctionsApi
 */
export interface SmartFunctionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiChat(
        requestParameters: SmartFunctionsApiAiChatRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatResult>;

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {SmartFunctionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiChatHistory(
        requestParameters: SmartFunctionsApiAiChatHistoryRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatHistoryResult>;

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiChatStream(
        requestParameters: SmartFunctionsApiAiChatStreamRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<object>>;

    /**
     * Returns usage statistics of chat for a user in a workspace.
     * @summary Get Chat Usage
     * @param {SmartFunctionsApiAiChatUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiChatUsage(
        requestParameters: SmartFunctionsApiAiChatUsageRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatUsageResponse>;

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {SmartFunctionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiSearch(
        requestParameters: SmartFunctionsApiAiSearchRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SearchResult>;

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {SmartFunctionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    anomalyDetection(
        requestParameters: SmartFunctionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {SmartFunctionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    anomalyDetectionResult(
        requestParameters: SmartFunctionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnomalyDetectionResult>;

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {SmartFunctionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    clustering(
        requestParameters: SmartFunctionsApiClusteringRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {SmartFunctionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    clusteringResult(
        requestParameters: SmartFunctionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ClusteringResult>;

    /**
     * Returns a list of Users who created any object for this workspace
     * @summary Get Analytics Catalog CreatedBy Users
     * @param {SmartFunctionsApiCreatedByRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    createdBy(
        requestParameters: SmartFunctionsApiCreatedByRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnalyticsCatalogCreatedBy>;

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    forecast(
        requestParameters: SmartFunctionsApiForecastRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    forecastResult(
        requestParameters: SmartFunctionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ForecastResult>;

    /**
     * Returns metadata quality issues detected by the platform linter.
     * @summary Get Quality Issues
     * @param {SmartFunctionsApiGetQualityIssuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    getQualityIssues(
        requestParameters: SmartFunctionsApiGetQualityIssuesRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<GetQualityIssuesResponse>;

    /**
     * Returns the status of a quality issues calculation process identified by process ID.
     * @summary Get Quality Issues Calculation Status
     * @param {SmartFunctionsApiGetQualityIssuesCalculationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    getQualityIssuesCalculationStatus(
        requestParameters: SmartFunctionsApiGetQualityIssuesCalculationStatusRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<QualityIssuesCalculationStatusResponse>;

    /**
     * Returns a list of Users who created any memory item for this workspace
     * @summary Get AI Memory CreatedBy Users
     * @param {SmartFunctionsApiMemoryCreatedByUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    memoryCreatedByUsers(
        requestParameters: SmartFunctionsApiMemoryCreatedByUsersRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<MemoryItemCreatedByUsers>;

    /**
     * Returns a list of available LLM Endpoints
     * @summary Get Active LLM Endpoints for this workspace
     * @param {SmartFunctionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    resolveLlmEndpoints(
        requestParameters: SmartFunctionsApiResolveLlmEndpointsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResolvedLlmEndpoints>;

    /**
     * Returns a list of tags for this workspace
     * @summary Get Analytics Catalog Tags
     * @param {SmartFunctionsApiTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    tags(
        requestParameters: SmartFunctionsApiTagsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnalyticsCatalogTags>;

    /**
     * Triggers asynchronous calculation of metadata quality issues and returns a process ID for status tracking.
     * @summary Trigger Quality Issues Calculation
     * @param {SmartFunctionsApiTriggerQualityIssuesCalculationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    triggerQualityIssuesCalculation(
        requestParameters: SmartFunctionsApiTriggerQualityIssuesCalculationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TriggerQualityIssuesCalculationResponse>;

    /**
     * Validates LLM endpoint with provided parameters.
     * @summary Validate LLM Endpoint
     * @param {SmartFunctionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    validateLLMEndpoint(
        requestParameters: SmartFunctionsApiValidateLLMEndpointRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ValidateLLMEndpointResponse>;

    /**
     * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
     * @summary Validate LLM Endpoint By Id
     * @param {SmartFunctionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    validateLLMEndpointById(
        requestParameters: SmartFunctionsApiValidateLLMEndpointByIdRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ValidateLLMEndpointResponse>;
}

/**
 * Request parameters for aiChat operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiChatRequest
 */
export interface SmartFunctionsApiAiChatRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiChat
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof SmartFunctionsApiAiChat
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiChatHistory operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiChatHistoryRequest
 */
export interface SmartFunctionsApiAiChatHistoryRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiChatHistory
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatHistoryRequest}
     * @memberof SmartFunctionsApiAiChatHistory
     */
    readonly chatHistoryRequest: ChatHistoryRequest;
}

/**
 * Request parameters for aiChatStream operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiChatStreamRequest
 */
export interface SmartFunctionsApiAiChatStreamRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiChatStream
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof SmartFunctionsApiAiChatStream
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiChatUsage operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiChatUsageRequest
 */
export interface SmartFunctionsApiAiChatUsageRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiChatUsage
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for aiSearch operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiSearchRequest
 */
export interface SmartFunctionsApiAiSearchRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiSearch
     */
    readonly workspaceId: string;

    /**
     *
     * @type {SearchRequest}
     * @memberof SmartFunctionsApiAiSearch
     */
    readonly searchRequest: SearchRequest;
}

/**
 * Request parameters for anomalyDetection operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAnomalyDetectionRequest
 */
export interface SmartFunctionsApiAnomalyDetectionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly resultId: string;

    /**
     *
     * @type {AnomalyDetectionRequest}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly anomalyDetectionRequest: AnomalyDetectionRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for anomalyDetectionResult operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAnomalyDetectionResultRequest
 */
export interface SmartFunctionsApiAnomalyDetectionResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for clustering operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiClusteringRequest
 */
export interface SmartFunctionsApiClusteringRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiClustering
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof SmartFunctionsApiClustering
     */
    readonly resultId: string;

    /**
     *
     * @type {ClusteringRequest}
     * @memberof SmartFunctionsApiClustering
     */
    readonly clusteringRequest: ClusteringRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof SmartFunctionsApiClustering
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for clusteringResult operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiClusteringResultRequest
 */
export interface SmartFunctionsApiClusteringResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for createdBy operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiCreatedByRequest
 */
export interface SmartFunctionsApiCreatedByRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiCreatedBy
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for forecast operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiForecastRequest
 */
export interface SmartFunctionsApiForecastRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiForecast
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof SmartFunctionsApiForecast
     */
    readonly resultId: string;

    /**
     *
     * @type {ForecastRequest}
     * @memberof SmartFunctionsApiForecast
     */
    readonly forecastRequest: ForecastRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof SmartFunctionsApiForecast
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for forecastResult operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiForecastResultRequest
 */
export interface SmartFunctionsApiForecastResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for getQualityIssues operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiGetQualityIssuesRequest
 */
export interface SmartFunctionsApiGetQualityIssuesRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiGetQualityIssues
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for getQualityIssuesCalculationStatus operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiGetQualityIssuesCalculationStatusRequest
 */
export interface SmartFunctionsApiGetQualityIssuesCalculationStatusRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiGetQualityIssuesCalculationStatus
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof SmartFunctionsApiGetQualityIssuesCalculationStatus
     */
    readonly processId: string;
}

/**
 * Request parameters for memoryCreatedByUsers operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiMemoryCreatedByUsersRequest
 */
export interface SmartFunctionsApiMemoryCreatedByUsersRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiMemoryCreatedByUsers
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for resolveLlmEndpoints operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiResolveLlmEndpointsRequest
 */
export interface SmartFunctionsApiResolveLlmEndpointsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiResolveLlmEndpoints
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for tags operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiTagsRequest
 */
export interface SmartFunctionsApiTagsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiTags
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for triggerQualityIssuesCalculation operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiTriggerQualityIssuesCalculationRequest
 */
export interface SmartFunctionsApiTriggerQualityIssuesCalculationRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiTriggerQualityIssuesCalculation
     */
    readonly workspaceId: string;
}

/**
 * Request parameters for validateLLMEndpoint operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiValidateLLMEndpointRequest
 */
export interface SmartFunctionsApiValidateLLMEndpointRequest {
    /**
     *
     * @type {ValidateLLMEndpointRequest}
     * @memberof SmartFunctionsApiValidateLLMEndpoint
     */
    readonly validateLLMEndpointRequest: ValidateLLMEndpointRequest;
}

/**
 * Request parameters for validateLLMEndpointById operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiValidateLLMEndpointByIdRequest
 */
export interface SmartFunctionsApiValidateLLMEndpointByIdRequest {
    /**
     *
     * @type {string}
     * @memberof SmartFunctionsApiValidateLLMEndpointById
     */
    readonly llmEndpointId: string;

    /**
     *
     * @type {ValidateLLMEndpointByIdRequest}
     * @memberof SmartFunctionsApiValidateLLMEndpointById
     */
    readonly validateLLMEndpointByIdRequest?: ValidateLLMEndpointByIdRequest;
}

/**
 * SmartFunctionsApi - object-oriented interface
 * @export
 * @class SmartFunctionsApi
 * @extends {BaseAPI}
 */
export class SmartFunctionsApi extends BaseAPI implements SmartFunctionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiChat(requestParameters: SmartFunctionsApiAiChatRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApi_AiChat(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {SmartFunctionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiChatHistory(
        requestParameters: SmartFunctionsApiAiChatHistoryRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_AiChatHistory(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiChatStream(
        requestParameters: SmartFunctionsApiAiChatStreamRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_AiChatStream(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns usage statistics of chat for a user in a workspace.
     * @summary Get Chat Usage
     * @param {SmartFunctionsApiAiChatUsageRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiChatUsage(requestParameters: SmartFunctionsApiAiChatUsageRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApi_AiChatUsage(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {SmartFunctionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiSearch(requestParameters: SmartFunctionsApiAiSearchRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApi_AiSearch(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {SmartFunctionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public anomalyDetection(
        requestParameters: SmartFunctionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_AnomalyDetection(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {SmartFunctionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public anomalyDetectionResult(
        requestParameters: SmartFunctionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_AnomalyDetectionResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {SmartFunctionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public clustering(requestParameters: SmartFunctionsApiClusteringRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApi_Clustering(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {SmartFunctionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public clusteringResult(
        requestParameters: SmartFunctionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_ClusteringResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns a list of Users who created any object for this workspace
     * @summary Get Analytics Catalog CreatedBy Users
     * @param {SmartFunctionsApiCreatedByRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public createdBy(requestParameters: SmartFunctionsApiCreatedByRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApi_CreatedBy(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public forecast(requestParameters: SmartFunctionsApiForecastRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApi_Forecast(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public forecastResult(
        requestParameters: SmartFunctionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_ForecastResult(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns metadata quality issues detected by the platform linter.
     * @summary Get Quality Issues
     * @param {SmartFunctionsApiGetQualityIssuesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public getQualityIssues(
        requestParameters: SmartFunctionsApiGetQualityIssuesRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_GetQualityIssues(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns the status of a quality issues calculation process identified by process ID.
     * @summary Get Quality Issues Calculation Status
     * @param {SmartFunctionsApiGetQualityIssuesCalculationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public getQualityIssuesCalculationStatus(
        requestParameters: SmartFunctionsApiGetQualityIssuesCalculationStatusRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_GetQualityIssuesCalculationStatus(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns a list of Users who created any memory item for this workspace
     * @summary Get AI Memory CreatedBy Users
     * @param {SmartFunctionsApiMemoryCreatedByUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public memoryCreatedByUsers(
        requestParameters: SmartFunctionsApiMemoryCreatedByUsersRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_MemoryCreatedByUsers(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns a list of available LLM Endpoints
     * @summary Get Active LLM Endpoints for this workspace
     * @param {SmartFunctionsApiResolveLlmEndpointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public resolveLlmEndpoints(
        requestParameters: SmartFunctionsApiResolveLlmEndpointsRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_ResolveLlmEndpoints(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Returns a list of tags for this workspace
     * @summary Get Analytics Catalog Tags
     * @param {SmartFunctionsApiTagsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public tags(requestParameters: SmartFunctionsApiTagsRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApi_Tags(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Triggers asynchronous calculation of metadata quality issues and returns a process ID for status tracking.
     * @summary Trigger Quality Issues Calculation
     * @param {SmartFunctionsApiTriggerQualityIssuesCalculationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public triggerQualityIssuesCalculation(
        requestParameters: SmartFunctionsApiTriggerQualityIssuesCalculationRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_TriggerQualityIssuesCalculation(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Validates LLM endpoint with provided parameters.
     * @summary Validate LLM Endpoint
     * @param {SmartFunctionsApiValidateLLMEndpointRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public validateLLMEndpoint(
        requestParameters: SmartFunctionsApiValidateLLMEndpointRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_ValidateLLMEndpoint(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }

    /**
     * Validates existing LLM endpoint with provided parameters and updates it if they are valid.
     * @summary Validate LLM Endpoint By Id
     * @param {SmartFunctionsApiValidateLLMEndpointByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public validateLLMEndpointById(
        requestParameters: SmartFunctionsApiValidateLLMEndpointByIdRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApi_ValidateLLMEndpointById(
            this.axios,
            this.basePath,
            requestParameters,
            options,
            this.configuration,
        );
    }
}
