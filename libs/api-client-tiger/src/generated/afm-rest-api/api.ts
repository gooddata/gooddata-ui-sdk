// (C) 2021 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

// @ts-ignore
import globalImportUrl from "url";
import globalImportQs from "qs";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from "./base";

// utility function that adds support for nested objects in query
const addFlattenedObjectTo = (object: any, target: any): void => {
    const flattened = globalImportQs.parse(globalImportQs.stringify(object, { allowDots: true }), {
        depth: 0,
    });
    Object.keys(flattened).forEach((key) => {
        target[key] = (flattened as any)[key];
    });
};

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 * @export
 * @interface AFM
 */
export interface AFM {
    /**
     *
     * @type {Array<AttributeItem>}
     * @memberof AFM
     */
    attributes: Array<AttributeItem>;
    /**
     * Various filter types to filter execution result.
     * @type {Array<FilterDefinition>}
     * @memberof AFM
     */
    filters: Array<FilterDefinition>;
    /**
     * Measures to be computed.
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    measures: Array<MeasureItem>;
    /**
     * Measures to be referenced from other AFM objects (e.g. filters) but not included in the result.
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    auxMeasures?: Array<MeasureItem>;
}
/**
 * A date filter specifying exact from and to dates.
 * @export
 * @interface AbsoluteDateFilter
 */
export interface AbsoluteDateFilter {
    /**
     *
     * @type {AbsoluteDateFilterBody}
     * @memberof AbsoluteDateFilter
     */
    absoluteDateFilter: AbsoluteDateFilterBody;
}
/**
 *
 * @export
 * @interface AbsoluteDateFilterBody
 */
export interface AbsoluteDateFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof AbsoluteDateFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof AbsoluteDateFilterBody
     */
    dataset: AfmObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBody
     */
    from: string;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBody
     */
    to: string;
}
/**
 *
 * @export
 * @interface AbsoluteDateFilterBodyAllOf
 */
export interface AbsoluteDateFilterBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBodyAllOf
     */
    from: string;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterBodyAllOf
     */
    to: string;
}
/**
 *
 * @export
 * @interface AbstractMeasureValueFilter
 */
export interface AbstractMeasureValueFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof AbstractMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<AfmObjectIdentifier>}
     * @memberof AbstractMeasureValueFilter
     */
    dimensionality?: Array<AfmObjectIdentifier>;
}
/**
 *
 * @export
 * @interface AbstractMeasureValueFilterAllOf
 */
export interface AbstractMeasureValueFilterAllOf {
    /**
     *
     * @type {Array<AfmObjectIdentifier>}
     * @memberof AbstractMeasureValueFilterAllOf
     */
    dimensionality?: Array<AfmObjectIdentifier>;
}
/**
 *
 * @export
 * @interface AfmExecution
 */
export interface AfmExecution {
    /**
     *
     * @type {AFM}
     * @memberof AfmExecution
     */
    execution: AFM;
    /**
     *
     * @type {ResultSpec}
     * @memberof AfmExecution
     */
    resultSpec: ResultSpec;
}
/**
 *
 * @export
 * @interface AfmExecutionResponse
 */
export interface AfmExecutionResponse {
    /**
     *
     * @type {ExecutionResponse}
     * @memberof AfmExecutionResponse
     */
    executionResponse: ExecutionResponse;
}
/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 * @export
 * @interface AfmObjectIdentifier
 */
export interface AfmObjectIdentifier {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AfmObjectIdentifier
     */
    identifier: ObjectIdentifier;
}
/**
 * Entity holding AFM and list of object types whose validity should be computed.
 * @export
 * @interface AfmValidObjectsQuery
 */
export interface AfmValidObjectsQuery {
    /**
     *
     * @type {Array<string>}
     * @memberof AfmValidObjectsQuery
     */
    types: Array<AfmValidObjectsQueryTypesEnum>;
    /**
     *
     * @type {AFM}
     * @memberof AfmValidObjectsQuery
     */
    afm: AFM;
}

/**
 * @export
 * @enum {string}
 */
export enum AfmValidObjectsQueryTypesEnum {
    Facts = "facts",
    Attributes = "attributes",
    Measures = "measures",
    UNRECOGNIZED = "UNRECOGNIZED",
}

/**
 * All objects of specified types valid with respect to given AFM.
 * @export
 * @interface AfmValidObjectsResponse
 */
export interface AfmValidObjectsResponse {
    /**
     *
     * @type {Array<ObjectIdentifier>}
     * @memberof AfmValidObjectsResponse
     */
    items: Array<ObjectIdentifier>;
}
/**
 * Measure representing arithmetics between measures.
 * @export
 * @interface ArithmeticMeasureDefinition
 */
export interface ArithmeticMeasureDefinition {
    /**
     *
     * @type {ArithmeticMeasureDefinitionArithmeticMeasure}
     * @memberof ArithmeticMeasureDefinition
     */
    arithmeticMeasure: ArithmeticMeasureDefinitionArithmeticMeasure;
}
/**
 *
 * @export
 * @interface ArithmeticMeasureDefinitionArithmeticMeasure
 */
export interface ArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of measures to apply arithmetic operation by chosen operator.
     * @type {Array<LocalIdentifier>}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    measureIdentifiers: Array<LocalIdentifier>;
    /**
     * Arithmetic operator describing operation between measures.
     * @type {string}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    operator: ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum {
    SUM = "SUM",
    DIFFERENCE = "DIFFERENCE",
    MULTIPLICATION = "MULTIPLICATION",
    RATIO = "RATIO",
    CHANGE = "CHANGE",
}

/**
 *
 * @export
 * @interface AttributeExecutionResultHeader
 */
export interface AttributeExecutionResultHeader {
    /**
     *
     * @type {AttributeResultHeader}
     * @memberof AttributeExecutionResultHeader
     */
    attributeHeader: AttributeResultHeader;
}
/**
 * @type AttributeFilter
 * Abstract filter definition type attributes
 * @export
 */
export type AttributeFilter = NegativeAttributeFilter | PositiveAttributeFilter;
/**
 * Filter on specific set of label values.
 * @export
 * @interface AttributeFilterElements
 */
export interface AttributeFilterElements {
    /**
     * Set of label values.
     * @type {Array<string>}
     * @memberof AttributeFilterElements
     */
    values: Array<string>;
}
/**
 *
 * @export
 * @interface AttributeHeader
 */
export interface AttributeHeader {
    /**
     *
     * @type {AttributeHeaderAttributeHeader}
     * @memberof AttributeHeader
     */
    attributeHeader: AttributeHeaderAttributeHeader;
}
/**
 *
 * @export
 * @interface AttributeHeaderAttributeHeader
 */
export interface AttributeHeaderAttributeHeader {
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    localIdentifier: string;
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    attribute: ObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    attributeName: string;
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    label: ObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    labelName: string;
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    primaryLabel: ObjectIdentifier;
    /**
     *
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    granularity?: AttributeHeaderAttributeHeaderGranularityEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum AttributeHeaderAttributeHeaderGranularityEnum {
    YEAR = "YEAR",
    DAY = "DAY",
    HOUR = "HOUR",
    MINUTE = "MINUTE",
    QUARTER = "QUARTER",
    MONTH = "MONTH",
    WEEK = "WEEK",
    QUARTEROFYEAR = "QUARTER_OF_YEAR",
    MONTHOFYEAR = "MONTH_OF_YEAR",
    DAYOFYEAR = "DAY_OF_YEAR",
    DAYOFWEEK = "DAY_OF_WEEK",
    DAYOFMONTH = "DAY_OF_MONTH",
    HOUROFDAY = "HOUR_OF_DAY",
    MINUTEOFHOUR = "MINUTE_OF_HOUR",
    WEEKOFYEAR = "WEEK_OF_YEAR",
}

/**
 *
 * @export
 * @interface AttributeItem
 */
export interface AttributeItem {
    /**
     *
     * @type {string}
     * @memberof AttributeItem
     */
    localIdentifier: string;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof AttributeItem
     */
    label: AfmObjectIdentifier;
}
/**
 * Header containing the information related to attributes.
 * @export
 * @interface AttributeResultHeader
 */
export interface AttributeResultHeader {
    /**
     * A value of the current attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    labelValue: string;
    /**
     * A value of the primary attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    primaryLabelValue: string;
}
/**
 *
 * @export
 * @interface CommonAttributeFilter
 */
export interface CommonAttributeFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonAttributeFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof CommonAttributeFilter
     */
    label: AfmObjectIdentifier;
}
/**
 *
 * @export
 * @interface CommonAttributeFilterAllOf
 */
export interface CommonAttributeFilterAllOf {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof CommonAttributeFilterAllOf
     */
    label: AfmObjectIdentifier;
}
/**
 *
 * @export
 * @interface CommonDateFilter
 */
export interface CommonDateFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonDateFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof CommonDateFilter
     */
    dataset: AfmObjectIdentifier;
}
/**
 *
 * @export
 * @interface CommonDateFilterAllOf
 */
export interface CommonDateFilterAllOf {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof CommonDateFilterAllOf
     */
    dataset: AfmObjectIdentifier;
}
/**
 *
 * @export
 * @interface CommonFilter
 */
export interface CommonFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonFilter
     */
    applyOnResult?: boolean;
}
/**
 *
 * @export
 * @interface CommonMeasureValueFilter
 */
export interface CommonMeasureValueFilter {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof CommonMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<AfmObjectIdentifier>}
     * @memberof CommonMeasureValueFilter
     */
    dimensionality?: Array<AfmObjectIdentifier>;
    /**
     *
     * @type {Identifier}
     * @memberof CommonMeasureValueFilter
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof CommonMeasureValueFilter
     */
    treatNullValuesAs?: number;
}
/**
 *
 * @export
 * @interface CommonMeasureValueFilterAllOf
 */
export interface CommonMeasureValueFilterAllOf {
    /**
     *
     * @type {Identifier}
     * @memberof CommonMeasureValueFilterAllOf
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof CommonMeasureValueFilterAllOf
     */
    treatNullValuesAs?: number;
}
/**
 * Filter the result by comparing specified measure to given constant value, using given comparison operator.
 * @export
 * @interface ComparisonMeasureValueFilter
 */
export interface ComparisonMeasureValueFilter {
    /**
     *
     * @type {ComparisonMeasureValueFilterBody}
     * @memberof ComparisonMeasureValueFilter
     */
    comparisonMeasureValueFilter: ComparisonMeasureValueFilterBody;
}
/**
 *
 * @export
 * @interface ComparisonMeasureValueFilterBody
 */
export interface ComparisonMeasureValueFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof ComparisonMeasureValueFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<AfmObjectIdentifier>}
     * @memberof ComparisonMeasureValueFilterBody
     */
    dimensionality?: Array<AfmObjectIdentifier>;
    /**
     *
     * @type {Identifier}
     * @memberof ComparisonMeasureValueFilterBody
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterBody
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof ComparisonMeasureValueFilterBody
     */
    operator: ComparisonMeasureValueFilterBodyOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterBody
     */
    value: number;
}

/**
 * @export
 * @enum {string}
 */
export enum ComparisonMeasureValueFilterBodyOperatorEnum {
    GREATERTHAN = "GREATER_THAN",
    GREATERTHANOREQUALTO = "GREATER_THAN_OR_EQUAL_TO",
    LESSTHAN = "LESS_THAN",
    LESSTHANOREQUALTO = "LESS_THAN_OR_EQUAL_TO",
    EQUALTO = "EQUAL_TO",
    NOTEQUALTO = "NOT_EQUAL_TO",
}

/**
 *
 * @export
 * @interface ComparisonMeasureValueFilterBodyAllOf
 */
export interface ComparisonMeasureValueFilterBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof ComparisonMeasureValueFilterBodyAllOf
     */
    operator: ComparisonMeasureValueFilterBodyAllOfOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterBodyAllOf
     */
    value: number;
}

/**
 * @export
 * @enum {string}
 */
export enum ComparisonMeasureValueFilterBodyAllOfOperatorEnum {
    GREATERTHAN = "GREATER_THAN",
    GREATERTHANOREQUALTO = "GREATER_THAN_OR_EQUAL_TO",
    LESSTHAN = "LESS_THAN",
    LESSTHANOREQUALTO = "LESS_THAN_OR_EQUAL_TO",
    EQUALTO = "EQUAL_TO",
    NOTEQUALTO = "NOT_EQUAL_TO",
}

/**
 * @type DateFilter
 * Abstract filter definition type for dates
 * @export
 */
export type DateFilter = AbsoluteDateFilter | RelativeDateFilter;
/**
 * Single dimension description.
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * List of items in current dimension. Can reference \'localIdentifier\' from \'AttributeItem\', or special pseudo attribute \"measureGroup\" representing list of measures.
     * @type {Array<string>}
     * @memberof Dimension
     */
    itemIdentifiers: Array<string>;
    /**
     * Dimension identification within requests. Other entities can reference this dimension by this value.
     * @type {string}
     * @memberof Dimension
     */
    localIdentifier?: string;
    /**
     * List of sorting rules. From most relevant to least relevant (less relevant rule is applied, when more relevant rule compares items as equal).
     * @type {Array<SortKeyAttribute | SortKeyValue>}
     * @memberof Dimension
     */
    sorting?: Array<SortKeyAttribute | SortKeyValue>;
}
/**
 * Contains the dimension-specific header information.
 * @export
 * @interface DimensionHeader
 */
export interface DimensionHeader {
    /**
     * An array containing header groups.
     * @type {Array<HeaderGroup>}
     * @memberof DimensionHeader
     */
    headerGroups: Array<HeaderGroup>;
}
/**
 * List of returned elements.
 * @export
 * @interface Element
 */
export interface Element {
    /**
     * Title of primary label of attribute owning requested label.
     * @type {string}
     * @memberof Element
     */
    primaryTitle: string;
    /**
     * Title of requested label.
     * @type {string}
     * @memberof Element
     */
    title: string;
}
/**
 * Entity holding list of sorted & filtered label elements, related primary label of attribute owning requested label and paging.
 * @export
 * @interface ElementsResponse
 */
export interface ElementsResponse {
    /**
     *
     * @type {ObjectIdentifier}
     * @memberof ElementsResponse
     */
    primaryLabel: ObjectIdentifier;
    /**
     * List of returned elements.
     * @type {Array<Element>}
     * @memberof ElementsResponse
     */
    elements: Array<Element>;
    /**
     *
     * @type {Paging}
     * @memberof ElementsResponse
     */
    paging: Paging;
    /**
     * Total count of items ignoring all filters (using on ```project``` and  ```label``` from request).
     * @type {number}
     * @memberof ElementsResponse
     */
    totalCountWithoutFilters?: number;
}
/**
 * Contains information about the error.
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
    /**
     * Error timestamp in ISO 8601.
     * @type {string}
     * @memberof ErrorMessage
     */
    timestamp: string;
    /**
     * HTTP error response status code.
     * @type {number}
     * @memberof ErrorMessage
     */
    status: number;
    /**
     * HTTP error message like: Bad Request, Not Found, etc.
     * @type {string}
     * @memberof ErrorMessage
     */
    error: string;
    /**
     * Error message returned by the server application.
     * @type {string}
     * @memberof ErrorMessage
     */
    message: string;
    /**
     * Path of the failed request.
     * @type {string}
     * @memberof ErrorMessage
     */
    path: string;
}
/**
 *
 * @export
 * @interface ExecutionLinks
 */
export interface ExecutionLinks {
    /**
     *
     * @type {string}
     * @memberof ExecutionLinks
     */
    executionResult: string;
}
/**
 *
 * @export
 * @interface ExecutionResponse
 */
export interface ExecutionResponse {
    /**
     *
     * @type {Array<ResultDimension>}
     * @memberof ExecutionResponse
     */
    dimensions: Array<ResultDimension>;
    /**
     *
     * @type {ExecutionLinks}
     * @memberof ExecutionResponse
     */
    links: ExecutionLinks;
}
/**
 * Contains the result of an AFM execution.
 * @export
 * @interface ExecutionResult
 */
export interface ExecutionResult {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     * @type {Array<object>}
     * @memberof ExecutionResult
     */
    data: Array<object>;
    /**
     * An array containing dimension headers. The size of the array corresponds to dimension size. Their order corresponds to the dimension order in the execution result spec.
     * @type {Array<DimensionHeader>}
     * @memberof ExecutionResult
     */
    dimensionHeaders: Array<DimensionHeader>;
    /**
     * An array with grand totals data corresponding to grand totals definition in result spec.
     * @type {Array<ExecutionResultGrandTotal>}
     * @memberof ExecutionResult
     */
    grandTotals: Array<ExecutionResultGrandTotal>;
    /**
     *
     * @type {ExecutionResultPaging}
     * @memberof ExecutionResult
     */
    paging: ExecutionResultPaging;
}
/**
 * Contains the data related to a grand total, including the reference to localIdentifier as specified in result spec.
 * @export
 * @interface ExecutionResultGrandTotal
 */
export interface ExecutionResultGrandTotal {
    /**
     *
     * @type {object}
     * @memberof ExecutionResultGrandTotal
     */
    data: object;
    /**
     *
     * @type {string}
     * @memberof ExecutionResultGrandTotal
     */
    localIdentifier: string;
}
/**
 * @type ExecutionResultHeader
 * Abstract execution result header
 * @export
 */
export type ExecutionResultHeader = AttributeExecutionResultHeader | MeasureExecutionResultHeader;
/**
 * A paging information related to the data presented in the execution result. These paging information are multi-dimensional.
 * @export
 * @interface ExecutionResultPaging
 */
export interface ExecutionResultPaging {
    /**
     * A count of the returned results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    count: Array<number>;
    /**
     * The offset of the results returned in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    offset: Array<number>;
    /**
     * A total count of the results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    total: Array<number>;
}
/**
 * @type FilterDefinition
 * Abstract filter definition type
 * @export
 */
export type FilterDefinition =
    | AttributeFilter
    | DateFilter
    | InlineFilterDefinition
    | MeasureValueFilter
    | RankingFilter;
/**
 * @type FilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple measure.
 * @export
 */
export type FilterDefinitionForSimpleMeasure = AttributeFilter | DateFilter;
/**
 * Definition of a grand total. Grand total data will be computed into a separate section of the result structure so that client has more options how to visualize them.
 * @export
 * @interface GrandTotal
 */
export interface GrandTotal {
    /**
     * Grand total identification within this request. The corresponding data in the result are expected to be matched using this identifier.
     * @type {string}
     * @memberof GrandTotal
     */
    localIdentifier: string;
    /**
     * Aggregation function for grand total computation.
     * @type {string}
     * @memberof GrandTotal
     */
    function: string;
    /**
     * Mapping specifying dimensions on which this grand total will be computed. Dimensions are referenced via their localIdentifiers. Optionally one can specify also the values (properties) of the dimensions\' attributes (see ```dimensionAttributesValues```).
     * @type {{ [key: string]: IncludedDimensionProps; }}
     * @memberof GrandTotal
     */
    includedDimensions: { [key: string]: IncludedDimensionProps };
}
/**
 * Contains the information specific for a group of headers. These groups correlate to attributes and measure groups.
 * @export
 * @interface HeaderGroup
 */
export interface HeaderGroup {
    /**
     * An array containing headers.
     * @type {Array<ExecutionResultHeader>}
     * @memberof HeaderGroup
     */
    headers: Array<ExecutionResultHeader>;
}
/**
 * @type Identifier
 * Abstract identifier type
 * @export
 */
export type Identifier = AfmObjectIdentifier | LocalIdentifier;
/**
 *
 * @export
 * @interface IncludedDimensionProps
 */
export interface IncludedDimensionProps {
    /**
     * Allows to customize for which attribute values the grand total will be computed. If the values for particular attribute are not specified then the totals for all values are computed. Note that this also covers the case of individual measures (treated as values of the \"measureGroup\" pseudo attribute).
     * @type {{ [key: string]: Array<string>; }}
     * @memberof IncludedDimensionProps
     */
    dimensionAttributesValues: { [key: string]: Array<string> };
}
/**
 * Filter in form of direct MAQL query.
 * @export
 * @interface InlineFilterDefinition
 */
export interface InlineFilterDefinition {
    /**
     *
     * @type {InlineFilterDefinitionBody}
     * @memberof InlineFilterDefinition
     */
    inline: InlineFilterDefinitionBody;
}
/**
 *
 * @export
 * @interface InlineFilterDefinitionBody
 */
export interface InlineFilterDefinitionBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof InlineFilterDefinitionBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {string}
     * @memberof InlineFilterDefinitionBody
     */
    filter: string;
}
/**
 *
 * @export
 * @interface InlineFilterDefinitionBodyAllOf
 */
export interface InlineFilterDefinitionBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof InlineFilterDefinitionBodyAllOf
     */
    filter: string;
}
/**
 * Measure defined by the raw MAQL query.
 * @export
 * @interface InlineMeasureDefinition
 */
export interface InlineMeasureDefinition {
    /**
     *
     * @type {InlineMeasureDefinitionInline}
     * @memberof InlineMeasureDefinition
     */
    inline: InlineMeasureDefinitionInline;
}
/**
 *
 * @export
 * @interface InlineMeasureDefinitionInline
 */
export interface InlineMeasureDefinitionInline {
    /**
     *
     * @type {string}
     * @memberof InlineMeasureDefinitionInline
     */
    maql: string;
}
/**
 * String that uniquely identifies the measure in the context of the current AFM.
 * @export
 * @interface LocalIdentifier
 */
export interface LocalIdentifier {
    /**
     *
     * @type {string}
     * @memberof LocalIdentifier
     */
    localIdentifier: string;
}
/**
 * @type MeasureDefinition
 * Abstract measure definition type
 * @export
 */
export type MeasureDefinition =
    | ArithmeticMeasureDefinition
    | InlineMeasureDefinition
    | PopDatasetMeasureDefinition
    | PopDateMeasureDefinition
    | SimpleMeasureDefinition;
/**
 *
 * @export
 * @interface MeasureExecutionResultHeader
 */
export interface MeasureExecutionResultHeader {
    /**
     *
     * @type {MeasureResultHeader}
     * @memberof MeasureExecutionResultHeader
     */
    measureHeader: MeasureResultHeader;
}
/**
 *
 * @export
 * @interface MeasureGroupHeader
 */
export interface MeasureGroupHeader {
    /**
     *
     * @type {Array<MeasureHeaderOut>}
     * @memberof MeasureGroupHeader
     */
    measureGroupHeaders: Array<MeasureHeaderOut>;
}
/**
 *
 * @export
 * @interface MeasureHeaderOut
 */
export interface MeasureHeaderOut {
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    localIdentifier: string;
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    format?: string;
    /**
     *
     * @type {string}
     * @memberof MeasureHeaderOut
     */
    name?: string;
}
/**
 *
 * @export
 * @interface MeasureItem
 */
export interface MeasureItem {
    /**
     *
     * @type {string}
     * @memberof MeasureItem
     */
    localIdentifier: string;
    /**
     *
     * @type {MeasureDefinition}
     * @memberof MeasureItem
     */
    definition: MeasureDefinition;
}
/**
 * Header containing the information related to measures.
 * @export
 * @interface MeasureResultHeader
 */
export interface MeasureResultHeader {
    /**
     * Measure index. Starts at 0.
     * @type {number}
     * @memberof MeasureResultHeader
     */
    measureIndex: number;
}
/**
 * @type MeasureValueFilter
 * Abstract filter definition type filtering by the value of the measure.
 * @export
 */
export type MeasureValueFilter = ComparisonMeasureValueFilter | RangeMeasureValueFilter;
/**
 * Filter able to limit element values by label and related selected negated elements.
 * @export
 * @interface NegativeAttributeFilter
 */
export interface NegativeAttributeFilter {
    /**
     *
     * @type {NegativeAttributeFilterBody}
     * @memberof NegativeAttributeFilter
     */
    negativeAttributeFilter: NegativeAttributeFilterBody;
}
/**
 *
 * @export
 * @interface NegativeAttributeFilterBody
 */
export interface NegativeAttributeFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof NegativeAttributeFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof NegativeAttributeFilterBody
     */
    label: AfmObjectIdentifier;
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof NegativeAttributeFilterBody
     */
    notIn: AttributeFilterElements;
}
/**
 *
 * @export
 * @interface NegativeAttributeFilterBodyAllOf
 */
export interface NegativeAttributeFilterBodyAllOf {
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof NegativeAttributeFilterBodyAllOf
     */
    notIn: AttributeFilterElements;
}
/**
 * Identifier of LDM object determined by ID & type.
 * @export
 * @interface ObjectIdentifier
 */
export interface ObjectIdentifier {
    /**
     *
     * @type {string}
     * @memberof ObjectIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ObjectIdentifier
     */
    type: string;
}
/**
 * Current page description.
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * Count of returnable items ignoring paging.
     * @type {number}
     * @memberof Paging
     */
    total: number;
    /**
     * Count of items in this page.
     * @type {number}
     * @memberof Paging
     */
    count: number;
    /**
     * Offset of this page.
     * @type {number}
     * @memberof Paging
     */
    offset: number;
    /**
     * Link to next page, or null if this is last page.
     * @type {string}
     * @memberof Paging
     */
    next?: string;
}
/**
 *
 * @export
 * @interface PopDataset
 */
export interface PopDataset {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof PopDataset
     */
    dataset: AfmObjectIdentifier;
    /**
     *
     * @type {number}
     * @memberof PopDataset
     */
    periodsAgo: number;
}
/**
 * Previous period type of measure.
 * @export
 * @interface PopDatasetMeasureDefinition
 */
export interface PopDatasetMeasureDefinition {
    /**
     *
     * @type {PopDatasetMeasureDefinitionPreviousPeriodMeasure}
     * @memberof PopDatasetMeasureDefinition
     */
    previousPeriodMeasure: PopDatasetMeasureDefinitionPreviousPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDatasetMeasureDefinitionPreviousPeriodMeasure
 */
export interface PopDatasetMeasureDefinitionPreviousPeriodMeasure {
    /**
     *
     * @type {LocalIdentifier}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    measureIdentifier: LocalIdentifier;
    /**
     *
     * @type {Array<PopDataset>}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    dateDatasets: Array<PopDataset>;
}
/**
 *
 * @export
 * @interface PopDate
 */
export interface PopDate {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof PopDate
     */
    attribute: AfmObjectIdentifier;
    /**
     *
     * @type {number}
     * @memberof PopDate
     */
    periodsAgo: number;
}
/**
 * Period over period type of measure.
 * @export
 * @interface PopDateMeasureDefinition
 */
export interface PopDateMeasureDefinition {
    /**
     *
     * @type {PopDateMeasureDefinitionOverPeriodMeasure}
     * @memberof PopDateMeasureDefinition
     */
    overPeriodMeasure: PopDateMeasureDefinitionOverPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDateMeasureDefinitionOverPeriodMeasure
 */
export interface PopDateMeasureDefinitionOverPeriodMeasure {
    /**
     *
     * @type {LocalIdentifier}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    measureIdentifier: LocalIdentifier;
    /**
     *
     * @type {Array<PopDate>}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    dateAttributes: Array<PopDate>;
}
/**
 * Filter able to limit element values by label and related selected elements.
 * @export
 * @interface PositiveAttributeFilter
 */
export interface PositiveAttributeFilter {
    /**
     *
     * @type {PositiveAttributeFilterBody}
     * @memberof PositiveAttributeFilter
     */
    positiveAttributeFilter: PositiveAttributeFilterBody;
}
/**
 *
 * @export
 * @interface PositiveAttributeFilterBody
 */
export interface PositiveAttributeFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof PositiveAttributeFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof PositiveAttributeFilterBody
     */
    label: AfmObjectIdentifier;
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof PositiveAttributeFilterBody
     */
    in: AttributeFilterElements;
}
/**
 *
 * @export
 * @interface PositiveAttributeFilterBodyAllOf
 */
export interface PositiveAttributeFilterBodyAllOf {
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof PositiveAttributeFilterBodyAllOf
     */
    in: AttributeFilterElements;
}
/**
 * Filter the result by comparing specified measure to given range of values.
 * @export
 * @interface RangeMeasureValueFilter
 */
export interface RangeMeasureValueFilter {
    /**
     *
     * @type {RangeMeasureValueFilterBody}
     * @memberof RangeMeasureValueFilter
     */
    rangeMeasureValueFilter: RangeMeasureValueFilterBody;
}
/**
 *
 * @export
 * @interface RangeMeasureValueFilterBody
 */
export interface RangeMeasureValueFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof RangeMeasureValueFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<AfmObjectIdentifier>}
     * @memberof RangeMeasureValueFilterBody
     */
    dimensionality?: Array<AfmObjectIdentifier>;
    /**
     *
     * @type {Identifier}
     * @memberof RangeMeasureValueFilterBody
     */
    measure: Identifier;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBody
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof RangeMeasureValueFilterBody
     */
    operator: RangeMeasureValueFilterBodyOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBody
     */
    from: number;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBody
     */
    to: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RangeMeasureValueFilterBodyOperatorEnum {
    BETWEEN = "BETWEEN",
    NOTBETWEEN = "NOT_BETWEEN",
}

/**
 *
 * @export
 * @interface RangeMeasureValueFilterBodyAllOf
 */
export interface RangeMeasureValueFilterBodyAllOf {
    /**
     *
     * @type {string}
     * @memberof RangeMeasureValueFilterBodyAllOf
     */
    operator: RangeMeasureValueFilterBodyAllOfOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBodyAllOf
     */
    from: number;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterBodyAllOf
     */
    to: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RangeMeasureValueFilterBodyAllOfOperatorEnum {
    BETWEEN = "BETWEEN",
    NOTBETWEEN = "NOT_BETWEEN",
}

/**
 * Filter the result on top/bottom N values according to given measure(s).
 * @export
 * @interface RankingFilter
 */
export interface RankingFilter {
    /**
     *
     * @type {RankingFilterBody}
     * @memberof RankingFilter
     */
    rankingFilter: RankingFilterBody;
}
/**
 *
 * @export
 * @interface RankingFilterBody
 */
export interface RankingFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof RankingFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {Array<AfmObjectIdentifier>}
     * @memberof RankingFilterBody
     */
    dimensionality?: Array<AfmObjectIdentifier>;
    /**
     *
     * @type {Array<Identifier>}
     * @memberof RankingFilterBody
     */
    measures: Array<Identifier>;
    /**
     *
     * @type {string}
     * @memberof RankingFilterBody
     */
    operator: RankingFilterBodyOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RankingFilterBody
     */
    value: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RankingFilterBodyOperatorEnum {
    TOP = "TOP",
    BOTTOM = "BOTTOM",
}

/**
 *
 * @export
 * @interface RankingFilterBodyAllOf
 */
export interface RankingFilterBodyAllOf {
    /**
     *
     * @type {Array<Identifier>}
     * @memberof RankingFilterBodyAllOf
     */
    measures: Array<Identifier>;
    /**
     *
     * @type {string}
     * @memberof RankingFilterBodyAllOf
     */
    operator: RankingFilterBodyAllOfOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RankingFilterBodyAllOf
     */
    value: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RankingFilterBodyAllOfOperatorEnum {
    TOP = "TOP",
    BOTTOM = "BOTTOM",
}

/**
 *
 * @export
 * @interface RelativeDateFilter
 */
export interface RelativeDateFilter {
    /**
     *
     * @type {RelativeDateFilterBody}
     * @memberof RelativeDateFilter
     */
    relativeDateFilter: RelativeDateFilterBody;
}
/**
 *
 * @export
 * @interface RelativeDateFilterBody
 */
export interface RelativeDateFilterBody {
    /**
     * Force the filter to be applied on the result (true) or source data (false). If not specified at all the default behaviour specific to each type of filter is used.
     * @type {boolean}
     * @memberof RelativeDateFilterBody
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof RelativeDateFilterBody
     */
    dataset: AfmObjectIdentifier;
    /**
     * Date granularity specifying particular date attribute in given dimension.
     * @type {string}
     * @memberof RelativeDateFilterBody
     */
    granularity: RelativeDateFilterBodyGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     * @type {number}
     * @memberof RelativeDateFilterBody
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     * @type {number}
     * @memberof RelativeDateFilterBody
     */
    to: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RelativeDateFilterBodyGranularityEnum {
    MINUTE = "MINUTE",
    HOUR = "HOUR",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    QUARTER = "QUARTER",
    YEAR = "YEAR",
    MINUTEOFHOUR = "MINUTE_OF_HOUR",
    HOUROFDAY = "HOUR_OF_DAY",
    DAYOFWEEK = "DAY_OF_WEEK",
    DAYOFMONTH = "DAY_OF_MONTH",
    DAYOFYEAR = "DAY_OF_YEAR",
    WEEKOFYEAR = "WEEK_OF_YEAR",
    MONTHOFYEAR = "MONTH_OF_YEAR",
    QUARTEROFYEAR = "QUARTER_OF_YEAR",
}

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension.
 * @export
 * @interface RelativeDateFilterBodyAllOf
 */
export interface RelativeDateFilterBodyAllOf {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     * @type {string}
     * @memberof RelativeDateFilterBodyAllOf
     */
    granularity: RelativeDateFilterBodyAllOfGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     * @type {number}
     * @memberof RelativeDateFilterBodyAllOf
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     * @type {number}
     * @memberof RelativeDateFilterBodyAllOf
     */
    to: number;
}

/**
 * @export
 * @enum {string}
 */
export enum RelativeDateFilterBodyAllOfGranularityEnum {
    MINUTE = "MINUTE",
    HOUR = "HOUR",
    DAY = "DAY",
    WEEK = "WEEK",
    MONTH = "MONTH",
    QUARTER = "QUARTER",
    YEAR = "YEAR",
    MINUTEOFHOUR = "MINUTE_OF_HOUR",
    HOUROFDAY = "HOUR_OF_DAY",
    DAYOFWEEK = "DAY_OF_WEEK",
    DAYOFMONTH = "DAY_OF_MONTH",
    DAYOFYEAR = "DAY_OF_YEAR",
    WEEKOFYEAR = "WEEK_OF_YEAR",
    MONTHOFYEAR = "MONTH_OF_YEAR",
    QUARTEROFYEAR = "QUARTER_OF_YEAR",
}

/**
 *
 * @export
 * @interface ResultDimension
 */
export interface ResultDimension {
    /**
     *
     * @type {Array<MeasureGroupHeader | AttributeHeader>}
     * @memberof ResultDimension
     */
    headers: Array<MeasureGroupHeader | AttributeHeader>;
}
/**
 * Specifies how the result data will formatted (```dimensions```) and which additional data shall be computed (```grandTotals```).
 * @export
 * @interface ResultSpec
 */
export interface ResultSpec {
    /**
     *
     * @type {Array<Dimension>}
     * @memberof ResultSpec
     */
    dimensions: Array<Dimension>;
    /**
     *
     * @type {Array<GrandTotal>}
     * @memberof ResultSpec
     */
    grandTotals?: Array<GrandTotal>;
}
/**
 *
 * @export
 * @interface SimpleMeasureDefinition
 */
export interface SimpleMeasureDefinition {
    /**
     *
     * @type {SimpleMeasureDefinitionMeasure}
     * @memberof SimpleMeasureDefinition
     */
    measure: SimpleMeasureDefinitionMeasure;
}
/**
 *
 * @export
 * @interface SimpleMeasureDefinitionMeasure
 */
export interface SimpleMeasureDefinitionMeasure {
    /**
     *
     * @type {AfmObjectIdentifier}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    item: AfmObjectIdentifier;
    /**
     * Definition of aggregation type of the measure.
     * @type {string}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    aggregation?: SimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true compute the percentage of given measure values (broken down by AFM attributes) to the total (not broken down).
     * @type {boolean}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    computeRatio?: boolean;
    /**
     * Measure can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     * @type {Array<FilterDefinitionForSimpleMeasure>}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    filters?: Array<FilterDefinitionForSimpleMeasure>;
}

/**
 * @export
 * @enum {string}
 */
export enum SimpleMeasureDefinitionMeasureAggregationEnum {
    SUM = "SUM",
    COUNT = "COUNT",
    APPROXIMATE_COUNT = "APPROXIMATE_COUNT",
    AVG = "AVG",
    MIN = "MIN",
    MAX = "MAX",
    MEDIAN = "MEDIAN",
    RUNSUM = "RUNSUM",
}

/**
 * Sorting elements - ascending/descending order.
 * @export
 * @enum {string}
 */
export enum SortDirection {
    ASC = "ASC",
    DESC = "DESC",
}
/**
 * Sorting rule for sorting by attribute value in current dimension.
 * @export
 * @interface SortKeyAttribute
 */
export interface SortKeyAttribute {
    /**
     *
     * @type {SortKeyAttributeAttribute}
     * @memberof SortKeyAttribute
     */
    attribute: SortKeyAttributeAttribute;
}
/**
 *
 * @export
 * @interface SortKeyAttributeAttribute
 */
export interface SortKeyAttributeAttribute {
    /**
     *
     * @type {SortDirection}
     * @memberof SortKeyAttributeAttribute
     */
    direction?: SortDirection;
    /**
     * One of the \'Dimension.itemIdentifiers\' referencing the attribute which should be used for sorting the dimension.s
     * @type {string}
     * @memberof SortKeyAttributeAttribute
     */
    attributeIdentifier: string;
}
/**
 *
 * @export
 * @interface SortKeyValue
 */
export interface SortKeyValue {
    /**
     *
     * @type {SortKeyValueValue}
     * @memberof SortKeyValue
     */
    value: SortKeyValueValue;
}
/**
 *
 * @export
 * @interface SortKeyValueValue
 */
export interface SortKeyValueValue {
    /**
     *
     * @type {SortDirection}
     * @memberof SortKeyValueValue
     */
    direction?: SortDirection;
    /**
     * Mapping from dimensions to data column locators. Locators for each dimension opposite to the sorted one must be specified.
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof SortKeyValueValue
     */
    dataColumnLocators: { [key: string]: { [key: string]: string } };
}
/**
 * Sorting elements - ascending/descending order.
 * @export
 * @enum {string}
 */
export enum TotalFunction {
    SUM = "SUM",
    MIN = "MIN",
    MAX = "MAX",
    AVG = "AVG",
    MED = "MED",
}

/**
 * AfmControllerApi - axios parameter creator
 * @export
 */
export const AfmControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, afmExecution, skipCache, timestamp } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling computeReport.",
                );
            }
            // verify required parameter 'afmExecution' is not null or undefined
            if (afmExecution === null || afmExecution === undefined) {
                throw new RequiredError(
                    "afmExecution",
                    "Required parameter afmExecution was null or undefined when calling computeReport.",
                );
            }
            const localVarPath = `/api/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AfmControllerApi - functional programming interface
 * @export
 */
export const AfmControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmExecutionResponse> {
            const localVarAxiosArgs = AfmControllerApiAxiosParamCreator(configuration).computeReport(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * AfmControllerApi - factory interface
 * @export
 */
export const AfmControllerApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            params: {
                workspaceId: string;
                afmExecution: AfmExecution;
                skipCache?: boolean;
                timestamp?: string;
            },
            options?: any,
        ): AxiosPromise<AfmExecutionResponse> {
            return AfmControllerApiFp(configuration).computeReport(params, options)(axios, basePath);
        },
    };
};

/**
 * AfmControllerApi - interface
 * @export
 * @interface AfmControllerApi
 */
export interface AfmControllerApiInterface {
    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {string} workspaceId Workspace identifier
     * @param {AfmExecution} afmExecution
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {string} [timestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AfmControllerApiInterface
     */
    computeReport(
        params: {
            workspaceId: string;
            afmExecution: AfmExecution;
            skipCache?: boolean;
            timestamp?: string;
        },
        options?: any,
    ): AxiosPromise<AfmExecutionResponse>;
}

/**
 * AfmControllerApi - object-oriented interface
 * @export
 * @class AfmControllerApi
 * @extends {BaseAPI}
 */
export class AfmControllerApi extends BaseAPI implements AfmControllerApiInterface {
    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {string} workspaceId Workspace identifier
     * @param {AfmExecution} afmExecution
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {string} [timestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AfmControllerApi
     */
    public computeReport(
        params: {
            workspaceId: string;
            afmExecution: AfmExecution;
            skipCache?: boolean;
            timestamp?: string;
        },
        options?: any,
    ) {
        return AfmControllerApiFp(this.configuration).computeReport(params, options)(
            this.axios,
            this.basePath,
        );
    }
}

/**
 * ElementsControllerApi - axios parameter creator
 * @export
 */
export const ElementsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElements(
            params: {
                workspaceId: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                includeTotalWithoutFilters?: boolean;
                complementFilter?: boolean;
                patternFilter?: string;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options: any = {},
        ): RequestArgs {
            const {
                workspaceId,
                label,
                sortOrder,
                includeTotalWithoutFilters,
                complementFilter,
                patternFilter,
                offset,
                limit,
                skipCache,
            } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling computeLabelElements.",
                );
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError(
                    "label",
                    "Required parameter label was null or undefined when calling computeLabelElements.",
                );
            }
            const localVarPath =
                `/api/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (label !== undefined) {
                if (typeof label === "object") {
                    addFlattenedObjectTo(label, localVarQueryParameter);
                } else {
                    localVarQueryParameter["label"] = label;
                }
            }

            if (sortOrder !== undefined) {
                if (typeof sortOrder === "object") {
                    addFlattenedObjectTo(sortOrder, localVarQueryParameter);
                } else {
                    localVarQueryParameter["sortOrder"] = sortOrder;
                }
            }

            if (includeTotalWithoutFilters !== undefined) {
                if (typeof includeTotalWithoutFilters === "object") {
                    addFlattenedObjectTo(includeTotalWithoutFilters, localVarQueryParameter);
                } else {
                    localVarQueryParameter["includeTotalWithoutFilters"] = includeTotalWithoutFilters;
                }
            }

            if (complementFilter !== undefined) {
                if (typeof complementFilter === "object") {
                    addFlattenedObjectTo(complementFilter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["complementFilter"] = complementFilter;
                }
            }

            if (patternFilter !== undefined) {
                if (typeof patternFilter === "object") {
                    addFlattenedObjectTo(patternFilter, localVarQueryParameter);
                } else {
                    localVarQueryParameter["patternFilter"] = patternFilter;
                }
            }

            if (offset !== undefined) {
                if (typeof offset === "object") {
                    addFlattenedObjectTo(offset, localVarQueryParameter);
                } else {
                    localVarQueryParameter["offset"] = offset;
                }
            }

            if (limit !== undefined) {
                if (typeof limit === "object") {
                    addFlattenedObjectTo(limit, localVarQueryParameter);
                } else {
                    localVarQueryParameter["limit"] = limit;
                }
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ElementsControllerApi - functional programming interface
 * @export
 */
export const ElementsControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElements(
            params: {
                workspaceId: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                includeTotalWithoutFilters?: boolean;
                complementFilter?: boolean;
                patternFilter?: string;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse> {
            const localVarAxiosArgs = ElementsControllerApiAxiosParamCreator(
                configuration,
            ).computeLabelElements(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * ElementsControllerApi - factory interface
 * @export
 */
export const ElementsControllerApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElements(
            params: {
                workspaceId: string;
                label: string;
                sortOrder?: "ASC" | "DESC";
                includeTotalWithoutFilters?: boolean;
                complementFilter?: boolean;
                patternFilter?: string;
                offset?: number;
                limit?: number;
                skipCache?: boolean;
            },
            options?: any,
        ): AxiosPromise<ElementsResponse> {
            return ElementsControllerApiFp(configuration).computeLabelElements(params, options)(
                axios,
                basePath,
            );
        },
    };
};

/**
 * ElementsControllerApi - interface
 * @export
 * @interface ElementsControllerApi
 */
export interface ElementsControllerApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values.
     * @param {string} workspaceId Workspace identifier
     * @param {string} label Requested label.
     * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
     * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
     * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
     * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ElementsControllerApiInterface
     */
    computeLabelElements(
        params: {
            workspaceId: string;
            label: string;
            sortOrder?: "ASC" | "DESC";
            includeTotalWithoutFilters?: boolean;
            complementFilter?: boolean;
            patternFilter?: string;
            offset?: number;
            limit?: number;
            skipCache?: boolean;
        },
        options?: any,
    ): AxiosPromise<ElementsResponse>;
}

/**
 * ElementsControllerApi - object-oriented interface
 * @export
 * @class ElementsControllerApi
 * @extends {BaseAPI}
 */
export class ElementsControllerApi extends BaseAPI implements ElementsControllerApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values.
     * @param {string} workspaceId Workspace identifier
     * @param {string} label Requested label.
     * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
     * @param {boolean} [includeTotalWithoutFilters] Specify if &#x60;&#x60;&#x60;totalCountWithoutFilters&#x60;&#x60;&#x60; should be returned.
     * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60;
     * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ElementsControllerApi
     */
    public computeLabelElements(
        params: {
            workspaceId: string;
            label: string;
            sortOrder?: "ASC" | "DESC";
            includeTotalWithoutFilters?: boolean;
            complementFilter?: boolean;
            patternFilter?: string;
            offset?: number;
            limit?: number;
            skipCache?: boolean;
        },
        options?: any,
    ) {
        return ElementsControllerApiFp(this.configuration).computeLabelElements(params, options)(
            this.axios,
            this.basePath,
        );
    }
}

/**
 * ResultControllerApi - axios parameter creator
 * @export
 */
export const ResultControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            params: {
                workspaceId: string;
                resultId: string;
                offset?: Array<number>;
                limit?: Array<number>;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, resultId, offset, limit } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling retrieveResult.",
                );
            }
            // verify required parameter 'resultId' is not null or undefined
            if (resultId === null || resultId === undefined) {
                throw new RequiredError(
                    "resultId",
                    "Required parameter resultId was null or undefined when calling retrieveResult.",
                );
            }
            const localVarPath =
                `/api/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }

            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ResultControllerApi - functional programming interface
 * @export
 */
export const ResultControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            params: {
                workspaceId: string;
                resultId: string;
                offset?: Array<number>;
                limit?: Array<number>;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResult> {
            const localVarAxiosArgs = ResultControllerApiAxiosParamCreator(configuration).retrieveResult(
                params,
                options,
            );
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * ResultControllerApi - factory interface
 * @export
 */
export const ResultControllerApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            params: {
                workspaceId: string;
                resultId: string;
                offset?: Array<number>;
                limit?: Array<number>;
            },
            options?: any,
        ): AxiosPromise<ExecutionResult> {
            return ResultControllerApiFp(configuration).retrieveResult(params, options)(axios, basePath);
        },
    };
};

/**
 * ResultControllerApi - interface
 * @export
 * @interface ResultControllerApi
 */
export interface ResultControllerApiInterface {
    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {string} workspaceId Workspace identifier
     * @param {string} resultId Result ID
     * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultControllerApiInterface
     */
    retrieveResult(
        params: {
            workspaceId: string;
            resultId: string;
            offset?: Array<number>;
            limit?: Array<number>;
        },
        options?: any,
    ): AxiosPromise<ExecutionResult>;
}

/**
 * ResultControllerApi - object-oriented interface
 * @export
 * @class ResultControllerApi
 * @extends {BaseAPI}
 */
export class ResultControllerApi extends BaseAPI implements ResultControllerApiInterface {
    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {string} workspaceId Workspace identifier
     * @param {string} resultId Result ID
     * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultControllerApi
     */
    public retrieveResult(
        params: {
            workspaceId: string;
            resultId: string;
            offset?: Array<number>;
            limit?: Array<number>;
        },
        options?: any,
    ) {
        return ResultControllerApiFp(this.configuration).retrieveResult(params, options)(
            this.axios,
            this.basePath,
        );
    }
}

/**
 * ValidObjectsControllerApi - axios parameter creator
 * @export
 */
export const ValidObjectsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            params: {
                workspaceId: string;
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options: any = {},
        ): RequestArgs {
            const { workspaceId, afmValidObjectsQuery } = params;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError(
                    "workspaceId",
                    "Required parameter workspaceId was null or undefined when calling computeValidObjects.",
                );
            }
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            if (afmValidObjectsQuery === null || afmValidObjectsQuery === undefined) {
                throw new RequiredError(
                    "afmValidObjectsQuery",
                    "Required parameter afmValidObjectsQuery was null or undefined when calling computeValidObjects.",
                );
            }
            const localVarPath =
                `/api/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...options.headers };
            const needsSerialization =
                typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ValidObjectsControllerApi - functional programming interface
 * @export
 */
export const ValidObjectsControllerApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            params: {
                workspaceId: string;
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options: any = {},
        ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidObjectsResponse> {
            const localVarAxiosArgs = ValidObjectsControllerApiAxiosParamCreator(
                configuration,
            ).computeValidObjects(params, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {
                    ...localVarAxiosArgs.options,
                    url: basePath + localVarAxiosArgs.url,
                };
                return axios.request(axiosRequestArgs);
            };
        },
    };
};

/**
 * ValidObjectsControllerApi - factory interface
 * @export
 */
export const ValidObjectsControllerApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    return {
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            params: {
                workspaceId: string;
                afmValidObjectsQuery: AfmValidObjectsQuery;
            },
            options?: any,
        ): AxiosPromise<AfmValidObjectsResponse> {
            return ValidObjectsControllerApiFp(configuration).computeValidObjects(params, options)(
                axios,
                basePath,
            );
        },
    };
};

/**
 * ValidObjectsControllerApi - interface
 * @export
 * @interface ValidObjectsControllerApi
 */
export interface ValidObjectsControllerApiInterface {
    /**
     * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {string} workspaceId Workspace identifier
     * @param {AfmValidObjectsQuery} afmValidObjectsQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidObjectsControllerApiInterface
     */
    computeValidObjects(
        params: {
            workspaceId: string;
            afmValidObjectsQuery: AfmValidObjectsQuery;
        },
        options?: any,
    ): AxiosPromise<AfmValidObjectsResponse>;
}

/**
 * ValidObjectsControllerApi - object-oriented interface
 * @export
 * @class ValidObjectsControllerApi
 * @extends {BaseAPI}
 */
export class ValidObjectsControllerApi extends BaseAPI implements ValidObjectsControllerApiInterface {
    /**
     * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {string} workspaceId Workspace identifier
     * @param {AfmValidObjectsQuery} afmValidObjectsQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidObjectsControllerApi
     */
    public computeValidObjects(
        params: {
            workspaceId: string;
            afmValidObjectsQuery: AfmValidObjectsQuery;
        },
        options?: any,
    ) {
        return ValidObjectsControllerApiFp(this.configuration).computeValidObjects(params, options)(
            this.axios,
            this.basePath,
        );
    }
}
