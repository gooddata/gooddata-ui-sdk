// (C) 2025 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 * Top level executable entity. Combination of [A]ttributes, [F]ilters & [M]etrics.
 * @export
 * @interface AFM
 */
export interface AFM {
    /**
     * Attributes to be used in the computation.
     * @type {Array<AttributeItem>}
     * @memberof AFM
     */
    attributes: Array<AttributeItem>;
    /**
     * Various filter types to filter the execution result.
     * @type {Array<FilterDefinition>}
     * @memberof AFM
     */
    filters: Array<FilterDefinition>;
    /**
     * Metrics to be computed.
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    measures: Array<MeasureItem>;
    /**
     * Metrics to be referenced from other AFM objects (e.g. filters) but not included in the result.
     * @type {Array<MeasureItem>}
     * @memberof AFM
     */
    auxMeasures?: Array<MeasureItem>;
}
/**
 * A datetime filter specifying exact from and to values.
 * @export
 * @interface AbsoluteDateFilter
 */
export interface AbsoluteDateFilter {
    /**
     *
     * @type {AbsoluteDateFilterAbsoluteDateFilter}
     * @memberof AbsoluteDateFilter
     */
    absoluteDateFilter: AbsoluteDateFilterAbsoluteDateFilter;
}
/**
 *
 * @export
 * @interface AbsoluteDateFilterAbsoluteDateFilter
 */
export interface AbsoluteDateFilterAbsoluteDateFilter {
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    from: string;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    to: string;
    /**
     *
     * @type {string}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifierDataset}
     * @memberof AbsoluteDateFilterAbsoluteDateFilter
     */
    dataset: AfmObjectIdentifierDataset;
}
/**
 * @type AbstractMeasureValueFilter
 * @export
 */
export type AbstractMeasureValueFilter =
    | ComparisonMeasureValueFilter
    | RangeMeasureValueFilter
    | RankingFilter;

/**
 * Object, with which the user is actively working.
 * @export
 * @interface ActiveObjectIdentification
 */
export interface ActiveObjectIdentification {
    /**
     * Object ID.
     * @type {string}
     * @memberof ActiveObjectIdentification
     */
    id: string;
    /**
     * Object type, e.g. dashboard.
     * @type {string}
     * @memberof ActiveObjectIdentification
     */
    type: string;
    /**
     * Workspace ID.
     * @type {string}
     * @memberof ActiveObjectIdentification
     */
    workspaceId: string;
}
/**
 *
 * @export
 * @interface AfmExecution
 */
export interface AfmExecution {
    /**
     *
     * @type {AFM}
     * @memberof AfmExecution
     */
    execution: AFM;
    /**
     *
     * @type {ResultSpec}
     * @memberof AfmExecution
     */
    resultSpec: ResultSpec;
    /**
     *
     * @type {ExecutionSettings}
     * @memberof AfmExecution
     */
    settings?: ExecutionSettings;
}
/**
 * Response to AFM execution request
 * @export
 * @interface AfmExecutionResponse
 */
export interface AfmExecutionResponse {
    /**
     *
     * @type {ExecutionResponse}
     * @memberof AfmExecutionResponse
     */
    executionResponse: ExecutionResponse;
}
/**
 * @type AfmIdentifier
 * Reference to the attribute label to which the filter should be applied.
 * @export
 */
export type AfmIdentifier = AfmLocalIdentifier | AfmObjectIdentifier;

/**
 *
 * @export
 * @interface AfmLocalIdentifier
 */
export interface AfmLocalIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmLocalIdentifier
     */
    localIdentifier: string;
}
/**
 * ObjectIdentifier with `identifier` wrapper. This serves to distinguish MD object identifiers in AFM request from local identifiers.
 * @export
 * @interface AfmObjectIdentifier
 */
export interface AfmObjectIdentifier {
    /**
     *
     * @type {AfmObjectIdentifierIdentifier}
     * @memberof AfmObjectIdentifier
     */
    identifier: AfmObjectIdentifierIdentifier;
}
/**
 * Reference to the date attribute to use.
 * @export
 * @interface AfmObjectIdentifierAttribute
 */
export interface AfmObjectIdentifierAttribute {
    /**
     *
     * @type {AfmObjectIdentifierAttributeIdentifier}
     * @memberof AfmObjectIdentifierAttribute
     */
    identifier: AfmObjectIdentifierAttributeIdentifier;
}
/**
 *
 * @export
 * @interface AfmObjectIdentifierAttributeIdentifier
 */
export interface AfmObjectIdentifierAttributeIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierAttributeIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierAttributeIdentifier
     */
    type: AfmObjectIdentifierAttributeIdentifierTypeEnum;
}

export const AfmObjectIdentifierAttributeIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
} as const;

export type AfmObjectIdentifierAttributeIdentifierTypeEnum =
    typeof AfmObjectIdentifierAttributeIdentifierTypeEnum[keyof typeof AfmObjectIdentifierAttributeIdentifierTypeEnum];

/**
 * Reference to the metric, fact or attribute object to use for the metric.
 * @export
 * @interface AfmObjectIdentifierCore
 */
export interface AfmObjectIdentifierCore {
    /**
     *
     * @type {AfmObjectIdentifierCoreIdentifier}
     * @memberof AfmObjectIdentifierCore
     */
    identifier: AfmObjectIdentifierCoreIdentifier;
}
/**
 *
 * @export
 * @interface AfmObjectIdentifierCoreIdentifier
 */
export interface AfmObjectIdentifierCoreIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierCoreIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierCoreIdentifier
     */
    type: AfmObjectIdentifierCoreIdentifierTypeEnum;
}

export const AfmObjectIdentifierCoreIdentifierTypeEnum = {
    ATTRIBUTE: "attribute",
    LABEL: "label",
    FACT: "fact",
    METRIC: "metric",
} as const;

export type AfmObjectIdentifierCoreIdentifierTypeEnum =
    typeof AfmObjectIdentifierCoreIdentifierTypeEnum[keyof typeof AfmObjectIdentifierCoreIdentifierTypeEnum];

/**
 * Reference to the date dataset to which the filter should be applied.
 * @export
 * @interface AfmObjectIdentifierDataset
 */
export interface AfmObjectIdentifierDataset {
    /**
     *
     * @type {AfmObjectIdentifierDatasetIdentifier}
     * @memberof AfmObjectIdentifierDataset
     */
    identifier: AfmObjectIdentifierDatasetIdentifier;
}
/**
 *
 * @export
 * @interface AfmObjectIdentifierDatasetIdentifier
 */
export interface AfmObjectIdentifierDatasetIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierDatasetIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierDatasetIdentifier
     */
    type: AfmObjectIdentifierDatasetIdentifierTypeEnum;
}

export const AfmObjectIdentifierDatasetIdentifierTypeEnum = {
    DATASET: "dataset",
} as const;

export type AfmObjectIdentifierDatasetIdentifierTypeEnum =
    typeof AfmObjectIdentifierDatasetIdentifierTypeEnum[keyof typeof AfmObjectIdentifierDatasetIdentifierTypeEnum];

/**
 *
 * @export
 * @interface AfmObjectIdentifierIdentifier
 */
export interface AfmObjectIdentifierIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierIdentifier
     */
    type: AfmObjectIdentifierIdentifierTypeEnum;
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierIdentifier
     */
    id: string;
}

export const AfmObjectIdentifierIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
    ATTRIBUTE: "attribute",
    DASHBOARD_PLUGIN: "dashboardPlugin",
    DATASET: "dataset",
    FACT: "fact",
    LABEL: "label",
    METRIC: "metric",
    PROMPT: "prompt",
    VISUALIZATION_OBJECT: "visualizationObject",
    FILTER_CONTEXT: "filterContext",
} as const;

export type AfmObjectIdentifierIdentifierTypeEnum =
    typeof AfmObjectIdentifierIdentifierTypeEnum[keyof typeof AfmObjectIdentifierIdentifierTypeEnum];

/**
 *
 * @export
 * @interface AfmObjectIdentifierLabel
 */
export interface AfmObjectIdentifierLabel {
    /**
     *
     * @type {AfmObjectIdentifierLabelIdentifier}
     * @memberof AfmObjectIdentifierLabel
     */
    identifier: AfmObjectIdentifierLabelIdentifier;
}
/**
 *
 * @export
 * @interface AfmObjectIdentifierLabelIdentifier
 */
export interface AfmObjectIdentifierLabelIdentifier {
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierLabelIdentifier
     */
    type: AfmObjectIdentifierLabelIdentifierTypeEnum;
    /**
     *
     * @type {string}
     * @memberof AfmObjectIdentifierLabelIdentifier
     */
    id: string;
}

export const AfmObjectIdentifierLabelIdentifierTypeEnum = {
    LABEL: "label",
} as const;

export type AfmObjectIdentifierLabelIdentifierTypeEnum =
    typeof AfmObjectIdentifierLabelIdentifierTypeEnum[keyof typeof AfmObjectIdentifierLabelIdentifierTypeEnum];

/**
 * Entity describing the valid descendants request.
 * @export
 * @interface AfmValidDescendantsQuery
 */
export interface AfmValidDescendantsQuery {
    /**
     * List of identifiers of the attributes to get the valid descendants for.
     * @type {Array<AfmObjectIdentifierAttribute>}
     * @memberof AfmValidDescendantsQuery
     */
    attributes: Array<AfmObjectIdentifierAttribute>;
}
/**
 * Entity describing the valid descendants response.
 * @export
 * @interface AfmValidDescendantsResponse
 */
export interface AfmValidDescendantsResponse {
    /**
     * Map of attribute identifiers to list of valid descendants identifiers.
     * @type {{ [key: string]: Array<AfmObjectIdentifierAttribute>; }}
     * @memberof AfmValidDescendantsResponse
     */
    validDescendants: { [key: string]: Array<AfmObjectIdentifierAttribute> };
}
/**
 * Entity holding AFM and list of object types whose validity should be computed.
 * @export
 * @interface AfmValidObjectsQuery
 */
export interface AfmValidObjectsQuery {
    /**
     *
     * @type {Array<string>}
     * @memberof AfmValidObjectsQuery
     */
    types: Array<AfmValidObjectsQueryTypesEnum>;
    /**
     *
     * @type {AFM}
     * @memberof AfmValidObjectsQuery
     */
    afm: AFM;
}

export const AfmValidObjectsQueryTypesEnum = {
    FACTS: "facts",
    ATTRIBUTES: "attributes",
    MEASURES: "measures",
} as const;

export type AfmValidObjectsQueryTypesEnum =
    typeof AfmValidObjectsQueryTypesEnum[keyof typeof AfmValidObjectsQueryTypesEnum];

/**
 * All objects of specified types valid with respect to given AFM.
 * @export
 * @interface AfmValidObjectsResponse
 */
export interface AfmValidObjectsResponse {
    /**
     *
     * @type {Array<RestApiIdentifier>}
     * @memberof AfmValidObjectsResponse
     */
    items: Array<RestApiIdentifier>;
}
/**
 *
 * @export
 * @interface AnomalyDetectionRequest
 */
export interface AnomalyDetectionRequest {
    /**
     * Anomaly detection sensitivity.
     * @type {number}
     * @memberof AnomalyDetectionRequest
     */
    sensitivity: number;
}
/**
 *
 * @export
 * @interface AnomalyDetectionResult
 */
export interface AnomalyDetectionResult {
    /**
     *
     * @type {Array<string>}
     * @memberof AnomalyDetectionResult
     */
    attribute: Array<string>;
    /**
     *
     * @type {Array<number>}
     * @memberof AnomalyDetectionResult
     */
    values: Array<number>;
    /**
     *
     * @type {Array<boolean>}
     * @memberof AnomalyDetectionResult
     */
    anomalyFlag: Array<boolean>;
}
/**
 * Metric representing arithmetics between other metrics.
 * @export
 * @interface ArithmeticMeasureDefinition
 */
export interface ArithmeticMeasureDefinition {
    /**
     *
     * @type {ArithmeticMeasureDefinitionArithmeticMeasure}
     * @memberof ArithmeticMeasureDefinition
     */
    arithmeticMeasure: ArithmeticMeasureDefinitionArithmeticMeasure;
}
/**
 *
 * @export
 * @interface ArithmeticMeasureDefinitionArithmeticMeasure
 */
export interface ArithmeticMeasureDefinitionArithmeticMeasure {
    /**
     * List of metrics to apply arithmetic operation by chosen operator.
     * @type {Array<AfmLocalIdentifier>}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    measureIdentifiers: Array<AfmLocalIdentifier>;
    /**
     * Arithmetic operator describing operation between metrics.
     * @type {string}
     * @memberof ArithmeticMeasureDefinitionArithmeticMeasure
     */
    operator: ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
}

export const ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum = {
    SUM: "SUM",
    DIFFERENCE: "DIFFERENCE",
    MULTIPLICATION: "MULTIPLICATION",
    RATIO: "RATIO",
    CHANGE: "CHANGE",
} as const;

export type ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum =
    typeof ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum[keyof typeof ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum];

/**
 *
 * @export
 * @interface AttributeExecutionResultHeader
 */
export interface AttributeExecutionResultHeader {
    /**
     *
     * @type {AttributeResultHeader}
     * @memberof AttributeExecutionResultHeader
     */
    attributeHeader: AttributeResultHeader;
}
/**
 * @type AttributeFilter
 * Abstract filter definition type attributes
 * @export
 */
export type AttributeFilter = NegativeAttributeFilter | PositiveAttributeFilter;

/**
 * Filter on specific set of label values.
 * @export
 * @interface AttributeFilterElements
 */
export interface AttributeFilterElements {
    /**
     * Set of label values.
     * @type {Array<string>}
     * @memberof AttributeFilterElements
     */
    values: Array<string | null>;
}
/**
 * Attribute format describes formatting information to effectively format attribute values when needed.
 * @export
 * @interface AttributeFormat
 */
export interface AttributeFormat {
    /**
     * Format locale code like \'en-US\', \'cs-CZ\', etc.
     * @type {string}
     * @memberof AttributeFormat
     */
    locale: string;
    /**
     * ICU formatting pattern like \'y\', \'dd.MM.y\', etc.
     * @type {string}
     * @memberof AttributeFormat
     */
    pattern: string;
}
/**
 *
 * @export
 * @interface AttributeHeader
 */
export interface AttributeHeader {
    /**
     *
     * @type {AttributeHeaderAttributeHeader}
     * @memberof AttributeHeader
     */
    attributeHeader: AttributeHeaderAttributeHeader;
}
/**
 *
 * @export
 * @interface AttributeHeaderAttributeHeader
 */
export interface AttributeHeaderAttributeHeader {
    /**
     * Local identifier of the attribute this header relates to.
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    localIdentifier: string;
    /**
     *
     * @type {RestApiIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    label: RestApiIdentifier;
    /**
     * Label name.
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    labelName: string;
    /**
     *
     * @type {RestApiIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    attribute: RestApiIdentifier;
    /**
     * Attribute name.
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    attributeName: string;
    /**
     * Date granularity of the attribute, only filled for date attributes.
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    granularity?: AttributeHeaderAttributeHeaderGranularityEnum;
    /**
     *
     * @type {RestApiIdentifier}
     * @memberof AttributeHeaderAttributeHeader
     */
    primaryLabel: RestApiIdentifier;
    /**
     *
     * @type {AttributeFormat}
     * @memberof AttributeHeaderAttributeHeader
     */
    format?: AttributeFormat;
    /**
     * Attribute value type.
     * @type {string}
     * @memberof AttributeHeaderAttributeHeader
     */
    valueType?: AttributeHeaderAttributeHeaderValueTypeEnum;
}

export const AttributeHeaderAttributeHeaderGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type AttributeHeaderAttributeHeaderGranularityEnum =
    typeof AttributeHeaderAttributeHeaderGranularityEnum[keyof typeof AttributeHeaderAttributeHeaderGranularityEnum];
export const AttributeHeaderAttributeHeaderValueTypeEnum = {
    TEXT: "TEXT",
    HYPERLINK: "HYPERLINK",
    GEO: "GEO",
    GEO_LONGITUDE: "GEO_LONGITUDE",
    GEO_LATITUDE: "GEO_LATITUDE",
    IMAGE: "IMAGE",
} as const;

export type AttributeHeaderAttributeHeaderValueTypeEnum =
    typeof AttributeHeaderAttributeHeaderValueTypeEnum[keyof typeof AttributeHeaderAttributeHeaderValueTypeEnum];

/**
 *
 * @export
 * @interface AttributeItem
 */
export interface AttributeItem {
    /**
     * Local identifier of the attribute. This can be used to reference the attribute in other parts of the execution definition.
     * @type {string}
     * @memberof AttributeItem
     */
    localIdentifier: string;
    /**
     *
     * @type {AfmObjectIdentifierLabel}
     * @memberof AttributeItem
     */
    label: AfmObjectIdentifierLabel;
    /**
     * Indicates whether to show all values of given attribute even if the data bound to those values is not available.
     * @type {boolean}
     * @memberof AttributeItem
     */
    showAllValues?: boolean;
}
/**
 *
 * @export
 * @interface AttributeNegativeFilter
 */
export interface AttributeNegativeFilter {
    /**
     *
     * @type {string}
     * @memberof AttributeNegativeFilter
     */
    using: string;
    /**
     *
     * @type {Array<string>}
     * @memberof AttributeNegativeFilter
     */
    exclude: Array<string>;
}
/**
 *
 * @export
 * @interface AttributeNegativeFilterAllOf
 */
export interface AttributeNegativeFilterAllOf {
    /**
     *
     * @type {string}
     * @memberof AttributeNegativeFilterAllOf
     */
    using?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof AttributeNegativeFilterAllOf
     */
    exclude?: Array<string>;
}
/**
 *
 * @export
 * @interface AttributePositiveFilter
 */
export interface AttributePositiveFilter {
    /**
     *
     * @type {string}
     * @memberof AttributePositiveFilter
     */
    using: string;
    /**
     *
     * @type {Array<string>}
     * @memberof AttributePositiveFilter
     */
    include: Array<string>;
}
/**
 *
 * @export
 * @interface AttributePositiveFilterAllOf
 */
export interface AttributePositiveFilterAllOf {
    /**
     *
     * @type {string}
     * @memberof AttributePositiveFilterAllOf
     */
    using?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof AttributePositiveFilterAllOf
     */
    include?: Array<string>;
}
/**
 * Header containing the information related to attributes.
 * @export
 * @interface AttributeResultHeader
 */
export interface AttributeResultHeader {
    /**
     * A value of the current attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    labelValue: string;
    /**
     * A value of the primary attribute label.
     * @type {string}
     * @memberof AttributeResultHeader
     */
    primaryLabelValue: string;
}
/**
 * List of chat history interactions.
 * @export
 * @interface ChatHistoryInteraction
 */
export interface ChatHistoryInteraction {
    /**
     * User question
     * @type {string}
     * @memberof ChatHistoryInteraction
     */
    question: string;
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     * @type {string}
     * @memberof ChatHistoryInteraction
     */
    threadIdSuffix?: string;
    /**
     * Chat History interaction ID. Unique ID for each interaction.
     * @type {string}
     * @memberof ChatHistoryInteraction
     */
    chatHistoryInteractionId: string;
    /**
     * Has the interaction already finished? Can be used for polling when interaction is in progress.
     * @type {boolean}
     * @memberof ChatHistoryInteraction
     */
    interactionFinished: boolean;
    /**
     *
     * @type {RouteResult}
     * @memberof ChatHistoryInteraction
     */
    routing: RouteResult;
    /**
     * Text response for general questions.
     * @type {string}
     * @memberof ChatHistoryInteraction
     */
    textResponse?: string;
    /**
     * Error response in anything fails.
     * @type {string}
     * @memberof ChatHistoryInteraction
     */
    errorResponse?: string;
    /**
     *
     * @type {FoundObjects}
     * @memberof ChatHistoryInteraction
     */
    foundObjects?: FoundObjects;
    /**
     *
     * @type {CreatedVisualizations}
     * @memberof ChatHistoryInteraction
     */
    createdVisualizations?: CreatedVisualizations;
    /**
     * User feedback.
     * @type {string}
     * @memberof ChatHistoryInteraction
     */
    userFeedback?: ChatHistoryInteractionUserFeedbackEnum;
}

export const ChatHistoryInteractionUserFeedbackEnum = {
    POSITIVE: "POSITIVE",
    NEGATIVE: "NEGATIVE",
    NONE: "NONE",
} as const;

export type ChatHistoryInteractionUserFeedbackEnum =
    typeof ChatHistoryInteractionUserFeedbackEnum[keyof typeof ChatHistoryInteractionUserFeedbackEnum];

/**
 *
 * @export
 * @interface ChatHistoryRequest
 */
export interface ChatHistoryRequest {
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     * @type {string}
     * @memberof ChatHistoryRequest
     */
    threadIdSuffix?: string;
    /**
     * Return chat history records only after this interaction ID. If empty, complete chat history is returned.
     * @type {string}
     * @memberof ChatHistoryRequest
     */
    chatHistoryInteractionId?: string;
    /**
     * User feedback.
     * @type {string}
     * @memberof ChatHistoryRequest
     */
    userFeedback?: ChatHistoryRequestUserFeedbackEnum;
    /**
     * User feedback.
     * @type {boolean}
     * @memberof ChatHistoryRequest
     */
    reset?: boolean;
}

export const ChatHistoryRequestUserFeedbackEnum = {
    POSITIVE: "POSITIVE",
    NEGATIVE: "NEGATIVE",
    NONE: "NONE",
} as const;

export type ChatHistoryRequestUserFeedbackEnum =
    typeof ChatHistoryRequestUserFeedbackEnum[keyof typeof ChatHistoryRequestUserFeedbackEnum];

/**
 *
 * @export
 * @interface ChatHistoryResult
 */
export interface ChatHistoryResult {
    /**
     * List of chat history interactions.
     * @type {Array<ChatHistoryInteraction>}
     * @memberof ChatHistoryResult
     */
    interactions: Array<ChatHistoryInteraction>;
    /**
     * The conversation thread ID.
     * @type {string}
     * @memberof ChatHistoryResult
     */
    threadId: string;
}
/**
 *
 * @export
 * @interface ChatRequest
 */
export interface ChatRequest {
    /**
     * User question
     * @type {string}
     * @memberof ChatRequest
     */
    question: string;
    /**
     * Maximum number of search results.
     * @type {number}
     * @memberof ChatRequest
     */
    limitSearch?: number;
    /**
     * Maximum number of relevant objects included into context for LLM (for each object type).
     * @type {number}
     * @memberof ChatRequest
     */
    limitCreateContext?: number;
    /**
     * Maximum number of created results.
     * @type {number}
     * @memberof ChatRequest
     */
    limitCreate?: number;
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     * @type {string}
     * @memberof ChatRequest
     */
    threadIdSuffix?: string;
    /**
     *
     * @type {UserContext}
     * @memberof ChatRequest
     */
    userContext?: UserContext;
    /**
     * Temporary for experiments. Ratio of title score to descriptor score.
     * @type {number}
     * @memberof ChatRequest
     */
    titleToDescriptorRatio?: number;
    /**
     * Score, above which we return found object(s) and don\'t call LLM to create new objects.
     * @type {number}
     * @memberof ChatRequest
     */
    searchScoreThreshold?: number;
    /**
     * Score, above which we return found objects. Below this score objects are not relevant.
     * @type {number}
     * @memberof ChatRequest
     */
    relevantScoreThreshold?: number;
}
/**
 *
 * @export
 * @interface ChatResult
 */
export interface ChatResult {
    /**
     *
     * @type {RouteResult}
     * @memberof ChatResult
     */
    routing?: RouteResult;
    /**
     * Text response for general questions.
     * @type {string}
     * @memberof ChatResult
     */
    textResponse?: string;
    /**
     * Error response in anything fails.
     * @type {string}
     * @memberof ChatResult
     */
    errorResponse?: string;
    /**
     *
     * @type {FoundObjects}
     * @memberof ChatResult
     */
    foundObjects?: FoundObjects;
    /**
     *
     * @type {CreatedVisualizations}
     * @memberof ChatResult
     */
    createdVisualizations?: CreatedVisualizations;
    /**
     * Chat History thread suffix appended to ID generated by backend. Enables more chat windows.
     * @type {string}
     * @memberof ChatResult
     */
    threadIdSuffix?: string;
    /**
     * Chat History interaction ID. Unique ID for each interaction.
     * @type {string}
     * @memberof ChatResult
     */
    chatHistoryInteractionId?: string;
}
/**
 *
 * @export
 * @interface ClusteringRequest
 */
export interface ClusteringRequest {
    /**
     * Number of clusters to create
     * @type {number}
     * @memberof ClusteringRequest
     */
    numberOfClusters: number;
    /**
     * Threshold used for algorithm
     * @type {number}
     * @memberof ClusteringRequest
     */
    threshold?: number;
}
/**
 *
 * @export
 * @interface ClusteringResult
 */
export interface ClusteringResult {
    /**
     *
     * @type {Array<object>}
     * @memberof ClusteringResult
     */
    attribute: Array<object>;
    /**
     *
     * @type {Array<number>}
     * @memberof ClusteringResult
     */
    xCoord?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof ClusteringResult
     */
    yCoord?: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof ClusteringResult
     */
    clusters: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof ClusteringResult
     */
    ycoord: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof ClusteringResult
     */
    xcoord: Array<number>;
}
/**
 * Filter the result by comparing specified metric to given constant value, using given comparison operator.
 * @export
 * @interface ComparisonMeasureValueFilter
 */
export interface ComparisonMeasureValueFilter {
    /**
     *
     * @type {ComparisonMeasureValueFilterComparisonMeasureValueFilter}
     * @memberof ComparisonMeasureValueFilter
     */
    comparisonMeasureValueFilter: ComparisonMeasureValueFilterComparisonMeasureValueFilter;
}
/**
 *
 * @export
 * @interface ComparisonMeasureValueFilterComparisonMeasureValueFilter
 */
export interface ComparisonMeasureValueFilterComparisonMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     * @type {Array<AfmIdentifier>}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    dimensionality?: Array<AfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     * @type {number}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    operator: ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    value: number;
    /**
     *
     * @type {string}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmIdentifier}
     * @memberof ComparisonMeasureValueFilterComparisonMeasureValueFilter
     */
    measure: AfmIdentifier;
}

export const ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum = {
    GREATER_THAN: "GREATER_THAN",
    GREATER_THAN_OR_EQUAL_TO: "GREATER_THAN_OR_EQUAL_TO",
    LESS_THAN: "LESS_THAN",
    LESS_THAN_OR_EQUAL_TO: "LESS_THAN_OR_EQUAL_TO",
    EQUAL_TO: "EQUAL_TO",
    NOT_EQUAL_TO: "NOT_EQUAL_TO",
} as const;

export type ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum =
    typeof ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum[keyof typeof ComparisonMeasureValueFilterComparisonMeasureValueFilterOperatorEnum];

/**
 * List of created visualization objects
 * @export
 * @interface CreatedVisualization
 */
export interface CreatedVisualization {
    /**
     * Proposed ID of the new visualization
     * @type {string}
     * @memberof CreatedVisualization
     */
    id: string;
    /**
     * Proposed title of the new visualization
     * @type {string}
     * @memberof CreatedVisualization
     */
    title: string;
    /**
     * Visualization type requested in question
     * @type {string}
     * @memberof CreatedVisualization
     */
    visualizationType: CreatedVisualizationVisualizationTypeEnum;
    /**
     * List of metrics to be used in the new visualization
     * @type {Array<Metric>}
     * @memberof CreatedVisualization
     */
    metrics: Array<Metric>;
    /**
     * List of attributes representing the dimensionality of the new visualization
     * @type {Array<DimAttribute>}
     * @memberof CreatedVisualization
     */
    dimensionality: Array<DimAttribute>;
    /**
     * List of filters to be applied to the new visualization
     * @type {Array<AttributeNegativeFilter | AttributePositiveFilter | DateAbsoluteFilter | DateRelativeFilter>}
     * @memberof CreatedVisualization
     */
    filters: Array<
        AttributeNegativeFilter | AttributePositiveFilter | DateAbsoluteFilter | DateRelativeFilter
    >;
    /**
     * Suggestions for next steps
     * @type {Array<Suggestion>}
     * @memberof CreatedVisualization
     */
    suggestions: Array<Suggestion>;
}

export const CreatedVisualizationVisualizationTypeEnum = {
    TABLE: "TABLE",
    HEADLINE: "HEADLINE",
    BAR: "BAR",
    LINE: "LINE",
    PIE: "PIE",
    COLUMN: "COLUMN",
} as const;

export type CreatedVisualizationVisualizationTypeEnum =
    typeof CreatedVisualizationVisualizationTypeEnum[keyof typeof CreatedVisualizationVisualizationTypeEnum];

/**
 * Visualization definitions created by AI.
 * @export
 * @interface CreatedVisualizations
 */
export interface CreatedVisualizations {
    /**
     * List of created visualization objects
     * @type {Array<CreatedVisualization>}
     * @memberof CreatedVisualizations
     */
    objects: Array<CreatedVisualization>;
    /**
     * Reasoning from LLM. Description of how and why the answer was generated.
     * @type {string}
     * @memberof CreatedVisualizations
     */
    reasoning: string;
}
/**
 * Mapping from dimension items (either \'localIdentifier\' from \'AttributeItem\', or \"measureGroup\") to their respective values. This effectively specifies the path (location) of the data column used for sorting. Therefore values for all dimension items must be specified.
 * @export
 * @interface DataColumnLocator
 */
export interface DataColumnLocator {
    /**
     * Mapping from dimension items (either \'localIdentifier\' from \'AttributeItem\', or \"measureGroup\") to their respective values. This effectively specifies the path (location) of the data column used for sorting. Therefore values for all dimension items must be specified.
     * @type {{ [key: string]: string; }}
     * @memberof DataColumnLocator
     */
    properties: { [key: string]: string };
}
/**
 * Data column locators for the values.
 * @export
 * @interface DataColumnLocators
 */
export interface DataColumnLocators {
    /**
     * Mapping from dimensions to data column locators.
     * @type {{ [key: string]: DataColumnLocator; }}
     * @memberof DataColumnLocators
     */
    properties?: { [key: string]: DataColumnLocator };
}
/**
 *
 * @export
 * @interface DateAbsoluteFilter
 */
export interface DateAbsoluteFilter {
    /**
     *
     * @type {string}
     * @memberof DateAbsoluteFilter
     */
    using: string;
    /**
     *
     * @type {string}
     * @memberof DateAbsoluteFilter
     */
    from: string;
    /**
     *
     * @type {string}
     * @memberof DateAbsoluteFilter
     */
    to: string;
}
/**
 *
 * @export
 * @interface DateAbsoluteFilterAllOf
 */
export interface DateAbsoluteFilterAllOf {
    /**
     *
     * @type {string}
     * @memberof DateAbsoluteFilterAllOf
     */
    using?: string;
    /**
     *
     * @type {string}
     * @memberof DateAbsoluteFilterAllOf
     */
    from?: string;
    /**
     *
     * @type {string}
     * @memberof DateAbsoluteFilterAllOf
     */
    to?: string;
}
/**
 * @type DateFilter
 * Abstract filter definition type for dates.
 * @export
 */
export type DateFilter = AbsoluteDateFilter | RelativeDateFilter;

/**
 *
 * @export
 * @interface DateRelativeFilter
 */
export interface DateRelativeFilter {
    /**
     *
     * @type {string}
     * @memberof DateRelativeFilter
     */
    using: string;
    /**
     *
     * @type {string}
     * @memberof DateRelativeFilter
     */
    granularity: DateRelativeFilterGranularityEnum;
    /**
     *
     * @type {number}
     * @memberof DateRelativeFilter
     */
    from: number;
    /**
     *
     * @type {number}
     * @memberof DateRelativeFilter
     */
    to: number;
}

export const DateRelativeFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type DateRelativeFilterGranularityEnum =
    typeof DateRelativeFilterGranularityEnum[keyof typeof DateRelativeFilterGranularityEnum];

/**
 *
 * @export
 * @interface DateRelativeFilterAllOf
 */
export interface DateRelativeFilterAllOf {
    /**
     *
     * @type {string}
     * @memberof DateRelativeFilterAllOf
     */
    using?: string;
    /**
     *
     * @type {string}
     * @memberof DateRelativeFilterAllOf
     */
    granularity?: DateRelativeFilterAllOfGranularityEnum;
    /**
     *
     * @type {number}
     * @memberof DateRelativeFilterAllOf
     */
    from?: number;
    /**
     *
     * @type {number}
     * @memberof DateRelativeFilterAllOf
     */
    to?: number;
}

export const DateRelativeFilterAllOfGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type DateRelativeFilterAllOfGranularityEnum =
    typeof DateRelativeFilterAllOfGranularityEnum[keyof typeof DateRelativeFilterAllOfGranularityEnum];

/**
 * Filter definition type specified by label and values.
 * @export
 * @interface DependsOn
 */
export interface DependsOn {
    /**
     * Specifies on which label the filter depends on.
     * @type {string}
     * @memberof DependsOn
     */
    label: string;
    /**
     * Specifies values of the label for element filtering.
     * @type {Array<string>}
     * @memberof DependsOn
     */
    values: Array<string | null>;
    /**
     * Inverse filtering mode.
     * @type {boolean}
     * @memberof DependsOn
     */
    complementFilter?: boolean;
}
/**
 *
 * @export
 * @interface DependsOnAllOf
 */
export interface DependsOnAllOf {
    /**
     * Specifies on which label the filter depends on.
     * @type {string}
     * @memberof DependsOnAllOf
     */
    label?: string;
    /**
     * Specifies values of the label for element filtering.
     * @type {Array<string>}
     * @memberof DependsOnAllOf
     */
    values?: Array<string>;
    /**
     * Inverse filtering mode.
     * @type {boolean}
     * @memberof DependsOnAllOf
     */
    complementFilter?: boolean;
}
/**
 * Filter definition type for dates.
 * @export
 * @interface DependsOnDateFilter
 */
export interface DependsOnDateFilter {
    /**
     *
     * @type {DateFilter}
     * @memberof DependsOnDateFilter
     */
    dateFilter: DateFilter;
}
/**
 *
 * @export
 * @interface DependsOnDateFilterAllOf
 */
export interface DependsOnDateFilterAllOf {
    /**
     *
     * @type {DateFilter}
     * @memberof DependsOnDateFilterAllOf
     */
    dateFilter?: DateFilter;
}
/**
 * List of attributes representing the dimensionality of the new visualization
 * @export
 * @interface DimAttribute
 */
export interface DimAttribute {
    /**
     * ID of the object
     * @type {string}
     * @memberof DimAttribute
     */
    id: string;
    /**
     * Object type
     * @type {string}
     * @memberof DimAttribute
     */
    type: DimAttributeTypeEnum;
    /**
     * Title of attribute.
     * @type {string}
     * @memberof DimAttribute
     */
    title: string;
}

export const DimAttributeTypeEnum = {
    ATTRIBUTE: "attribute",
} as const;

export type DimAttributeTypeEnum = typeof DimAttributeTypeEnum[keyof typeof DimAttributeTypeEnum];

/**
 * Single dimension description.
 * @export
 * @interface Dimension
 */
export interface Dimension {
    /**
     * Dimension identification within requests. Other entities can reference this dimension by this value.
     * @type {string}
     * @memberof Dimension
     */
    localIdentifier?: string;
    /**
     * List of items in current dimension. Can reference \'localIdentifier\' from \'AttributeItem\', or special pseudo attribute \"measureGroup\" representing list of metrics.
     * @type {Array<string>}
     * @memberof Dimension
     */
    itemIdentifiers: Array<string>;
    /**
     * List of sorting rules. From most relevant to least relevant (less relevant rule is applied, when more relevant rule compares items as equal).
     * @type {Array<SortKey>}
     * @memberof Dimension
     */
    sorting?: Array<SortKey>;
}
/**
 * Contains the dimension-specific header information.
 * @export
 * @interface DimensionHeader
 */
export interface DimensionHeader {
    /**
     * An array containing header groups.
     * @type {Array<HeaderGroup>}
     * @memberof DimensionHeader
     */
    headerGroups: Array<HeaderGroup>;
}
/**
 * List of returned elements.
 * @export
 * @interface Element
 */
export interface Element {
    /**
     * Title of requested label.
     * @type {string}
     * @memberof Element
     */
    title: string | null;
    /**
     * Title of primary label of attribute owning requested label, null if the title is null or the primary label is excluded
     * @type {string}
     * @memberof Element
     */
    primaryTitle: string | null;
}
/**
 *
 * @export
 * @interface ElementsRequest
 */
export interface ElementsRequest {
    /**
     * Requested label.
     * @type {string}
     * @memberof ElementsRequest
     */
    label: string;
    /**
     * Excludes items from the result that differ only by primary label * ```false``` - return items with distinct primary label * ```true``` - return items with distinct requested label
     * @type {boolean}
     * @memberof ElementsRequest
     */
    excludePrimaryLabel?: boolean;
    /**
     *
     * @type {FilterBy}
     * @memberof ElementsRequest
     */
    filterBy?: FilterBy;
    /**
     * Sort order of returned items. Items are sorted by ```label``` title. If no sort order is specified then attribute\'s ```sortDirection``` is used, which is ASC by default
     * @type {string}
     * @memberof ElementsRequest
     */
    sortOrder?: ElementsRequestSortOrderEnum;
    /**
     * Inverse filters: * ```false``` - return items matching ```patternFilter``` and ```exactFilter``` * ```true``` - return items not matching ```patternFilter``` and ```exactFilter```
     * @type {boolean}
     * @memberof ElementsRequest
     */
    complementFilter?: boolean;
    /**
     * Return only items, whose ```label``` title case insensitively contains ```filter``` as substring.
     * @type {string}
     * @memberof ElementsRequest
     */
    patternFilter?: string;
    /**
     * Return only items, whose ```label``` title exactly matches one of ```filter```.
     * @type {Array<string>}
     * @memberof ElementsRequest
     */
    exactFilter?: Array<string>;
    /**
     * Return only items that are not filtered-out by the parent filters.
     * @type {Array<DependsOn | DependsOnDateFilter>}
     * @memberof ElementsRequest
     */
    dependsOn?: Array<DependsOn | DependsOnDateFilter>;
    /**
     * Return only items that are computable on metric.
     * @type {Array<ValidateByItem>}
     * @memberof ElementsRequest
     */
    validateBy?: Array<ValidateByItem>;
    /**
     * Specifies percentage of source table data scanned during the computation. This field is deprecated and is no longer used during the elements computation.
     * @type {number}
     * @memberof ElementsRequest
     * @deprecated
     */
    dataSamplingPercentage?: number;
    /**
     * If specified, the element data will be taken from the result with the same cacheId if it is available.
     * @type {string}
     * @memberof ElementsRequest
     */
    cacheId?: string;
}

export const ElementsRequestSortOrderEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type ElementsRequestSortOrderEnum =
    typeof ElementsRequestSortOrderEnum[keyof typeof ElementsRequestSortOrderEnum];

/**
 * Entity holding list of sorted & filtered label elements, related primary label of attribute owning requested label and paging.
 * @export
 * @interface ElementsResponse
 */
export interface ElementsResponse {
    /**
     *
     * @type {RestApiIdentifier}
     * @memberof ElementsResponse
     */
    primaryLabel: RestApiIdentifier;
    /**
     * List of returned elements.
     * @type {Array<Element>}
     * @memberof ElementsResponse
     */
    elements: Array<Element>;
    /**
     *
     * @type {Paging}
     * @memberof ElementsResponse
     */
    paging: Paging;
    /**
     * Granularity of requested label in case of date attribute
     * @type {string}
     * @memberof ElementsResponse
     */
    granularity?: ElementsResponseGranularityEnum;
    /**
     *
     * @type {AttributeFormat}
     * @memberof ElementsResponse
     */
    format?: AttributeFormat;
    /**
     * The client can use this in subsequent requests (like paging or search) to get results from the same point in time as the previous request. This is useful when the underlying data source has caches disabled and the client wants to avoid seeing inconsistent results and to also avoid excessive queries to the database itself.
     * @type {string}
     * @memberof ElementsResponse
     */
    cacheId?: string;
}

export const ElementsResponseGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type ElementsResponseGranularityEnum =
    typeof ElementsResponseGranularityEnum[keyof typeof ElementsResponseGranularityEnum];

/**
 * Links to the execution result.
 * @export
 * @interface ExecutionLinks
 */
export interface ExecutionLinks {
    /**
     * Link to the result data.
     * @type {string}
     * @memberof ExecutionLinks
     */
    executionResult: string;
}
/**
 * Response to AFM execution request body
 * @export
 * @interface ExecutionResponse
 */
export interface ExecutionResponse {
    /**
     * Dimensions of the result
     * @type {Array<ResultDimension>}
     * @memberof ExecutionResponse
     */
    dimensions: Array<ResultDimension>;
    /**
     *
     * @type {ExecutionLinks}
     * @memberof ExecutionResponse
     */
    links: ExecutionLinks;
}
/**
 * Contains the result of an AFM execution.
 * @export
 * @interface ExecutionResult
 */
export interface ExecutionResult {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     * @type {Array<object>}
     * @memberof ExecutionResult
     */
    data: Array<object>;
    /**
     * An array containing dimension headers. The size of the array corresponds to the number of dimensions. Their order corresponds to the dimension order in the execution result spec.
     * @type {Array<DimensionHeader>}
     * @memberof ExecutionResult
     */
    dimensionHeaders: Array<DimensionHeader>;
    /**
     *
     * @type {Array<ExecutionResultGrandTotal>}
     * @memberof ExecutionResult
     */
    grandTotals: Array<ExecutionResultGrandTotal>;
    /**
     *
     * @type {ExecutionResultPaging}
     * @memberof ExecutionResult
     */
    paging: ExecutionResultPaging;
}
/**
 * Contains the data of grand totals with the same dimensions.
 * @export
 * @interface ExecutionResultGrandTotal
 */
export interface ExecutionResultGrandTotal {
    /**
     * A multi-dimensional array of computed results. The most common one being a 2-dimensional array. The arrays can be composed of Double or null values.
     * @type {Array<object>}
     * @memberof ExecutionResultGrandTotal
     */
    data: Array<object>;
    /**
     * Contains headers for a subset of `totalDimensions` in which the totals are grand totals.
     * @type {Array<DimensionHeader>}
     * @memberof ExecutionResultGrandTotal
     */
    dimensionHeaders: Array<DimensionHeader>;
    /**
     * Dimensions of the grand totals.
     * @type {Array<string>}
     * @memberof ExecutionResultGrandTotal
     */
    totalDimensions: Array<string>;
}
/**
 * @type ExecutionResultHeader
 * Abstract execution result header
 * @export
 */
export type ExecutionResultHeader =
    | AttributeExecutionResultHeader
    | MeasureExecutionResultHeader
    | TotalExecutionResultHeader;

/**
 * A paging information related to the data presented in the execution result. These paging information are multi-dimensional.
 * @export
 * @interface ExecutionResultPaging
 */
export interface ExecutionResultPaging {
    /**
     * A count of the returned results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    count: Array<number>;
    /**
     * The offset of the results returned in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    offset: Array<number>;
    /**
     * A total count of the results in every dimension.
     * @type {Array<number>}
     * @memberof ExecutionResultPaging
     */
    total: Array<number>;
}
/**
 * Various settings affecting the process of AFM execution or its result
 * @export
 * @interface ExecutionSettings
 */
export interface ExecutionSettings {
    /**
     * Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     * @type {number}
     * @memberof ExecutionSettings
     */
    dataSamplingPercentage?: number;
}
/**
 * Specifies what is used for filtering.
 * @export
 * @interface FilterBy
 */
export interface FilterBy {
    /**
     * Specifies which label is used for filtering - primary or requested.
     * @type {string}
     * @memberof FilterBy
     */
    labelType?: FilterByLabelTypeEnum;
}

export const FilterByLabelTypeEnum = {
    PRIMARY: "PRIMARY",
    REQUESTED: "REQUESTED",
} as const;

export type FilterByLabelTypeEnum = typeof FilterByLabelTypeEnum[keyof typeof FilterByLabelTypeEnum];

/**
 * @type FilterDefinition
 * Abstract filter definition type
 * @export
 */
export type FilterDefinition =
    | AbsoluteDateFilter
    | ComparisonMeasureValueFilter
    | InlineFilterDefinition
    | NegativeAttributeFilter
    | PositiveAttributeFilter
    | RangeMeasureValueFilter
    | RankingFilter
    | RelativeDateFilter;

/**
 * @type FilterDefinitionForSimpleMeasure
 * Abstract filter definition type for simple metric.
 * @export
 */
export type FilterDefinitionForSimpleMeasure = AttributeFilter | DateFilter;

/**
 *
 * @export
 * @interface ForecastRequest
 */
export interface ForecastRequest {
    /**
     * Number of future periods that should be forecasted
     * @type {number}
     * @memberof ForecastRequest
     */
    forecastPeriod: number;
    /**
     * Confidence interval boundary value.
     * @type {number}
     * @memberof ForecastRequest
     */
    confidenceLevel?: number;
    /**
     * Whether the input data is seasonal
     * @type {boolean}
     * @memberof ForecastRequest
     */
    seasonal?: boolean;
}
/**
 *
 * @export
 * @interface ForecastResult
 */
export interface ForecastResult {
    /**
     *
     * @type {Array<string>}
     * @memberof ForecastResult
     */
    attribute: Array<string>;
    /**
     *
     * @type {Array<number>}
     * @memberof ForecastResult
     */
    origin: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof ForecastResult
     */
    prediction: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof ForecastResult
     */
    lowerBound: Array<number>;
    /**
     *
     * @type {Array<number>}
     * @memberof ForecastResult
     */
    upperBound: Array<number>;
}
/**
 * List of objects found by similarity search and post-processed by LLM.
 * @export
 * @interface FoundObjects
 */
export interface FoundObjects {
    /**
     * List of objects found with a similarity search.
     * @type {Array<SearchResultObject>}
     * @memberof FoundObjects
     */
    objects: Array<SearchResultObject>;
    /**
     * Reasoning from LLM. Description of how and why the answer was generated.
     * @type {string}
     * @memberof FoundObjects
     */
    reasoning: string;
}
/**
 * Contains the information specific for a group of headers. These groups correlate to attributes and metric groups.
 * @export
 * @interface HeaderGroup
 */
export interface HeaderGroup {
    /**
     * An array containing headers.
     * @type {Array<ExecutionResultHeader>}
     * @memberof HeaderGroup
     */
    headers: Array<ExecutionResultHeader>;
}
/**
 * Filter in form of direct MAQL query.
 * @export
 * @interface InlineFilterDefinition
 */
export interface InlineFilterDefinition {
    /**
     *
     * @type {InlineFilterDefinitionInline}
     * @memberof InlineFilterDefinition
     */
    inline: InlineFilterDefinitionInline;
}
/**
 *
 * @export
 * @interface InlineFilterDefinitionInline
 */
export interface InlineFilterDefinitionInline {
    /**
     * MAQL query representing the filter.
     * @type {string}
     * @memberof InlineFilterDefinitionInline
     */
    filter: string;
    /**
     *
     * @type {string}
     * @memberof InlineFilterDefinitionInline
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof InlineFilterDefinitionInline
     */
    applyOnResult?: boolean;
}
/**
 * Metric defined by the raw MAQL query.
 * @export
 * @interface InlineMeasureDefinition
 */
export interface InlineMeasureDefinition {
    /**
     *
     * @type {InlineMeasureDefinitionInline}
     * @memberof InlineMeasureDefinition
     */
    inline: InlineMeasureDefinitionInline;
}
/**
 *
 * @export
 * @interface InlineMeasureDefinitionInline
 */
export interface InlineMeasureDefinitionInline {
    /**
     * MAQL query defining the metric.
     * @type {string}
     * @memberof InlineMeasureDefinitionInline
     */
    maql: string;
}
/**
 *
 * @export
 * @interface KeyDriversDimension
 */
export interface KeyDriversDimension {
    /**
     *
     * @type {RestApiIdentifier}
     * @memberof KeyDriversDimension
     */
    label: RestApiIdentifier;
    /**
     *
     * @type {string}
     * @memberof KeyDriversDimension
     */
    labelName: string;
    /**
     *
     * @type {RestApiIdentifier}
     * @memberof KeyDriversDimension
     */
    attribute: RestApiIdentifier;
    /**
     *
     * @type {string}
     * @memberof KeyDriversDimension
     */
    attributeName: string;
    /**
     *
     * @type {string}
     * @memberof KeyDriversDimension
     */
    granularity?: KeyDriversDimensionGranularityEnum;
    /**
     *
     * @type {AttributeFormat}
     * @memberof KeyDriversDimension
     */
    format?: AttributeFormat;
    /**
     *
     * @type {string}
     * @memberof KeyDriversDimension
     */
    valueType?: KeyDriversDimensionValueTypeEnum;
}

export const KeyDriversDimensionGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type KeyDriversDimensionGranularityEnum =
    typeof KeyDriversDimensionGranularityEnum[keyof typeof KeyDriversDimensionGranularityEnum];
export const KeyDriversDimensionValueTypeEnum = {
    TEXT: "TEXT",
    HYPERLINK: "HYPERLINK",
    GEO: "GEO",
    GEO_LONGITUDE: "GEO_LONGITUDE",
    GEO_LATITUDE: "GEO_LATITUDE",
    IMAGE: "IMAGE",
} as const;

export type KeyDriversDimensionValueTypeEnum =
    typeof KeyDriversDimensionValueTypeEnum[keyof typeof KeyDriversDimensionValueTypeEnum];

/**
 *
 * @export
 * @interface KeyDriversRequest
 */
export interface KeyDriversRequest {
    /**
     *
     * @type {MeasureItem}
     * @memberof KeyDriversRequest
     */
    metric: MeasureItem;
    /**
     * Additional metrics to be included in the computation, but excluded from the analysis.
     * @type {Array<MeasureItem>}
     * @memberof KeyDriversRequest
     */
    auxMetrics?: Array<MeasureItem>;
    /**
     * Sorting elements - ascending/descending order.
     * @type {string}
     * @memberof KeyDriversRequest
     */
    sortDirection?: KeyDriversRequestSortDirectionEnum;
}

export const KeyDriversRequestSortDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type KeyDriversRequestSortDirectionEnum =
    typeof KeyDriversRequestSortDirectionEnum[keyof typeof KeyDriversRequestSortDirectionEnum];

/**
 *
 * @export
 * @interface KeyDriversResponse
 */
export interface KeyDriversResponse {
    /**
     *
     * @type {Array<KeyDriversDimension>}
     * @memberof KeyDriversResponse
     */
    dimensions: Array<KeyDriversDimension>;
    /**
     *
     * @type {ExecutionLinks}
     * @memberof KeyDriversResponse
     */
    links: ExecutionLinks;
}
/**
 *
 * @export
 * @interface KeyDriversResult
 */
export interface KeyDriversResult {
    /**
     *
     * @type {object}
     * @memberof KeyDriversResult
     */
    data: object;
}
/**
 * @type MeasureDefinition
 * Abstract metric definition type
 * @export
 */
export type MeasureDefinition =
    | ArithmeticMeasureDefinition
    | InlineMeasureDefinition
    | PopMeasureDefinition
    | SimpleMeasureDefinition;

/**
 *
 * @export
 * @interface MeasureExecutionResultHeader
 */
export interface MeasureExecutionResultHeader {
    /**
     *
     * @type {MeasureResultHeader}
     * @memberof MeasureExecutionResultHeader
     */
    measureHeader: MeasureResultHeader;
}
/**
 * Measure group headers
 * @export
 * @interface MeasureGroupHeaders
 */
export interface MeasureGroupHeaders {
    /**
     *
     * @type {Array<MeasureHeader>}
     * @memberof MeasureGroupHeaders
     */
    measureGroupHeaders?: Array<MeasureHeader>;
    /**
     *
     * @type {MeasureHeader}
     * @memberof MeasureGroupHeaders
     */
    first?: MeasureHeader;
    /**
     *
     * @type {MeasureHeader}
     * @memberof MeasureGroupHeaders
     */
    last?: MeasureHeader;
}
/**
 *
 * @export
 * @interface MeasureHeader
 */
export interface MeasureHeader {
    /**
     * Local identifier of the measure this header relates to.
     * @type {string}
     * @memberof MeasureHeader
     */
    localIdentifier: string;
    /**
     * Format to be used to format the measure data.
     * @type {string}
     * @memberof MeasureHeader
     */
    format?: string;
    /**
     * Name of the measure.
     * @type {string}
     * @memberof MeasureHeader
     */
    name?: string;
}
/**
 * Metric is a quantity that is calculated from the data.
 * @export
 * @interface MeasureItem
 */
export interface MeasureItem {
    /**
     * Local identifier of the metric. This can be used to reference the metric in other parts of the execution definition.
     * @type {string}
     * @memberof MeasureItem
     */
    localIdentifier: string;
    /**
     *
     * @type {MeasureDefinition}
     * @memberof MeasureItem
     */
    definition: MeasureDefinition;
}
/**
 * Header containing the information related to metrics.
 * @export
 * @interface MeasureResultHeader
 */
export interface MeasureResultHeader {
    /**
     * Metric index. Starts at 0.
     * @type {number}
     * @memberof MeasureResultHeader
     */
    measureIndex: number;
}
/**
 * @type MeasureValueFilter
 * Abstract filter definition type filtering by the value of the metric.
 * @export
 */
export type MeasureValueFilter = ComparisonMeasureValueFilter | RangeMeasureValueFilter;

/**
 * List of metrics to be used in the new visualization
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * ID of the object
     * @type {string}
     * @memberof Metric
     */
    id: string;
    /**
     * Object type
     * @type {string}
     * @memberof Metric
     */
    type: MetricTypeEnum;
    /**
     * Title of metric.
     * @type {string}
     * @memberof Metric
     */
    title: string;
    /**
     * Agg function. Empty if a stored metric is used.
     * @type {string}
     * @memberof Metric
     */
    aggFunction?: MetricAggFunctionEnum;
}

export const MetricTypeEnum = {
    METRIC: "metric",
    FACT: "fact",
    ATTRIBUTE: "attribute",
} as const;

export type MetricTypeEnum = typeof MetricTypeEnum[keyof typeof MetricTypeEnum];
export const MetricAggFunctionEnum = {
    COUNT: "COUNT",
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    AVG: "AVG",
    MEDIAN: "MEDIAN",
} as const;

export type MetricAggFunctionEnum = typeof MetricAggFunctionEnum[keyof typeof MetricAggFunctionEnum];

/**
 * Filter able to limit element values by label and related selected negated elements.
 * @export
 * @interface NegativeAttributeFilter
 */
export interface NegativeAttributeFilter {
    /**
     *
     * @type {NegativeAttributeFilterNegativeAttributeFilter}
     * @memberof NegativeAttributeFilter
     */
    negativeAttributeFilter: NegativeAttributeFilterNegativeAttributeFilter;
}
/**
 *
 * @export
 * @interface NegativeAttributeFilterNegativeAttributeFilter
 */
export interface NegativeAttributeFilterNegativeAttributeFilter {
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof NegativeAttributeFilterNegativeAttributeFilter
     */
    notIn: AttributeFilterElements;
    /**
     *
     * @type {string}
     * @memberof NegativeAttributeFilterNegativeAttributeFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof NegativeAttributeFilterNegativeAttributeFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmIdentifier}
     * @memberof NegativeAttributeFilterNegativeAttributeFilter
     */
    label: AfmIdentifier;
}
/**
 * Current page description.
 * @export
 * @interface Paging
 */
export interface Paging {
    /**
     * Count of returnable items ignoring paging.
     * @type {number}
     * @memberof Paging
     */
    total: number;
    /**
     * Count of items in this page.
     * @type {number}
     * @memberof Paging
     */
    count: number;
    /**
     * Offset of this page.
     * @type {number}
     * @memberof Paging
     */
    offset: number;
    /**
     * Link to next page, or null if this is last page.
     * @type {string}
     * @memberof Paging
     */
    next?: string;
}
/**
 * Combination of the date data set to use and how many periods ago to calculate the previous period for.
 * @export
 * @interface PopDataset
 */
export interface PopDataset {
    /**
     *
     * @type {AfmObjectIdentifierDataset}
     * @memberof PopDataset
     */
    dataset: AfmObjectIdentifierDataset;
    /**
     * Number of periods ago to calculate the previous period for.
     * @type {number}
     * @memberof PopDataset
     */
    periodsAgo: number;
}
/**
 * Previous period type of metric.
 * @export
 * @interface PopDatasetMeasureDefinition
 */
export interface PopDatasetMeasureDefinition {
    /**
     *
     * @type {PopDatasetMeasureDefinitionPreviousPeriodMeasure}
     * @memberof PopDatasetMeasureDefinition
     */
    previousPeriodMeasure: PopDatasetMeasureDefinitionPreviousPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDatasetMeasureDefinitionPreviousPeriodMeasure
 */
export interface PopDatasetMeasureDefinitionPreviousPeriodMeasure {
    /**
     *
     * @type {AfmLocalIdentifier}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    measureIdentifier: AfmLocalIdentifier;
    /**
     * Specification of which date data sets to use for determining the period to calculate the previous period for.
     * @type {Array<PopDataset>}
     * @memberof PopDatasetMeasureDefinitionPreviousPeriodMeasure
     */
    dateDatasets: Array<PopDataset>;
}
/**
 * Combination of the date attribute to use and how many periods ago to calculate the PoP for.
 * @export
 * @interface PopDate
 */
export interface PopDate {
    /**
     *
     * @type {AfmObjectIdentifierAttribute}
     * @memberof PopDate
     */
    attribute: AfmObjectIdentifierAttribute;
    /**
     * Number of periods ago to calculate the previous period for.
     * @type {number}
     * @memberof PopDate
     */
    periodsAgo: number;
}
/**
 * Period over period type of metric.
 * @export
 * @interface PopDateMeasureDefinition
 */
export interface PopDateMeasureDefinition {
    /**
     *
     * @type {PopDateMeasureDefinitionOverPeriodMeasure}
     * @memberof PopDateMeasureDefinition
     */
    overPeriodMeasure: PopDateMeasureDefinitionOverPeriodMeasure;
}
/**
 *
 * @export
 * @interface PopDateMeasureDefinitionOverPeriodMeasure
 */
export interface PopDateMeasureDefinitionOverPeriodMeasure {
    /**
     *
     * @type {AfmLocalIdentifier}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    measureIdentifier: AfmLocalIdentifier;
    /**
     * Attributes to use for determining the period to calculate the PoP for.
     * @type {Array<PopDate>}
     * @memberof PopDateMeasureDefinitionOverPeriodMeasure
     */
    dateAttributes: Array<PopDate>;
}
/**
 * @type PopMeasureDefinition
 * @export
 */
export type PopMeasureDefinition = PopDatasetMeasureDefinition | PopDateMeasureDefinition;

/**
 * Filter able to limit element values by label and related selected elements.
 * @export
 * @interface PositiveAttributeFilter
 */
export interface PositiveAttributeFilter {
    /**
     *
     * @type {PositiveAttributeFilterPositiveAttributeFilter}
     * @memberof PositiveAttributeFilter
     */
    positiveAttributeFilter: PositiveAttributeFilterPositiveAttributeFilter;
}
/**
 *
 * @export
 * @interface PositiveAttributeFilterPositiveAttributeFilter
 */
export interface PositiveAttributeFilterPositiveAttributeFilter {
    /**
     *
     * @type {AttributeFilterElements}
     * @memberof PositiveAttributeFilterPositiveAttributeFilter
     */
    in: AttributeFilterElements;
    /**
     *
     * @type {string}
     * @memberof PositiveAttributeFilterPositiveAttributeFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof PositiveAttributeFilterPositiveAttributeFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmIdentifier}
     * @memberof PositiveAttributeFilterPositiveAttributeFilter
     */
    label: AfmIdentifier;
}
/**
 * Filter the result by comparing specified metric to given range of values.
 * @export
 * @interface RangeMeasureValueFilter
 */
export interface RangeMeasureValueFilter {
    /**
     *
     * @type {RangeMeasureValueFilterRangeMeasureValueFilter}
     * @memberof RangeMeasureValueFilter
     */
    rangeMeasureValueFilter: RangeMeasureValueFilterRangeMeasureValueFilter;
}
/**
 *
 * @export
 * @interface RangeMeasureValueFilterRangeMeasureValueFilter
 */
export interface RangeMeasureValueFilterRangeMeasureValueFilter {
    /**
     * References to the attributes to be used when filtering.
     * @type {Array<AfmIdentifier>}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    dimensionality?: Array<AfmIdentifier>;
    /**
     * A value that will be substituted for null values in the metric for the comparisons.
     * @type {number}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    treatNullValuesAs?: number;
    /**
     *
     * @type {string}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    operator: RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    from: number;
    /**
     *
     * @type {number}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    to: number;
    /**
     *
     * @type {string}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmIdentifier}
     * @memberof RangeMeasureValueFilterRangeMeasureValueFilter
     */
    measure: AfmIdentifier;
}

export const RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum = {
    BETWEEN: "BETWEEN",
    NOT_BETWEEN: "NOT_BETWEEN",
} as const;

export type RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum =
    typeof RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum[keyof typeof RangeMeasureValueFilterRangeMeasureValueFilterOperatorEnum];

/**
 * Filter the result on top/bottom N values according to given metric(s).
 * @export
 * @interface RankingFilter
 */
export interface RankingFilter {
    /**
     *
     * @type {RankingFilterRankingFilter}
     * @memberof RankingFilter
     */
    rankingFilter: RankingFilterRankingFilter;
}
/**
 *
 * @export
 * @interface RankingFilterRankingFilter
 */
export interface RankingFilterRankingFilter {
    /**
     * References to the attributes to be used when filtering.
     * @type {Array<AfmIdentifier>}
     * @memberof RankingFilterRankingFilter
     */
    dimensionality?: Array<AfmIdentifier>;
    /**
     * References to the metrics to be used when filtering.
     * @type {Array<AfmIdentifier>}
     * @memberof RankingFilterRankingFilter
     */
    measures: Array<AfmIdentifier>;
    /**
     * The type of ranking to use, TOP or BOTTOM.
     * @type {string}
     * @memberof RankingFilterRankingFilter
     */
    operator: RankingFilterRankingFilterOperatorEnum;
    /**
     * Number of top/bottom values to filter.
     * @type {number}
     * @memberof RankingFilterRankingFilter
     */
    value: number;
    /**
     *
     * @type {string}
     * @memberof RankingFilterRankingFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof RankingFilterRankingFilter
     */
    applyOnResult?: boolean;
}

export const RankingFilterRankingFilterOperatorEnum = {
    TOP: "TOP",
    BOTTOM: "BOTTOM",
} as const;

export type RankingFilterRankingFilterOperatorEnum =
    typeof RankingFilterRankingFilterOperatorEnum[keyof typeof RankingFilterRankingFilterOperatorEnum];

/**
 * A date filter specifying a time interval that is relative to the current date. For example, last week, next month, and so on. Field dataset is representing qualifier of date dimension.
 * @export
 * @interface RelativeDateFilter
 */
export interface RelativeDateFilter {
    /**
     *
     * @type {RelativeDateFilterRelativeDateFilter}
     * @memberof RelativeDateFilter
     */
    relativeDateFilter: RelativeDateFilterRelativeDateFilter;
}
/**
 *
 * @export
 * @interface RelativeDateFilterRelativeDateFilter
 */
export interface RelativeDateFilterRelativeDateFilter {
    /**
     * Date granularity specifying particular date attribute in given dimension.
     * @type {string}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    granularity: RelativeDateFilterRelativeDateFilterGranularityEnum;
    /**
     * Start of the filtering interval. Specified by number of periods (with respect to given granularity). Typically negative (historical time interval like -2 for \'2 days/weeks, ... ago\').
     * @type {number}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    from: number;
    /**
     * End of the filtering interval. Specified by number of periods (with respect to given granularity). Value \'O\' is representing current time-interval (current day, week, ...).
     * @type {number}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    to: number;
    /**
     *
     * @type {string}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {boolean}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    applyOnResult?: boolean;
    /**
     *
     * @type {AfmObjectIdentifierDataset}
     * @memberof RelativeDateFilterRelativeDateFilter
     */
    dataset: AfmObjectIdentifierDataset;
}

export const RelativeDateFilterRelativeDateFilterGranularityEnum = {
    MINUTE: "MINUTE",
    HOUR: "HOUR",
    DAY: "DAY",
    WEEK: "WEEK",
    MONTH: "MONTH",
    QUARTER: "QUARTER",
    YEAR: "YEAR",
    MINUTE_OF_HOUR: "MINUTE_OF_HOUR",
    HOUR_OF_DAY: "HOUR_OF_DAY",
    DAY_OF_WEEK: "DAY_OF_WEEK",
    DAY_OF_MONTH: "DAY_OF_MONTH",
    DAY_OF_YEAR: "DAY_OF_YEAR",
    WEEK_OF_YEAR: "WEEK_OF_YEAR",
    MONTH_OF_YEAR: "MONTH_OF_YEAR",
    QUARTER_OF_YEAR: "QUARTER_OF_YEAR",
} as const;

export type RelativeDateFilterRelativeDateFilterGranularityEnum =
    typeof RelativeDateFilterRelativeDateFilterGranularityEnum[keyof typeof RelativeDateFilterRelativeDateFilterGranularityEnum];

/**
 * Object identifier.
 * @export
 * @interface RestApiIdentifier
 */
export interface RestApiIdentifier {
    /**
     *
     * @type {string}
     * @memberof RestApiIdentifier
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof RestApiIdentifier
     */
    type: string;
}
/**
 * All execution result\'s metadata used for calculation including ExecutionResponse
 * @export
 * @interface ResultCacheMetadata
 */
export interface ResultCacheMetadata {
    /**
     *
     * @type {AFM}
     * @memberof ResultCacheMetadata
     */
    afm: AFM;
    /**
     *
     * @type {ExecutionResponse}
     * @memberof ResultCacheMetadata
     */
    executionResponse: ExecutionResponse;
    /**
     *
     * @type {ResultSpec}
     * @memberof ResultCacheMetadata
     */
    resultSpec: ResultSpec;
    /**
     *
     * @type {number}
     * @memberof ResultCacheMetadata
     */
    resultSize: number;
}
/**
 * Single result dimension
 * @export
 * @interface ResultDimension
 */
export interface ResultDimension {
    /**
     *
     * @type {Array<ResultDimensionHeader>}
     * @memberof ResultDimension
     */
    headers: Array<ResultDimensionHeader>;
    /**
     * Local identifier of the dimension.
     * @type {string}
     * @memberof ResultDimension
     */
    localIdentifier: string;
}
/**
 * @type ResultDimensionHeader
 * One of the headers in a result dimension.
 * @export
 */
export type ResultDimensionHeader = AttributeHeader | MeasureGroupHeaders;

/**
 * Specifies how the result data will be formatted (```dimensions```) and which additional data shall be computed (```totals```).
 * @export
 * @interface ResultSpec
 */
export interface ResultSpec {
    /**
     *
     * @type {Array<Dimension>}
     * @memberof ResultSpec
     */
    dimensions: Array<Dimension>;
    /**
     *
     * @type {Array<Total>}
     * @memberof ResultSpec
     */
    totals?: Array<Total>;
}
/**
 * Question -> Use Case routing. May contain final answer is a special use case is not required.
 * @export
 * @interface RouteResult
 */
export interface RouteResult {
    /**
     * Use case where LLM routed based on question.
     * @type {string}
     * @memberof RouteResult
     */
    useCase: RouteResultUseCaseEnum;
    /**
     * Explanation why LLM picked this use case.
     * @type {string}
     * @memberof RouteResult
     */
    reasoning: string;
}

export const RouteResultUseCaseEnum = {
    INVALID: "INVALID",
    GENERAL: "GENERAL",
    SEARCH: "SEARCH",
    CREATE_VISUALIZATION: "CREATE_VISUALIZATION",
    EXTEND_VISUALIZATION: "EXTEND_VISUALIZATION",
    HOWTO: "HOWTO",
} as const;

export type RouteResultUseCaseEnum = typeof RouteResultUseCaseEnum[keyof typeof RouteResultUseCaseEnum];

/**
 *
 * @export
 * @interface SearchRelationshipObject
 */
export interface SearchRelationshipObject {
    /**
     * Source workspace ID. If relationship is dashboard->visualization, this is the workspace where the dashboard is located.
     * @type {string}
     * @memberof SearchRelationshipObject
     */
    sourceWorkspaceId: string;
    /**
     * Source object ID.
     * @type {string}
     * @memberof SearchRelationshipObject
     */
    sourceObjectId: string;
    /**
     * Source object type, e.g. dashboard.
     * @type {string}
     * @memberof SearchRelationshipObject
     */
    sourceObjectType: string;
    /**
     * Source object title.
     * @type {string}
     * @memberof SearchRelationshipObject
     */
    sourceObjectTitle: string;
    /**
     * Target workspace ID. If relationship is dashboard->visualization, this is the workspace where the visualization is located.
     * @type {string}
     * @memberof SearchRelationshipObject
     */
    targetWorkspaceId: string;
    /**
     * Target object ID.
     * @type {string}
     * @memberof SearchRelationshipObject
     */
    targetObjectId: string;
    /**
     * Target object type, e.g. visualization.
     * @type {string}
     * @memberof SearchRelationshipObject
     */
    targetObjectType: string;
    /**
     * Target object title.
     * @type {string}
     * @memberof SearchRelationshipObject
     */
    targetObjectTitle: string;
}
/**
 *
 * @export
 * @interface SearchRequest
 */
export interface SearchRequest {
    /**
     * Keyword/sentence is input for search.
     * @type {string}
     * @memberof SearchRequest
     */
    question: string;
    /**
     * List of object types to search for.
     * @type {Array<string>}
     * @memberof SearchRequest
     */
    objectTypes?: Array<SearchRequestObjectTypesEnum>;
    /**
     * Turn on deep search. If true, content of complex objects will be searched as well, e.g. metrics in visualizations.
     * @type {boolean}
     * @memberof SearchRequest
     */
    deepSearch?: boolean;
    /**
     * Maximum number of results to return. There is a hard limit and the actual number of returned results may be lower than what is requested.
     * @type {number}
     * @memberof SearchRequest
     */
    limit?: number;
    /**
     * Temporary for experiments. Ratio of title score to descriptor score.
     * @type {number}
     * @memberof SearchRequest
     */
    titleToDescriptorRatio?: number;
    /**
     * Score, above which we return found objects. Below this score objects are not relevant.
     * @type {number}
     * @memberof SearchRequest
     */
    relevantScoreThreshold?: number;
}

export const SearchRequestObjectTypesEnum = {
    ATTRIBUTE: "attribute",
    METRIC: "metric",
    FACT: "fact",
    LABEL: "label",
    DATE: "date",
    DATASET: "dataset",
    VISUALIZATION: "visualization",
    DASHBOARD: "dashboard",
} as const;

export type SearchRequestObjectTypesEnum =
    typeof SearchRequestObjectTypesEnum[keyof typeof SearchRequestObjectTypesEnum];

/**
 *
 * @export
 * @interface SearchResult
 */
export interface SearchResult {
    /**
     *
     * @type {Array<SearchResultObject>}
     * @memberof SearchResult
     */
    results: Array<SearchResultObject>;
    /**
     *
     * @type {Array<SearchRelationshipObject>}
     * @memberof SearchResult
     */
    relationships: Array<SearchRelationshipObject>;
    /**
     * If something is not working properly this field will contain explanation.
     * @type {string}
     * @memberof SearchResult
     */
    reasoning: string;
}
/**
 *
 * @export
 * @interface SearchResultObject
 */
export interface SearchResultObject {
    /**
     * Object ID.
     * @type {string}
     * @memberof SearchResultObject
     */
    id: string;
    /**
     * Object type, e.g. dashboard.
     * @type {string}
     * @memberof SearchResultObject
     */
    type: string;
    /**
     * Workspace ID.
     * @type {string}
     * @memberof SearchResultObject
     */
    workspaceId: string;
    /**
     * Object title.
     * @type {string}
     * @memberof SearchResultObject
     */
    title: string;
    /**
     * Object description.
     * @type {string}
     * @memberof SearchResultObject
     */
    description?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SearchResultObject
     */
    tags?: Array<string>;
    /**
     * Timestamp when object was created.
     * @type {string}
     * @memberof SearchResultObject
     */
    createdAt?: string;
    /**
     * Timestamp when object was last modified.
     * @type {string}
     * @memberof SearchResultObject
     */
    modifiedAt?: string;
    /**
     * If the object is visualization, this field defines the type of visualization.
     * @type {string}
     * @memberof SearchResultObject
     */
    visualizationUrl?: string;
    /**
     * Result score calculated by a similarity search algorithm (cosine_distance).
     * @type {number}
     * @memberof SearchResultObject
     */
    score?: number;
    /**
     * Result score for object title.
     * @type {number}
     * @memberof SearchResultObject
     */
    scoreTitle?: number;
    /**
     * Result score for descriptor containing(now) description and tags.
     * @type {number}
     * @memberof SearchResultObject
     */
    scoreDescriptor?: number;
    /**
     * Result score for exact match(id/title). 1/1000. Other scores are multiplied by this.
     * @type {number}
     * @memberof SearchResultObject
     */
    scoreExactMatch?: number;
}
/**
 * Metric defined by referencing a MAQL metric or an LDM fact object with aggregation.
 * @export
 * @interface SimpleMeasureDefinition
 */
export interface SimpleMeasureDefinition {
    /**
     *
     * @type {SimpleMeasureDefinitionMeasure}
     * @memberof SimpleMeasureDefinition
     */
    measure: SimpleMeasureDefinitionMeasure;
}
/**
 *
 * @export
 * @interface SimpleMeasureDefinitionMeasure
 */
export interface SimpleMeasureDefinitionMeasure {
    /**
     *
     * @type {AfmObjectIdentifierCore}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    item: AfmObjectIdentifierCore;
    /**
     * Definition of aggregation type of the metric.
     * @type {string}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    aggregation?: SimpleMeasureDefinitionMeasureAggregationEnum;
    /**
     * If true, compute the percentage of given metric values (broken down by AFM attributes) to the total (not broken down).
     * @type {boolean}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    computeRatio?: boolean;
    /**
     * Metrics can be filtered by attribute filters with the same interface as ones for global AFM. Note that only one DateFilter is allowed.
     * @type {Array<FilterDefinitionForSimpleMeasure>}
     * @memberof SimpleMeasureDefinitionMeasure
     */
    filters?: Array<FilterDefinitionForSimpleMeasure>;
}

export const SimpleMeasureDefinitionMeasureAggregationEnum = {
    SUM: "SUM",
    COUNT: "COUNT",
    AVG: "AVG",
    MIN: "MIN",
    MAX: "MAX",
    MEDIAN: "MEDIAN",
    RUNSUM: "RUNSUM",
    APPROXIMATE_COUNT: "APPROXIMATE_COUNT",
} as const;

export type SimpleMeasureDefinitionMeasureAggregationEnum =
    typeof SimpleMeasureDefinitionMeasureAggregationEnum[keyof typeof SimpleMeasureDefinitionMeasureAggregationEnum];

/**
 *
 * @export
 * @interface SmartFunctionResponse
 */
export interface SmartFunctionResponse {
    /**
     *
     * @type {ExecutionLinks}
     * @memberof SmartFunctionResponse
     */
    links: ExecutionLinks;
}
/**
 * @type SortKey
 * @export
 */
export type SortKey = SortKeyAttribute | SortKeyTotal | SortKeyValue;

/**
 * Sorting rule for sorting by attribute value in current dimension.
 * @export
 * @interface SortKeyAttribute
 */
export interface SortKeyAttribute {
    /**
     *
     * @type {SortKeyAttributeAttribute}
     * @memberof SortKeyAttribute
     */
    attribute: SortKeyAttributeAttribute;
}
/**
 *
 * @export
 * @interface SortKeyAttributeAttribute
 */
export interface SortKeyAttributeAttribute {
    /**
     * Item reference (to \'itemIdentifiers\') referencing, which item should be used for sorting. Only references to attributes are allowed.
     * @type {string}
     * @memberof SortKeyAttributeAttribute
     */
    attributeIdentifier: string;
    /**
     * Mechanism by which this attribute should be sorted. Available options are: - DEFAULT: sorting based on default rules (using sort column if defined, otherwise this label)  - LABEL: sorting by this label values  - ATTRIBUTE: sorting by values of this label\'s attribute (or rather the primary label)  - ATTRIBUTE: sorting by values of this label\'s attribute (or rather the primary label)- AREA: sorting by area (total or subtotal) corresponding to each attribute value. The area is computed by summing up all metric values in all other dimensions.
     * @type {string}
     * @memberof SortKeyAttributeAttribute
     */
    sortType?: SortKeyAttributeAttributeSortTypeEnum;
    /**
     * Sorting elements - ascending/descending order.
     * @type {string}
     * @memberof SortKeyAttributeAttribute
     */
    direction?: SortKeyAttributeAttributeDirectionEnum;
}

export const SortKeyAttributeAttributeSortTypeEnum = {
    DEFAULT: "DEFAULT",
    LABEL: "LABEL",
    ATTRIBUTE: "ATTRIBUTE",
    AREA: "AREA",
} as const;

export type SortKeyAttributeAttributeSortTypeEnum =
    typeof SortKeyAttributeAttributeSortTypeEnum[keyof typeof SortKeyAttributeAttributeSortTypeEnum];
export const SortKeyAttributeAttributeDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type SortKeyAttributeAttributeDirectionEnum =
    typeof SortKeyAttributeAttributeDirectionEnum[keyof typeof SortKeyAttributeAttributeDirectionEnum];

/**
 * Sorting rule for sorting by total value. DataColumnLocators are only required if there is ambiguity. Locator for measureGroup is taken from the metric of the total.
 * @export
 * @interface SortKeyTotal
 */
export interface SortKeyTotal {
    /**
     *
     * @type {SortKeyTotalTotal}
     * @memberof SortKeyTotal
     */
    total: SortKeyTotalTotal;
}
/**
 *
 * @export
 * @interface SortKeyTotalTotal
 */
export interface SortKeyTotalTotal {
    /**
     * Local identifier of the total to sort by.
     * @type {string}
     * @memberof SortKeyTotalTotal
     */
    totalIdentifier: string;
    /**
     *
     * @type {DataColumnLocators}
     * @memberof SortKeyTotalTotal
     */
    dataColumnLocators?: DataColumnLocators;
    /**
     * Sorting elements - ascending/descending order.
     * @type {string}
     * @memberof SortKeyTotalTotal
     */
    direction?: SortKeyTotalTotalDirectionEnum;
}

export const SortKeyTotalTotalDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type SortKeyTotalTotalDirectionEnum =
    typeof SortKeyTotalTotalDirectionEnum[keyof typeof SortKeyTotalTotalDirectionEnum];

/**
 * Sorting rule for sorting by measure value. DataColumnLocators for each dimension opposite to the sorted one must be specified.
 * @export
 * @interface SortKeyValue
 */
export interface SortKeyValue {
    /**
     *
     * @type {SortKeyValueValue}
     * @memberof SortKeyValue
     */
    value: SortKeyValueValue;
}
/**
 *
 * @export
 * @interface SortKeyValueValue
 */
export interface SortKeyValueValue {
    /**
     *
     * @type {DataColumnLocators}
     * @memberof SortKeyValueValue
     */
    dataColumnLocators: DataColumnLocators;
    /**
     * Sorting elements - ascending/descending order.
     * @type {string}
     * @memberof SortKeyValueValue
     */
    direction?: SortKeyValueValueDirectionEnum;
}

export const SortKeyValueValueDirectionEnum = {
    ASC: "ASC",
    DESC: "DESC",
} as const;

export type SortKeyValueValueDirectionEnum =
    typeof SortKeyValueValueDirectionEnum[keyof typeof SortKeyValueValueDirectionEnum];

/**
 * Suggestions for next steps
 * @export
 * @interface Suggestion
 */
export interface Suggestion {
    /**
     * Suggestion query
     * @type {string}
     * @memberof Suggestion
     */
    query: string;
    /**
     * Suggestion button label
     * @type {string}
     * @memberof Suggestion
     */
    label: string;
}
/**
 * Definition of a total. There are two types of totals: grand totals and subtotals. Grand total data will be returned in a separate section of the result structure while subtotals are fully integrated into the main result data. The mechanism for this distinction is automatic and it\'s described in `TotalDimension`
 * @export
 * @interface Total
 */
export interface Total {
    /**
     * Total identification within this request. Used e.g. in sorting by a total.
     * @type {string}
     * @memberof Total
     */
    localIdentifier: string;
    /**
     * Aggregation function to compute the total.
     * @type {string}
     * @memberof Total
     */
    function: TotalFunctionEnum;
    /**
     * The metric for which the total will be computed
     * @type {string}
     * @memberof Total
     */
    metric: string;
    /**
     *
     * @type {Array<TotalDimension>}
     * @memberof Total
     */
    totalDimensions: Array<TotalDimension>;
}

export const TotalFunctionEnum = {
    SUM: "SUM",
    MIN: "MIN",
    MAX: "MAX",
    AVG: "AVG",
    MED: "MED",
    NAT: "NAT",
} as const;

export type TotalFunctionEnum = typeof TotalFunctionEnum[keyof typeof TotalFunctionEnum];

/**
 * A list of dimensions across which the total will be computed. Total headers for only these dimensions will be returned in the result.
 * @export
 * @interface TotalDimension
 */
export interface TotalDimension {
    /**
     * An identifier of a dimension for which the total will be computed.
     * @type {string}
     * @memberof TotalDimension
     */
    dimensionIdentifier: string;
    /**
     * List of dimension items which will be used for total computation. The total is a grand total in this dimension if the list is empty or it includes the first dimension item from the dimension definition, and its data and header will be returned in a separate `ExecutionResultGrandTotal` structure. Otherwise, it is a subtotal and the data will be integrated into the main result.
     * @type {Array<string>}
     * @memberof TotalDimension
     */
    totalDimensionItems: Array<string>;
}
/**
 *
 * @export
 * @interface TotalExecutionResultHeader
 */
export interface TotalExecutionResultHeader {
    /**
     *
     * @type {TotalResultHeader}
     * @memberof TotalExecutionResultHeader
     */
    totalHeader: TotalResultHeader;
}
/**
 * Header containing the information related to a subtotal.
 * @export
 * @interface TotalResultHeader
 */
export interface TotalResultHeader {
    /**
     *
     * @type {string}
     * @memberof TotalResultHeader
     */
    function: string;
}
/**
 * User context, which can affect the behavior of the underlying AI features.
 * @export
 * @interface UserContext
 */
export interface UserContext {
    /**
     *
     * @type {ActiveObjectIdentification}
     * @memberof UserContext
     */
    activeObject: ActiveObjectIdentification;
}
/**
 *
 * @export
 * @interface ValidateByItem
 */
export interface ValidateByItem {
    /**
     * Specifies entity used for valid elements computation.
     * @type {string}
     * @memberof ValidateByItem
     */
    id: string;
    /**
     * Specifies entity type which could be label, attribute, fact, or metric.
     * @type {string}
     * @memberof ValidateByItem
     */
    type: string;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChat: async (
            workspaceId: string,
            chatRequest: ChatRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChat", "workspaceId", workspaceId);
            // verify required parameter 'chatRequest' is not null or undefined
            assertParamExists("aiChat", "chatRequest", chatRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chat`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
                : chatRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {string} workspaceId Workspace identifier
         * @param {ChatHistoryRequest} chatHistoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatHistory: async (
            workspaceId: string,
            chatHistoryRequest: ChatHistoryRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChatHistory", "workspaceId", workspaceId);
            // verify required parameter 'chatHistoryRequest' is not null or undefined
            assertParamExists("aiChatHistory", "chatHistoryRequest", chatHistoryRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatHistory`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatHistoryRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatHistoryRequest !== undefined ? chatHistoryRequest : {})
                : chatHistoryRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatStream: async (
            workspaceId: string,
            chatRequest: ChatRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChatStream", "workspaceId", workspaceId);
            // verify required parameter 'chatRequest' is not null or undefined
            assertParamExists("aiChatStream", "chatRequest", chatRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatStream`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
                : chatRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {string} workspaceId Workspace identifier
         * @param {SearchRequest} searchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiSearch: async (
            workspaceId: string,
            searchRequest: SearchRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiSearch", "workspaceId", workspaceId);
            // verify required parameter 'searchRequest' is not null or undefined
            assertParamExists("aiSearch", "searchRequest", searchRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/search`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof searchRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(searchRequest !== undefined ? searchRequest : {})
                : searchRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {AnomalyDetectionRequest} anomalyDetectionRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetection: async (
            workspaceId: string,
            resultId: string,
            anomalyDetectionRequest: AnomalyDetectionRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("anomalyDetection", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("anomalyDetection", "resultId", resultId);
            // verify required parameter 'anomalyDetectionRequest' is not null or undefined
            assertParamExists("anomalyDetection", "anomalyDetectionRequest", anomalyDetectionRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof anomalyDetectionRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(anomalyDetectionRequest !== undefined ? anomalyDetectionRequest : {})
                : anomalyDetectionRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetectionResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("anomalyDetectionResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("anomalyDetectionResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ClusteringRequest} clusteringRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustering: async (
            workspaceId: string,
            resultId: string,
            clusteringRequest: ClusteringRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("clustering", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("clustering", "resultId", resultId);
            // verify required parameter 'clusteringRequest' is not null or undefined
            assertParamExists("clustering", "clusteringRequest", clusteringRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof clusteringRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(clusteringRequest !== undefined ? clusteringRequest : {})
                : clusteringRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusteringResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("clusteringResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("clusteringResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: async (
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeLabelElementsPost", "workspaceId", workspaceId);
            // verify required parameter 'elementsRequest' is not null or undefined
            assertParamExists("computeLabelElementsPost", "elementsRequest", elementsRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof elementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
                : elementsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeReport", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("computeReport", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants: async (
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidDescendants", "workspaceId", workspaceId);
            // verify required parameter 'afmValidDescendantsQuery' is not null or undefined
            assertParamExists(
                "computeValidDescendants",
                "afmValidDescendantsQuery",
                afmValidDescendantsQuery,
            );
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidDescendants`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidDescendantsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidDescendantsQuery !== undefined ? afmValidDescendantsQuery : {})
                : afmValidDescendantsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: async (
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidObjects", "workspaceId", workspaceId);
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            assertParamExists("computeValidObjects", "afmValidObjectsQuery", afmValidObjectsQuery);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS",
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("explainAFM", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("explainAFM", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (explainType !== undefined) {
                localVarQueryParameter["explainType"] = explainType;
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast: async (
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecast", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecast", "resultId", resultId);
            // verify required parameter 'forecastRequest' is not null or undefined
            assertParamExists("forecast", "forecastRequest", forecastRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof forecastRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(forecastRequest !== undefined ? forecastRequest : {})
                : forecastRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecastResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecastResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {string} workspaceId Workspace identifier
         * @param {KeyDriversRequest} keyDriversRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysis: async (
            workspaceId: string,
            keyDriversRequest: KeyDriversRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("keyDriverAnalysis", "workspaceId", workspaceId);
            // verify required parameter 'keyDriversRequest' is not null or undefined
            assertParamExists("keyDriverAnalysis", "keyDriversRequest", keyDriversRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof keyDriversRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(keyDriversRequest !== undefined ? keyDriversRequest : {})
                : keyDriversRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysisResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("keyDriverAnalysisResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("keyDriverAnalysisResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata: async (
            workspaceId: string,
            resultId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}/metadata`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: async (
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }

            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }

            if (excludedTotalDimensions) {
                localVarQueryParameter["excludedTotalDimensions"] = excludedTotalDimensions.join(
                    COLLECTION_FORMATS.csv,
                );
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChat(
            workspaceId: string,
            chatRequest: ChatRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChat(
                workspaceId,
                chatRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {string} workspaceId Workspace identifier
         * @param {ChatHistoryRequest} chatHistoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatHistory(
            workspaceId: string,
            chatHistoryRequest: ChatHistoryRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatHistoryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatHistory(
                workspaceId,
                chatHistoryRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatStream(
            workspaceId: string,
            chatRequest: ChatRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatStream(
                workspaceId,
                chatRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {string} workspaceId Workspace identifier
         * @param {SearchRequest} searchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiSearch(
            workspaceId: string,
            searchRequest: SearchRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiSearch(
                workspaceId,
                searchRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {AnomalyDetectionRequest} anomalyDetectionRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async anomalyDetection(
            workspaceId: string,
            resultId: string,
            anomalyDetectionRequest: AnomalyDetectionRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.anomalyDetection(
                workspaceId,
                resultId,
                anomalyDetectionRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async anomalyDetectionResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnomalyDetectionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.anomalyDetectionResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ClusteringRequest} clusteringRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clustering(
            workspaceId: string,
            resultId: string,
            clusteringRequest: ClusteringRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clustering(
                workspaceId,
                resultId,
                clusteringRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusteringResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusteringResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusteringResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeLabelElementsPost(
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeLabelElementsPost(
                workspaceId,
                elementsRequest,
                offset,
                limit,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeReport(
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmExecutionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeReport(
                workspaceId,
                afmExecution,
                skipCache,
                timestamp,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidDescendants(
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidDescendantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidDescendants(
                workspaceId,
                afmValidDescendantsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidObjects(
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidObjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidObjects(
                workspaceId,
                afmValidObjectsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explainAFM(
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS",
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explainAFM(
                workspaceId,
                afmExecution,
                explainType,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecast(
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecast(
                workspaceId,
                resultId,
                forecastRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecastResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForecastResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecastResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {string} workspaceId Workspace identifier
         * @param {KeyDriversRequest} keyDriversRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyDriverAnalysis(
            workspaceId: string,
            keyDriversRequest: KeyDriversRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDriversResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyDriverAnalysis(
                workspaceId,
                keyDriversRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyDriverAnalysisResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDriversResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyDriverAnalysisResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveExecutionMetadata(
            workspaceId: string,
            resultId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultCacheMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveExecutionMetadata(
                workspaceId,
                resultId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveResult(
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveResult(
                workspaceId,
                resultId,
                offset,
                limit,
                excludedTotalDimensions,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {ActionsApiAiChatRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChat(
            requestParameters: ActionsApiAiChatRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ChatResult> {
            return localVarFp
                .aiChat(requestParameters.workspaceId, requestParameters.chatRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {ActionsApiAiChatHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatHistory(
            requestParameters: ActionsApiAiChatHistoryRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ChatHistoryResult> {
            return localVarFp
                .aiChatHistory(requestParameters.workspaceId, requestParameters.chatHistoryRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {ActionsApiAiChatStreamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatStream(
            requestParameters: ActionsApiAiChatStreamRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<object>> {
            return localVarFp
                .aiChatStream(requestParameters.workspaceId, requestParameters.chatRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {ActionsApiAiSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiSearch(
            requestParameters: ActionsApiAiSearchRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SearchResult> {
            return localVarFp
                .aiSearch(requestParameters.workspaceId, requestParameters.searchRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {ActionsApiAnomalyDetectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetection(
            requestParameters: ActionsApiAnomalyDetectionRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .anomalyDetection(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.anomalyDetectionRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {ActionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetectionResult(
            requestParameters: ActionsApiAnomalyDetectionResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AnomalyDetectionResult> {
            return localVarFp
                .anomalyDetectionResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {ActionsApiClusteringRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustering(
            requestParameters: ActionsApiClusteringRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .clustering(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.clusteringRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {ActionsApiClusteringResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusteringResult(
            requestParameters: ActionsApiClusteringResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ClusteringResult> {
            return localVarFp
                .clusteringResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(
            requestParameters: ActionsApiComputeLabelElementsPostRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ElementsResponse> {
            return localVarFp
                .computeLabelElementsPost(
                    requestParameters.workspaceId,
                    requestParameters.elementsRequest,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            requestParameters: ActionsApiComputeReportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmExecutionResponse> {
            return localVarFp
                .computeReport(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.skipCache,
                    requestParameters.timestamp,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants(
            requestParameters: ActionsApiComputeValidDescendantsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidDescendantsResponse> {
            return localVarFp
                .computeValidDescendants(
                    requestParameters.workspaceId,
                    requestParameters.afmValidDescendantsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            requestParameters: ActionsApiComputeValidObjectsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidObjectsResponse> {
            return localVarFp
                .computeValidObjects(
                    requestParameters.workspaceId,
                    requestParameters.afmValidObjectsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(
            requestParameters: ActionsApiExplainAFMRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<any> {
            return localVarFp
                .explainAFM(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.explainType,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {ActionsApiForecastRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast(
            requestParameters: ActionsApiForecastRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .forecast(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.forecastRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult(
            requestParameters: ActionsApiForecastResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ForecastResult> {
            return localVarFp
                .forecastResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {ActionsApiKeyDriverAnalysisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysis(
            requestParameters: ActionsApiKeyDriverAnalysisRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<KeyDriversResponse> {
            return localVarFp
                .keyDriverAnalysis(
                    requestParameters.workspaceId,
                    requestParameters.keyDriversRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {ActionsApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysisResult(
            requestParameters: ActionsApiKeyDriverAnalysisResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<KeyDriversResult> {
            return localVarFp
                .keyDriverAnalysisResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata(
            requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ResultCacheMetadata> {
            return localVarFp
                .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            requestParameters: ActionsApiRetrieveResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExecutionResult> {
            return localVarFp
                .retrieveResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.excludedTotalDimensions,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiChat(
        requestParameters: ActionsApiAiChatRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatResult>;

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {ActionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiChatHistory(
        requestParameters: ActionsApiAiChatHistoryRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatHistoryResult>;

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiChatStream(
        requestParameters: ActionsApiAiChatStreamRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<object>>;

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {ActionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    aiSearch(
        requestParameters: ActionsApiAiSearchRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SearchResult>;

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {ActionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    anomalyDetection(
        requestParameters: ActionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {ActionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    anomalyDetectionResult(
        requestParameters: ActionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnomalyDetectionResult>;

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {ActionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    clustering(
        requestParameters: ActionsApiClusteringRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {ActionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    clusteringResult(
        requestParameters: ActionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ClusteringResult>;

    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeLabelElementsPost(
        requestParameters: ActionsApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ElementsResponse>;

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeReport(
        requestParameters: ActionsApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmExecutionResponse>;

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeValidDescendants(
        requestParameters: ActionsApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidDescendantsResponse>;

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    computeValidObjects(
        requestParameters: ActionsApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidObjectsResponse>;

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    explainAFM(
        requestParameters: ActionsApiExplainAFMRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<any>;

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {ActionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    forecast(
        requestParameters: ActionsApiForecastRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    forecastResult(
        requestParameters: ActionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ForecastResult>;

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ActionsApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    keyDriverAnalysis(
        requestParameters: ActionsApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResponse>;

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ActionsApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    keyDriverAnalysisResult(
        requestParameters: ActionsApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResult>;

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    retrieveExecutionMetadata(
        requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResultCacheMetadata>;

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    retrieveResult(
        requestParameters: ActionsApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExecutionResult>;
}

/**
 * Request parameters for aiChat operation in ActionsApi.
 * @export
 * @interface ActionsApiAiChatRequest
 */
export interface ActionsApiAiChatRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiChat
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof ActionsApiAiChat
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiChatHistory operation in ActionsApi.
 * @export
 * @interface ActionsApiAiChatHistoryRequest
 */
export interface ActionsApiAiChatHistoryRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiChatHistory
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatHistoryRequest}
     * @memberof ActionsApiAiChatHistory
     */
    readonly chatHistoryRequest: ChatHistoryRequest;
}

/**
 * Request parameters for aiChatStream operation in ActionsApi.
 * @export
 * @interface ActionsApiAiChatStreamRequest
 */
export interface ActionsApiAiChatStreamRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiChatStream
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof ActionsApiAiChatStream
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiSearch operation in ActionsApi.
 * @export
 * @interface ActionsApiAiSearchRequest
 */
export interface ActionsApiAiSearchRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAiSearch
     */
    readonly workspaceId: string;

    /**
     *
     * @type {SearchRequest}
     * @memberof ActionsApiAiSearch
     */
    readonly searchRequest: SearchRequest;
}

/**
 * Request parameters for anomalyDetection operation in ActionsApi.
 * @export
 * @interface ActionsApiAnomalyDetectionRequest
 */
export interface ActionsApiAnomalyDetectionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly resultId: string;

    /**
     *
     * @type {AnomalyDetectionRequest}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly anomalyDetectionRequest: AnomalyDetectionRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiAnomalyDetection
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for anomalyDetectionResult operation in ActionsApi.
 * @export
 * @interface ActionsApiAnomalyDetectionResultRequest
 */
export interface ActionsApiAnomalyDetectionResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiAnomalyDetectionResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for clustering operation in ActionsApi.
 * @export
 * @interface ActionsApiClusteringRequest
 */
export interface ActionsApiClusteringRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiClustering
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof ActionsApiClustering
     */
    readonly resultId: string;

    /**
     *
     * @type {ClusteringRequest}
     * @memberof ActionsApiClustering
     */
    readonly clusteringRequest: ClusteringRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiClustering
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for clusteringResult operation in ActionsApi.
 * @export
 * @interface ActionsApiClusteringResultRequest
 */
export interface ActionsApiClusteringResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiClusteringResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiClusteringResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiClusteringResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiClusteringResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for computeLabelElementsPost operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeLabelElementsPostRequest
 */
export interface ActionsApiComputeLabelElementsPostRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ElementsRequest}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly elementsRequest: ElementsRequest;

    /**
     * Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly offset?: number;

    /**
     * Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly limit?: number;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiComputeLabelElementsPost
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for computeReport operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeReportRequest
 */
export interface ActionsApiComputeReportRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeReport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ActionsApiComputeReport
     */
    readonly afmExecution: AfmExecution;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiComputeReport
     */
    readonly skipCache?: boolean;

    /**
     *
     * @type {string}
     * @memberof ActionsApiComputeReport
     */
    readonly timestamp?: string;
}

/**
 * Request parameters for computeValidDescendants operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeValidDescendantsRequest
 */
export interface ActionsApiComputeValidDescendantsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeValidDescendants
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidDescendantsQuery}
     * @memberof ActionsApiComputeValidDescendants
     */
    readonly afmValidDescendantsQuery: AfmValidDescendantsQuery;
}

/**
 * Request parameters for computeValidObjects operation in ActionsApi.
 * @export
 * @interface ActionsApiComputeValidObjectsRequest
 */
export interface ActionsApiComputeValidObjectsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiComputeValidObjects
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidObjectsQuery}
     * @memberof ActionsApiComputeValidObjects
     */
    readonly afmValidObjectsQuery: AfmValidObjectsQuery;
}

/**
 * Request parameters for explainAFM operation in ActionsApi.
 * @export
 * @interface ActionsApiExplainAFMRequest
 */
export interface ActionsApiExplainAFMRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiExplainAFM
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ActionsApiExplainAFM
     */
    readonly afmExecution: AfmExecution;

    /**
     * Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
     * @type {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'}
     * @memberof ActionsApiExplainAFM
     */
    readonly explainType?:
        | "MAQL"
        | "GRPC_MODEL"
        | "GRPC_MODEL_SVG"
        | "WDF"
        | "QT"
        | "QT_SVG"
        | "OPT_QT"
        | "OPT_QT_SVG"
        | "SQL"
        | "SETTINGS";
}

/**
 * Request parameters for forecast operation in ActionsApi.
 * @export
 * @interface ActionsApiForecastRequest
 */
export interface ActionsApiForecastRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiForecast
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof ActionsApiForecast
     */
    readonly resultId: string;

    /**
     *
     * @type {ForecastRequest}
     * @memberof ActionsApiForecast
     */
    readonly forecastRequest: ForecastRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiForecast
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for forecastResult operation in ActionsApi.
 * @export
 * @interface ActionsApiForecastResultRequest
 */
export interface ActionsApiForecastResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiForecastResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiForecastResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiForecastResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiForecastResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for keyDriverAnalysis operation in ActionsApi.
 * @export
 * @interface ActionsApiKeyDriverAnalysisRequest
 */
export interface ActionsApiKeyDriverAnalysisRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiKeyDriverAnalysis
     */
    readonly workspaceId: string;

    /**
     *
     * @type {KeyDriversRequest}
     * @memberof ActionsApiKeyDriverAnalysis
     */
    readonly keyDriversRequest: KeyDriversRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ActionsApiKeyDriverAnalysis
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for keyDriverAnalysisResult operation in ActionsApi.
 * @export
 * @interface ActionsApiKeyDriverAnalysisResultRequest
 */
export interface ActionsApiKeyDriverAnalysisResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ActionsApiKeyDriverAnalysisResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for retrieveExecutionMetadata operation in ActionsApi.
 * @export
 * @interface ActionsApiRetrieveExecutionMetadataRequest
 */
export interface ActionsApiRetrieveExecutionMetadataRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiRetrieveExecutionMetadata
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiRetrieveExecutionMetadata
     */
    readonly resultId: string;
}

/**
 * Request parameters for retrieveResult operation in ActionsApi.
 * @export
 * @interface ActionsApiRetrieveResultRequest
 */
export interface ActionsApiRetrieveResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ActionsApiRetrieveResult
     */
    readonly resultId: string;

    /**
     * Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly offset?: Array<number>;

    /**
     * Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly limit?: Array<number>;

    /**
     * Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
     * @type {Array<string>}
     * @memberof ActionsApiRetrieveResult
     */
    readonly excludedTotalDimensions?: Array<string>;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiChat(requestParameters: ActionsApiAiChatRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .aiChat(requestParameters.workspaceId, requestParameters.chatRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {ActionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiChatHistory(requestParameters: ActionsApiAiChatHistoryRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .aiChatHistory(requestParameters.workspaceId, requestParameters.chatHistoryRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {ActionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiChatStream(requestParameters: ActionsApiAiChatStreamRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .aiChatStream(requestParameters.workspaceId, requestParameters.chatRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {ActionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public aiSearch(requestParameters: ActionsApiAiSearchRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .aiSearch(requestParameters.workspaceId, requestParameters.searchRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {ActionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public anomalyDetection(
        requestParameters: ActionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .anomalyDetection(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.anomalyDetectionRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {ActionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public anomalyDetectionResult(
        requestParameters: ActionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .anomalyDetectionResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {ActionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public clustering(requestParameters: ActionsApiClusteringRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .clustering(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.clusteringRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {ActionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public clusteringResult(
        requestParameters: ActionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .clusteringResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ActionsApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeLabelElementsPost(
        requestParameters: ActionsApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .computeLabelElementsPost(
                requestParameters.workspaceId,
                requestParameters.elementsRequest,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ActionsApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeReport(requestParameters: ActionsApiComputeReportRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .computeReport(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.skipCache,
                requestParameters.timestamp,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ActionsApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeValidDescendants(
        requestParameters: ActionsApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .computeValidDescendants(
                requestParameters.workspaceId,
                requestParameters.afmValidDescendantsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ActionsApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public computeValidObjects(
        requestParameters: ActionsApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .computeValidObjects(
                requestParameters.workspaceId,
                requestParameters.afmValidObjectsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ActionsApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public explainAFM(requestParameters: ActionsApiExplainAFMRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .explainAFM(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.explainType,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {ActionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public forecast(requestParameters: ActionsApiForecastRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .forecast(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.forecastRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {ActionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public forecastResult(requestParameters: ActionsApiForecastResultRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .forecastResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ActionsApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public keyDriverAnalysis(
        requestParameters: ActionsApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .keyDriverAnalysis(
                requestParameters.workspaceId,
                requestParameters.keyDriversRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ActionsApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public keyDriverAnalysisResult(
        requestParameters: ActionsApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .keyDriverAnalysisResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ActionsApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public retrieveExecutionMetadata(
        requestParameters: ActionsApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ActionsApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public retrieveResult(requestParameters: ActionsApiRetrieveResultRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .retrieveResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.excludedTotalDimensions,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ComputationApi - axios parameter creator
 * @export
 */
export const ComputationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: async (
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeLabelElementsPost", "workspaceId", workspaceId);
            // verify required parameter 'elementsRequest' is not null or undefined
            assertParamExists("computeLabelElementsPost", "elementsRequest", elementsRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/collectLabelElements`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof elementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
                : elementsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeReport", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("computeReport", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants: async (
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidDescendants", "workspaceId", workspaceId);
            // verify required parameter 'afmValidDescendantsQuery' is not null or undefined
            assertParamExists(
                "computeValidDescendants",
                "afmValidDescendantsQuery",
                afmValidDescendantsQuery,
            );
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidDescendants`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidDescendantsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidDescendantsQuery !== undefined ? afmValidDescendantsQuery : {})
                : afmValidDescendantsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: async (
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("computeValidObjects", "workspaceId", workspaceId);
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            assertParamExists("computeValidObjects", "afmValidObjectsQuery", afmValidObjectsQuery);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: async (
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS",
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("explainAFM", "workspaceId", workspaceId);
            // verify required parameter 'afmExecution' is not null or undefined
            assertParamExists("explainAFM", "afmExecution", afmExecution);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/execution/afm/explain`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (explainType !== undefined) {
                localVarQueryParameter["explainType"] = explainType;
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {string} workspaceId Workspace identifier
         * @param {KeyDriversRequest} keyDriversRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysis: async (
            workspaceId: string,
            keyDriversRequest: KeyDriversRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("keyDriverAnalysis", "workspaceId", workspaceId);
            // verify required parameter 'keyDriversRequest' is not null or undefined
            assertParamExists("keyDriverAnalysis", "keyDriversRequest", keyDriversRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers`.replace(
                    `{${"workspaceId"}}`,
                    encodeURIComponent(String(workspaceId)),
                );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof keyDriversRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(keyDriversRequest !== undefined ? keyDriversRequest : {})
                : keyDriversRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysisResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("keyDriverAnalysisResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("keyDriverAnalysisResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/computeKeyDrivers/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata: async (
            workspaceId: string,
            resultId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveExecutionMetadata", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}/metadata`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: async (
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("retrieveResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("retrieveResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }

            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }

            if (excludedTotalDimensions) {
                localVarQueryParameter["excludedTotalDimensions"] = excludedTotalDimensions.join(
                    COLLECTION_FORMATS.csv,
                );
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ComputationApi - functional programming interface
 * @export
 */
export const ComputationApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ComputationApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {number} [limit] Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeLabelElementsPost(
            workspaceId: string,
            elementsRequest: ElementsRequest,
            offset?: number,
            limit?: number,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ElementsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeLabelElementsPost(
                workspaceId,
                elementsRequest,
                offset,
                limit,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeReport(
            workspaceId: string,
            afmExecution: AfmExecution,
            skipCache?: boolean,
            timestamp?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmExecutionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeReport(
                workspaceId,
                afmExecution,
                skipCache,
                timestamp,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidDescendantsQuery} afmValidDescendantsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidDescendants(
            workspaceId: string,
            afmValidDescendantsQuery: AfmValidDescendantsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidDescendantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidDescendants(
                workspaceId,
                afmValidDescendantsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeValidObjects(
            workspaceId: string,
            afmValidObjectsQuery: AfmValidObjectsQuery,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AfmValidObjectsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeValidObjects(
                workspaceId,
                afmValidObjectsQuery,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'} [explainType] Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async explainAFM(
            workspaceId: string,
            afmExecution: AfmExecution,
            explainType?:
                | "MAQL"
                | "GRPC_MODEL"
                | "GRPC_MODEL_SVG"
                | "WDF"
                | "QT"
                | "QT_SVG"
                | "OPT_QT"
                | "OPT_QT_SVG"
                | "SQL"
                | "SETTINGS",
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.explainAFM(
                workspaceId,
                afmExecution,
                explainType,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {string} workspaceId Workspace identifier
         * @param {KeyDriversRequest} keyDriversRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyDriverAnalysis(
            workspaceId: string,
            keyDriversRequest: KeyDriversRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDriversResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyDriverAnalysis(
                workspaceId,
                keyDriversRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keyDriverAnalysisResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeyDriversResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keyDriverAnalysisResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveExecutionMetadata(
            workspaceId: string,
            resultId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultCacheMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveExecutionMetadata(
                workspaceId,
                resultId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {Array<string>} [excludedTotalDimensions] Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveResult(
            workspaceId: string,
            resultId: string,
            offset?: Array<number>,
            limit?: Array<number>,
            excludedTotalDimensions?: Array<string>,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecutionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveResult(
                workspaceId,
                resultId,
                offset,
                limit,
                excludedTotalDimensions,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ComputationApi - factory interface
 * @export
 */
export const ComputationApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ComputationApiFp(configuration);
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
         * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost(
            requestParameters: ComputationApiComputeLabelElementsPostRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ElementsResponse> {
            return localVarFp
                .computeLabelElementsPost(
                    requestParameters.workspaceId,
                    requestParameters.elementsRequest,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport(
            requestParameters: ComputationApiComputeReportRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmExecutionResponse> {
            return localVarFp
                .computeReport(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.skipCache,
                    requestParameters.timestamp,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
         * @summary (BETA) Valid descendants
         * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidDescendants(
            requestParameters: ComputationApiComputeValidDescendantsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidDescendantsResponse> {
            return localVarFp
                .computeValidDescendants(
                    requestParameters.workspaceId,
                    requestParameters.afmValidDescendantsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects(
            requestParameters: ComputationApiComputeValidObjectsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AfmValidObjectsResponse> {
            return localVarFp
                .computeValidObjects(
                    requestParameters.workspaceId,
                    requestParameters.afmValidObjectsQuery,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM.
         * @summary AFM explain resource.
         * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM(
            requestParameters: ComputationApiExplainAFMRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<any> {
            return localVarFp
                .explainAFM(
                    requestParameters.workspaceId,
                    requestParameters.afmExecution,
                    requestParameters.explainType,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
         * @summary (EXPERIMENTAL) Compute key driver analysis
         * @param {ComputationApiKeyDriverAnalysisRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysis(
            requestParameters: ComputationApiKeyDriverAnalysisRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<KeyDriversResponse> {
            return localVarFp
                .keyDriverAnalysis(
                    requestParameters.workspaceId,
                    requestParameters.keyDriversRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets key driver analysis.
         * @summary (EXPERIMENTAL) Get key driver analysis result
         * @param {ComputationApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keyDriverAnalysisResult(
            requestParameters: ComputationApiKeyDriverAnalysisResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<KeyDriversResult> {
            return localVarFp
                .keyDriverAnalysisResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
         * @summary Get a single execution result\'s metadata.
         * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExecutionMetadata(
            requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ResultCacheMetadata> {
            return localVarFp
                .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult(
            requestParameters: ComputationApiRetrieveResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ExecutionResult> {
            return localVarFp
                .retrieveResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    requestParameters.excludedTotalDimensions,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComputationApi - interface
 * @export
 * @interface ComputationApi
 */
export interface ComputationApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeLabelElementsPost(
        requestParameters: ComputationApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ElementsResponse>;

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeReport(
        requestParameters: ComputationApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmExecutionResponse>;

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeValidDescendants(
        requestParameters: ComputationApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidDescendantsResponse>;

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    computeValidObjects(
        requestParameters: ComputationApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AfmValidObjectsResponse>;

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    explainAFM(
        requestParameters: ComputationApiExplainAFMRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<any>;

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ComputationApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    keyDriverAnalysis(
        requestParameters: ComputationApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResponse>;

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ComputationApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    keyDriverAnalysisResult(
        requestParameters: ComputationApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<KeyDriversResult>;

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    retrieveExecutionMetadata(
        requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ResultCacheMetadata>;

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    retrieveResult(
        requestParameters: ComputationApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ExecutionResult>;
}

/**
 * Request parameters for computeLabelElementsPost operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeLabelElementsPostRequest
 */
export interface ComputationApiComputeLabelElementsPostRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ElementsRequest}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly elementsRequest: ElementsRequest;

    /**
     * Request page with this offset. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly offset?: number;

    /**
     * Return only this number of items. Must be positive integer. The API is limited to the maximum of 10000 items. Therefore this parameter is limited to this number as well.
     * @type {number}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly limit?: number;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiComputeLabelElementsPost
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for computeReport operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeReportRequest
 */
export interface ComputationApiComputeReportRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeReport
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ComputationApiComputeReport
     */
    readonly afmExecution: AfmExecution;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiComputeReport
     */
    readonly skipCache?: boolean;

    /**
     *
     * @type {string}
     * @memberof ComputationApiComputeReport
     */
    readonly timestamp?: string;
}

/**
 * Request parameters for computeValidDescendants operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeValidDescendantsRequest
 */
export interface ComputationApiComputeValidDescendantsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeValidDescendants
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidDescendantsQuery}
     * @memberof ComputationApiComputeValidDescendants
     */
    readonly afmValidDescendantsQuery: AfmValidDescendantsQuery;
}

/**
 * Request parameters for computeValidObjects operation in ComputationApi.
 * @export
 * @interface ComputationApiComputeValidObjectsRequest
 */
export interface ComputationApiComputeValidObjectsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiComputeValidObjects
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmValidObjectsQuery}
     * @memberof ComputationApiComputeValidObjects
     */
    readonly afmValidObjectsQuery: AfmValidObjectsQuery;
}

/**
 * Request parameters for explainAFM operation in ComputationApi.
 * @export
 * @interface ComputationApiExplainAFMRequest
 */
export interface ComputationApiExplainAFMRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiExplainAFM
     */
    readonly workspaceId: string;

    /**
     *
     * @type {AfmExecution}
     * @memberof ComputationApiExplainAFM
     */
    readonly afmExecution: AfmExecution;

    /**
     * Requested explain type. If not specified all types are bundled in a ZIP archive.  &#x60;MAQL&#x60; - MAQL Abstract Syntax Tree, execution dimensions and related info  &#x60;GRPC_MODEL&#x60; - Datasets used in execution  &#x60;GRPC_MODEL_SVG&#x60; - Generated SVG image of the datasets  &#x60;WDF&#x60; - Workspace data filters in execution workspace context  &#x60;QT&#x60; - Query Tree, created from MAQL AST using Logical Data Model,  contains all information needed to generate SQL  &#x60;QT_SVG&#x60; - Generated SVG image of the Query Tree  &#x60;OPT_QT&#x60; - Optimized Query Tree  &#x60;OPT_QT_SVG&#x60; - Generated SVG image of the Optimized Query Tree  &#x60;SQL&#x60; - Final SQL to be executed  &#x60;SETTINGS&#x60; - Settings used to execute explain request
     * @type {'MAQL' | 'GRPC_MODEL' | 'GRPC_MODEL_SVG' | 'WDF' | 'QT' | 'QT_SVG' | 'OPT_QT' | 'OPT_QT_SVG' | 'SQL' | 'SETTINGS'}
     * @memberof ComputationApiExplainAFM
     */
    readonly explainType?:
        | "MAQL"
        | "GRPC_MODEL"
        | "GRPC_MODEL_SVG"
        | "WDF"
        | "QT"
        | "QT_SVG"
        | "OPT_QT"
        | "OPT_QT_SVG"
        | "SQL"
        | "SETTINGS";
}

/**
 * Request parameters for keyDriverAnalysis operation in ComputationApi.
 * @export
 * @interface ComputationApiKeyDriverAnalysisRequest
 */
export interface ComputationApiKeyDriverAnalysisRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiKeyDriverAnalysis
     */
    readonly workspaceId: string;

    /**
     *
     * @type {KeyDriversRequest}
     * @memberof ComputationApiKeyDriverAnalysis
     */
    readonly keyDriversRequest: KeyDriversRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof ComputationApiKeyDriverAnalysis
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for keyDriverAnalysisResult operation in ComputationApi.
 * @export
 * @interface ComputationApiKeyDriverAnalysisResultRequest
 */
export interface ComputationApiKeyDriverAnalysisResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof ComputationApiKeyDriverAnalysisResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for retrieveExecutionMetadata operation in ComputationApi.
 * @export
 * @interface ComputationApiRetrieveExecutionMetadataRequest
 */
export interface ComputationApiRetrieveExecutionMetadataRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiRetrieveExecutionMetadata
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiRetrieveExecutionMetadata
     */
    readonly resultId: string;
}

/**
 * Request parameters for retrieveResult operation in ComputationApi.
 * @export
 * @interface ComputationApiRetrieveResultRequest
 */
export interface ComputationApiRetrieveResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComputationApiRetrieveResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof ComputationApiRetrieveResult
     */
    readonly resultId: string;

    /**
     * Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly offset?: Array<number>;

    /**
     * Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @type {Array<number>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly limit?: Array<number>;

    /**
     * Identifiers of the dimensions where grand total data should not be returned for this request. A grand total will not be returned if all of its totalDimensions are in excludedTotalDimensions.
     * @type {Array<string>}
     * @memberof ComputationApiRetrieveResult
     */
    readonly excludedTotalDimensions?: Array<string>;
}

/**
 * ComputationApi - object-oriented interface
 * @export
 * @class ComputationApi
 * @extends {BaseAPI}
 */
export class ComputationApi extends BaseAPI implements ComputationApiInterface {
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values. The resulting data are limited by the static platform limit to the maximum of 10000 rows.
     * @param {ComputationApiComputeLabelElementsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeLabelElementsPost(
        requestParameters: ComputationApiComputeLabelElementsPostRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeLabelElementsPost(
                requestParameters.workspaceId,
                requestParameters.elementsRequest,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {ComputationApiComputeReportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeReport(
        requestParameters: ComputationApiComputeReportRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeReport(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.skipCache,
                requestParameters.timestamp,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Returns map of lists of attributes that can be used as descendants of the given attributes.
     * @summary (BETA) Valid descendants
     * @param {ComputationApiComputeValidDescendantsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeValidDescendants(
        requestParameters: ComputationApiComputeValidDescendantsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeValidDescendants(
                requestParameters.workspaceId,
                requestParameters.afmValidDescendantsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list containing attributes, facts, or metrics, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {ComputationApiComputeValidObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public computeValidObjects(
        requestParameters: ComputationApiComputeValidObjectsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .computeValidObjects(
                requestParameters.workspaceId,
                requestParameters.afmValidObjectsQuery,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides static structures needed for investigation of a problem with given AFM.
     * @summary AFM explain resource.
     * @param {ComputationApiExplainAFMRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public explainAFM(requestParameters: ComputationApiExplainAFMRequest, options?: AxiosRequestConfig) {
        return ComputationApiFp(this.configuration)
            .explainAFM(
                requestParameters.workspaceId,
                requestParameters.afmExecution,
                requestParameters.explainType,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes key driver analysis for the provided execution definition.
     * @summary (EXPERIMENTAL) Compute key driver analysis
     * @param {ComputationApiKeyDriverAnalysisRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public keyDriverAnalysis(
        requestParameters: ComputationApiKeyDriverAnalysisRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .keyDriverAnalysis(
                requestParameters.workspaceId,
                requestParameters.keyDriversRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets key driver analysis.
     * @summary (EXPERIMENTAL) Get key driver analysis result
     * @param {ComputationApiKeyDriverAnalysisResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public keyDriverAnalysisResult(
        requestParameters: ComputationApiKeyDriverAnalysisResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .keyDriverAnalysisResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * The resource provides execution result\'s metadata as AFM and resultSpec used in execution request and an executionResponse
     * @summary Get a single execution result\'s metadata.
     * @param {ComputationApiRetrieveExecutionMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public retrieveExecutionMetadata(
        requestParameters: ComputationApiRetrieveExecutionMetadataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .retrieveExecutionMetadata(requestParameters.workspaceId, requestParameters.resultId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {ComputationApiRetrieveResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public retrieveResult(
        requestParameters: ComputationApiRetrieveResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .retrieveResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                requestParameters.excludedTotalDimensions,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * SmartFunctionsApi - axios parameter creator
 * @export
 */
export const SmartFunctionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChat: async (
            workspaceId: string,
            chatRequest: ChatRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChat", "workspaceId", workspaceId);
            // verify required parameter 'chatRequest' is not null or undefined
            assertParamExists("aiChat", "chatRequest", chatRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chat`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
                : chatRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {string} workspaceId Workspace identifier
         * @param {ChatHistoryRequest} chatHistoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatHistory: async (
            workspaceId: string,
            chatHistoryRequest: ChatHistoryRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChatHistory", "workspaceId", workspaceId);
            // verify required parameter 'chatHistoryRequest' is not null or undefined
            assertParamExists("aiChatHistory", "chatHistoryRequest", chatHistoryRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatHistory`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatHistoryRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatHistoryRequest !== undefined ? chatHistoryRequest : {})
                : chatHistoryRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatStream: async (
            workspaceId: string,
            chatRequest: ChatRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiChatStream", "workspaceId", workspaceId);
            // verify required parameter 'chatRequest' is not null or undefined
            assertParamExists("aiChatStream", "chatRequest", chatRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/chatStream`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof chatRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(chatRequest !== undefined ? chatRequest : {})
                : chatRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {string} workspaceId Workspace identifier
         * @param {SearchRequest} searchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiSearch: async (
            workspaceId: string,
            searchRequest: SearchRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("aiSearch", "workspaceId", workspaceId);
            // verify required parameter 'searchRequest' is not null or undefined
            assertParamExists("aiSearch", "searchRequest", searchRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/ai/search`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof searchRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(searchRequest !== undefined ? searchRequest : {})
                : searchRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {AnomalyDetectionRequest} anomalyDetectionRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetection: async (
            workspaceId: string,
            resultId: string,
            anomalyDetectionRequest: AnomalyDetectionRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("anomalyDetection", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("anomalyDetection", "resultId", resultId);
            // verify required parameter 'anomalyDetectionRequest' is not null or undefined
            assertParamExists("anomalyDetection", "anomalyDetectionRequest", anomalyDetectionRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof anomalyDetectionRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(anomalyDetectionRequest !== undefined ? anomalyDetectionRequest : {})
                : anomalyDetectionRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetectionResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("anomalyDetectionResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("anomalyDetectionResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/anomalyDetection/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ClusteringRequest} clusteringRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustering: async (
            workspaceId: string,
            resultId: string,
            clusteringRequest: ClusteringRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("clustering", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("clustering", "resultId", resultId);
            // verify required parameter 'clusteringRequest' is not null or undefined
            assertParamExists("clustering", "clusteringRequest", clusteringRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof clusteringRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(clusteringRequest !== undefined ? clusteringRequest : {})
                : clusteringRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusteringResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("clusteringResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("clusteringResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/clustering/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast: async (
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecast", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecast", "resultId", resultId);
            // verify required parameter 'forecastRequest' is not null or undefined
            assertParamExists("forecast", "forecastRequest", forecastRequest);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof forecastRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(forecastRequest !== undefined ? forecastRequest : {})
                : forecastRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult: async (
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("forecastResult", "workspaceId", workspaceId);
            // verify required parameter 'resultId' is not null or undefined
            assertParamExists("forecastResult", "resultId", resultId);
            const localVarPath =
                `/api/v1/actions/workspaces/{workspaceId}/execution/functions/forecast/result/{resultId}`
                    .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                    .replace(`{${"resultId"}}`, encodeURIComponent(String(resultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter["offset"] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter["limit"] = limit;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * SmartFunctionsApi - functional programming interface
 * @export
 */
export const SmartFunctionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SmartFunctionsApiAxiosParamCreator(configuration);
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChat(
            workspaceId: string,
            chatRequest: ChatRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChat(
                workspaceId,
                chatRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {string} workspaceId Workspace identifier
         * @param {ChatHistoryRequest} chatHistoryRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatHistory(
            workspaceId: string,
            chatHistoryRequest: ChatHistoryRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatHistoryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatHistory(
                workspaceId,
                chatHistoryRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {string} workspaceId Workspace identifier
         * @param {ChatRequest} chatRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiChatStream(
            workspaceId: string,
            chatRequest: ChatRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiChatStream(
                workspaceId,
                chatRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {string} workspaceId Workspace identifier
         * @param {SearchRequest} searchRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiSearch(
            workspaceId: string,
            searchRequest: SearchRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiSearch(
                workspaceId,
                searchRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {AnomalyDetectionRequest} anomalyDetectionRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async anomalyDetection(
            workspaceId: string,
            resultId: string,
            anomalyDetectionRequest: AnomalyDetectionRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.anomalyDetection(
                workspaceId,
                resultId,
                anomalyDetectionRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async anomalyDetectionResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnomalyDetectionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.anomalyDetectionResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ClusteringRequest} clusteringRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clustering(
            workspaceId: string,
            resultId: string,
            clusteringRequest: ClusteringRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clustering(
                workspaceId,
                resultId,
                clusteringRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusteringResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusteringResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusteringResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Input result ID to be used in the computation
         * @param {ForecastRequest} forecastRequest
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecast(
            workspaceId: string,
            resultId: string,
            forecastRequest: ForecastRequest,
            skipCache?: boolean,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartFunctionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecast(
                workspaceId,
                resultId,
                forecastRequest,
                skipCache,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forecastResult(
            workspaceId: string,
            resultId: string,
            offset?: number,
            limit?: number,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForecastResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forecastResult(
                workspaceId,
                resultId,
                offset,
                limit,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * SmartFunctionsApi - factory interface
 * @export
 */
export const SmartFunctionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = SmartFunctionsApiFp(configuration);
    return {
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {SmartFunctionsApiAiChatRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChat(
            requestParameters: SmartFunctionsApiAiChatRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ChatResult> {
            return localVarFp
                .aiChat(requestParameters.workspaceId, requestParameters.chatRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
         * @summary (BETA) Get Chat History
         * @param {SmartFunctionsApiAiChatHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatHistory(
            requestParameters: SmartFunctionsApiAiChatHistoryRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ChatHistoryResult> {
            return localVarFp
                .aiChatHistory(requestParameters.workspaceId, requestParameters.chatHistoryRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Combines multiple use cases such as search, create visualizations, ...
         * @summary (BETA) Chat with AI
         * @param {SmartFunctionsApiAiChatStreamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiChatStream(
            requestParameters: SmartFunctionsApiAiChatStreamRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Array<object>> {
            return localVarFp
                .aiChatStream(requestParameters.workspaceId, requestParameters.chatRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
         * @summary (BETA) Semantic Search in Metadata
         * @param {SmartFunctionsApiAiSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiSearch(
            requestParameters: SmartFunctionsApiAiSearchRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SearchResult> {
            return localVarFp
                .aiSearch(requestParameters.workspaceId, requestParameters.searchRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes anomaly detection.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
         * @param {SmartFunctionsApiAnomalyDetectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetection(
            requestParameters: SmartFunctionsApiAnomalyDetectionRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .anomalyDetection(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.anomalyDetectionRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets anomalies.
         * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
         * @param {SmartFunctionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        anomalyDetectionResult(
            requestParameters: SmartFunctionsApiAnomalyDetectionResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<AnomalyDetectionResult> {
            return localVarFp
                .anomalyDetectionResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
         * @summary (EXPERIMENTAL) Smart functions - Clustering
         * @param {SmartFunctionsApiClusteringRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustering(
            requestParameters: SmartFunctionsApiClusteringRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .clustering(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.clusteringRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (EXPERIMENTAL) Gets clustering result.
         * @summary (EXPERIMENTAL) Smart functions - Clustering Result
         * @param {SmartFunctionsApiClusteringResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusteringResult(
            requestParameters: SmartFunctionsApiClusteringResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ClusteringResult> {
            return localVarFp
                .clusteringResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Computes forecasted data points from the provided execution result and parameters.
         * @summary (BETA) Smart functions - Forecast
         * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecast(
            requestParameters: SmartFunctionsApiForecastRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<SmartFunctionResponse> {
            return localVarFp
                .forecast(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.forecastRequest,
                    requestParameters.skipCache,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * (BETA) Gets forecast result.
         * @summary (BETA) Smart functions - Forecast Result
         * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forecastResult(
            requestParameters: SmartFunctionsApiForecastResultRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ForecastResult> {
            return localVarFp
                .forecastResult(
                    requestParameters.workspaceId,
                    requestParameters.resultId,
                    requestParameters.offset,
                    requestParameters.limit,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * SmartFunctionsApi - interface
 * @export
 * @interface SmartFunctionsApi
 */
export interface SmartFunctionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiChat(
        requestParameters: SmartFunctionsApiAiChatRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatResult>;

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {SmartFunctionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiChatHistory(
        requestParameters: SmartFunctionsApiAiChatHistoryRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ChatHistoryResult>;

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiChatStream(
        requestParameters: SmartFunctionsApiAiChatStreamRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Array<object>>;

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {SmartFunctionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    aiSearch(
        requestParameters: SmartFunctionsApiAiSearchRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SearchResult>;

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {SmartFunctionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    anomalyDetection(
        requestParameters: SmartFunctionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {SmartFunctionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    anomalyDetectionResult(
        requestParameters: SmartFunctionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<AnomalyDetectionResult>;

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {SmartFunctionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    clustering(
        requestParameters: SmartFunctionsApiClusteringRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {SmartFunctionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    clusteringResult(
        requestParameters: SmartFunctionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ClusteringResult>;

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    forecast(
        requestParameters: SmartFunctionsApiForecastRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<SmartFunctionResponse>;

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApiInterface
     */
    forecastResult(
        requestParameters: SmartFunctionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ForecastResult>;
}

/**
 * Request parameters for aiChat operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiChatRequest
 */
export interface SmartFunctionsApiAiChatRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiChat
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof SmartFunctionsApiAiChat
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiChatHistory operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiChatHistoryRequest
 */
export interface SmartFunctionsApiAiChatHistoryRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiChatHistory
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatHistoryRequest}
     * @memberof SmartFunctionsApiAiChatHistory
     */
    readonly chatHistoryRequest: ChatHistoryRequest;
}

/**
 * Request parameters for aiChatStream operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiChatStreamRequest
 */
export interface SmartFunctionsApiAiChatStreamRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiChatStream
     */
    readonly workspaceId: string;

    /**
     *
     * @type {ChatRequest}
     * @memberof SmartFunctionsApiAiChatStream
     */
    readonly chatRequest: ChatRequest;
}

/**
 * Request parameters for aiSearch operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAiSearchRequest
 */
export interface SmartFunctionsApiAiSearchRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAiSearch
     */
    readonly workspaceId: string;

    /**
     *
     * @type {SearchRequest}
     * @memberof SmartFunctionsApiAiSearch
     */
    readonly searchRequest: SearchRequest;
}

/**
 * Request parameters for anomalyDetection operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAnomalyDetectionRequest
 */
export interface SmartFunctionsApiAnomalyDetectionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly resultId: string;

    /**
     *
     * @type {AnomalyDetectionRequest}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly anomalyDetectionRequest: AnomalyDetectionRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof SmartFunctionsApiAnomalyDetection
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for anomalyDetectionResult operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiAnomalyDetectionResultRequest
 */
export interface SmartFunctionsApiAnomalyDetectionResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiAnomalyDetectionResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for clustering operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiClusteringRequest
 */
export interface SmartFunctionsApiClusteringRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiClustering
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof SmartFunctionsApiClustering
     */
    readonly resultId: string;

    /**
     *
     * @type {ClusteringRequest}
     * @memberof SmartFunctionsApiClustering
     */
    readonly clusteringRequest: ClusteringRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof SmartFunctionsApiClustering
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for clusteringResult operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiClusteringResultRequest
 */
export interface SmartFunctionsApiClusteringResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiClusteringResult
     */
    readonly limit?: number;
}

/**
 * Request parameters for forecast operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiForecastRequest
 */
export interface SmartFunctionsApiForecastRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiForecast
     */
    readonly workspaceId: string;

    /**
     * Input result ID to be used in the computation
     * @type {string}
     * @memberof SmartFunctionsApiForecast
     */
    readonly resultId: string;

    /**
     *
     * @type {ForecastRequest}
     * @memberof SmartFunctionsApiForecast
     */
    readonly forecastRequest: ForecastRequest;

    /**
     * Ignore all caches during execution of current request.
     * @type {boolean}
     * @memberof SmartFunctionsApiForecast
     */
    readonly skipCache?: boolean;
}

/**
 * Request parameters for forecastResult operation in SmartFunctionsApi.
 * @export
 * @interface SmartFunctionsApiForecastResultRequest
 */
export interface SmartFunctionsApiForecastResultRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly workspaceId: string;

    /**
     * Result ID
     * @type {string}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly resultId: string;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly offset?: number;

    /**
     *
     * @type {number}
     * @memberof SmartFunctionsApiForecastResult
     */
    readonly limit?: number;
}

/**
 * SmartFunctionsApi - object-oriented interface
 * @export
 * @class SmartFunctionsApi
 * @extends {BaseAPI}
 */
export class SmartFunctionsApi extends BaseAPI implements SmartFunctionsApiInterface {
    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiChat(requestParameters: SmartFunctionsApiAiChatRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .aiChat(requestParameters.workspaceId, requestParameters.chatRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Post thread ID (and optionally interaction ID) to get full/partial chat history.
     * @summary (BETA) Get Chat History
     * @param {SmartFunctionsApiAiChatHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiChatHistory(
        requestParameters: SmartFunctionsApiAiChatHistoryRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .aiChatHistory(requestParameters.workspaceId, requestParameters.chatHistoryRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Combines multiple use cases such as search, create visualizations, ...
     * @summary (BETA) Chat with AI
     * @param {SmartFunctionsApiAiChatStreamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiChatStream(
        requestParameters: SmartFunctionsApiAiChatStreamRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .aiChatStream(requestParameters.workspaceId, requestParameters.chatRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Uses similarity (e.g. cosine distance) search to find top X most similar metadata objects.
     * @summary (BETA) Semantic Search in Metadata
     * @param {SmartFunctionsApiAiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public aiSearch(requestParameters: SmartFunctionsApiAiSearchRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .aiSearch(requestParameters.workspaceId, requestParameters.searchRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes anomaly detection.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection
     * @param {SmartFunctionsApiAnomalyDetectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public anomalyDetection(
        requestParameters: SmartFunctionsApiAnomalyDetectionRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .anomalyDetection(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.anomalyDetectionRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets anomalies.
     * @summary (EXPERIMENTAL) Smart functions - Anomaly Detection Result
     * @param {SmartFunctionsApiAnomalyDetectionResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public anomalyDetectionResult(
        requestParameters: SmartFunctionsApiAnomalyDetectionResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .anomalyDetectionResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Computes clusters for data points from the provided execution result and parameters.
     * @summary (EXPERIMENTAL) Smart functions - Clustering
     * @param {SmartFunctionsApiClusteringRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public clustering(requestParameters: SmartFunctionsApiClusteringRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .clustering(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.clusteringRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (EXPERIMENTAL) Gets clustering result.
     * @summary (EXPERIMENTAL) Smart functions - Clustering Result
     * @param {SmartFunctionsApiClusteringResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public clusteringResult(
        requestParameters: SmartFunctionsApiClusteringResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .clusteringResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Computes forecasted data points from the provided execution result and parameters.
     * @summary (BETA) Smart functions - Forecast
     * @param {SmartFunctionsApiForecastRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public forecast(requestParameters: SmartFunctionsApiForecastRequest, options?: AxiosRequestConfig) {
        return SmartFunctionsApiFp(this.configuration)
            .forecast(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.forecastRequest,
                requestParameters.skipCache,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * (BETA) Gets forecast result.
     * @summary (BETA) Smart functions - Forecast Result
     * @param {SmartFunctionsApiForecastResultRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartFunctionsApi
     */
    public forecastResult(
        requestParameters: SmartFunctionsApiForecastResultRequest,
        options?: AxiosRequestConfig,
    ) {
        return SmartFunctionsApiFp(this.configuration)
            .forecastResult(
                requestParameters.workspaceId,
                requestParameters.resultId,
                requestParameters.offset,
                requestParameters.limit,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}
