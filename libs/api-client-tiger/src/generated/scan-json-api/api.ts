/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration.js';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

export interface ColumnStatistic {
    'type': ColumnStatisticTypeEnum;
    'value'?: string;
}

export type ColumnStatisticTypeEnum = 'COUNT' | 'COUNT_NULL' | 'COUNT_UNIQUE' | 'AVG' | 'STDDEV' | 'MIN' | 'MAX' | 'PERCENTILE_25' | 'PERCENTILE_50' | 'PERCENTILE_75';

export interface ColumnStatisticWarning {
    'action': string;
    'message': string;
}

/**
 * A request to retrieve statistics for a column.
 */
export interface ColumnStatisticsRequest {
    'from': ColumnStatisticsRequestFrom;
    'columnName': string;
    'statistics'?: Array<ColumnStatisticsRequestStatisticsEnum>;
    'histogram'?: HistogramProperties;
    'frequency'?: FrequencyProperties;
}

export type ColumnStatisticsRequestStatisticsEnum = 'COUNT' | 'COUNT_NULL' | 'COUNT_UNIQUE' | 'AVG' | 'STDDEV' | 'MIN' | 'MAX' | 'PERCENTILE_25' | 'PERCENTILE_50' | 'PERCENTILE_75';

/**
 * @type ColumnStatisticsRequestFrom
 */
export type ColumnStatisticsRequestFrom = SqlQuery | Table;

export interface ColumnStatisticsResponse {
    'statistics'?: Array<ColumnStatistic>;
    'histogram'?: Histogram;
    'frequency'?: Frequency;
    'warnings'?: Array<ColumnStatisticWarning>;
}

/**
 * Warning related to single column.
 */
export interface ColumnWarning {
    /**
     * Column name.
     */
    'name': string;
    /**
     * Warning message related to the column.
     */
    'message': string;
}

/**
 * A parameter for testing data source connection
 */
export interface DataSourceParameter {
    /**
     * Parameter name.
     */
    'name': string;
    /**
     * Parameter value.
     */
    'value': string;
}

/**
 * Result of getSchemata. Contains list of available DB schema names.
 */
export interface DataSourceSchemata {
    'schemaNames': Array<string>;
}

/**
 * A table column.
 */
export interface DeclarativeColumn {
    /**
     * Column name
     */
    'name': string;
    /**
     * Column type
     */
    'dataType': DeclarativeColumnDataTypeEnum;
    /**
     * Is column part of primary key?
     */
    'isPrimaryKey'?: boolean;
    /**
     * Referenced table (Foreign key)
     */
    'referencedTableId'?: string;
    /**
     * Referenced table (Foreign key)
     */
    'referencedTableColumn'?: string;
    /**
     * Column description/comment from database
     */
    'description'?: string;
    /**
     * Column is nullable
     */
    'isNullable'?: boolean;
}

export type DeclarativeColumnDataTypeEnum = 'INT' | 'STRING' | 'DATE' | 'NUMERIC' | 'TIMESTAMP' | 'TIMESTAMP_TZ' | 'BOOLEAN';

/**
 * A database table.
 */
export interface DeclarativeTable {
    /**
     * Table id.
     */
    'id': string;
    /**
     * Path to table.
     */
    'path': Array<string>;
    /**
     * Table type: TABLE or VIEW.
     */
    'type': string;
    /**
     * Table or view name prefix used in scan. Will be stripped when generating LDM.
     */
    'namePrefix'?: string;
    /**
     * An array of physical columns
     */
    'columns': Array<DeclarativeColumn>;
}

/**
 * A physical data model (PDM) tables.
 */
export interface DeclarativeTables {
    /**
     * An array of physical database tables.
     */
    'tables': Array<DeclarativeTable>;
}

export interface Frequency {
    'buckets': Array<FrequencyBucket>;
}

export interface FrequencyBucket {
    'count': number;
    'value'?: string;
}

export interface FrequencyProperties {
    /**
     * The maximum number of distinct values to return.
     */
    'valueLimit'?: number;
}

export interface Histogram {
    'buckets': Array<HistogramBucket>;
}

export interface HistogramBucket {
    'count': number;
    'lowerBound': number;
    'upperBound': number;
}

export interface HistogramProperties {
    'bucketCount': number;
}

/**
 * A request containing all information critical to model scanning.
 */
export interface ScanRequest {
    /**
     * A separator between prefixes and the names.
     */
    'separator': string;
    /**
     * A flag indicating whether the tables should be scanned.
     */
    'scanTables': boolean;
    /**
     * A flag indicating whether the views should be scanned.
     */
    'scanViews': boolean;
    /**
     * What schemata will be scanned.
     */
    'schemata'?: Array<string>;
    /**
     * Tables starting with this prefix will be scanned. The prefix is then followed by the value of `separator` parameter. Given the table prefix is `out_table` and separator is `__`, the table with name like `out_table__customers` will be scanned.
     */
    'tablePrefix'?: string;
    /**
     * Views starting with this prefix will be scanned. The prefix is then followed by the value of `separator` parameter. Given the view prefix is `out_view` and separator is `__`, the table with name like `out_view__us_customers` will be scanned.
     */
    'viewPrefix'?: string;
}

/**
 * Result of scan of data source physical model.
 */
export interface ScanResultPdm {
    'pdm': DeclarativeTables;
    'warnings': Array<TableWarning>;
}

/**
 * A request with SQL query to by analyzed.
 */
export interface ScanSqlRequest {
    /**
     * SQL query to be analyzed.
     */
    'sql': string;
}

/**
 * Result of scanSql. Consists of array of query columns including type. Sql query result data preview can be attached optionally
 */
export interface ScanSqlResponse {
    /**
     * Array of columns with types.
     */
    'columns': Array<SqlColumn>;
    /**
     * Array of rows where each row is another array of string values.
     */
    'dataPreview'?: Array<Array<string | null>>;
}

/**
 * A SQL query result column.
 */
export interface SqlColumn {
    /**
     * Column name
     */
    'name': string;
    /**
     * Column type
     */
    'dataType': SqlColumnDataTypeEnum;
    /**
     * Column description/comment from database
     */
    'description'?: string;
}

export type SqlColumnDataTypeEnum = 'INT' | 'STRING' | 'DATE' | 'NUMERIC' | 'TIMESTAMP' | 'TIMESTAMP_TZ' | 'BOOLEAN';

export interface SqlQuery {
    'sql': string;
}

export interface Table {
    'tableName': string;
}

/**
 * Warnings related to single table.
 */
export interface TableWarning {
    /**
     * Table name.
     */
    'name': string;
    /**
     * Warning message related to the table.
     */
    'message'?: string;
    'columns': Array<ColumnWarning>;
}

/**
 * A request containing all information for testing data source definition.
 */
export interface TestDefinitionRequest {
    /**
     * Type of database, where test should connect to.
     */
    'type': TestDefinitionRequestTypeEnum;
    /**
     * URL to database in JDBC format, where test should connect to.
     */
    'url'?: string;
    /**
     * Database schema.
     */
    'schema'?: string;
    /**
     * Database user name.
     */
    'username'?: string;
    /**
     * Database user password.
     */
    'password'?: string;
    /**
     * Secret for token based authentication for data sources which supports it.
     */
    'token'?: string;
    /**
     * Private key for data sources which supports key-pair authentication.
     */
    'privateKey'?: string;
    /**
     * Passphrase for a encrypted version of a private key.
     */
    'privateKeyPassphrase'?: string;
    /**
     * Id for client based authentication for data sources which supports it.
     */
    'clientId'?: string;
    /**
     * Secret for client based authentication for data sources which supports it.
     */
    'clientSecret'?: string;
    'parameters'?: Array<DataSourceParameter>;
}

export type TestDefinitionRequestTypeEnum = 'POSTGRESQL' | 'REDSHIFT' | 'VERTICA' | 'SNOWFLAKE' | 'ADS' | 'BIGQUERY' | 'MSSQL' | 'PRESTO' | 'DREMIO' | 'DRILL' | 'GREENPLUM' | 'AZURESQL' | 'SYNAPSESQL' | 'DATABRICKS' | 'GDSTORAGE' | 'CLICKHOUSE' | 'MYSQL' | 'MARIADB' | 'ORACLE' | 'PINOT' | 'SINGLESTORE' | 'MOTHERDUCK' | 'FLEXCONNECT' | 'STARROCKS' | 'ATHENA' | 'MONGODB' | 'CRATEDB';

/**
 * A structure containing duration of the test queries run on a data source. It is omitted if an error happens.
 */
export interface TestQueryDuration {
    /**
     * Field containing duration of a test select query on a data source. In milliseconds.
     */
    'simpleSelect': number;
    /**
     * Field containing duration of a test \'create table as select\' query on a datasource. In milliseconds. The field is omitted if a data source doesn\'t support caching.
     */
    'createCacheTable'?: number;
}

/**
 * A request containing all information for testing existing data source.
 */
export interface TestRequest {
    /**
     * URL to database in JDBC format, where test should connect to.
     */
    'url'?: string;
    /**
     * Database schema.
     */
    'schema'?: string;
    /**
     * Database user name.
     */
    'username'?: string;
    /**
     * Database user password.
     */
    'password'?: string;
    /**
     * Secret for token based authentication for data sources which supports it.
     */
    'token'?: string;
    /**
     * Private key for data sources which supports key-pair authentication.
     */
    'privateKey'?: string;
    /**
     * Passphrase for a encrypted version of a private key.
     */
    'privateKeyPassphrase'?: string;
    /**
     * Id for client based authentication for data sources which supports it.
     */
    'clientId'?: string;
    /**
     * Secret for client based authentication for data sources which supports it.
     */
    'clientSecret'?: string;
    'parameters'?: Array<DataSourceParameter>;
}

/**
 * Response from data source testing.
 */
export interface TestResponse {
    /**
     * A flag indicating whether test passed or not.
     */
    'successful': boolean;
    /**
     * Field containing more details in case of a failure. Details are available to a privileged user only.
     */
    'error'?: string;
    'queryDurationMillis'?: TestQueryDuration;
}



// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
 * @summary (EXPERIMENTAL) Compute column statistics
 * @param {string} dataSourceId 
 * @param {ColumnStatisticsRequest} columnStatisticsRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ColumnStatistics(
    dataSourceId: string, columnStatisticsRequest: ColumnStatisticsRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('columnStatistics', 'dataSourceId', dataSourceId)
    // verify required parameter 'columnStatisticsRequest' is not null or undefined
    assertParamExists('columnStatistics', 'columnStatisticsRequest', columnStatisticsRequest)
    const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/computeColumnStatistics`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof columnStatisticsRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(columnStatisticsRequest !== undefined ? columnStatisticsRequest : {})
        : columnStatisticsRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
 * @summary Get a list of schema names of a database
 * @param {string} dataSourceId Data source id
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_GetDataSourceSchemata(
    dataSourceId: string, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('getDataSourceSchemata', 'dataSourceId', dataSourceId)
    const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSchemata`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
 * @summary Scan a database to get a physical data model (PDM)
 * @param {string} dataSourceId Data source id
 * @param {ScanRequest} scanRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ScanDataSource(
    dataSourceId: string, scanRequest: ScanRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('scanDataSource', 'dataSourceId', dataSourceId)
    // verify required parameter 'scanRequest' is not null or undefined
    assertParamExists('scanDataSource', 'scanRequest', scanRequest)
    const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scan`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof scanRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(scanRequest !== undefined ? scanRequest : {})
        : scanRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
 * @summary Collect metadata about SQL query
 * @param {string} dataSourceId Data source id
 * @param {ScanSqlRequest} scanSqlRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_ScanSql(
    dataSourceId: string, scanSqlRequest: ScanSqlRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('scanSql', 'dataSourceId', dataSourceId)
    // verify required parameter 'scanSqlRequest' is not null or undefined
    assertParamExists('scanSql', 'scanSqlRequest', scanSqlRequest)
    const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSql`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof scanSqlRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(scanSqlRequest !== undefined ? scanSqlRequest : {})
        : scanSqlRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Test if it is possible to connect to a database using an existing data source definition.
 * @summary Test data source connection by data source id
 * @param {string} dataSourceId Data source id
 * @param {TestRequest} testRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_TestDataSource(
    dataSourceId: string, testRequest: TestRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('testDataSource', 'dataSourceId', dataSourceId)
    // verify required parameter 'testRequest' is not null or undefined
    assertParamExists('testDataSource', 'testRequest', testRequest)
    const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/test`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof testRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testRequest !== undefined ? testRequest : {})
        : testRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ActionsApi FP - ActionsApiAxiosParamCreator
/**
 * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
 * @summary Test connection by data source definition
 * @param {TestDefinitionRequest} testDefinitionRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApiAxiosParamCreator_TestDataSourceDefinition(
    testDefinitionRequest: TestDefinitionRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'testDefinitionRequest' is not null or undefined
    assertParamExists('testDataSourceDefinition', 'testDefinitionRequest', testDefinitionRequest)
    const localVarPath = `/api/v1/actions/dataSource/test`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof testDefinitionRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testDefinitionRequest !== undefined ? testDefinitionRequest : {})
        : testDefinitionRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// ActionsApi Api FP
/**
 * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
 * @summary (EXPERIMENTAL) Compute column statistics
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiColumnStatisticsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ColumnStatistics(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiColumnStatisticsRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ColumnStatisticsResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ColumnStatistics(
        requestParameters.dataSourceId, requestParameters.columnStatisticsRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
 * @summary Get a list of schema names of a database
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiGetDataSourceSchemataRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_GetDataSourceSchemata(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiGetDataSourceSchemataRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<DataSourceSchemata> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_GetDataSourceSchemata(
        requestParameters.dataSourceId, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
 * @summary Scan a database to get a physical data model (PDM)
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiScanDataSourceRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ScanDataSource(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiScanDataSourceRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ScanResultPdm> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ScanDataSource(
        requestParameters.dataSourceId, requestParameters.scanRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
 * @summary Collect metadata about SQL query
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiScanSqlRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_ScanSql(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiScanSqlRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ScanSqlResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_ScanSql(
        requestParameters.dataSourceId, requestParameters.scanSqlRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * Test if it is possible to connect to a database using an existing data source definition.
 * @summary Test data source connection by data source id
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiTestDataSourceRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_TestDataSource(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiTestDataSourceRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<TestResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_TestDataSource(
        requestParameters.dataSourceId, requestParameters.testRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ActionsApi Api FP
/**
 * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
 * @summary Test connection by data source definition
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ActionsApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ActionsApi_TestDataSourceDefinition(
    axios: AxiosInstance, basePath: string,
    requestParameters: ActionsApiTestDataSourceDefinitionRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<TestResponse> {
    const localVarAxiosArgs = await ActionsApiAxiosParamCreator_TestDataSourceDefinition(
        requestParameters.testDefinitionRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
     * @summary (EXPERIMENTAL) Compute column statistics
     * @param {ActionsApiColumnStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    columnStatistics(requestParameters: ActionsApiColumnStatisticsRequest, options?: AxiosRequestConfig): AxiosPromise<ColumnStatisticsResponse>;

    /**
     * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
     * @summary Get a list of schema names of a database
     * @param {ActionsApiGetDataSourceSchemataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getDataSourceSchemata(requestParameters: ActionsApiGetDataSourceSchemataRequest, options?: AxiosRequestConfig): AxiosPromise<DataSourceSchemata>;

    /**
     * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
     * @summary Scan a database to get a physical data model (PDM)
     * @param {ActionsApiScanDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    scanDataSource(requestParameters: ActionsApiScanDataSourceRequest, options?: AxiosRequestConfig): AxiosPromise<ScanResultPdm>;

    /**
     * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
     * @summary Collect metadata about SQL query
     * @param {ActionsApiScanSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    scanSql(requestParameters: ActionsApiScanSqlRequest, options?: AxiosRequestConfig): AxiosPromise<ScanSqlResponse>;

    /**
     * Test if it is possible to connect to a database using an existing data source definition.
     * @summary Test data source connection by data source id
     * @param {ActionsApiTestDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    testDataSource(requestParameters: ActionsApiTestDataSourceRequest, options?: AxiosRequestConfig): AxiosPromise<TestResponse>;

    /**
     * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
     * @summary Test connection by data source definition
     * @param {ActionsApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    testDataSourceDefinition(requestParameters: ActionsApiTestDataSourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<TestResponse>;

}

/**
 * Request parameters for columnStatistics operation in ActionsApi.
 * @export
 * @interface ActionsApiColumnStatisticsRequest
 */
export interface ActionsApiColumnStatisticsRequest {
    /**
     * 
     * @type {string}
     * @memberof ActionsApiColumnStatistics
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {ColumnStatisticsRequest}
     * @memberof ActionsApiColumnStatistics
     */
    readonly columnStatisticsRequest: ColumnStatisticsRequest
}

/**
 * Request parameters for getDataSourceSchemata operation in ActionsApi.
 * @export
 * @interface ActionsApiGetDataSourceSchemataRequest
 */
export interface ActionsApiGetDataSourceSchemataRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ActionsApiGetDataSourceSchemata
     */
    readonly dataSourceId: string
}

/**
 * Request parameters for scanDataSource operation in ActionsApi.
 * @export
 * @interface ActionsApiScanDataSourceRequest
 */
export interface ActionsApiScanDataSourceRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ActionsApiScanDataSource
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {ScanRequest}
     * @memberof ActionsApiScanDataSource
     */
    readonly scanRequest: ScanRequest
}

/**
 * Request parameters for scanSql operation in ActionsApi.
 * @export
 * @interface ActionsApiScanSqlRequest
 */
export interface ActionsApiScanSqlRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ActionsApiScanSql
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {ScanSqlRequest}
     * @memberof ActionsApiScanSql
     */
    readonly scanSqlRequest: ScanSqlRequest
}

/**
 * Request parameters for testDataSource operation in ActionsApi.
 * @export
 * @interface ActionsApiTestDataSourceRequest
 */
export interface ActionsApiTestDataSourceRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ActionsApiTestDataSource
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {TestRequest}
     * @memberof ActionsApiTestDataSource
     */
    readonly testRequest: TestRequest
}

/**
 * Request parameters for testDataSourceDefinition operation in ActionsApi.
 * @export
 * @interface ActionsApiTestDataSourceDefinitionRequest
 */
export interface ActionsApiTestDataSourceDefinitionRequest {
    /**
     * 
     * @type {TestDefinitionRequest}
     * @memberof ActionsApiTestDataSourceDefinition
     */
    readonly testDefinitionRequest: TestDefinitionRequest
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
     * @summary (EXPERIMENTAL) Compute column statistics
     * @param {ActionsApiColumnStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public columnStatistics(requestParameters: ActionsApiColumnStatisticsRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ColumnStatistics(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
     * @summary Get a list of schema names of a database
     * @param {ActionsApiGetDataSourceSchemataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getDataSourceSchemata(requestParameters: ActionsApiGetDataSourceSchemataRequest, options?: AxiosRequestConfig) {
        return ActionsApi_GetDataSourceSchemata(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
     * @summary Scan a database to get a physical data model (PDM)
     * @param {ActionsApiScanDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public scanDataSource(requestParameters: ActionsApiScanDataSourceRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ScanDataSource(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
     * @summary Collect metadata about SQL query
     * @param {ActionsApiScanSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public scanSql(requestParameters: ActionsApiScanSqlRequest, options?: AxiosRequestConfig) {
        return ActionsApi_ScanSql(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Test if it is possible to connect to a database using an existing data source definition.
     * @summary Test data source connection by data source id
     * @param {ActionsApiTestDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public testDataSource(requestParameters: ActionsApiTestDataSourceRequest, options?: AxiosRequestConfig) {
        return ActionsApi_TestDataSource(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
     * @summary Test connection by data source definition
     * @param {ActionsApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public testDataSourceDefinition(requestParameters: ActionsApiTestDataSourceDefinitionRequest, options?: AxiosRequestConfig) {
        return ActionsApi_TestDataSourceDefinition(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}


// ComputationApi FP - ComputationApiAxiosParamCreator
/**
 * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
 * @summary (EXPERIMENTAL) Compute column statistics
 * @param {string} dataSourceId 
 * @param {ColumnStatisticsRequest} columnStatisticsRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApiAxiosParamCreator_ColumnStatistics(
    dataSourceId: string, columnStatisticsRequest: ColumnStatisticsRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('columnStatistics', 'dataSourceId', dataSourceId)
    // verify required parameter 'columnStatisticsRequest' is not null or undefined
    assertParamExists('columnStatistics', 'columnStatisticsRequest', columnStatisticsRequest)
    const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/computeColumnStatistics`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof columnStatisticsRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(columnStatisticsRequest !== undefined ? columnStatisticsRequest : {})
        : columnStatisticsRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// ComputationApi Api FP
/**
 * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
 * @summary (EXPERIMENTAL) Compute column statistics
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ComputationApiColumnStatisticsRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ComputationApi_ColumnStatistics(
    axios: AxiosInstance, basePath: string,
    requestParameters: ComputationApiColumnStatisticsRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ColumnStatisticsResponse> {
    const localVarAxiosArgs = await ComputationApiAxiosParamCreator_ColumnStatistics(
        requestParameters.dataSourceId, requestParameters.columnStatisticsRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * ComputationApi - interface
 * @export
 * @interface ComputationApi
 */
export interface ComputationApiInterface {
    /**
     * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
     * @summary (EXPERIMENTAL) Compute column statistics
     * @param {ComputationApiColumnStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    columnStatistics(requestParameters: ComputationApiColumnStatisticsRequest, options?: AxiosRequestConfig): AxiosPromise<ColumnStatisticsResponse>;

}

/**
 * Request parameters for columnStatistics operation in ComputationApi.
 * @export
 * @interface ComputationApiColumnStatisticsRequest
 */
export interface ComputationApiColumnStatisticsRequest {
    /**
     * 
     * @type {string}
     * @memberof ComputationApiColumnStatistics
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {ColumnStatisticsRequest}
     * @memberof ComputationApiColumnStatistics
     */
    readonly columnStatisticsRequest: ColumnStatisticsRequest
}

/**
 * ComputationApi - object-oriented interface
 * @export
 * @class ComputationApi
 * @extends {BaseAPI}
 */
export class ComputationApi extends BaseAPI implements ComputationApiInterface {
    /**
     * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
     * @summary (EXPERIMENTAL) Compute column statistics
     * @param {ComputationApiColumnStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public columnStatistics(requestParameters: ComputationApiColumnStatisticsRequest, options?: AxiosRequestConfig) {
        return ComputationApi_ColumnStatistics(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}


// ScanningApi FP - ScanningApiAxiosParamCreator
/**
 * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
 * @summary Get a list of schema names of a database
 * @param {string} dataSourceId Data source id
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ScanningApiAxiosParamCreator_GetDataSourceSchemata(
    dataSourceId: string, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('getDataSourceSchemata', 'dataSourceId', dataSourceId)
    const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSchemata`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ScanningApi FP - ScanningApiAxiosParamCreator
/**
 * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
 * @summary Scan a database to get a physical data model (PDM)
 * @param {string} dataSourceId Data source id
 * @param {ScanRequest} scanRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ScanningApiAxiosParamCreator_ScanDataSource(
    dataSourceId: string, scanRequest: ScanRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('scanDataSource', 'dataSourceId', dataSourceId)
    // verify required parameter 'scanRequest' is not null or undefined
    assertParamExists('scanDataSource', 'scanRequest', scanRequest)
    const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scan`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof scanRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(scanRequest !== undefined ? scanRequest : {})
        : scanRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// ScanningApi FP - ScanningApiAxiosParamCreator
/**
 * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
 * @summary Collect metadata about SQL query
 * @param {string} dataSourceId Data source id
 * @param {ScanSqlRequest} scanSqlRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ScanningApiAxiosParamCreator_ScanSql(
    dataSourceId: string, scanSqlRequest: ScanSqlRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('scanSql', 'dataSourceId', dataSourceId)
    // verify required parameter 'scanSqlRequest' is not null or undefined
    assertParamExists('scanSql', 'scanSqlRequest', scanSqlRequest)
    const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSql`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof scanSqlRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(scanSqlRequest !== undefined ? scanSqlRequest : {})
        : scanSqlRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// ScanningApi Api FP
/**
 * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
 * @summary Get a list of schema names of a database
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ScanningApiGetDataSourceSchemataRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ScanningApi_GetDataSourceSchemata(
    axios: AxiosInstance, basePath: string,
    requestParameters: ScanningApiGetDataSourceSchemataRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<DataSourceSchemata> {
    const localVarAxiosArgs = await ScanningApiAxiosParamCreator_GetDataSourceSchemata(
        requestParameters.dataSourceId, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ScanningApi Api FP
/**
 * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
 * @summary Scan a database to get a physical data model (PDM)
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ScanningApiScanDataSourceRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ScanningApi_ScanDataSource(
    axios: AxiosInstance, basePath: string,
    requestParameters: ScanningApiScanDataSourceRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ScanResultPdm> {
    const localVarAxiosArgs = await ScanningApiAxiosParamCreator_ScanDataSource(
        requestParameters.dataSourceId, requestParameters.scanRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// ScanningApi Api FP
/**
 * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
 * @summary Collect metadata about SQL query
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {ScanningApiScanSqlRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function ScanningApi_ScanSql(
    axios: AxiosInstance, basePath: string,
    requestParameters: ScanningApiScanSqlRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<ScanSqlResponse> {
    const localVarAxiosArgs = await ScanningApiAxiosParamCreator_ScanSql(
        requestParameters.dataSourceId, requestParameters.scanSqlRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * ScanningApi - interface
 * @export
 * @interface ScanningApi
 */
export interface ScanningApiInterface {
    /**
     * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
     * @summary Get a list of schema names of a database
     * @param {ScanningApiGetDataSourceSchemataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApiInterface
     */
    getDataSourceSchemata(requestParameters: ScanningApiGetDataSourceSchemataRequest, options?: AxiosRequestConfig): AxiosPromise<DataSourceSchemata>;

    /**
     * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
     * @summary Scan a database to get a physical data model (PDM)
     * @param {ScanningApiScanDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApiInterface
     */
    scanDataSource(requestParameters: ScanningApiScanDataSourceRequest, options?: AxiosRequestConfig): AxiosPromise<ScanResultPdm>;

    /**
     * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
     * @summary Collect metadata about SQL query
     * @param {ScanningApiScanSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApiInterface
     */
    scanSql(requestParameters: ScanningApiScanSqlRequest, options?: AxiosRequestConfig): AxiosPromise<ScanSqlResponse>;

}

/**
 * Request parameters for getDataSourceSchemata operation in ScanningApi.
 * @export
 * @interface ScanningApiGetDataSourceSchemataRequest
 */
export interface ScanningApiGetDataSourceSchemataRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ScanningApiGetDataSourceSchemata
     */
    readonly dataSourceId: string
}

/**
 * Request parameters for scanDataSource operation in ScanningApi.
 * @export
 * @interface ScanningApiScanDataSourceRequest
 */
export interface ScanningApiScanDataSourceRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ScanningApiScanDataSource
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {ScanRequest}
     * @memberof ScanningApiScanDataSource
     */
    readonly scanRequest: ScanRequest
}

/**
 * Request parameters for scanSql operation in ScanningApi.
 * @export
 * @interface ScanningApiScanSqlRequest
 */
export interface ScanningApiScanSqlRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ScanningApiScanSql
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {ScanSqlRequest}
     * @memberof ScanningApiScanSql
     */
    readonly scanSqlRequest: ScanSqlRequest
}

/**
 * ScanningApi - object-oriented interface
 * @export
 * @class ScanningApi
 * @extends {BaseAPI}
 */
export class ScanningApi extends BaseAPI implements ScanningApiInterface {
    /**
     * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
     * @summary Get a list of schema names of a database
     * @param {ScanningApiGetDataSourceSchemataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApi
     */
    public getDataSourceSchemata(requestParameters: ScanningApiGetDataSourceSchemataRequest, options?: AxiosRequestConfig) {
        return ScanningApi_GetDataSourceSchemata(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
     * @summary Scan a database to get a physical data model (PDM)
     * @param {ScanningApiScanDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApi
     */
    public scanDataSource(requestParameters: ScanningApiScanDataSourceRequest, options?: AxiosRequestConfig) {
        return ScanningApi_ScanDataSource(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
     * @summary Collect metadata about SQL query
     * @param {ScanningApiScanSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApi
     */
    public scanSql(requestParameters: ScanningApiScanSqlRequest, options?: AxiosRequestConfig) {
        return ScanningApi_ScanSql(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}


// TestConnectionApi FP - TestConnectionApiAxiosParamCreator
/**
 * Test if it is possible to connect to a database using an existing data source definition.
 * @summary Test data source connection by data source id
 * @param {string} dataSourceId Data source id
 * @param {TestRequest} testRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function TestConnectionApiAxiosParamCreator_TestDataSource(
    dataSourceId: string, testRequest: TestRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'dataSourceId' is not null or undefined
    assertParamExists('testDataSource', 'dataSourceId', dataSourceId)
    // verify required parameter 'testRequest' is not null or undefined
    assertParamExists('testDataSource', 'testRequest', testRequest)
    const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/test`
        .replace(`{${"dataSourceId"}}`, encodeURIComponent(String(dataSourceId)));
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof testRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testRequest !== undefined ? testRequest : {})
        : testRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}


// TestConnectionApi FP - TestConnectionApiAxiosParamCreator
/**
 * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
 * @summary Test connection by data source definition
 * @param {TestDefinitionRequest} testDefinitionRequest 
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function TestConnectionApiAxiosParamCreator_TestDataSourceDefinition(
    testDefinitionRequest: TestDefinitionRequest, 
    options: AxiosRequestConfig = {},
    configuration?: Configuration,
): Promise<RequestArgs> {
    // verify required parameter 'testDefinitionRequest' is not null or undefined
    assertParamExists('testDataSourceDefinition', 'testDefinitionRequest', testDefinitionRequest)
    const localVarPath = `/api/v1/actions/dataSource/test`;
    // use dummy base URL string because the URL constructor only accepts absolute URLs.
    const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
    let baseOptions;
    if (configuration) {
        baseOptions = configuration.baseOptions;
    }
    const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
    const localVarHeaderParameter = {} as any;
    const localVarQueryParameter = {} as any;


    
    const consumes = [
        'application/json'
    ];
    // use application/json if present, otherwise fallback to the first one
    localVarHeaderParameter['Content-Type'] = consumes.includes('application/json')
        ? 'application/json'
        : consumes[0];

    setSearchParams(localVarUrlObj, localVarQueryParameter);
    const headersFromBaseOptions = baseOptions?.headers ? baseOptions.headers : {};
    localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
    };
    const needsSerialization =
        typeof testDefinitionRequest !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
    localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(testDefinitionRequest !== undefined ? testDefinitionRequest : {})
        : testDefinitionRequest || "";

    return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
    };
}



// TestConnectionApi Api FP
/**
 * Test if it is possible to connect to a database using an existing data source definition.
 * @summary Test data source connection by data source id
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {TestConnectionApiTestDataSourceRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function TestConnectionApi_TestDataSource(
    axios: AxiosInstance, basePath: string,
    requestParameters: TestConnectionApiTestDataSourceRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<TestResponse> {
    const localVarAxiosArgs = await TestConnectionApiAxiosParamCreator_TestDataSource(
        requestParameters.dataSourceId, requestParameters.testRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


// TestConnectionApi Api FP
/**
 * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
 * @summary Test connection by data source definition
 * @param {AxiosInstance} axios Axios instance.
 * @param {string} basePath Base path.
 * @param {TestConnectionApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
 * @param {*} [options] Override http request option.
 * @param {Configuration} [configuration] Optional configuration.
 * @throws {RequiredError}
 */
export async function TestConnectionApi_TestDataSourceDefinition(
    axios: AxiosInstance, basePath: string,
    requestParameters: TestConnectionApiTestDataSourceDefinitionRequest, 
    options?: AxiosRequestConfig,
    configuration?: Configuration,
): AxiosPromise<TestResponse> {
    const localVarAxiosArgs = await TestConnectionApiAxiosParamCreator_TestDataSourceDefinition(
        requestParameters.testDefinitionRequest, 
        options || {},
        configuration,
    );
    return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, basePath);
}


/**
 * TestConnectionApi - interface
 * @export
 * @interface TestConnectionApi
 */
export interface TestConnectionApiInterface {
    /**
     * Test if it is possible to connect to a database using an existing data source definition.
     * @summary Test data source connection by data source id
     * @param {TestConnectionApiTestDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestConnectionApiInterface
     */
    testDataSource(requestParameters: TestConnectionApiTestDataSourceRequest, options?: AxiosRequestConfig): AxiosPromise<TestResponse>;

    /**
     * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
     * @summary Test connection by data source definition
     * @param {TestConnectionApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestConnectionApiInterface
     */
    testDataSourceDefinition(requestParameters: TestConnectionApiTestDataSourceDefinitionRequest, options?: AxiosRequestConfig): AxiosPromise<TestResponse>;

}

/**
 * Request parameters for testDataSource operation in TestConnectionApi.
 * @export
 * @interface TestConnectionApiTestDataSourceRequest
 */
export interface TestConnectionApiTestDataSourceRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof TestConnectionApiTestDataSource
     */
    readonly dataSourceId: string

    /**
     * 
     * @type {TestRequest}
     * @memberof TestConnectionApiTestDataSource
     */
    readonly testRequest: TestRequest
}

/**
 * Request parameters for testDataSourceDefinition operation in TestConnectionApi.
 * @export
 * @interface TestConnectionApiTestDataSourceDefinitionRequest
 */
export interface TestConnectionApiTestDataSourceDefinitionRequest {
    /**
     * 
     * @type {TestDefinitionRequest}
     * @memberof TestConnectionApiTestDataSourceDefinition
     */
    readonly testDefinitionRequest: TestDefinitionRequest
}

/**
 * TestConnectionApi - object-oriented interface
 * @export
 * @class TestConnectionApi
 * @extends {BaseAPI}
 */
export class TestConnectionApi extends BaseAPI implements TestConnectionApiInterface {
    /**
     * Test if it is possible to connect to a database using an existing data source definition.
     * @summary Test data source connection by data source id
     * @param {TestConnectionApiTestDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestConnectionApi
     */
    public testDataSource(requestParameters: TestConnectionApiTestDataSourceRequest, options?: AxiosRequestConfig) {
        return TestConnectionApi_TestDataSource(this.axios, this.basePath, requestParameters, options, this.configuration);
    }

    /**
     * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
     * @summary Test connection by data source definition
     * @param {TestConnectionApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestConnectionApi
     */
    public testDataSourceDefinition(requestParameters: TestConnectionApiTestDataSourceDefinitionRequest, options?: AxiosRequestConfig) {
        return TestConnectionApi_TestDataSourceDefinition(this.axios, this.basePath, requestParameters, options, this.configuration);
    }
}

