// (C) 2025 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

export interface ColumnStatistic {
    type: ColumnStatisticTypeEnum;
    value?: string;
}

export const ColumnStatisticTypeEnum = {
    COUNT: "COUNT",
    COUNT_NULL: "COUNT_NULL",
    COUNT_UNIQUE: "COUNT_UNIQUE",
    AVG: "AVG",
    STDDEV: "STDDEV",
    MIN: "MIN",
    MAX: "MAX",
    PERCENTILE_25: "PERCENTILE_25",
    PERCENTILE_50: "PERCENTILE_50",
    PERCENTILE_75: "PERCENTILE_75",
} as const;

export type ColumnStatisticTypeEnum = (typeof ColumnStatisticTypeEnum)[keyof typeof ColumnStatisticTypeEnum];

export interface ColumnStatisticWarning {
    action: string;
    message: string;
}
/**
 * A request to retrieve statistics for a column.
 */
export interface ColumnStatisticsRequest {
    from: ColumnStatisticsRequestFrom;
    columnName: string;
    statistics?: Array<ColumnStatisticsRequestStatisticsEnum>;
    histogram?: HistogramProperties;
    frequency?: FrequencyProperties;
}

export const ColumnStatisticsRequestStatisticsEnum = {
    COUNT: "COUNT",
    COUNT_NULL: "COUNT_NULL",
    COUNT_UNIQUE: "COUNT_UNIQUE",
    AVG: "AVG",
    STDDEV: "STDDEV",
    MIN: "MIN",
    MAX: "MAX",
    PERCENTILE_25: "PERCENTILE_25",
    PERCENTILE_50: "PERCENTILE_50",
    PERCENTILE_75: "PERCENTILE_75",
} as const;

export type ColumnStatisticsRequestStatisticsEnum =
    (typeof ColumnStatisticsRequestStatisticsEnum)[keyof typeof ColumnStatisticsRequestStatisticsEnum];

/**
 * @type ColumnStatisticsRequestFrom
 */
export type ColumnStatisticsRequestFrom = SqlQuery | Table;

export interface ColumnStatisticsResponse {
    statistics?: Array<ColumnStatistic>;
    histogram?: Histogram;
    frequency?: Frequency;
    warnings?: Array<ColumnStatisticWarning>;
}
/**
 * Warning related to single column.
 */
export interface ColumnWarning {
    /**
     * Column name.
     */
    name: string;
    /**
     * Warning message related to the column.
     */
    message: string;
}
/**
 * A parameter for testing data source connection
 */
export interface DataSourceParameter {
    /**
     * Parameter name.
     */
    name: string;
    /**
     * Parameter value.
     */
    value: string;
}
/**
 * Result of getSchemata. Contains list of available DB schema names.
 */
export interface DataSourceSchemata {
    schemaNames: Array<string>;
}
/**
 * A table column.
 */
export interface DeclarativeColumn {
    /**
     * Column name
     */
    name: string;
    /**
     * Column type
     */
    dataType: DeclarativeColumnDataTypeEnum;
    /**
     * Is column part of primary key?
     */
    isPrimaryKey?: boolean;
    /**
     * Referenced table (Foreign key)
     */
    referencedTableId?: string;
    /**
     * Referenced table (Foreign key)
     */
    referencedTableColumn?: string;
}

export const DeclarativeColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
} as const;

export type DeclarativeColumnDataTypeEnum =
    (typeof DeclarativeColumnDataTypeEnum)[keyof typeof DeclarativeColumnDataTypeEnum];

/**
 * A database table.
 */
export interface DeclarativeTable {
    /**
     * Table id.
     */
    id: string;
    /**
     * Path to table.
     */
    path: Array<string>;
    /**
     * Table type: TABLE or VIEW.
     */
    type: string;
    /**
     * Table or view name prefix used in scan. Will be stripped when generating LDM.
     */
    namePrefix?: string;
    /**
     * An array of physical columns
     */
    columns: Array<DeclarativeColumn>;
}
/**
 * A physical data model (PDM) tables.
 */
export interface DeclarativeTables {
    /**
     * An array of physical database tables.
     */
    tables: Array<DeclarativeTable>;
}
export interface Frequency {
    buckets: Array<FrequencyBucket>;
}
export interface FrequencyBucket {
    count: number;
    value?: string;
}
export interface FrequencyProperties {
    /**
     * The maximum number of distinct values to return.
     */
    valueLimit?: number;
}
export interface Histogram {
    buckets: Array<HistogramBucket>;
}
export interface HistogramBucket {
    count: number;
    lowerBound: number;
    upperBound: number;
}
export interface HistogramProperties {
    bucketCount: number;
}
/**
 * A request containing all information critical to model scanning.
 */
export interface ScanRequest {
    /**
     * A separator between prefixes and the names.
     */
    separator: string;
    /**
     * A flag indicating whether the tables should be scanned.
     */
    scanTables: boolean;
    /**
     * A flag indicating whether the views should be scanned.
     */
    scanViews: boolean;
    /**
     * What schemata will be scanned.
     */
    schemata?: Array<string>;
    /**
     * Tables starting with this prefix will be scanned. The prefix is then followed by the value of `separator` parameter. Given the table prefix is `out_table` and separator is `__`, the table with name like `out_table__customers` will be scanned.
     */
    tablePrefix?: string;
    /**
     * Views starting with this prefix will be scanned. The prefix is then followed by the value of `separator` parameter. Given the view prefix is `out_view` and separator is `__`, the table with name like `out_view__us_customers` will be scanned.
     */
    viewPrefix?: string;
}
/**
 * Result of scan of data source physical model.
 */
export interface ScanResultPdm {
    pdm: DeclarativeTables;
    warnings: Array<TableWarning>;
}
/**
 * A request with SQL query to by analyzed.
 */
export interface ScanSqlRequest {
    /**
     * SQL query to be analyzed.
     */
    sql: string;
}
/**
 * Result of scanSql. Consists of array of query columns including type. Sql query result data preview can be attached optionally
 */
export interface ScanSqlResponse {
    /**
     * Array of columns with types.
     */
    columns: Array<SqlColumn>;
    /**
     * Array of rows where each row is another array of string values.
     */
    dataPreview?: Array<Array<string | null>>;
}
/**
 * A SQL query result column.
 */
export interface SqlColumn {
    /**
     * Column name
     */
    name: string;
    /**
     * Column type
     */
    dataType: SqlColumnDataTypeEnum;
}

export const SqlColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
} as const;

export type SqlColumnDataTypeEnum = (typeof SqlColumnDataTypeEnum)[keyof typeof SqlColumnDataTypeEnum];

export interface SqlQuery {
    sql: string;
}
export interface Table {
    tableName: string;
}
/**
 * Warnings related to single table.
 */
export interface TableWarning {
    /**
     * Table name.
     */
    name: string;
    /**
     * Warning message related to the table.
     */
    message?: string;
    columns: Array<ColumnWarning>;
}
/**
 * A request containing all information for testing data source definition.
 */
export interface TestDefinitionRequest {
    /**
     * Type of database, where test should connect to.
     */
    type: TestDefinitionRequestTypeEnum;
    /**
     * URL to database in JDBC format, where test should connect to.
     */
    url?: string;
    /**
     * Database schema.
     */
    schema?: string;
    /**
     * Database user name.
     */
    username?: string;
    /**
     * Database user password.
     */
    password?: string;
    /**
     * Secret for token based authentication for data sources which supports it.
     */
    token?: string;
    /**
     * Private key for data sources which supports key-pair authentication.
     */
    privateKey?: string;
    /**
     * Passphrase for a encrypted version of a private key.
     */
    privateKeyPassphrase?: string;
    /**
     * Id for client based authentication for data sources which supports it.
     */
    clientId?: string;
    /**
     * Secret for client based authentication for data sources which supports it.
     */
    clientSecret?: string;
    parameters?: Array<DataSourceParameter>;
}

export const TestDefinitionRequestTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
    GREENPLUM: "GREENPLUM",
    AZURESQL: "AZURESQL",
    SYNAPSESQL: "SYNAPSESQL",
    DATABRICKS: "DATABRICKS",
    GDSTORAGE: "GDSTORAGE",
    CLICKHOUSE: "CLICKHOUSE",
    MYSQL: "MYSQL",
    MARIADB: "MARIADB",
    ORACLE: "ORACLE",
    PINOT: "PINOT",
    SINGLESTORE: "SINGLESTORE",
    MOTHERDUCK: "MOTHERDUCK",
    FLEXCONNECT: "FLEXCONNECT",
    STARROCKS: "STARROCKS",
    ATHENA: "ATHENA",
    MONGODB: "MONGODB",
} as const;

export type TestDefinitionRequestTypeEnum =
    (typeof TestDefinitionRequestTypeEnum)[keyof typeof TestDefinitionRequestTypeEnum];

/**
 * A structure containing duration of the test queries run on a data source. It is omitted if an error happens.
 */
export interface TestQueryDuration {
    /**
     * Field containing duration of a test select query on a data source. In milliseconds.
     */
    simpleSelect: number;
    /**
     * Field containing duration of a test \'create table as select\' query on a datasource. In milliseconds. The field is omitted if a data source doesn\'t support caching.
     */
    createCacheTable?: number;
}
/**
 * A request containing all information for testing existing data source.
 */
export interface TestRequest {
    /**
     * URL to database in JDBC format, where test should connect to.
     */
    url?: string;
    /**
     * Database schema.
     */
    schema?: string;
    /**
     * Database user name.
     */
    username?: string;
    /**
     * Database user password.
     */
    password?: string;
    /**
     * Secret for token based authentication for data sources which supports it.
     */
    token?: string;
    /**
     * Private key for data sources which supports key-pair authentication.
     */
    privateKey?: string;
    /**
     * Passphrase for a encrypted version of a private key.
     */
    privateKeyPassphrase?: string;
    /**
     * Id for client based authentication for data sources which supports it.
     */
    clientId?: string;
    /**
     * Secret for client based authentication for data sources which supports it.
     */
    clientSecret?: string;
    parameters?: Array<DataSourceParameter>;
}
/**
 * Response from data source testing.
 */
export interface TestResponse {
    /**
     * A flag indicating whether test passed or not.
     */
    successful: boolean;
    /**
     * Field containing more details in case of a failure. Details are available to a privileged user only.
     */
    error?: string;
    queryDurationMillis?: TestQueryDuration;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
         * @summary (EXPERIMENTAL) Compute column statistics
         * @param {string} dataSourceId
         * @param {ColumnStatisticsRequest} columnStatisticsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnStatistics: async (
            dataSourceId: string,
            columnStatisticsRequest: ColumnStatisticsRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("columnStatistics", "dataSourceId", dataSourceId);
            // verify required parameter 'columnStatisticsRequest' is not null or undefined
            assertParamExists("columnStatistics", "columnStatisticsRequest", columnStatisticsRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/computeColumnStatistics`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof columnStatisticsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(columnStatisticsRequest !== undefined ? columnStatisticsRequest : {})
                : columnStatisticsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {string} dataSourceId Data source id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceSchemata: async (
            dataSourceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getDataSourceSchemata", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSchemata`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {string} dataSourceId Data source id
         * @param {ScanRequest} scanRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanDataSource: async (
            dataSourceId: string,
            scanRequest: ScanRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("scanDataSource", "dataSourceId", dataSourceId);
            // verify required parameter 'scanRequest' is not null or undefined
            assertParamExists("scanDataSource", "scanRequest", scanRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scan`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof scanRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(scanRequest !== undefined ? scanRequest : {})
                : scanRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {string} dataSourceId Data source id
         * @param {ScanSqlRequest} scanSqlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanSql: async (
            dataSourceId: string,
            scanSqlRequest: ScanSqlRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("scanSql", "dataSourceId", dataSourceId);
            // verify required parameter 'scanSqlRequest' is not null or undefined
            assertParamExists("scanSql", "scanSqlRequest", scanSqlRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSql`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof scanSqlRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(scanSqlRequest !== undefined ? scanSqlRequest : {})
                : scanSqlRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {string} dataSourceId Data source id
         * @param {TestRequest} testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSource: async (
            dataSourceId: string,
            testRequest: TestRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("testDataSource", "dataSourceId", dataSourceId);
            // verify required parameter 'testRequest' is not null or undefined
            assertParamExists("testDataSource", "testRequest", testRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/test`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof testRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testRequest !== undefined ? testRequest : {})
                : testRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestDefinitionRequest} testDefinitionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSourceDefinition: async (
            testDefinitionRequest: TestDefinitionRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'testDefinitionRequest' is not null or undefined
            assertParamExists("testDataSourceDefinition", "testDefinitionRequest", testDefinitionRequest);
            const localVarPath = `/api/v1/actions/dataSource/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof testDefinitionRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testDefinitionRequest !== undefined ? testDefinitionRequest : {})
                : testDefinitionRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
         * @summary (EXPERIMENTAL) Compute column statistics
         * @param {string} dataSourceId
         * @param {ColumnStatisticsRequest} columnStatisticsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async columnStatistics(
            dataSourceId: string,
            columnStatisticsRequest: ColumnStatisticsRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ColumnStatisticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.columnStatistics(
                dataSourceId,
                columnStatisticsRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {string} dataSourceId Data source id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourceSchemata(
            dataSourceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataSourceSchemata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourceSchemata(
                dataSourceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {string} dataSourceId Data source id
         * @param {ScanRequest} scanRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanDataSource(
            dataSourceId: string,
            scanRequest: ScanRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanResultPdm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanDataSource(
                dataSourceId,
                scanRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {string} dataSourceId Data source id
         * @param {ScanSqlRequest} scanSqlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanSql(
            dataSourceId: string,
            scanSqlRequest: ScanSqlRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanSqlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanSql(
                dataSourceId,
                scanSqlRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {string} dataSourceId Data source id
         * @param {TestRequest} testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testDataSource(
            dataSourceId: string,
            testRequest: TestRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testDataSource(
                dataSourceId,
                testRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestDefinitionRequest} testDefinitionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testDataSourceDefinition(
            testDefinitionRequest: TestDefinitionRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testDataSourceDefinition(
                testDefinitionRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
         * @summary (EXPERIMENTAL) Compute column statistics
         * @param {ActionsApiColumnStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnStatistics(
            requestParameters: ActionsApiColumnStatisticsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ColumnStatisticsResponse> {
            return localVarFp
                .columnStatistics(
                    requestParameters.dataSourceId,
                    requestParameters.columnStatisticsRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {ActionsApiGetDataSourceSchemataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceSchemata(
            requestParameters: ActionsApiGetDataSourceSchemataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<DataSourceSchemata> {
            return localVarFp
                .getDataSourceSchemata(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {ActionsApiScanDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanDataSource(
            requestParameters: ActionsApiScanDataSourceRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ScanResultPdm> {
            return localVarFp
                .scanDataSource(requestParameters.dataSourceId, requestParameters.scanRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {ActionsApiScanSqlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanSql(
            requestParameters: ActionsApiScanSqlRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ScanSqlResponse> {
            return localVarFp
                .scanSql(requestParameters.dataSourceId, requestParameters.scanSqlRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {ActionsApiTestDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSource(
            requestParameters: ActionsApiTestDataSourceRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testDataSource(requestParameters.dataSourceId, requestParameters.testRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {ActionsApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSourceDefinition(
            requestParameters: ActionsApiTestDataSourceDefinitionRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testDataSourceDefinition(requestParameters.testDefinitionRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
     * @summary (EXPERIMENTAL) Compute column statistics
     * @param {ActionsApiColumnStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    columnStatistics(
        requestParameters: ActionsApiColumnStatisticsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ColumnStatisticsResponse>;

    /**
     * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
     * @summary Get a list of schema names of a database
     * @param {ActionsApiGetDataSourceSchemataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getDataSourceSchemata(
        requestParameters: ActionsApiGetDataSourceSchemataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<DataSourceSchemata>;

    /**
     * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
     * @summary Scan a database to get a physical data model (PDM)
     * @param {ActionsApiScanDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    scanDataSource(
        requestParameters: ActionsApiScanDataSourceRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ScanResultPdm>;

    /**
     * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
     * @summary Collect metadata about SQL query
     * @param {ActionsApiScanSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    scanSql(
        requestParameters: ActionsApiScanSqlRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ScanSqlResponse>;

    /**
     * Test if it is possible to connect to a database using an existing data source definition.
     * @summary Test data source connection by data source id
     * @param {ActionsApiTestDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    testDataSource(
        requestParameters: ActionsApiTestDataSourceRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;

    /**
     * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
     * @summary Test connection by data source definition
     * @param {ActionsApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    testDataSourceDefinition(
        requestParameters: ActionsApiTestDataSourceDefinitionRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;
}

/**
 * Request parameters for columnStatistics operation in ActionsApi.
 * @export
 * @interface ActionsApiColumnStatisticsRequest
 */
export interface ActionsApiColumnStatisticsRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiColumnStatistics
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ColumnStatisticsRequest}
     * @memberof ActionsApiColumnStatistics
     */
    readonly columnStatisticsRequest: ColumnStatisticsRequest;
}

/**
 * Request parameters for getDataSourceSchemata operation in ActionsApi.
 * @export
 * @interface ActionsApiGetDataSourceSchemataRequest
 */
export interface ActionsApiGetDataSourceSchemataRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ActionsApiGetDataSourceSchemata
     */
    readonly dataSourceId: string;
}

/**
 * Request parameters for scanDataSource operation in ActionsApi.
 * @export
 * @interface ActionsApiScanDataSourceRequest
 */
export interface ActionsApiScanDataSourceRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ActionsApiScanDataSource
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ScanRequest}
     * @memberof ActionsApiScanDataSource
     */
    readonly scanRequest: ScanRequest;
}

/**
 * Request parameters for scanSql operation in ActionsApi.
 * @export
 * @interface ActionsApiScanSqlRequest
 */
export interface ActionsApiScanSqlRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ActionsApiScanSql
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ScanSqlRequest}
     * @memberof ActionsApiScanSql
     */
    readonly scanSqlRequest: ScanSqlRequest;
}

/**
 * Request parameters for testDataSource operation in ActionsApi.
 * @export
 * @interface ActionsApiTestDataSourceRequest
 */
export interface ActionsApiTestDataSourceRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ActionsApiTestDataSource
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {TestRequest}
     * @memberof ActionsApiTestDataSource
     */
    readonly testRequest: TestRequest;
}

/**
 * Request parameters for testDataSourceDefinition operation in ActionsApi.
 * @export
 * @interface ActionsApiTestDataSourceDefinitionRequest
 */
export interface ActionsApiTestDataSourceDefinitionRequest {
    /**
     *
     * @type {TestDefinitionRequest}
     * @memberof ActionsApiTestDataSourceDefinition
     */
    readonly testDefinitionRequest: TestDefinitionRequest;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
     * @summary (EXPERIMENTAL) Compute column statistics
     * @param {ActionsApiColumnStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public columnStatistics(
        requestParameters: ActionsApiColumnStatisticsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .columnStatistics(
                requestParameters.dataSourceId,
                requestParameters.columnStatisticsRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
     * @summary Get a list of schema names of a database
     * @param {ActionsApiGetDataSourceSchemataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getDataSourceSchemata(
        requestParameters: ActionsApiGetDataSourceSchemataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .getDataSourceSchemata(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
     * @summary Scan a database to get a physical data model (PDM)
     * @param {ActionsApiScanDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public scanDataSource(requestParameters: ActionsApiScanDataSourceRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .scanDataSource(requestParameters.dataSourceId, requestParameters.scanRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
     * @summary Collect metadata about SQL query
     * @param {ActionsApiScanSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public scanSql(requestParameters: ActionsApiScanSqlRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .scanSql(requestParameters.dataSourceId, requestParameters.scanSqlRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test if it is possible to connect to a database using an existing data source definition.
     * @summary Test data source connection by data source id
     * @param {ActionsApiTestDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public testDataSource(requestParameters: ActionsApiTestDataSourceRequest, options?: AxiosRequestConfig) {
        return ActionsApiFp(this.configuration)
            .testDataSource(requestParameters.dataSourceId, requestParameters.testRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
     * @summary Test connection by data source definition
     * @param {ActionsApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public testDataSourceDefinition(
        requestParameters: ActionsApiTestDataSourceDefinitionRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .testDataSourceDefinition(requestParameters.testDefinitionRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ComputationApi - axios parameter creator
 * @export
 */
export const ComputationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
         * @summary (EXPERIMENTAL) Compute column statistics
         * @param {string} dataSourceId
         * @param {ColumnStatisticsRequest} columnStatisticsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnStatistics: async (
            dataSourceId: string,
            columnStatisticsRequest: ColumnStatisticsRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("columnStatistics", "dataSourceId", dataSourceId);
            // verify required parameter 'columnStatisticsRequest' is not null or undefined
            assertParamExists("columnStatistics", "columnStatisticsRequest", columnStatisticsRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/computeColumnStatistics`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof columnStatisticsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(columnStatisticsRequest !== undefined ? columnStatisticsRequest : {})
                : columnStatisticsRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ComputationApi - functional programming interface
 * @export
 */
export const ComputationApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ComputationApiAxiosParamCreator(configuration);
    return {
        /**
         * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
         * @summary (EXPERIMENTAL) Compute column statistics
         * @param {string} dataSourceId
         * @param {ColumnStatisticsRequest} columnStatisticsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async columnStatistics(
            dataSourceId: string,
            columnStatisticsRequest: ColumnStatisticsRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ColumnStatisticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.columnStatistics(
                dataSourceId,
                columnStatisticsRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ComputationApi - factory interface
 * @export
 */
export const ComputationApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ComputationApiFp(configuration);
    return {
        /**
         * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
         * @summary (EXPERIMENTAL) Compute column statistics
         * @param {ComputationApiColumnStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        columnStatistics(
            requestParameters: ComputationApiColumnStatisticsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ColumnStatisticsResponse> {
            return localVarFp
                .columnStatistics(
                    requestParameters.dataSourceId,
                    requestParameters.columnStatisticsRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComputationApi - interface
 * @export
 * @interface ComputationApi
 */
export interface ComputationApiInterface {
    /**
     * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
     * @summary (EXPERIMENTAL) Compute column statistics
     * @param {ComputationApiColumnStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApiInterface
     */
    columnStatistics(
        requestParameters: ComputationApiColumnStatisticsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ColumnStatisticsResponse>;
}

/**
 * Request parameters for columnStatistics operation in ComputationApi.
 * @export
 * @interface ComputationApiColumnStatisticsRequest
 */
export interface ComputationApiColumnStatisticsRequest {
    /**
     *
     * @type {string}
     * @memberof ComputationApiColumnStatistics
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ColumnStatisticsRequest}
     * @memberof ComputationApiColumnStatistics
     */
    readonly columnStatisticsRequest: ColumnStatisticsRequest;
}

/**
 * ComputationApi - object-oriented interface
 * @export
 * @class ComputationApi
 * @extends {BaseAPI}
 */
export class ComputationApi extends BaseAPI implements ComputationApiInterface {
    /**
     * (EXPERIMENTAL) Computes the requested statistical parameters of a column in a data source.
     * @summary (EXPERIMENTAL) Compute column statistics
     * @param {ComputationApiColumnStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputationApi
     */
    public columnStatistics(
        requestParameters: ComputationApiColumnStatisticsRequest,
        options?: AxiosRequestConfig,
    ) {
        return ComputationApiFp(this.configuration)
            .columnStatistics(
                requestParameters.dataSourceId,
                requestParameters.columnStatisticsRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * ScanningApi - axios parameter creator
 * @export
 */
export const ScanningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {string} dataSourceId Data source id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceSchemata: async (
            dataSourceId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("getDataSourceSchemata", "dataSourceId", dataSourceId);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSchemata`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {string} dataSourceId Data source id
         * @param {ScanRequest} scanRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanDataSource: async (
            dataSourceId: string,
            scanRequest: ScanRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("scanDataSource", "dataSourceId", dataSourceId);
            // verify required parameter 'scanRequest' is not null or undefined
            assertParamExists("scanDataSource", "scanRequest", scanRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scan`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof scanRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(scanRequest !== undefined ? scanRequest : {})
                : scanRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {string} dataSourceId Data source id
         * @param {ScanSqlRequest} scanSqlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanSql: async (
            dataSourceId: string,
            scanSqlRequest: ScanSqlRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("scanSql", "dataSourceId", dataSourceId);
            // verify required parameter 'scanSqlRequest' is not null or undefined
            assertParamExists("scanSql", "scanSqlRequest", scanSqlRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/scanSql`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof scanSqlRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(scanSqlRequest !== undefined ? scanSqlRequest : {})
                : scanSqlRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ScanningApi - functional programming interface
 * @export
 */
export const ScanningApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ScanningApiAxiosParamCreator(configuration);
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {string} dataSourceId Data source id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataSourceSchemata(
            dataSourceId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataSourceSchemata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSourceSchemata(
                dataSourceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {string} dataSourceId Data source id
         * @param {ScanRequest} scanRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanDataSource(
            dataSourceId: string,
            scanRequest: ScanRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanResultPdm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanDataSource(
                dataSourceId,
                scanRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {string} dataSourceId Data source id
         * @param {ScanSqlRequest} scanSqlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanSql(
            dataSourceId: string,
            scanSqlRequest: ScanSqlRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanSqlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanSql(
                dataSourceId,
                scanSqlRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ScanningApi - factory interface
 * @export
 */
export const ScanningApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ScanningApiFp(configuration);
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {ScanningApiGetDataSourceSchemataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceSchemata(
            requestParameters: ScanningApiGetDataSourceSchemataRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<DataSourceSchemata> {
            return localVarFp
                .getDataSourceSchemata(requestParameters.dataSourceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {ScanningApiScanDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanDataSource(
            requestParameters: ScanningApiScanDataSourceRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ScanResultPdm> {
            return localVarFp
                .scanDataSource(requestParameters.dataSourceId, requestParameters.scanRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {ScanningApiScanSqlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanSql(
            requestParameters: ScanningApiScanSqlRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<ScanSqlResponse> {
            return localVarFp
                .scanSql(requestParameters.dataSourceId, requestParameters.scanSqlRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScanningApi - interface
 * @export
 * @interface ScanningApi
 */
export interface ScanningApiInterface {
    /**
     * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
     * @summary Get a list of schema names of a database
     * @param {ScanningApiGetDataSourceSchemataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApiInterface
     */
    getDataSourceSchemata(
        requestParameters: ScanningApiGetDataSourceSchemataRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<DataSourceSchemata>;

    /**
     * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
     * @summary Scan a database to get a physical data model (PDM)
     * @param {ScanningApiScanDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApiInterface
     */
    scanDataSource(
        requestParameters: ScanningApiScanDataSourceRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ScanResultPdm>;

    /**
     * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
     * @summary Collect metadata about SQL query
     * @param {ScanningApiScanSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApiInterface
     */
    scanSql(
        requestParameters: ScanningApiScanSqlRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<ScanSqlResponse>;
}

/**
 * Request parameters for getDataSourceSchemata operation in ScanningApi.
 * @export
 * @interface ScanningApiGetDataSourceSchemataRequest
 */
export interface ScanningApiGetDataSourceSchemataRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ScanningApiGetDataSourceSchemata
     */
    readonly dataSourceId: string;
}

/**
 * Request parameters for scanDataSource operation in ScanningApi.
 * @export
 * @interface ScanningApiScanDataSourceRequest
 */
export interface ScanningApiScanDataSourceRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ScanningApiScanDataSource
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ScanRequest}
     * @memberof ScanningApiScanDataSource
     */
    readonly scanRequest: ScanRequest;
}

/**
 * Request parameters for scanSql operation in ScanningApi.
 * @export
 * @interface ScanningApiScanSqlRequest
 */
export interface ScanningApiScanSqlRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof ScanningApiScanSql
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {ScanSqlRequest}
     * @memberof ScanningApiScanSql
     */
    readonly scanSqlRequest: ScanSqlRequest;
}

/**
 * ScanningApi - object-oriented interface
 * @export
 * @class ScanningApi
 * @extends {BaseAPI}
 */
export class ScanningApi extends BaseAPI implements ScanningApiInterface {
    /**
     * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
     * @summary Get a list of schema names of a database
     * @param {ScanningApiGetDataSourceSchemataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApi
     */
    public getDataSourceSchemata(
        requestParameters: ScanningApiGetDataSourceSchemataRequest,
        options?: AxiosRequestConfig,
    ) {
        return ScanningApiFp(this.configuration)
            .getDataSourceSchemata(requestParameters.dataSourceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
     * @summary Scan a database to get a physical data model (PDM)
     * @param {ScanningApiScanDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApi
     */
    public scanDataSource(requestParameters: ScanningApiScanDataSourceRequest, options?: AxiosRequestConfig) {
        return ScanningApiFp(this.configuration)
            .scanDataSource(requestParameters.dataSourceId, requestParameters.scanRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
     * @summary Collect metadata about SQL query
     * @param {ScanningApiScanSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScanningApi
     */
    public scanSql(requestParameters: ScanningApiScanSqlRequest, options?: AxiosRequestConfig) {
        return ScanningApiFp(this.configuration)
            .scanSql(requestParameters.dataSourceId, requestParameters.scanSqlRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * TestConnectionApi - axios parameter creator
 * @export
 */
export const TestConnectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {string} dataSourceId Data source id
         * @param {TestRequest} testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSource: async (
            dataSourceId: string,
            testRequest: TestRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'dataSourceId' is not null or undefined
            assertParamExists("testDataSource", "dataSourceId", dataSourceId);
            // verify required parameter 'testRequest' is not null or undefined
            assertParamExists("testDataSource", "testRequest", testRequest);
            const localVarPath = `/api/v1/actions/dataSources/{dataSourceId}/test`.replace(
                `{${"dataSourceId"}}`,
                encodeURIComponent(String(dataSourceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof testRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testRequest !== undefined ? testRequest : {})
                : testRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestDefinitionRequest} testDefinitionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSourceDefinition: async (
            testDefinitionRequest: TestDefinitionRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'testDefinitionRequest' is not null or undefined
            assertParamExists("testDataSourceDefinition", "testDefinitionRequest", testDefinitionRequest);
            const localVarPath = `/api/v1/actions/dataSource/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof testDefinitionRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testDefinitionRequest !== undefined ? testDefinitionRequest : {})
                : testDefinitionRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * TestConnectionApi - functional programming interface
 * @export
 */
export const TestConnectionApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TestConnectionApiAxiosParamCreator(configuration);
    return {
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {string} dataSourceId Data source id
         * @param {TestRequest} testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testDataSource(
            dataSourceId: string,
            testRequest: TestRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testDataSource(
                dataSourceId,
                testRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestDefinitionRequest} testDefinitionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testDataSourceDefinition(
            testDefinitionRequest: TestDefinitionRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testDataSourceDefinition(
                testDefinitionRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * TestConnectionApi - factory interface
 * @export
 */
export const TestConnectionApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = TestConnectionApiFp(configuration);
    return {
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {TestConnectionApiTestDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSource(
            requestParameters: TestConnectionApiTestDataSourceRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testDataSource(requestParameters.dataSourceId, requestParameters.testRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestConnectionApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSourceDefinition(
            requestParameters: TestConnectionApiTestDataSourceDefinitionRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testDataSourceDefinition(requestParameters.testDefinitionRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestConnectionApi - interface
 * @export
 * @interface TestConnectionApi
 */
export interface TestConnectionApiInterface {
    /**
     * Test if it is possible to connect to a database using an existing data source definition.
     * @summary Test data source connection by data source id
     * @param {TestConnectionApiTestDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestConnectionApiInterface
     */
    testDataSource(
        requestParameters: TestConnectionApiTestDataSourceRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;

    /**
     * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
     * @summary Test connection by data source definition
     * @param {TestConnectionApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestConnectionApiInterface
     */
    testDataSourceDefinition(
        requestParameters: TestConnectionApiTestDataSourceDefinitionRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;
}

/**
 * Request parameters for testDataSource operation in TestConnectionApi.
 * @export
 * @interface TestConnectionApiTestDataSourceRequest
 */
export interface TestConnectionApiTestDataSourceRequest {
    /**
     * Data source id
     * @type {string}
     * @memberof TestConnectionApiTestDataSource
     */
    readonly dataSourceId: string;

    /**
     *
     * @type {TestRequest}
     * @memberof TestConnectionApiTestDataSource
     */
    readonly testRequest: TestRequest;
}

/**
 * Request parameters for testDataSourceDefinition operation in TestConnectionApi.
 * @export
 * @interface TestConnectionApiTestDataSourceDefinitionRequest
 */
export interface TestConnectionApiTestDataSourceDefinitionRequest {
    /**
     *
     * @type {TestDefinitionRequest}
     * @memberof TestConnectionApiTestDataSourceDefinition
     */
    readonly testDefinitionRequest: TestDefinitionRequest;
}

/**
 * TestConnectionApi - object-oriented interface
 * @export
 * @class TestConnectionApi
 * @extends {BaseAPI}
 */
export class TestConnectionApi extends BaseAPI implements TestConnectionApiInterface {
    /**
     * Test if it is possible to connect to a database using an existing data source definition.
     * @summary Test data source connection by data source id
     * @param {TestConnectionApiTestDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestConnectionApi
     */
    public testDataSource(
        requestParameters: TestConnectionApiTestDataSourceRequest,
        options?: AxiosRequestConfig,
    ) {
        return TestConnectionApiFp(this.configuration)
            .testDataSource(requestParameters.dataSourceId, requestParameters.testRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
     * @summary Test connection by data source definition
     * @param {TestConnectionApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestConnectionApi
     */
    public testDataSourceDefinition(
        requestParameters: TestConnectionApiTestDataSourceDefinitionRequest,
        options?: AxiosRequestConfig,
    ) {
        return TestConnectionApiFp(this.configuration)
            .testDataSourceDefinition(requestParameters.testDefinitionRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
